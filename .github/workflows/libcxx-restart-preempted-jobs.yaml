name: Restart Preempted Libc++ Workflow

# The libc++ builders run on preemptable VMs, which can be shutdown at any time.
# This workflow identifies when a workflow run was canceled due to the VM being preempted,
# and restarts the workflow run.

# We identify a canceled workflow run by checking the annotations of the check runs in the check suite,
# which should contain the message "The runner has received a shutdown signal."

# Note: If a job is both preempted and also contains a non-preemption failure, we do not restart the workflow.

on:
  workflow_run:
    workflows: [Build and Test libc\+\+]
    types:
      - completed

permissions:
  contents: read

jobs:
  restart:
    if: github.repository_owner == 'llvm' && (github.event.workflow_run.conclusion == 'failure' || github.event.workflow_run.conclusion == 'cancelled')
    name: "Restart Job"
    permissions:
      statuses: read
      checks: write
      actions: write
    runs-on: ubuntu-latest
    steps:
      - name: "Restart Job"
        uses: actions/github-script@60a0d83039c74a4aee543508d2ffcb1c3799cdea #v7.0.1
        with:
          script: |
            const FAILURE_REGEX = /Process completed with exit code 1./
            const SPURIOUS_FAILURE_REGEX = /^context cancelled$/
            const PREEMPTION_REGEX = /The runner has received a shutdown signal/

            function log(msg) {
              core.notice(msg)
            }

            // Return whether a failed check run actually failed due to a spurious error.
            // This requires looking at the logs of the run.
            function is_spurious_failure(check_run) {
              return false;
              // github.rest.actions.downloadJobLogsForWorkflowRun({
              //   owner,
              //   repo,
              //   job_id,
              // });
            }

            const wf_run = context.payload.workflow_run
            log(`Running on "${wf_run.display_title}" by @${wf_run.actor.login} (event: ${wf_run.event})\nWorkflow run URL: ${wf_run.html_url}`)

            log('Listing check runs for suite')
            const check_suites = await github.rest.checks.listForSuite({
              owner: context.repo.owner,
              repo: context.repo.repo,
              check_suite_id: context.payload.workflow_run.check_suite_id,
              per_page: 100 // FIXME: We don't have 100 check runs yet, but we should handle this better.
            })

            preemptions = [];
            spurious_failures = [];
            legitimate_failures = [];
            for (check_run of check_suites.data.check_runs) {
              log(`Checking check run: ${check_run.id}`);
              if (check_run.status != 'completed') {
                log('Check run was not completed. Skipping.');
                continue;
              }

              if (check_run.conclusion != 'failure' && check_run.conclusion != 'cancelled') {
                log(`Check run had conclusion: ${check_run.conclusion}. Skipping.`);
                continue;
              }

              annotations = await github.rest.checks.listAnnotations({
                owner: context.repo.owner,
                repo: context.repo.repo,
                check_run_id: check_run.id
              })

              preemption_annotation = annotations.data.find(function(annotation) {
                return annotation.annotation_level == 'failure' &&
                       annotation.message.match(PREEMPTION_REGEX) != null;
              });
              if (preemption_annotation != null) {
                log(`Found preemption message: ${preemption_annotation.message}`);
                preemptions.push(check_run);
                break;
              }

              failure_annotation = annotations.data.find(function(annotation) {
                return annotation.annotation_level == 'failure' &&
                       annotation.message.match(FAILURE_REGEX) != null;
              });
              if (failure_annotation != null) {
                // We found a failure annotation, now classify it as spurious or legitimate.
                if (is_spurious_failure(check_run)) {
                  log(`Found spurious failure message in run: ${check_run.id}`);
                  spurious_failures.push(check_run);
                } else {
                  log(`Found legitimate failure annotation: ${failure_annotation.message}`);
                  legitimate_failures.push(check_run);
                }
                break;
              }
            }

            if (spurious_failures || preemptions) {
              log('Found some spurious failures and/or preempted jobs');
              if (legitimate_failures) {
                log('Also found some legitimate failures, so not restarting the workflow.');
              } else {
                log('Did not find any legitimate failures. Restarting workflow.');
                await github.rest.actions.reRunWorkflowFailedJobs({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  run_id: context.payload.workflow_run.id
                })
              }
            } else {
              log('Did not find any preempted jobs or spurious failures. Not restarting the workflow.');
            }
