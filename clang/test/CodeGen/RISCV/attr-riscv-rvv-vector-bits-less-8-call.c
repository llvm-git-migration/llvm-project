// NOTE: Assertions have been autogenerated by utils/update_cc_test_checks.py
// RUN: %clang_cc1 -triple riscv64-none-linux-gnu -target-feature +f -target-feature +d -target-feature +zve64d -mvscale-min=1 -mvscale-max=1 -O1 -emit-llvm -o - %s | FileCheck %s --check-prefix=CHECK-64
// RUN: %clang_cc1 -triple riscv64-none-linux-gnu -target-feature +f -target-feature +d -target-feature +zve64d -mvscale-min=2 -mvscale-max=2 -O1 -emit-llvm -o - %s | FileCheck %s --check-prefix=CHECK-128

// REQUIRES: riscv-registered-target

#include <riscv_vector.h>

typedef vbool32_t fixed_bool32_t __attribute__((riscv_rvv_vector_bits(__riscv_v_fixed_vlen/32)));
typedef vbool64_t fixed_bool64_t __attribute__((riscv_rvv_vector_bits(__riscv_v_fixed_vlen/64)));

//===----------------------------------------------------------------------===//
// fixed, fixed
//===----------------------------------------------------------------------===//

// CHECK-64-LABEL: @call_bool32_ff(
// CHECK-64-NEXT:  entry:
// CHECK-64-NEXT:    [[SAVED_VALUE:%.*]] = alloca <1 x i8>, align 1
// CHECK-64-NEXT:    [[SAVED_VALUE2:%.*]] = alloca <1 x i8>, align 1
// CHECK-64-NEXT:    [[SAVED_VALUE3:%.*]] = alloca <vscale x 2 x i1>, align 1
// CHECK-64-NEXT:    [[OP1_COERCE:%.*]] = bitcast <vscale x 8 x i1> [[TMP0:%.*]] to <vscale x 1 x i8>
// CHECK-64-NEXT:    [[OP1:%.*]] = tail call <1 x i8> @llvm.vector.extract.v1i8.nxv1i8(<vscale x 1 x i8> [[OP1_COERCE]], i64 0)
// CHECK-64-NEXT:    [[OP2_COERCE:%.*]] = bitcast <vscale x 8 x i1> [[TMP1:%.*]] to <vscale x 1 x i8>
// CHECK-64-NEXT:    [[OP2:%.*]] = tail call <1 x i8> @llvm.vector.extract.v1i8.nxv1i8(<vscale x 1 x i8> [[OP2_COERCE]], i64 0)
// CHECK-64-NEXT:    store <1 x i8> [[OP1]], ptr [[SAVED_VALUE]], align 1, !tbaa [[TBAA6:![0-9]+]]
// CHECK-64-NEXT:    [[TMP2:%.*]] = load <vscale x 2 x i1>, ptr [[SAVED_VALUE]], align 1, !tbaa [[TBAA6]]
// CHECK-64-NEXT:    store <1 x i8> [[OP2]], ptr [[SAVED_VALUE2]], align 1, !tbaa [[TBAA6]]
// CHECK-64-NEXT:    [[TMP3:%.*]] = load <vscale x 2 x i1>, ptr [[SAVED_VALUE2]], align 1, !tbaa [[TBAA6]]
// CHECK-64-NEXT:    [[TMP4:%.*]] = tail call <vscale x 2 x i1> @llvm.riscv.vmand.nxv2i1.i64(<vscale x 2 x i1> [[TMP2]], <vscale x 2 x i1> [[TMP3]], i64 2)
// CHECK-64-NEXT:    store <vscale x 2 x i1> [[TMP4]], ptr [[SAVED_VALUE3]], align 1, !tbaa [[TBAA9:![0-9]+]]
// CHECK-64-NEXT:    [[TMP5:%.*]] = load <1 x i8>, ptr [[SAVED_VALUE3]], align 1, !tbaa [[TBAA6]]
// CHECK-64-NEXT:    [[CAST_SCALABLE:%.*]] = tail call <vscale x 1 x i8> @llvm.vector.insert.nxv1i8.v1i8(<vscale x 1 x i8> undef, <1 x i8> [[TMP5]], i64 0)
// CHECK-64-NEXT:    [[TMP6:%.*]] = bitcast <vscale x 1 x i8> [[CAST_SCALABLE]] to <vscale x 8 x i1>
// CHECK-64-NEXT:    ret <vscale x 8 x i1> [[TMP6]]
//
// CHECK-128-LABEL: @call_bool32_ff(
// CHECK-128-NEXT:  entry:
// CHECK-128-NEXT:    [[OP1:%.*]] = alloca <1 x i8>, align 1
// CHECK-128-NEXT:    [[OP2:%.*]] = alloca <1 x i8>, align 1
// CHECK-128-NEXT:    [[SAVED_VALUE4:%.*]] = alloca <vscale x 2 x i1>, align 1
// CHECK-128-NEXT:    [[RETVAL_COERCE:%.*]] = alloca <vscale x 4 x i1>, align 1
// CHECK-128-NEXT:    store <vscale x 4 x i1> [[OP1_COERCE:%.*]], ptr [[OP1]], align 1
// CHECK-128-NEXT:    store <vscale x 4 x i1> [[OP2_COERCE:%.*]], ptr [[OP2]], align 1
// CHECK-128-NEXT:    [[TMP0:%.*]] = load <vscale x 2 x i1>, ptr [[OP1]], align 1, !tbaa [[TBAA6:![0-9]+]]
// CHECK-128-NEXT:    [[TMP1:%.*]] = load <vscale x 2 x i1>, ptr [[OP2]], align 1, !tbaa [[TBAA6]]
// CHECK-128-NEXT:    [[TMP2:%.*]] = tail call <vscale x 2 x i1> @llvm.riscv.vmand.nxv2i1.i64(<vscale x 2 x i1> [[TMP0]], <vscale x 2 x i1> [[TMP1]], i64 4)
// CHECK-128-NEXT:    store <vscale x 2 x i1> [[TMP2]], ptr [[SAVED_VALUE4]], align 1, !tbaa [[TBAA9:![0-9]+]]
// CHECK-128-NEXT:    [[TMP3:%.*]] = load <1 x i8>, ptr [[SAVED_VALUE4]], align 1, !tbaa [[TBAA6]]
// CHECK-128-NEXT:    store <1 x i8> [[TMP3]], ptr [[RETVAL_COERCE]], align 1
// CHECK-128-NEXT:    [[TMP4:%.*]] = load <vscale x 4 x i1>, ptr [[RETVAL_COERCE]], align 1
// CHECK-128-NEXT:    ret <vscale x 4 x i1> [[TMP4]]
//
fixed_bool32_t call_bool32_ff(fixed_bool32_t op1, fixed_bool32_t op2) {
  return __riscv_vmand(op1, op2, __riscv_v_fixed_vlen / 32);
}

// CHECK-64-LABEL: @call_bool64_ff(
// CHECK-64-NEXT:  entry:
// CHECK-64-NEXT:    [[SAVED_VALUE:%.*]] = alloca <1 x i8>, align 1
// CHECK-64-NEXT:    [[SAVED_VALUE2:%.*]] = alloca <1 x i8>, align 1
// CHECK-64-NEXT:    [[SAVED_VALUE3:%.*]] = alloca <vscale x 1 x i1>, align 1
// CHECK-64-NEXT:    [[OP1_COERCE:%.*]] = bitcast <vscale x 8 x i1> [[TMP0:%.*]] to <vscale x 1 x i8>
// CHECK-64-NEXT:    [[OP1:%.*]] = tail call <1 x i8> @llvm.vector.extract.v1i8.nxv1i8(<vscale x 1 x i8> [[OP1_COERCE]], i64 0)
// CHECK-64-NEXT:    [[OP2_COERCE:%.*]] = bitcast <vscale x 8 x i1> [[TMP1:%.*]] to <vscale x 1 x i8>
// CHECK-64-NEXT:    [[OP2:%.*]] = tail call <1 x i8> @llvm.vector.extract.v1i8.nxv1i8(<vscale x 1 x i8> [[OP2_COERCE]], i64 0)
// CHECK-64-NEXT:    store <1 x i8> [[OP1]], ptr [[SAVED_VALUE]], align 1, !tbaa [[TBAA6]]
// CHECK-64-NEXT:    [[TMP2:%.*]] = load <vscale x 1 x i1>, ptr [[SAVED_VALUE]], align 1, !tbaa [[TBAA6]]
// CHECK-64-NEXT:    store <1 x i8> [[OP2]], ptr [[SAVED_VALUE2]], align 1, !tbaa [[TBAA6]]
// CHECK-64-NEXT:    [[TMP3:%.*]] = load <vscale x 1 x i1>, ptr [[SAVED_VALUE2]], align 1, !tbaa [[TBAA6]]
// CHECK-64-NEXT:    [[TMP4:%.*]] = tail call <vscale x 1 x i1> @llvm.riscv.vmand.nxv1i1.i64(<vscale x 1 x i1> [[TMP2]], <vscale x 1 x i1> [[TMP3]], i64 1)
// CHECK-64-NEXT:    store <vscale x 1 x i1> [[TMP4]], ptr [[SAVED_VALUE3]], align 1, !tbaa [[TBAA11:![0-9]+]]
// CHECK-64-NEXT:    [[TMP5:%.*]] = load <1 x i8>, ptr [[SAVED_VALUE3]], align 1, !tbaa [[TBAA6]]
// CHECK-64-NEXT:    [[CAST_SCALABLE:%.*]] = tail call <vscale x 1 x i8> @llvm.vector.insert.nxv1i8.v1i8(<vscale x 1 x i8> undef, <1 x i8> [[TMP5]], i64 0)
// CHECK-64-NEXT:    [[TMP6:%.*]] = bitcast <vscale x 1 x i8> [[CAST_SCALABLE]] to <vscale x 8 x i1>
// CHECK-64-NEXT:    ret <vscale x 8 x i1> [[TMP6]]
//
// CHECK-128-LABEL: @call_bool64_ff(
// CHECK-128-NEXT:  entry:
// CHECK-128-NEXT:    [[OP1:%.*]] = alloca <1 x i8>, align 1
// CHECK-128-NEXT:    [[OP2:%.*]] = alloca <1 x i8>, align 1
// CHECK-128-NEXT:    [[SAVED_VALUE4:%.*]] = alloca <vscale x 1 x i1>, align 1
// CHECK-128-NEXT:    [[RETVAL_COERCE:%.*]] = alloca <vscale x 4 x i1>, align 1
// CHECK-128-NEXT:    store <vscale x 4 x i1> [[OP1_COERCE:%.*]], ptr [[OP1]], align 1
// CHECK-128-NEXT:    store <vscale x 4 x i1> [[OP2_COERCE:%.*]], ptr [[OP2]], align 1
// CHECK-128-NEXT:    [[TMP0:%.*]] = load <vscale x 1 x i1>, ptr [[OP1]], align 1, !tbaa [[TBAA6]]
// CHECK-128-NEXT:    [[TMP1:%.*]] = load <vscale x 1 x i1>, ptr [[OP2]], align 1, !tbaa [[TBAA6]]
// CHECK-128-NEXT:    [[TMP2:%.*]] = tail call <vscale x 1 x i1> @llvm.riscv.vmand.nxv1i1.i64(<vscale x 1 x i1> [[TMP0]], <vscale x 1 x i1> [[TMP1]], i64 2)
// CHECK-128-NEXT:    store <vscale x 1 x i1> [[TMP2]], ptr [[SAVED_VALUE4]], align 1, !tbaa [[TBAA11:![0-9]+]]
// CHECK-128-NEXT:    [[TMP3:%.*]] = load <1 x i8>, ptr [[SAVED_VALUE4]], align 1, !tbaa [[TBAA6]]
// CHECK-128-NEXT:    store <1 x i8> [[TMP3]], ptr [[RETVAL_COERCE]], align 1
// CHECK-128-NEXT:    [[TMP4:%.*]] = load <vscale x 4 x i1>, ptr [[RETVAL_COERCE]], align 1
// CHECK-128-NEXT:    ret <vscale x 4 x i1> [[TMP4]]
//
fixed_bool64_t call_bool64_ff(fixed_bool64_t op1, fixed_bool64_t op2) {
  return __riscv_vmand(op1, op2, __riscv_v_fixed_vlen / 64);
}

//===----------------------------------------------------------------------===//
// fixed, scalable
//===----------------------------------------------------------------------===//

// CHECK-64-LABEL: @call_bool32_fs(
// CHECK-64-NEXT:  entry:
// CHECK-64-NEXT:    [[SAVED_VALUE:%.*]] = alloca <1 x i8>, align 1
// CHECK-64-NEXT:    [[SAVED_VALUE1:%.*]] = alloca <vscale x 2 x i1>, align 1
// CHECK-64-NEXT:    [[OP1_COERCE:%.*]] = bitcast <vscale x 8 x i1> [[TMP0:%.*]] to <vscale x 1 x i8>
// CHECK-64-NEXT:    [[OP1:%.*]] = tail call <1 x i8> @llvm.vector.extract.v1i8.nxv1i8(<vscale x 1 x i8> [[OP1_COERCE]], i64 0)
// CHECK-64-NEXT:    store <1 x i8> [[OP1]], ptr [[SAVED_VALUE]], align 1, !tbaa [[TBAA6]]
// CHECK-64-NEXT:    [[TMP1:%.*]] = load <vscale x 2 x i1>, ptr [[SAVED_VALUE]], align 1, !tbaa [[TBAA6]]
// CHECK-64-NEXT:    [[TMP2:%.*]] = tail call <vscale x 2 x i1> @llvm.riscv.vmand.nxv2i1.i64(<vscale x 2 x i1> [[TMP1]], <vscale x 2 x i1> [[OP2:%.*]], i64 2)
// CHECK-64-NEXT:    store <vscale x 2 x i1> [[TMP2]], ptr [[SAVED_VALUE1]], align 1, !tbaa [[TBAA9]]
// CHECK-64-NEXT:    [[TMP3:%.*]] = load <1 x i8>, ptr [[SAVED_VALUE1]], align 1, !tbaa [[TBAA6]]
// CHECK-64-NEXT:    [[CAST_SCALABLE:%.*]] = tail call <vscale x 1 x i8> @llvm.vector.insert.nxv1i8.v1i8(<vscale x 1 x i8> undef, <1 x i8> [[TMP3]], i64 0)
// CHECK-64-NEXT:    [[TMP4:%.*]] = bitcast <vscale x 1 x i8> [[CAST_SCALABLE]] to <vscale x 8 x i1>
// CHECK-64-NEXT:    ret <vscale x 8 x i1> [[TMP4]]
//
// CHECK-128-LABEL: @call_bool32_fs(
// CHECK-128-NEXT:  entry:
// CHECK-128-NEXT:    [[OP1:%.*]] = alloca <1 x i8>, align 1
// CHECK-128-NEXT:    [[SAVED_VALUE2:%.*]] = alloca <vscale x 2 x i1>, align 1
// CHECK-128-NEXT:    [[RETVAL_COERCE:%.*]] = alloca <vscale x 4 x i1>, align 1
// CHECK-128-NEXT:    store <vscale x 4 x i1> [[OP1_COERCE:%.*]], ptr [[OP1]], align 1
// CHECK-128-NEXT:    [[TMP0:%.*]] = load <vscale x 2 x i1>, ptr [[OP1]], align 1, !tbaa [[TBAA6]]
// CHECK-128-NEXT:    [[TMP1:%.*]] = tail call <vscale x 2 x i1> @llvm.riscv.vmand.nxv2i1.i64(<vscale x 2 x i1> [[TMP0]], <vscale x 2 x i1> [[OP2:%.*]], i64 4)
// CHECK-128-NEXT:    store <vscale x 2 x i1> [[TMP1]], ptr [[SAVED_VALUE2]], align 1, !tbaa [[TBAA9]]
// CHECK-128-NEXT:    [[TMP2:%.*]] = load <1 x i8>, ptr [[SAVED_VALUE2]], align 1, !tbaa [[TBAA6]]
// CHECK-128-NEXT:    store <1 x i8> [[TMP2]], ptr [[RETVAL_COERCE]], align 1
// CHECK-128-NEXT:    [[TMP3:%.*]] = load <vscale x 4 x i1>, ptr [[RETVAL_COERCE]], align 1
// CHECK-128-NEXT:    ret <vscale x 4 x i1> [[TMP3]]
//
fixed_bool32_t call_bool32_fs(fixed_bool32_t op1, vbool32_t op2) {
  return __riscv_vmand(op1, op2, __riscv_v_fixed_vlen / 32);
}

// CHECK-64-LABEL: @call_bool64_fs(
// CHECK-64-NEXT:  entry:
// CHECK-64-NEXT:    [[SAVED_VALUE:%.*]] = alloca <1 x i8>, align 1
// CHECK-64-NEXT:    [[SAVED_VALUE1:%.*]] = alloca <vscale x 1 x i1>, align 1
// CHECK-64-NEXT:    [[OP1_COERCE:%.*]] = bitcast <vscale x 8 x i1> [[TMP0:%.*]] to <vscale x 1 x i8>
// CHECK-64-NEXT:    [[OP1:%.*]] = tail call <1 x i8> @llvm.vector.extract.v1i8.nxv1i8(<vscale x 1 x i8> [[OP1_COERCE]], i64 0)
// CHECK-64-NEXT:    store <1 x i8> [[OP1]], ptr [[SAVED_VALUE]], align 1, !tbaa [[TBAA6]]
// CHECK-64-NEXT:    [[TMP1:%.*]] = load <vscale x 1 x i1>, ptr [[SAVED_VALUE]], align 1, !tbaa [[TBAA6]]
// CHECK-64-NEXT:    [[TMP2:%.*]] = tail call <vscale x 1 x i1> @llvm.riscv.vmand.nxv1i1.i64(<vscale x 1 x i1> [[TMP1]], <vscale x 1 x i1> [[OP2:%.*]], i64 1)
// CHECK-64-NEXT:    store <vscale x 1 x i1> [[TMP2]], ptr [[SAVED_VALUE1]], align 1, !tbaa [[TBAA11]]
// CHECK-64-NEXT:    [[TMP3:%.*]] = load <1 x i8>, ptr [[SAVED_VALUE1]], align 1, !tbaa [[TBAA6]]
// CHECK-64-NEXT:    [[CAST_SCALABLE:%.*]] = tail call <vscale x 1 x i8> @llvm.vector.insert.nxv1i8.v1i8(<vscale x 1 x i8> undef, <1 x i8> [[TMP3]], i64 0)
// CHECK-64-NEXT:    [[TMP4:%.*]] = bitcast <vscale x 1 x i8> [[CAST_SCALABLE]] to <vscale x 8 x i1>
// CHECK-64-NEXT:    ret <vscale x 8 x i1> [[TMP4]]
//
// CHECK-128-LABEL: @call_bool64_fs(
// CHECK-128-NEXT:  entry:
// CHECK-128-NEXT:    [[OP1:%.*]] = alloca <1 x i8>, align 1
// CHECK-128-NEXT:    [[SAVED_VALUE2:%.*]] = alloca <vscale x 1 x i1>, align 1
// CHECK-128-NEXT:    [[RETVAL_COERCE:%.*]] = alloca <vscale x 4 x i1>, align 1
// CHECK-128-NEXT:    store <vscale x 4 x i1> [[OP1_COERCE:%.*]], ptr [[OP1]], align 1
// CHECK-128-NEXT:    [[TMP0:%.*]] = load <vscale x 1 x i1>, ptr [[OP1]], align 1, !tbaa [[TBAA6]]
// CHECK-128-NEXT:    [[TMP1:%.*]] = tail call <vscale x 1 x i1> @llvm.riscv.vmand.nxv1i1.i64(<vscale x 1 x i1> [[TMP0]], <vscale x 1 x i1> [[OP2:%.*]], i64 2)
// CHECK-128-NEXT:    store <vscale x 1 x i1> [[TMP1]], ptr [[SAVED_VALUE2]], align 1, !tbaa [[TBAA11]]
// CHECK-128-NEXT:    [[TMP2:%.*]] = load <1 x i8>, ptr [[SAVED_VALUE2]], align 1, !tbaa [[TBAA6]]
// CHECK-128-NEXT:    store <1 x i8> [[TMP2]], ptr [[RETVAL_COERCE]], align 1
// CHECK-128-NEXT:    [[TMP3:%.*]] = load <vscale x 4 x i1>, ptr [[RETVAL_COERCE]], align 1
// CHECK-128-NEXT:    ret <vscale x 4 x i1> [[TMP3]]
//
fixed_bool64_t call_bool64_fs(fixed_bool64_t op1, vbool64_t op2) {
  return __riscv_vmand(op1, op2, __riscv_v_fixed_vlen / 64);
}

//===----------------------------------------------------------------------===//
// scalable, scalable
//===----------------------------------------------------------------------===//

// CHECK-64-LABEL: @call_bool32_ss(
// CHECK-64-NEXT:  entry:
// CHECK-64-NEXT:    [[SAVED_VALUE:%.*]] = alloca <vscale x 2 x i1>, align 1
// CHECK-64-NEXT:    [[TMP0:%.*]] = tail call <vscale x 2 x i1> @llvm.riscv.vmand.nxv2i1.i64(<vscale x 2 x i1> [[OP1:%.*]], <vscale x 2 x i1> [[OP2:%.*]], i64 2)
// CHECK-64-NEXT:    store <vscale x 2 x i1> [[TMP0]], ptr [[SAVED_VALUE]], align 1, !tbaa [[TBAA9]]
// CHECK-64-NEXT:    [[TMP1:%.*]] = load <1 x i8>, ptr [[SAVED_VALUE]], align 1, !tbaa [[TBAA6]]
// CHECK-64-NEXT:    [[CAST_SCALABLE:%.*]] = tail call <vscale x 1 x i8> @llvm.vector.insert.nxv1i8.v1i8(<vscale x 1 x i8> undef, <1 x i8> [[TMP1]], i64 0)
// CHECK-64-NEXT:    [[TMP2:%.*]] = bitcast <vscale x 1 x i8> [[CAST_SCALABLE]] to <vscale x 8 x i1>
// CHECK-64-NEXT:    ret <vscale x 8 x i1> [[TMP2]]
//
// CHECK-128-LABEL: @call_bool32_ss(
// CHECK-128-NEXT:  entry:
// CHECK-128-NEXT:    [[SAVED_VALUE:%.*]] = alloca <vscale x 2 x i1>, align 1
// CHECK-128-NEXT:    [[RETVAL_COERCE:%.*]] = alloca <vscale x 4 x i1>, align 1
// CHECK-128-NEXT:    [[TMP0:%.*]] = tail call <vscale x 2 x i1> @llvm.riscv.vmand.nxv2i1.i64(<vscale x 2 x i1> [[OP1:%.*]], <vscale x 2 x i1> [[OP2:%.*]], i64 4)
// CHECK-128-NEXT:    store <vscale x 2 x i1> [[TMP0]], ptr [[SAVED_VALUE]], align 1, !tbaa [[TBAA9]]
// CHECK-128-NEXT:    [[TMP1:%.*]] = load <1 x i8>, ptr [[SAVED_VALUE]], align 1, !tbaa [[TBAA6]]
// CHECK-128-NEXT:    store <1 x i8> [[TMP1]], ptr [[RETVAL_COERCE]], align 1
// CHECK-128-NEXT:    [[TMP2:%.*]] = load <vscale x 4 x i1>, ptr [[RETVAL_COERCE]], align 1
// CHECK-128-NEXT:    ret <vscale x 4 x i1> [[TMP2]]
//
fixed_bool32_t call_bool32_ss(vbool32_t op1, vbool32_t op2) {
  return __riscv_vmand(op1, op2, __riscv_v_fixed_vlen / 32);
}

// CHECK-64-LABEL: @call_bool64_ss(
// CHECK-64-NEXT:  entry:
// CHECK-64-NEXT:    [[SAVED_VALUE:%.*]] = alloca <vscale x 1 x i1>, align 1
// CHECK-64-NEXT:    [[TMP0:%.*]] = tail call <vscale x 1 x i1> @llvm.riscv.vmand.nxv1i1.i64(<vscale x 1 x i1> [[OP1:%.*]], <vscale x 1 x i1> [[OP2:%.*]], i64 1)
// CHECK-64-NEXT:    store <vscale x 1 x i1> [[TMP0]], ptr [[SAVED_VALUE]], align 1, !tbaa [[TBAA11]]
// CHECK-64-NEXT:    [[TMP1:%.*]] = load <1 x i8>, ptr [[SAVED_VALUE]], align 1, !tbaa [[TBAA6]]
// CHECK-64-NEXT:    [[CAST_SCALABLE:%.*]] = tail call <vscale x 1 x i8> @llvm.vector.insert.nxv1i8.v1i8(<vscale x 1 x i8> undef, <1 x i8> [[TMP1]], i64 0)
// CHECK-64-NEXT:    [[TMP2:%.*]] = bitcast <vscale x 1 x i8> [[CAST_SCALABLE]] to <vscale x 8 x i1>
// CHECK-64-NEXT:    ret <vscale x 8 x i1> [[TMP2]]
//
// CHECK-128-LABEL: @call_bool64_ss(
// CHECK-128-NEXT:  entry:
// CHECK-128-NEXT:    [[SAVED_VALUE:%.*]] = alloca <vscale x 1 x i1>, align 1
// CHECK-128-NEXT:    [[RETVAL_COERCE:%.*]] = alloca <vscale x 4 x i1>, align 1
// CHECK-128-NEXT:    [[TMP0:%.*]] = tail call <vscale x 1 x i1> @llvm.riscv.vmand.nxv1i1.i64(<vscale x 1 x i1> [[OP1:%.*]], <vscale x 1 x i1> [[OP2:%.*]], i64 2)
// CHECK-128-NEXT:    store <vscale x 1 x i1> [[TMP0]], ptr [[SAVED_VALUE]], align 1, !tbaa [[TBAA11]]
// CHECK-128-NEXT:    [[TMP1:%.*]] = load <1 x i8>, ptr [[SAVED_VALUE]], align 1, !tbaa [[TBAA6]]
// CHECK-128-NEXT:    store <1 x i8> [[TMP1]], ptr [[RETVAL_COERCE]], align 1
// CHECK-128-NEXT:    [[TMP2:%.*]] = load <vscale x 4 x i1>, ptr [[RETVAL_COERCE]], align 1
// CHECK-128-NEXT:    ret <vscale x 4 x i1> [[TMP2]]
//
fixed_bool64_t call_bool64_ss(vbool64_t op1, vbool64_t op2) {
  return __riscv_vmand(op1, op2, __riscv_v_fixed_vlen / 64);
}
