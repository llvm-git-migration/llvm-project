// NOTE: Assertions have been autogenerated by utils/update_cc_test_checks.py UTC_ARGS: --version 5
// RUN: %clang_cc1 %s -emit-llvm -o - -triple=amdgcn-amd-amdhsa -ffreestanding \
// RUN:   -fvisibility=hidden | FileCheck --check-prefix=AMDGCN %s
//: %clang_cc1 %s -emit-llvm -o - -triple=spirv64-unknown-unknown -ffreestanding \
//:   -fvisibility=hidden | FileCheck --check-prefix=SPIRV %s

//
// SPIRV-LABEL: define hidden spir_func void @fe1a(
// SPIRV-SAME: ) #[[ATTR0:[0-9]+]] {
// SPIRV-NEXT:  [[ENTRY:.*:]]
// SPIRV-NEXT:    fence syncscope("workgroup") release
// SPIRV-NEXT:    ret void
// AMDGCN-LABEL: define hidden void @fe1a(
// AMDGCN-SAME: ) #[[ATTR0:[0-9]+]] {
// AMDGCN-NEXT:  [[ENTRY:.*:]]
// AMDGCN-NEXT:    fence syncscope("workgroup-one-as") release
// AMDGCN-NEXT:    ret void
//
void fe1a() {
  __scoped_atomic_thread_fence(__ATOMIC_RELEASE, __MEMORY_SCOPE_WRKGRP);
}

//
// SPIRV-LABEL: define hidden spir_func void @fe1b(
// SPIRV-SAME: i32 noundef [[ORD:%.*]]) #[[ATTR0]] {
// SPIRV-NEXT:  [[ENTRY:.*:]]
// SPIRV-NEXT:    [[ORD_ADDR:%.*]] = alloca i32, align 4
// SPIRV-NEXT:    store i32 [[ORD]], ptr [[ORD_ADDR]], align 4
// SPIRV-NEXT:    [[TMP0:%.*]] = load i32, ptr [[ORD_ADDR]], align 4
// SPIRV-NEXT:    switch i32 [[TMP0]], label %[[ATOMIC_SCOPE_CONTINUE:.*]] [
// SPIRV-NEXT:      i32 1, label %[[ACQUIRE:.*]]
// SPIRV-NEXT:      i32 2, label %[[ACQUIRE]]
// SPIRV-NEXT:      i32 3, label %[[RELEASE:.*]]
// SPIRV-NEXT:      i32 4, label %[[ACQREL:.*]]
// SPIRV-NEXT:      i32 5, label %[[SEQCST:.*]]
// SPIRV-NEXT:    ]
// SPIRV:       [[ATOMIC_SCOPE_CONTINUE]]:
// SPIRV-NEXT:    ret void
// SPIRV:       [[ACQUIRE]]:
// SPIRV-NEXT:    fence syncscope("workgroup") acquire
// SPIRV-NEXT:    br label %[[ATOMIC_SCOPE_CONTINUE]]
// SPIRV:       [[RELEASE]]:
// SPIRV-NEXT:    fence syncscope("workgroup") release
// SPIRV-NEXT:    br label %[[ATOMIC_SCOPE_CONTINUE]]
// SPIRV:       [[ACQREL]]:
// SPIRV-NEXT:    fence syncscope("workgroup") acq_rel
// SPIRV-NEXT:    br label %[[ATOMIC_SCOPE_CONTINUE]]
// SPIRV:       [[SEQCST]]:
// SPIRV-NEXT:    fence syncscope("workgroup") seq_cst
// SPIRV-NEXT:    br label %[[ATOMIC_SCOPE_CONTINUE]]
// AMDGCN-LABEL: define hidden void @fe1b(
// AMDGCN-SAME: i32 noundef [[ORD:%.*]]) #[[ATTR0]] {
// AMDGCN-NEXT:  [[ENTRY:.*:]]
// AMDGCN-NEXT:    [[ORD_ADDR:%.*]] = alloca i32, align 4, addrspace(5)
// AMDGCN-NEXT:    [[ORD_ADDR_ASCAST:%.*]] = addrspacecast ptr addrspace(5) [[ORD_ADDR]] to ptr
// AMDGCN-NEXT:    store i32 [[ORD]], ptr [[ORD_ADDR_ASCAST]], align 4
// AMDGCN-NEXT:    [[TMP0:%.*]] = load i32, ptr [[ORD_ADDR_ASCAST]], align 4
// AMDGCN-NEXT:    switch i32 [[TMP0]], label %[[ATOMIC_SCOPE_CONTINUE:.*]] [
// AMDGCN-NEXT:      i32 1, label %[[ACQUIRE:.*]]
// AMDGCN-NEXT:      i32 2, label %[[ACQUIRE]]
// AMDGCN-NEXT:      i32 3, label %[[RELEASE:.*]]
// AMDGCN-NEXT:      i32 4, label %[[ACQREL:.*]]
// AMDGCN-NEXT:      i32 5, label %[[SEQCST:.*]]
// AMDGCN-NEXT:    ]
// AMDGCN:       [[ATOMIC_SCOPE_CONTINUE]]:
// AMDGCN-NEXT:    ret void
// AMDGCN:       [[ACQUIRE]]:
// AMDGCN-NEXT:    fence syncscope("workgroup-one-as") acquire
// AMDGCN-NEXT:    br label %[[ATOMIC_SCOPE_CONTINUE]]
// AMDGCN:       [[RELEASE]]:
// AMDGCN-NEXT:    fence syncscope("workgroup-one-as") release
// AMDGCN-NEXT:    br label %[[ATOMIC_SCOPE_CONTINUE]]
// AMDGCN:       [[ACQREL]]:
// AMDGCN-NEXT:    fence syncscope("workgroup-one-as") acq_rel
// AMDGCN-NEXT:    br label %[[ATOMIC_SCOPE_CONTINUE]]
// AMDGCN:       [[SEQCST]]:
// AMDGCN-NEXT:    fence syncscope("workgroup") seq_cst
// AMDGCN-NEXT:    br label %[[ATOMIC_SCOPE_CONTINUE]]
//
void fe1b(int ord) {
  __scoped_atomic_thread_fence(ord, __MEMORY_SCOPE_WRKGRP);
}

//
// SPIRV-LABEL: define hidden spir_func void @fe1c(
// SPIRV-SAME: i32 noundef [[SCOPE:%.*]]) #[[ATTR0]] {
// SPIRV-NEXT:  [[ENTRY:.*:]]
// SPIRV-NEXT:    [[SCOPE_ADDR:%.*]] = alloca i32, align 4
// SPIRV-NEXT:    store i32 [[SCOPE]], ptr [[SCOPE_ADDR]], align 4
// SPIRV-NEXT:    [[TMP0:%.*]] = load i32, ptr [[SCOPE_ADDR]], align 4
// SPIRV-NEXT:    switch i32 [[TMP0]], label %[[ATOMIC_SCOPE_CONTINUE:.*]] [
// SPIRV-NEXT:      i32 1, label %[[DEVICE_SCOPE:.*]]
// SPIRV-NEXT:      i32 0, label %[[SYSTEM_SCOPE:.*]]
// SPIRV-NEXT:      i32 2, label %[[WORKGROUP_SCOPE:.*]]
// SPIRV-NEXT:      i32 3, label %[[WAVEFRONT_SCOPE:.*]]
// SPIRV-NEXT:      i32 4, label %[[SINGLE_SCOPE:.*]]
// SPIRV-NEXT:    ]
// SPIRV:       [[ATOMIC_SCOPE_CONTINUE]]:
// SPIRV-NEXT:    ret void
// SPIRV:       [[DEVICE_SCOPE]]:
// SPIRV-NEXT:    fence syncscope("device") release
// SPIRV-NEXT:    br label %[[ATOMIC_SCOPE_CONTINUE]]
// SPIRV:       [[SYSTEM_SCOPE]]:
// SPIRV-NEXT:    fence release
// SPIRV-NEXT:    br label %[[ATOMIC_SCOPE_CONTINUE]]
// SPIRV:       [[WORKGROUP_SCOPE]]:
// SPIRV-NEXT:    fence syncscope("workgroup") release
// SPIRV-NEXT:    br label %[[ATOMIC_SCOPE_CONTINUE]]
// SPIRV:       [[WAVEFRONT_SCOPE]]:
// SPIRV-NEXT:    fence syncscope("subgroup") release
// SPIRV-NEXT:    br label %[[ATOMIC_SCOPE_CONTINUE]]
// SPIRV:       [[SINGLE_SCOPE]]:
// SPIRV-NEXT:    fence syncscope("singlethread") release
// SPIRV-NEXT:    br label %[[ATOMIC_SCOPE_CONTINUE]]
// AMDGCN-LABEL: define hidden void @fe1c(
// AMDGCN-SAME: i32 noundef [[SCOPE:%.*]]) #[[ATTR0]] {
// AMDGCN-NEXT:  [[ENTRY:.*:]]
// AMDGCN-NEXT:    [[SCOPE_ADDR:%.*]] = alloca i32, align 4, addrspace(5)
// AMDGCN-NEXT:    [[SCOPE_ADDR_ASCAST:%.*]] = addrspacecast ptr addrspace(5) [[SCOPE_ADDR]] to ptr
// AMDGCN-NEXT:    store i32 [[SCOPE]], ptr [[SCOPE_ADDR_ASCAST]], align 4
// AMDGCN-NEXT:    [[TMP0:%.*]] = load i32, ptr [[SCOPE_ADDR_ASCAST]], align 4
// AMDGCN-NEXT:    switch i32 [[TMP0]], label %[[ATOMIC_SCOPE_CONTINUE:.*]] [
// AMDGCN-NEXT:      i32 1, label %[[DEVICE_SCOPE:.*]]
// AMDGCN-NEXT:      i32 0, label %[[SYSTEM_SCOPE:.*]]
// AMDGCN-NEXT:      i32 2, label %[[WORKGROUP_SCOPE:.*]]
// AMDGCN-NEXT:      i32 3, label %[[WAVEFRONT_SCOPE:.*]]
// AMDGCN-NEXT:      i32 4, label %[[SINGLE_SCOPE:.*]]
// AMDGCN-NEXT:    ]
// AMDGCN:       [[ATOMIC_SCOPE_CONTINUE]]:
// AMDGCN-NEXT:    ret void
// AMDGCN:       [[DEVICE_SCOPE]]:
// AMDGCN-NEXT:    fence syncscope("agent-one-as") release
// AMDGCN-NEXT:    br label %[[ATOMIC_SCOPE_CONTINUE]]
// AMDGCN:       [[SYSTEM_SCOPE]]:
// AMDGCN-NEXT:    fence syncscope("one-as") release
// AMDGCN-NEXT:    br label %[[ATOMIC_SCOPE_CONTINUE]]
// AMDGCN:       [[WORKGROUP_SCOPE]]:
// AMDGCN-NEXT:    fence syncscope("workgroup-one-as") release
// AMDGCN-NEXT:    br label %[[ATOMIC_SCOPE_CONTINUE]]
// AMDGCN:       [[WAVEFRONT_SCOPE]]:
// AMDGCN-NEXT:    fence syncscope("wavefront-one-as") release
// AMDGCN-NEXT:    br label %[[ATOMIC_SCOPE_CONTINUE]]
// AMDGCN:       [[SINGLE_SCOPE]]:
// AMDGCN-NEXT:    fence syncscope("singlethread-one-as") release
// AMDGCN-NEXT:    br label %[[ATOMIC_SCOPE_CONTINUE]]
//
void fe1c(int scope) {
  __scoped_atomic_thread_fence(__ATOMIC_RELEASE, scope);
}

//
// SPIRV-LABEL: define hidden spir_func void @fe2a(
// SPIRV-SAME: ) #[[ATTR0]] {
// SPIRV-NEXT:  [[ENTRY:.*:]]
// SPIRV-NEXT:    ret void
// AMDGCN-LABEL: define hidden void @fe2a(
// AMDGCN-SAME: ) #[[ATTR0]] {
// AMDGCN-NEXT:  [[ENTRY:.*:]]
// AMDGCN-NEXT:    ret void
//
void fe2a() {
  __scoped_atomic_thread_fence(999, __MEMORY_SCOPE_SYSTEM);
}

//
// SPIRV-LABEL: define hidden spir_func void @fe2b(
// SPIRV-SAME: ) #[[ATTR0]] {
// SPIRV-NEXT:  [[ENTRY:.*:]]
// SPIRV-NEXT:    fence release
// SPIRV-NEXT:    ret void
// AMDGCN-LABEL: define hidden void @fe2b(
// AMDGCN-SAME: ) #[[ATTR0]] {
// AMDGCN-NEXT:  [[ENTRY:.*:]]
// AMDGCN-NEXT:    fence syncscope("one-as") release
// AMDGCN-NEXT:    ret void
//
void fe2b() {
  __scoped_atomic_thread_fence(__ATOMIC_RELEASE, 999);
}
