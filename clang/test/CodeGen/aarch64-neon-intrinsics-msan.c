// NOTE: Assertions have been autogenerated by utils/update_cc_test_checks.py UTC_ARGS: --version 4
// RUN: %clang_cc1 -triple arm64-none-linux-gnu -target-feature +neon \
// RUN:     -S -disable-O0-optnone \
// RUN:  -flax-vector-conversions=none -emit-llvm -o - %s \
// RUN: | opt -S -passes=mem2reg \
// RUN: | opt -S -passes=msan \
// RUN: | FileCheck %s

// REQUIRES: aarch64-registered-target || arm-registered-target

// Forked from aarch64-neon-intrinsics.c

#include <arm_neon.h>

// CHECK-LABEL: define dso_local <16 x i8> @test_vld1q_u8(
// CHECK-SAME: ptr noundef [[A:%.*]]) #[[ATTR0:[0-9]+]] {
// CHECK-NEXT:  entry:
// CHECK-NEXT:    call void @llvm.donothing()
// CHECK-NEXT:    [[TMP0:%.*]] = load <16 x i8>, ptr [[A]], align 1
// CHECK-NEXT:    store <16 x i8> zeroinitializer, ptr @__msan_retval_tls, align 8
// CHECK-NEXT:    ret <16 x i8> [[TMP0]]
//
uint8x16_t test_vld1q_u8(uint8_t const *a) {
  return vld1q_u8(a);
}

// CHECK-LABEL: define dso_local <8 x i16> @test_vld1q_u16(
// CHECK-SAME: ptr noundef [[A:%.*]]) #[[ATTR0]] {
// CHECK-NEXT:  entry:
// CHECK-NEXT:    call void @llvm.donothing()
// CHECK-NEXT:    [[TMP0:%.*]] = load <8 x i16>, ptr [[A]], align 2
// CHECK-NEXT:    store <8 x i16> zeroinitializer, ptr @__msan_retval_tls, align 8
// CHECK-NEXT:    ret <8 x i16> [[TMP0]]
//
uint16x8_t test_vld1q_u16(uint16_t const *a) {
  return vld1q_u16(a);
}

// CHECK-LABEL: define dso_local <4 x i32> @test_vld1q_u32(
// CHECK-SAME: ptr noundef [[A:%.*]]) #[[ATTR0]] {
// CHECK-NEXT:  entry:
// CHECK-NEXT:    call void @llvm.donothing()
// CHECK-NEXT:    [[TMP0:%.*]] = load <4 x i32>, ptr [[A]], align 4
// CHECK-NEXT:    store <4 x i32> zeroinitializer, ptr @__msan_retval_tls, align 8
// CHECK-NEXT:    ret <4 x i32> [[TMP0]]
//
uint32x4_t test_vld1q_u32(uint32_t const *a) {
  return vld1q_u32(a);
}

// CHECK-LABEL: define dso_local <2 x i64> @test_vld1q_u64(
// CHECK-SAME: ptr noundef [[A:%.*]]) #[[ATTR0]] {
// CHECK-NEXT:  entry:
// CHECK-NEXT:    call void @llvm.donothing()
// CHECK-NEXT:    [[TMP0:%.*]] = load <2 x i64>, ptr [[A]], align 8
// CHECK-NEXT:    store <2 x i64> zeroinitializer, ptr @__msan_retval_tls, align 8
// CHECK-NEXT:    ret <2 x i64> [[TMP0]]
//
uint64x2_t test_vld1q_u64(uint64_t const *a) {
  return vld1q_u64(a);
}

// CHECK-LABEL: define dso_local <16 x i8> @test_vld1q_s8(
// CHECK-SAME: ptr noundef [[A:%.*]]) #[[ATTR0]] {
// CHECK-NEXT:  entry:
// CHECK-NEXT:    call void @llvm.donothing()
// CHECK-NEXT:    [[TMP0:%.*]] = load <16 x i8>, ptr [[A]], align 1
// CHECK-NEXT:    store <16 x i8> zeroinitializer, ptr @__msan_retval_tls, align 8
// CHECK-NEXT:    ret <16 x i8> [[TMP0]]
//
int8x16_t test_vld1q_s8(int8_t const *a) {
  return vld1q_s8(a);
}

// CHECK-LABEL: define dso_local <8 x i16> @test_vld1q_s16(
// CHECK-SAME: ptr noundef [[A:%.*]]) #[[ATTR0]] {
// CHECK-NEXT:  entry:
// CHECK-NEXT:    call void @llvm.donothing()
// CHECK-NEXT:    [[TMP0:%.*]] = load <8 x i16>, ptr [[A]], align 2
// CHECK-NEXT:    store <8 x i16> zeroinitializer, ptr @__msan_retval_tls, align 8
// CHECK-NEXT:    ret <8 x i16> [[TMP0]]
//
int16x8_t test_vld1q_s16(int16_t const *a) {
  return vld1q_s16(a);
}

// CHECK-LABEL: define dso_local <4 x i32> @test_vld1q_s32(
// CHECK-SAME: ptr noundef [[A:%.*]]) #[[ATTR0]] {
// CHECK-NEXT:  entry:
// CHECK-NEXT:    call void @llvm.donothing()
// CHECK-NEXT:    [[TMP0:%.*]] = load <4 x i32>, ptr [[A]], align 4
// CHECK-NEXT:    store <4 x i32> zeroinitializer, ptr @__msan_retval_tls, align 8
// CHECK-NEXT:    ret <4 x i32> [[TMP0]]
//
int32x4_t test_vld1q_s32(int32_t const *a) {
  return vld1q_s32(a);
}

// CHECK-LABEL: define dso_local <2 x i64> @test_vld1q_s64(
// CHECK-SAME: ptr noundef [[A:%.*]]) #[[ATTR0]] {
// CHECK-NEXT:  entry:
// CHECK-NEXT:    call void @llvm.donothing()
// CHECK-NEXT:    [[TMP0:%.*]] = load <2 x i64>, ptr [[A]], align 8
// CHECK-NEXT:    store <2 x i64> zeroinitializer, ptr @__msan_retval_tls, align 8
// CHECK-NEXT:    ret <2 x i64> [[TMP0]]
//
int64x2_t test_vld1q_s64(int64_t const *a) {
  return vld1q_s64(a);
}

// CHECK-LABEL: define dso_local <8 x half> @test_vld1q_f16(
// CHECK-SAME: ptr noundef [[A:%.*]]) #[[ATTR0]] {
// CHECK-NEXT:  entry:
// CHECK-NEXT:    call void @llvm.donothing()
// CHECK-NEXT:    [[TMP0:%.*]] = load <8 x half>, ptr [[A]], align 2
// CHECK-NEXT:    store <8 x i16> zeroinitializer, ptr @__msan_retval_tls, align 8
// CHECK-NEXT:    ret <8 x half> [[TMP0]]
//
float16x8_t test_vld1q_f16(float16_t const *a) {
  return vld1q_f16(a);
}

// CHECK-LABEL: define dso_local <4 x float> @test_vld1q_f32(
// CHECK-SAME: ptr noundef [[A:%.*]]) #[[ATTR0]] {
// CHECK-NEXT:  entry:
// CHECK-NEXT:    call void @llvm.donothing()
// CHECK-NEXT:    [[TMP0:%.*]] = load <4 x float>, ptr [[A]], align 4
// CHECK-NEXT:    store <4 x i32> zeroinitializer, ptr @__msan_retval_tls, align 8
// CHECK-NEXT:    ret <4 x float> [[TMP0]]
//
float32x4_t test_vld1q_f32(float32_t const *a) {
  return vld1q_f32(a);
}

// CHECK-LABEL: define dso_local <2 x double> @test_vld1q_f64(
// CHECK-SAME: ptr noundef [[A:%.*]]) #[[ATTR0]] {
// CHECK-NEXT:  entry:
// CHECK-NEXT:    call void @llvm.donothing()
// CHECK-NEXT:    [[TMP0:%.*]] = load <2 x double>, ptr [[A]], align 8
// CHECK-NEXT:    store <2 x i64> zeroinitializer, ptr @__msan_retval_tls, align 8
// CHECK-NEXT:    ret <2 x double> [[TMP0]]
//
float64x2_t test_vld1q_f64(float64_t const *a) {
  return vld1q_f64(a);
}

// CHECK-LABEL: define dso_local <16 x i8> @test_vld1q_p8(
// CHECK-SAME: ptr noundef [[A:%.*]]) #[[ATTR0]] {
// CHECK-NEXT:  entry:
// CHECK-NEXT:    call void @llvm.donothing()
// CHECK-NEXT:    [[TMP0:%.*]] = load <16 x i8>, ptr [[A]], align 1
// CHECK-NEXT:    store <16 x i8> zeroinitializer, ptr @__msan_retval_tls, align 8
// CHECK-NEXT:    ret <16 x i8> [[TMP0]]
//
poly8x16_t test_vld1q_p8(poly8_t const *a) {
  return vld1q_p8(a);
}

// CHECK-LABEL: define dso_local <8 x i16> @test_vld1q_p16(
// CHECK-SAME: ptr noundef [[A:%.*]]) #[[ATTR0]] {
// CHECK-NEXT:  entry:
// CHECK-NEXT:    call void @llvm.donothing()
// CHECK-NEXT:    [[TMP0:%.*]] = load <8 x i16>, ptr [[A]], align 2
// CHECK-NEXT:    store <8 x i16> zeroinitializer, ptr @__msan_retval_tls, align 8
// CHECK-NEXT:    ret <8 x i16> [[TMP0]]
//
poly16x8_t test_vld1q_p16(poly16_t const *a) {
  return vld1q_p16(a);
}

// CHECK-LABEL: define dso_local <8 x i8> @test_vld1_u8(
// CHECK-SAME: ptr noundef [[A:%.*]]) #[[ATTR0]] {
// CHECK-NEXT:  entry:
// CHECK-NEXT:    call void @llvm.donothing()
// CHECK-NEXT:    [[TMP0:%.*]] = load <8 x i8>, ptr [[A]], align 1
// CHECK-NEXT:    store <8 x i8> zeroinitializer, ptr @__msan_retval_tls, align 8
// CHECK-NEXT:    ret <8 x i8> [[TMP0]]
//
uint8x8_t test_vld1_u8(uint8_t const *a) {
  return vld1_u8(a);
}

// CHECK-LABEL: define dso_local <4 x i16> @test_vld1_u16(
// CHECK-SAME: ptr noundef [[A:%.*]]) #[[ATTR0]] {
// CHECK-NEXT:  entry:
// CHECK-NEXT:    call void @llvm.donothing()
// CHECK-NEXT:    [[TMP0:%.*]] = load <4 x i16>, ptr [[A]], align 2
// CHECK-NEXT:    store <4 x i16> zeroinitializer, ptr @__msan_retval_tls, align 8
// CHECK-NEXT:    ret <4 x i16> [[TMP0]]
//
uint16x4_t test_vld1_u16(uint16_t const *a) {
  return vld1_u16(a);
}

// CHECK-LABEL: define dso_local <2 x i32> @test_vld1_u32(
// CHECK-SAME: ptr noundef [[A:%.*]]) #[[ATTR0]] {
// CHECK-NEXT:  entry:
// CHECK-NEXT:    call void @llvm.donothing()
// CHECK-NEXT:    [[TMP0:%.*]] = load <2 x i32>, ptr [[A]], align 4
// CHECK-NEXT:    store <2 x i32> zeroinitializer, ptr @__msan_retval_tls, align 8
// CHECK-NEXT:    ret <2 x i32> [[TMP0]]
//
uint32x2_t test_vld1_u32(uint32_t const *a) {
  return vld1_u32(a);
}

// CHECK-LABEL: define dso_local <1 x i64> @test_vld1_u64(
// CHECK-SAME: ptr noundef [[A:%.*]]) #[[ATTR0]] {
// CHECK-NEXT:  entry:
// CHECK-NEXT:    call void @llvm.donothing()
// CHECK-NEXT:    [[TMP0:%.*]] = load <1 x i64>, ptr [[A]], align 8
// CHECK-NEXT:    store <1 x i64> zeroinitializer, ptr @__msan_retval_tls, align 8
// CHECK-NEXT:    ret <1 x i64> [[TMP0]]
//
uint64x1_t test_vld1_u64(uint64_t const *a) {
  return vld1_u64(a);
}

// CHECK-LABEL: define dso_local <8 x i8> @test_vld1_s8(
// CHECK-SAME: ptr noundef [[A:%.*]]) #[[ATTR0]] {
// CHECK-NEXT:  entry:
// CHECK-NEXT:    call void @llvm.donothing()
// CHECK-NEXT:    [[TMP0:%.*]] = load <8 x i8>, ptr [[A]], align 1
// CHECK-NEXT:    store <8 x i8> zeroinitializer, ptr @__msan_retval_tls, align 8
// CHECK-NEXT:    ret <8 x i8> [[TMP0]]
//
int8x8_t test_vld1_s8(int8_t const *a) {
  return vld1_s8(a);
}

// CHECK-LABEL: define dso_local <4 x i16> @test_vld1_s16(
// CHECK-SAME: ptr noundef [[A:%.*]]) #[[ATTR0]] {
// CHECK-NEXT:  entry:
// CHECK-NEXT:    call void @llvm.donothing()
// CHECK-NEXT:    [[TMP0:%.*]] = load <4 x i16>, ptr [[A]], align 2
// CHECK-NEXT:    store <4 x i16> zeroinitializer, ptr @__msan_retval_tls, align 8
// CHECK-NEXT:    ret <4 x i16> [[TMP0]]
//
int16x4_t test_vld1_s16(int16_t const *a) {
  return vld1_s16(a);
}

// CHECK-LABEL: define dso_local <2 x i32> @test_vld1_s32(
// CHECK-SAME: ptr noundef [[A:%.*]]) #[[ATTR0]] {
// CHECK-NEXT:  entry:
// CHECK-NEXT:    call void @llvm.donothing()
// CHECK-NEXT:    [[TMP0:%.*]] = load <2 x i32>, ptr [[A]], align 4
// CHECK-NEXT:    store <2 x i32> zeroinitializer, ptr @__msan_retval_tls, align 8
// CHECK-NEXT:    ret <2 x i32> [[TMP0]]
//
int32x2_t test_vld1_s32(int32_t const *a) {
  return vld1_s32(a);
}

// CHECK-LABEL: define dso_local <1 x i64> @test_vld1_s64(
// CHECK-SAME: ptr noundef [[A:%.*]]) #[[ATTR0]] {
// CHECK-NEXT:  entry:
// CHECK-NEXT:    call void @llvm.donothing()
// CHECK-NEXT:    [[TMP0:%.*]] = load <1 x i64>, ptr [[A]], align 8
// CHECK-NEXT:    store <1 x i64> zeroinitializer, ptr @__msan_retval_tls, align 8
// CHECK-NEXT:    ret <1 x i64> [[TMP0]]
//
int64x1_t test_vld1_s64(int64_t const *a) {
  return vld1_s64(a);
}

// CHECK-LABEL: define dso_local <4 x half> @test_vld1_f16(
// CHECK-SAME: ptr noundef [[A:%.*]]) #[[ATTR0]] {
// CHECK-NEXT:  entry:
// CHECK-NEXT:    call void @llvm.donothing()
// CHECK-NEXT:    [[TMP0:%.*]] = load <4 x half>, ptr [[A]], align 2
// CHECK-NEXT:    store <4 x i16> zeroinitializer, ptr @__msan_retval_tls, align 8
// CHECK-NEXT:    ret <4 x half> [[TMP0]]
//
float16x4_t test_vld1_f16(float16_t const *a) {
  return vld1_f16(a);
}

// CHECK-LABEL: define dso_local <2 x float> @test_vld1_f32(
// CHECK-SAME: ptr noundef [[A:%.*]]) #[[ATTR0]] {
// CHECK-NEXT:  entry:
// CHECK-NEXT:    call void @llvm.donothing()
// CHECK-NEXT:    [[TMP0:%.*]] = load <2 x float>, ptr [[A]], align 4
// CHECK-NEXT:    store <2 x i32> zeroinitializer, ptr @__msan_retval_tls, align 8
// CHECK-NEXT:    ret <2 x float> [[TMP0]]
//
float32x2_t test_vld1_f32(float32_t const *a) {
  return vld1_f32(a);
}

// CHECK-LABEL: define dso_local <1 x double> @test_vld1_f64(
// CHECK-SAME: ptr noundef [[A:%.*]]) #[[ATTR0]] {
// CHECK-NEXT:  entry:
// CHECK-NEXT:    call void @llvm.donothing()
// CHECK-NEXT:    [[TMP0:%.*]] = load <1 x double>, ptr [[A]], align 8
// CHECK-NEXT:    store <1 x i64> zeroinitializer, ptr @__msan_retval_tls, align 8
// CHECK-NEXT:    ret <1 x double> [[TMP0]]
//
float64x1_t test_vld1_f64(float64_t const *a) {
  return vld1_f64(a);
}

// CHECK-LABEL: define dso_local <8 x i8> @test_vld1_p8(
// CHECK-SAME: ptr noundef [[A:%.*]]) #[[ATTR0]] {
// CHECK-NEXT:  entry:
// CHECK-NEXT:    call void @llvm.donothing()
// CHECK-NEXT:    [[TMP0:%.*]] = load <8 x i8>, ptr [[A]], align 1
// CHECK-NEXT:    store <8 x i8> zeroinitializer, ptr @__msan_retval_tls, align 8
// CHECK-NEXT:    ret <8 x i8> [[TMP0]]
//
poly8x8_t test_vld1_p8(poly8_t const *a) {
  return vld1_p8(a);
}

// CHECK-LABEL: define dso_local <4 x i16> @test_vld1_p16(
// CHECK-SAME: ptr noundef [[A:%.*]]) #[[ATTR0]] {
// CHECK-NEXT:  entry:
// CHECK-NEXT:    call void @llvm.donothing()
// CHECK-NEXT:    [[TMP0:%.*]] = load <4 x i16>, ptr [[A]], align 2
// CHECK-NEXT:    store <4 x i16> zeroinitializer, ptr @__msan_retval_tls, align 8
// CHECK-NEXT:    ret <4 x i16> [[TMP0]]
//
poly16x4_t test_vld1_p16(poly16_t const *a) {
  return vld1_p16(a);
}

// CHECK-LABEL: define dso_local <8 x i8> @test_vld1_u8_void(
// CHECK-SAME: ptr noundef [[A:%.*]]) #[[ATTR0]] {
// CHECK-NEXT:  entry:
// CHECK-NEXT:    call void @llvm.donothing()
// CHECK-NEXT:    [[TMP0:%.*]] = load <8 x i8>, ptr [[A]], align 1
// CHECK-NEXT:    store <8 x i8> zeroinitializer, ptr @__msan_retval_tls, align 8
// CHECK-NEXT:    ret <8 x i8> [[TMP0]]
//
uint8x8_t test_vld1_u8_void(void *a) {
  return vld1_u8(a);
}

// CHECK-LABEL: define dso_local <4 x i16> @test_vld1_u16_void(
// CHECK-SAME: ptr noundef [[A:%.*]]) #[[ATTR0]] {
// CHECK-NEXT:  entry:
// CHECK-NEXT:    call void @llvm.donothing()
// CHECK-NEXT:    [[TMP0:%.*]] = load <4 x i16>, ptr [[A]], align 1
// CHECK-NEXT:    store <4 x i16> zeroinitializer, ptr @__msan_retval_tls, align 8
// CHECK-NEXT:    ret <4 x i16> [[TMP0]]
//
uint16x4_t test_vld1_u16_void(void *a) {
  return vld1_u16(a);
}

// CHECK-LABEL: define dso_local <2 x i32> @test_vld1_u32_void(
// CHECK-SAME: ptr noundef [[A:%.*]]) #[[ATTR0]] {
// CHECK-NEXT:  entry:
// CHECK-NEXT:    call void @llvm.donothing()
// CHECK-NEXT:    [[TMP0:%.*]] = load <2 x i32>, ptr [[A]], align 1
// CHECK-NEXT:    store <2 x i32> zeroinitializer, ptr @__msan_retval_tls, align 8
// CHECK-NEXT:    ret <2 x i32> [[TMP0]]
//
uint32x2_t test_vld1_u32_void(void *a) {
  return vld1_u32(a);
}

// CHECK-LABEL: define dso_local <1 x i64> @test_vld1_u64_void(
// CHECK-SAME: ptr noundef [[A:%.*]]) #[[ATTR0]] {
// CHECK-NEXT:  entry:
// CHECK-NEXT:    call void @llvm.donothing()
// CHECK-NEXT:    [[TMP0:%.*]] = load <1 x i64>, ptr [[A]], align 1
// CHECK-NEXT:    store <1 x i64> zeroinitializer, ptr @__msan_retval_tls, align 8
// CHECK-NEXT:    ret <1 x i64> [[TMP0]]
//
uint64x1_t test_vld1_u64_void(void *a) {
  return vld1_u64(a);
}

// CHECK-LABEL: define dso_local <8 x i8> @test_vld1_s8_void(
// CHECK-SAME: ptr noundef [[A:%.*]]) #[[ATTR0]] {
// CHECK-NEXT:  entry:
// CHECK-NEXT:    call void @llvm.donothing()
// CHECK-NEXT:    [[TMP0:%.*]] = load <8 x i8>, ptr [[A]], align 1
// CHECK-NEXT:    store <8 x i8> zeroinitializer, ptr @__msan_retval_tls, align 8
// CHECK-NEXT:    ret <8 x i8> [[TMP0]]
//
int8x8_t test_vld1_s8_void(void *a) {
  return vld1_s8(a);
}

// CHECK-LABEL: define dso_local <4 x i16> @test_vld1_s16_void(
// CHECK-SAME: ptr noundef [[A:%.*]]) #[[ATTR0]] {
// CHECK-NEXT:  entry:
// CHECK-NEXT:    call void @llvm.donothing()
// CHECK-NEXT:    [[TMP0:%.*]] = load <4 x i16>, ptr [[A]], align 1
// CHECK-NEXT:    store <4 x i16> zeroinitializer, ptr @__msan_retval_tls, align 8
// CHECK-NEXT:    ret <4 x i16> [[TMP0]]
//
int16x4_t test_vld1_s16_void(void *a) {
  return vld1_s16(a);
}

// CHECK-LABEL: define dso_local <2 x i32> @test_vld1_s32_void(
// CHECK-SAME: ptr noundef [[A:%.*]]) #[[ATTR0]] {
// CHECK-NEXT:  entry:
// CHECK-NEXT:    call void @llvm.donothing()
// CHECK-NEXT:    [[TMP0:%.*]] = load <2 x i32>, ptr [[A]], align 1
// CHECK-NEXT:    store <2 x i32> zeroinitializer, ptr @__msan_retval_tls, align 8
// CHECK-NEXT:    ret <2 x i32> [[TMP0]]
//
int32x2_t test_vld1_s32_void(void *a) {
  return vld1_s32(a);
}

// CHECK-LABEL: define dso_local <1 x i64> @test_vld1_s64_void(
// CHECK-SAME: ptr noundef [[A:%.*]]) #[[ATTR0]] {
// CHECK-NEXT:  entry:
// CHECK-NEXT:    call void @llvm.donothing()
// CHECK-NEXT:    [[TMP0:%.*]] = load <1 x i64>, ptr [[A]], align 1
// CHECK-NEXT:    store <1 x i64> zeroinitializer, ptr @__msan_retval_tls, align 8
// CHECK-NEXT:    ret <1 x i64> [[TMP0]]
//
int64x1_t test_vld1_s64_void(void *a) {
  return vld1_s64(a);
}

// CHECK-LABEL: define dso_local <4 x half> @test_vld1_f16_void(
// CHECK-SAME: ptr noundef [[A:%.*]]) #[[ATTR0]] {
// CHECK-NEXT:  entry:
// CHECK-NEXT:    call void @llvm.donothing()
// CHECK-NEXT:    [[TMP0:%.*]] = load <4 x half>, ptr [[A]], align 1
// CHECK-NEXT:    store <4 x i16> zeroinitializer, ptr @__msan_retval_tls, align 8
// CHECK-NEXT:    ret <4 x half> [[TMP0]]
//
float16x4_t test_vld1_f16_void(void *a) {
  return vld1_f16(a);
}

// CHECK-LABEL: define dso_local <2 x float> @test_vld1_f32_void(
// CHECK-SAME: ptr noundef [[A:%.*]]) #[[ATTR0]] {
// CHECK-NEXT:  entry:
// CHECK-NEXT:    call void @llvm.donothing()
// CHECK-NEXT:    [[TMP0:%.*]] = load <2 x float>, ptr [[A]], align 1
// CHECK-NEXT:    store <2 x i32> zeroinitializer, ptr @__msan_retval_tls, align 8
// CHECK-NEXT:    ret <2 x float> [[TMP0]]
//
float32x2_t test_vld1_f32_void(void *a) {
  return vld1_f32(a);
}

// CHECK-LABEL: define dso_local <1 x double> @test_vld1_f64_void(
// CHECK-SAME: ptr noundef [[A:%.*]]) #[[ATTR0]] {
// CHECK-NEXT:  entry:
// CHECK-NEXT:    call void @llvm.donothing()
// CHECK-NEXT:    [[TMP0:%.*]] = load <1 x double>, ptr [[A]], align 1
// CHECK-NEXT:    store <1 x i64> zeroinitializer, ptr @__msan_retval_tls, align 8
// CHECK-NEXT:    ret <1 x double> [[TMP0]]
//
float64x1_t test_vld1_f64_void(void *a) {
  return vld1_f64(a);
}

// CHECK-LABEL: define dso_local <8 x i8> @test_vld1_p8_void(
// CHECK-SAME: ptr noundef [[A:%.*]]) #[[ATTR0]] {
// CHECK-NEXT:  entry:
// CHECK-NEXT:    call void @llvm.donothing()
// CHECK-NEXT:    [[TMP0:%.*]] = load <8 x i8>, ptr [[A]], align 1
// CHECK-NEXT:    store <8 x i8> zeroinitializer, ptr @__msan_retval_tls, align 8
// CHECK-NEXT:    ret <8 x i8> [[TMP0]]
//
poly8x8_t test_vld1_p8_void(void *a) {
  return vld1_p8(a);
}

// CHECK-LABEL: define dso_local <4 x i16> @test_vld1_p16_void(
// CHECK-SAME: ptr noundef [[A:%.*]]) #[[ATTR0]] {
// CHECK-NEXT:  entry:
// CHECK-NEXT:    call void @llvm.donothing()
// CHECK-NEXT:    [[TMP0:%.*]] = load <4 x i16>, ptr [[A]], align 1
// CHECK-NEXT:    store <4 x i16> zeroinitializer, ptr @__msan_retval_tls, align 8
// CHECK-NEXT:    ret <4 x i16> [[TMP0]]
//
poly16x4_t test_vld1_p16_void(void *a) {
  return vld1_p16(a);
}

// CHECK-LABEL: define dso_local %struct.uint8x16x2_t @test_vld2q_u8(
// CHECK-SAME: ptr noundef [[A:%.*]]) #[[ATTR0]] {
// CHECK-NEXT:  entry:
// CHECK-NEXT:    call void @llvm.donothing()
// CHECK-NEXT:    [[RETVAL:%.*]] = alloca [[STRUCT_UINT8X16X2_T:%.*]], align 16
// CHECK-NEXT:    [[TMP0:%.*]] = ptrtoint ptr [[RETVAL]] to i64
// CHECK-NEXT:    [[TMP1:%.*]] = xor i64 [[TMP0]], 193514046488576
// CHECK-NEXT:    [[TMP2:%.*]] = inttoptr i64 [[TMP1]] to ptr
// CHECK-NEXT:    call void @llvm.memset.p0.i64(ptr align 16 [[TMP2]], i8 0, i64 32, i1 false)
// CHECK-NEXT:    [[__RET:%.*]] = alloca [[STRUCT_UINT8X16X2_T]], align 16
// CHECK-NEXT:    [[TMP3:%.*]] = ptrtoint ptr [[__RET]] to i64
// CHECK-NEXT:    [[TMP4:%.*]] = xor i64 [[TMP3]], 193514046488576
// CHECK-NEXT:    [[TMP5:%.*]] = inttoptr i64 [[TMP4]] to ptr
// CHECK-NEXT:    call void @llvm.memset.p0.i64(ptr align 16 [[TMP5]], i8 0, i64 32, i1 false)
// CHECK-NEXT:    [[VLD2:%.*]] = call { <16 x i8>, <16 x i8> } @llvm.aarch64.neon.ld2.v16i8.p0(ptr [[A]])
// CHECK-NEXT:    [[TMP6:%.*]] = ptrtoint ptr [[__RET]] to i64
// CHECK-NEXT:    [[TMP7:%.*]] = xor i64 [[TMP6]], 193514046488576
// CHECK-NEXT:    [[TMP8:%.*]] = inttoptr i64 [[TMP7]] to ptr
// CHECK-NEXT:    store { <16 x i8>, <16 x i8> } zeroinitializer, ptr [[TMP8]], align 16
// CHECK-NEXT:    store { <16 x i8>, <16 x i8> } [[VLD2]], ptr [[__RET]], align 16
// CHECK-NEXT:    [[TMP9:%.*]] = call ptr @__msan_memcpy(ptr [[RETVAL]], ptr [[__RET]], i64 32)
// CHECK-NEXT:    [[TMP10:%.*]] = load [[STRUCT_UINT8X16X2_T]], ptr [[RETVAL]], align 16
// CHECK-NEXT:    store { [2 x <16 x i8>] } zeroinitializer, ptr @__msan_retval_tls, align 8
// CHECK-NEXT:    ret [[STRUCT_UINT8X16X2_T]] [[TMP10]]
//
uint8x16x2_t test_vld2q_u8(uint8_t const *a) {
  return vld2q_u8(a);
}

// CHECK-LABEL: define dso_local %struct.uint16x8x2_t @test_vld2q_u16(
// CHECK-SAME: ptr noundef [[A:%.*]]) #[[ATTR0]] {
// CHECK-NEXT:  entry:
// CHECK-NEXT:    call void @llvm.donothing()
// CHECK-NEXT:    [[RETVAL:%.*]] = alloca [[STRUCT_UINT16X8X2_T:%.*]], align 16
// CHECK-NEXT:    [[TMP0:%.*]] = ptrtoint ptr [[RETVAL]] to i64
// CHECK-NEXT:    [[TMP1:%.*]] = xor i64 [[TMP0]], 193514046488576
// CHECK-NEXT:    [[TMP2:%.*]] = inttoptr i64 [[TMP1]] to ptr
// CHECK-NEXT:    call void @llvm.memset.p0.i64(ptr align 16 [[TMP2]], i8 0, i64 32, i1 false)
// CHECK-NEXT:    [[__RET:%.*]] = alloca [[STRUCT_UINT16X8X2_T]], align 16
// CHECK-NEXT:    [[TMP3:%.*]] = ptrtoint ptr [[__RET]] to i64
// CHECK-NEXT:    [[TMP4:%.*]] = xor i64 [[TMP3]], 193514046488576
// CHECK-NEXT:    [[TMP5:%.*]] = inttoptr i64 [[TMP4]] to ptr
// CHECK-NEXT:    call void @llvm.memset.p0.i64(ptr align 16 [[TMP5]], i8 0, i64 32, i1 false)
// CHECK-NEXT:    [[VLD2:%.*]] = call { <8 x i16>, <8 x i16> } @llvm.aarch64.neon.ld2.v8i16.p0(ptr [[A]])
// CHECK-NEXT:    [[TMP6:%.*]] = ptrtoint ptr [[__RET]] to i64
// CHECK-NEXT:    [[TMP7:%.*]] = xor i64 [[TMP6]], 193514046488576
// CHECK-NEXT:    [[TMP8:%.*]] = inttoptr i64 [[TMP7]] to ptr
// CHECK-NEXT:    store { <8 x i16>, <8 x i16> } zeroinitializer, ptr [[TMP8]], align 16
// CHECK-NEXT:    store { <8 x i16>, <8 x i16> } [[VLD2]], ptr [[__RET]], align 16
// CHECK-NEXT:    [[TMP9:%.*]] = call ptr @__msan_memcpy(ptr [[RETVAL]], ptr [[__RET]], i64 32)
// CHECK-NEXT:    [[TMP10:%.*]] = load [[STRUCT_UINT16X8X2_T]], ptr [[RETVAL]], align 16
// CHECK-NEXT:    store { [2 x <8 x i16>] } zeroinitializer, ptr @__msan_retval_tls, align 8
// CHECK-NEXT:    ret [[STRUCT_UINT16X8X2_T]] [[TMP10]]
//
uint16x8x2_t test_vld2q_u16(uint16_t const *a) {
  return vld2q_u16(a);
}

// CHECK-LABEL: define dso_local %struct.uint32x4x2_t @test_vld2q_u32(
// CHECK-SAME: ptr noundef [[A:%.*]]) #[[ATTR0]] {
// CHECK-NEXT:  entry:
// CHECK-NEXT:    call void @llvm.donothing()
// CHECK-NEXT:    [[RETVAL:%.*]] = alloca [[STRUCT_UINT32X4X2_T:%.*]], align 16
// CHECK-NEXT:    [[TMP0:%.*]] = ptrtoint ptr [[RETVAL]] to i64
// CHECK-NEXT:    [[TMP1:%.*]] = xor i64 [[TMP0]], 193514046488576
// CHECK-NEXT:    [[TMP2:%.*]] = inttoptr i64 [[TMP1]] to ptr
// CHECK-NEXT:    call void @llvm.memset.p0.i64(ptr align 16 [[TMP2]], i8 0, i64 32, i1 false)
// CHECK-NEXT:    [[__RET:%.*]] = alloca [[STRUCT_UINT32X4X2_T]], align 16
// CHECK-NEXT:    [[TMP3:%.*]] = ptrtoint ptr [[__RET]] to i64
// CHECK-NEXT:    [[TMP4:%.*]] = xor i64 [[TMP3]], 193514046488576
// CHECK-NEXT:    [[TMP5:%.*]] = inttoptr i64 [[TMP4]] to ptr
// CHECK-NEXT:    call void @llvm.memset.p0.i64(ptr align 16 [[TMP5]], i8 0, i64 32, i1 false)
// CHECK-NEXT:    [[VLD2:%.*]] = call { <4 x i32>, <4 x i32> } @llvm.aarch64.neon.ld2.v4i32.p0(ptr [[A]])
// CHECK-NEXT:    [[TMP6:%.*]] = ptrtoint ptr [[__RET]] to i64
// CHECK-NEXT:    [[TMP7:%.*]] = xor i64 [[TMP6]], 193514046488576
// CHECK-NEXT:    [[TMP8:%.*]] = inttoptr i64 [[TMP7]] to ptr
// CHECK-NEXT:    store { <4 x i32>, <4 x i32> } zeroinitializer, ptr [[TMP8]], align 16
// CHECK-NEXT:    store { <4 x i32>, <4 x i32> } [[VLD2]], ptr [[__RET]], align 16
// CHECK-NEXT:    [[TMP9:%.*]] = call ptr @__msan_memcpy(ptr [[RETVAL]], ptr [[__RET]], i64 32)
// CHECK-NEXT:    [[TMP10:%.*]] = load [[STRUCT_UINT32X4X2_T]], ptr [[RETVAL]], align 16
// CHECK-NEXT:    store { [2 x <4 x i32>] } zeroinitializer, ptr @__msan_retval_tls, align 8
// CHECK-NEXT:    ret [[STRUCT_UINT32X4X2_T]] [[TMP10]]
//
uint32x4x2_t test_vld2q_u32(uint32_t const *a) {
  return vld2q_u32(a);
}

// CHECK-LABEL: define dso_local %struct.uint64x2x2_t @test_vld2q_u64(
// CHECK-SAME: ptr noundef [[A:%.*]]) #[[ATTR0]] {
// CHECK-NEXT:  entry:
// CHECK-NEXT:    call void @llvm.donothing()
// CHECK-NEXT:    [[RETVAL:%.*]] = alloca [[STRUCT_UINT64X2X2_T:%.*]], align 16
// CHECK-NEXT:    [[TMP0:%.*]] = ptrtoint ptr [[RETVAL]] to i64
// CHECK-NEXT:    [[TMP1:%.*]] = xor i64 [[TMP0]], 193514046488576
// CHECK-NEXT:    [[TMP2:%.*]] = inttoptr i64 [[TMP1]] to ptr
// CHECK-NEXT:    call void @llvm.memset.p0.i64(ptr align 16 [[TMP2]], i8 0, i64 32, i1 false)
// CHECK-NEXT:    [[__RET:%.*]] = alloca [[STRUCT_UINT64X2X2_T]], align 16
// CHECK-NEXT:    [[TMP3:%.*]] = ptrtoint ptr [[__RET]] to i64
// CHECK-NEXT:    [[TMP4:%.*]] = xor i64 [[TMP3]], 193514046488576
// CHECK-NEXT:    [[TMP5:%.*]] = inttoptr i64 [[TMP4]] to ptr
// CHECK-NEXT:    call void @llvm.memset.p0.i64(ptr align 16 [[TMP5]], i8 0, i64 32, i1 false)
// CHECK-NEXT:    [[VLD2:%.*]] = call { <2 x i64>, <2 x i64> } @llvm.aarch64.neon.ld2.v2i64.p0(ptr [[A]])
// CHECK-NEXT:    [[TMP6:%.*]] = ptrtoint ptr [[__RET]] to i64
// CHECK-NEXT:    [[TMP7:%.*]] = xor i64 [[TMP6]], 193514046488576
// CHECK-NEXT:    [[TMP8:%.*]] = inttoptr i64 [[TMP7]] to ptr
// CHECK-NEXT:    store { <2 x i64>, <2 x i64> } zeroinitializer, ptr [[TMP8]], align 16
// CHECK-NEXT:    store { <2 x i64>, <2 x i64> } [[VLD2]], ptr [[__RET]], align 16
// CHECK-NEXT:    [[TMP9:%.*]] = call ptr @__msan_memcpy(ptr [[RETVAL]], ptr [[__RET]], i64 32)
// CHECK-NEXT:    [[TMP10:%.*]] = load [[STRUCT_UINT64X2X2_T]], ptr [[RETVAL]], align 16
// CHECK-NEXT:    store { [2 x <2 x i64>] } zeroinitializer, ptr @__msan_retval_tls, align 8
// CHECK-NEXT:    ret [[STRUCT_UINT64X2X2_T]] [[TMP10]]
//
uint64x2x2_t test_vld2q_u64(uint64_t const *a) {
  return vld2q_u64(a);
}

// CHECK-LABEL: define dso_local %struct.int8x16x2_t @test_vld2q_s8(
// CHECK-SAME: ptr noundef [[A:%.*]]) #[[ATTR0]] {
// CHECK-NEXT:  entry:
// CHECK-NEXT:    call void @llvm.donothing()
// CHECK-NEXT:    [[RETVAL:%.*]] = alloca [[STRUCT_INT8X16X2_T:%.*]], align 16
// CHECK-NEXT:    [[TMP0:%.*]] = ptrtoint ptr [[RETVAL]] to i64
// CHECK-NEXT:    [[TMP1:%.*]] = xor i64 [[TMP0]], 193514046488576
// CHECK-NEXT:    [[TMP2:%.*]] = inttoptr i64 [[TMP1]] to ptr
// CHECK-NEXT:    call void @llvm.memset.p0.i64(ptr align 16 [[TMP2]], i8 0, i64 32, i1 false)
// CHECK-NEXT:    [[__RET:%.*]] = alloca [[STRUCT_INT8X16X2_T]], align 16
// CHECK-NEXT:    [[TMP3:%.*]] = ptrtoint ptr [[__RET]] to i64
// CHECK-NEXT:    [[TMP4:%.*]] = xor i64 [[TMP3]], 193514046488576
// CHECK-NEXT:    [[TMP5:%.*]] = inttoptr i64 [[TMP4]] to ptr
// CHECK-NEXT:    call void @llvm.memset.p0.i64(ptr align 16 [[TMP5]], i8 0, i64 32, i1 false)
// CHECK-NEXT:    [[VLD2:%.*]] = call { <16 x i8>, <16 x i8> } @llvm.aarch64.neon.ld2.v16i8.p0(ptr [[A]])
// CHECK-NEXT:    [[TMP6:%.*]] = ptrtoint ptr [[__RET]] to i64
// CHECK-NEXT:    [[TMP7:%.*]] = xor i64 [[TMP6]], 193514046488576
// CHECK-NEXT:    [[TMP8:%.*]] = inttoptr i64 [[TMP7]] to ptr
// CHECK-NEXT:    store { <16 x i8>, <16 x i8> } zeroinitializer, ptr [[TMP8]], align 16
// CHECK-NEXT:    store { <16 x i8>, <16 x i8> } [[VLD2]], ptr [[__RET]], align 16
// CHECK-NEXT:    [[TMP9:%.*]] = call ptr @__msan_memcpy(ptr [[RETVAL]], ptr [[__RET]], i64 32)
// CHECK-NEXT:    [[TMP10:%.*]] = load [[STRUCT_INT8X16X2_T]], ptr [[RETVAL]], align 16
// CHECK-NEXT:    store { [2 x <16 x i8>] } zeroinitializer, ptr @__msan_retval_tls, align 8
// CHECK-NEXT:    ret [[STRUCT_INT8X16X2_T]] [[TMP10]]
//
int8x16x2_t test_vld2q_s8(int8_t const *a) {
  return vld2q_s8(a);
}

// CHECK-LABEL: define dso_local %struct.int16x8x2_t @test_vld2q_s16(
// CHECK-SAME: ptr noundef [[A:%.*]]) #[[ATTR0]] {
// CHECK-NEXT:  entry:
// CHECK-NEXT:    call void @llvm.donothing()
// CHECK-NEXT:    [[RETVAL:%.*]] = alloca [[STRUCT_INT16X8X2_T:%.*]], align 16
// CHECK-NEXT:    [[TMP0:%.*]] = ptrtoint ptr [[RETVAL]] to i64
// CHECK-NEXT:    [[TMP1:%.*]] = xor i64 [[TMP0]], 193514046488576
// CHECK-NEXT:    [[TMP2:%.*]] = inttoptr i64 [[TMP1]] to ptr
// CHECK-NEXT:    call void @llvm.memset.p0.i64(ptr align 16 [[TMP2]], i8 0, i64 32, i1 false)
// CHECK-NEXT:    [[__RET:%.*]] = alloca [[STRUCT_INT16X8X2_T]], align 16
// CHECK-NEXT:    [[TMP3:%.*]] = ptrtoint ptr [[__RET]] to i64
// CHECK-NEXT:    [[TMP4:%.*]] = xor i64 [[TMP3]], 193514046488576
// CHECK-NEXT:    [[TMP5:%.*]] = inttoptr i64 [[TMP4]] to ptr
// CHECK-NEXT:    call void @llvm.memset.p0.i64(ptr align 16 [[TMP5]], i8 0, i64 32, i1 false)
// CHECK-NEXT:    [[VLD2:%.*]] = call { <8 x i16>, <8 x i16> } @llvm.aarch64.neon.ld2.v8i16.p0(ptr [[A]])
// CHECK-NEXT:    [[TMP6:%.*]] = ptrtoint ptr [[__RET]] to i64
// CHECK-NEXT:    [[TMP7:%.*]] = xor i64 [[TMP6]], 193514046488576
// CHECK-NEXT:    [[TMP8:%.*]] = inttoptr i64 [[TMP7]] to ptr
// CHECK-NEXT:    store { <8 x i16>, <8 x i16> } zeroinitializer, ptr [[TMP8]], align 16
// CHECK-NEXT:    store { <8 x i16>, <8 x i16> } [[VLD2]], ptr [[__RET]], align 16
// CHECK-NEXT:    [[TMP9:%.*]] = call ptr @__msan_memcpy(ptr [[RETVAL]], ptr [[__RET]], i64 32)
// CHECK-NEXT:    [[TMP10:%.*]] = load [[STRUCT_INT16X8X2_T]], ptr [[RETVAL]], align 16
// CHECK-NEXT:    store { [2 x <8 x i16>] } zeroinitializer, ptr @__msan_retval_tls, align 8
// CHECK-NEXT:    ret [[STRUCT_INT16X8X2_T]] [[TMP10]]
//
int16x8x2_t test_vld2q_s16(int16_t const *a) {
  return vld2q_s16(a);
}

// CHECK-LABEL: define dso_local %struct.int32x4x2_t @test_vld2q_s32(
// CHECK-SAME: ptr noundef [[A:%.*]]) #[[ATTR0]] {
// CHECK-NEXT:  entry:
// CHECK-NEXT:    call void @llvm.donothing()
// CHECK-NEXT:    [[RETVAL:%.*]] = alloca [[STRUCT_INT32X4X2_T:%.*]], align 16
// CHECK-NEXT:    [[TMP0:%.*]] = ptrtoint ptr [[RETVAL]] to i64
// CHECK-NEXT:    [[TMP1:%.*]] = xor i64 [[TMP0]], 193514046488576
// CHECK-NEXT:    [[TMP2:%.*]] = inttoptr i64 [[TMP1]] to ptr
// CHECK-NEXT:    call void @llvm.memset.p0.i64(ptr align 16 [[TMP2]], i8 0, i64 32, i1 false)
// CHECK-NEXT:    [[__RET:%.*]] = alloca [[STRUCT_INT32X4X2_T]], align 16
// CHECK-NEXT:    [[TMP3:%.*]] = ptrtoint ptr [[__RET]] to i64
// CHECK-NEXT:    [[TMP4:%.*]] = xor i64 [[TMP3]], 193514046488576
// CHECK-NEXT:    [[TMP5:%.*]] = inttoptr i64 [[TMP4]] to ptr
// CHECK-NEXT:    call void @llvm.memset.p0.i64(ptr align 16 [[TMP5]], i8 0, i64 32, i1 false)
// CHECK-NEXT:    [[VLD2:%.*]] = call { <4 x i32>, <4 x i32> } @llvm.aarch64.neon.ld2.v4i32.p0(ptr [[A]])
// CHECK-NEXT:    [[TMP6:%.*]] = ptrtoint ptr [[__RET]] to i64
// CHECK-NEXT:    [[TMP7:%.*]] = xor i64 [[TMP6]], 193514046488576
// CHECK-NEXT:    [[TMP8:%.*]] = inttoptr i64 [[TMP7]] to ptr
// CHECK-NEXT:    store { <4 x i32>, <4 x i32> } zeroinitializer, ptr [[TMP8]], align 16
// CHECK-NEXT:    store { <4 x i32>, <4 x i32> } [[VLD2]], ptr [[__RET]], align 16
// CHECK-NEXT:    [[TMP9:%.*]] = call ptr @__msan_memcpy(ptr [[RETVAL]], ptr [[__RET]], i64 32)
// CHECK-NEXT:    [[TMP10:%.*]] = load [[STRUCT_INT32X4X2_T]], ptr [[RETVAL]], align 16
// CHECK-NEXT:    store { [2 x <4 x i32>] } zeroinitializer, ptr @__msan_retval_tls, align 8
// CHECK-NEXT:    ret [[STRUCT_INT32X4X2_T]] [[TMP10]]
//
int32x4x2_t test_vld2q_s32(int32_t const *a) {
  return vld2q_s32(a);
}

// CHECK-LABEL: define dso_local %struct.int64x2x2_t @test_vld2q_s64(
// CHECK-SAME: ptr noundef [[A:%.*]]) #[[ATTR0]] {
// CHECK-NEXT:  entry:
// CHECK-NEXT:    call void @llvm.donothing()
// CHECK-NEXT:    [[RETVAL:%.*]] = alloca [[STRUCT_INT64X2X2_T:%.*]], align 16
// CHECK-NEXT:    [[TMP0:%.*]] = ptrtoint ptr [[RETVAL]] to i64
// CHECK-NEXT:    [[TMP1:%.*]] = xor i64 [[TMP0]], 193514046488576
// CHECK-NEXT:    [[TMP2:%.*]] = inttoptr i64 [[TMP1]] to ptr
// CHECK-NEXT:    call void @llvm.memset.p0.i64(ptr align 16 [[TMP2]], i8 0, i64 32, i1 false)
// CHECK-NEXT:    [[__RET:%.*]] = alloca [[STRUCT_INT64X2X2_T]], align 16
// CHECK-NEXT:    [[TMP3:%.*]] = ptrtoint ptr [[__RET]] to i64
// CHECK-NEXT:    [[TMP4:%.*]] = xor i64 [[TMP3]], 193514046488576
// CHECK-NEXT:    [[TMP5:%.*]] = inttoptr i64 [[TMP4]] to ptr
// CHECK-NEXT:    call void @llvm.memset.p0.i64(ptr align 16 [[TMP5]], i8 0, i64 32, i1 false)
// CHECK-NEXT:    [[VLD2:%.*]] = call { <2 x i64>, <2 x i64> } @llvm.aarch64.neon.ld2.v2i64.p0(ptr [[A]])
// CHECK-NEXT:    [[TMP6:%.*]] = ptrtoint ptr [[__RET]] to i64
// CHECK-NEXT:    [[TMP7:%.*]] = xor i64 [[TMP6]], 193514046488576
// CHECK-NEXT:    [[TMP8:%.*]] = inttoptr i64 [[TMP7]] to ptr
// CHECK-NEXT:    store { <2 x i64>, <2 x i64> } zeroinitializer, ptr [[TMP8]], align 16
// CHECK-NEXT:    store { <2 x i64>, <2 x i64> } [[VLD2]], ptr [[__RET]], align 16
// CHECK-NEXT:    [[TMP9:%.*]] = call ptr @__msan_memcpy(ptr [[RETVAL]], ptr [[__RET]], i64 32)
// CHECK-NEXT:    [[TMP10:%.*]] = load [[STRUCT_INT64X2X2_T]], ptr [[RETVAL]], align 16
// CHECK-NEXT:    store { [2 x <2 x i64>] } zeroinitializer, ptr @__msan_retval_tls, align 8
// CHECK-NEXT:    ret [[STRUCT_INT64X2X2_T]] [[TMP10]]
//
int64x2x2_t test_vld2q_s64(int64_t const *a) {
  return vld2q_s64(a);
}

// CHECK-LABEL: define dso_local %struct.float16x8x2_t @test_vld2q_f16(
// CHECK-SAME: ptr noundef [[A:%.*]]) #[[ATTR0]] {
// CHECK-NEXT:  entry:
// CHECK-NEXT:    call void @llvm.donothing()
// CHECK-NEXT:    [[RETVAL:%.*]] = alloca [[STRUCT_FLOAT16X8X2_T:%.*]], align 16
// CHECK-NEXT:    [[TMP0:%.*]] = ptrtoint ptr [[RETVAL]] to i64
// CHECK-NEXT:    [[TMP1:%.*]] = xor i64 [[TMP0]], 193514046488576
// CHECK-NEXT:    [[TMP2:%.*]] = inttoptr i64 [[TMP1]] to ptr
// CHECK-NEXT:    call void @llvm.memset.p0.i64(ptr align 16 [[TMP2]], i8 0, i64 32, i1 false)
// CHECK-NEXT:    [[__RET:%.*]] = alloca [[STRUCT_FLOAT16X8X2_T]], align 16
// CHECK-NEXT:    [[TMP3:%.*]] = ptrtoint ptr [[__RET]] to i64
// CHECK-NEXT:    [[TMP4:%.*]] = xor i64 [[TMP3]], 193514046488576
// CHECK-NEXT:    [[TMP5:%.*]] = inttoptr i64 [[TMP4]] to ptr
// CHECK-NEXT:    call void @llvm.memset.p0.i64(ptr align 16 [[TMP5]], i8 0, i64 32, i1 false)
// CHECK-NEXT:    [[VLD2:%.*]] = call { <8 x half>, <8 x half> } @llvm.aarch64.neon.ld2.v8f16.p0(ptr [[A]])
// CHECK-NEXT:    [[TMP6:%.*]] = ptrtoint ptr [[__RET]] to i64
// CHECK-NEXT:    [[TMP7:%.*]] = xor i64 [[TMP6]], 193514046488576
// CHECK-NEXT:    [[TMP8:%.*]] = inttoptr i64 [[TMP7]] to ptr
// CHECK-NEXT:    store { <8 x i16>, <8 x i16> } zeroinitializer, ptr [[TMP8]], align 16
// CHECK-NEXT:    store { <8 x half>, <8 x half> } [[VLD2]], ptr [[__RET]], align 16
// CHECK-NEXT:    [[TMP9:%.*]] = call ptr @__msan_memcpy(ptr [[RETVAL]], ptr [[__RET]], i64 32)
// CHECK-NEXT:    [[TMP10:%.*]] = load [[STRUCT_FLOAT16X8X2_T]], ptr [[RETVAL]], align 16
// CHECK-NEXT:    store { [2 x <8 x i16>] } zeroinitializer, ptr @__msan_retval_tls, align 8
// CHECK-NEXT:    ret [[STRUCT_FLOAT16X8X2_T]] [[TMP10]]
//
float16x8x2_t test_vld2q_f16(float16_t const *a) {
  return vld2q_f16(a);
}

// CHECK-LABEL: define dso_local %struct.float32x4x2_t @test_vld2q_f32(
// CHECK-SAME: ptr noundef [[A:%.*]]) #[[ATTR0]] {
// CHECK-NEXT:  entry:
// CHECK-NEXT:    call void @llvm.donothing()
// CHECK-NEXT:    [[RETVAL:%.*]] = alloca [[STRUCT_FLOAT32X4X2_T:%.*]], align 16
// CHECK-NEXT:    [[TMP0:%.*]] = ptrtoint ptr [[RETVAL]] to i64
// CHECK-NEXT:    [[TMP1:%.*]] = xor i64 [[TMP0]], 193514046488576
// CHECK-NEXT:    [[TMP2:%.*]] = inttoptr i64 [[TMP1]] to ptr
// CHECK-NEXT:    call void @llvm.memset.p0.i64(ptr align 16 [[TMP2]], i8 0, i64 32, i1 false)
// CHECK-NEXT:    [[__RET:%.*]] = alloca [[STRUCT_FLOAT32X4X2_T]], align 16
// CHECK-NEXT:    [[TMP3:%.*]] = ptrtoint ptr [[__RET]] to i64
// CHECK-NEXT:    [[TMP4:%.*]] = xor i64 [[TMP3]], 193514046488576
// CHECK-NEXT:    [[TMP5:%.*]] = inttoptr i64 [[TMP4]] to ptr
// CHECK-NEXT:    call void @llvm.memset.p0.i64(ptr align 16 [[TMP5]], i8 0, i64 32, i1 false)
// CHECK-NEXT:    [[VLD2:%.*]] = call { <4 x float>, <4 x float> } @llvm.aarch64.neon.ld2.v4f32.p0(ptr [[A]])
// CHECK-NEXT:    [[TMP6:%.*]] = ptrtoint ptr [[__RET]] to i64
// CHECK-NEXT:    [[TMP7:%.*]] = xor i64 [[TMP6]], 193514046488576
// CHECK-NEXT:    [[TMP8:%.*]] = inttoptr i64 [[TMP7]] to ptr
// CHECK-NEXT:    store { <4 x i32>, <4 x i32> } zeroinitializer, ptr [[TMP8]], align 16
// CHECK-NEXT:    store { <4 x float>, <4 x float> } [[VLD2]], ptr [[__RET]], align 16
// CHECK-NEXT:    [[TMP9:%.*]] = call ptr @__msan_memcpy(ptr [[RETVAL]], ptr [[__RET]], i64 32)
// CHECK-NEXT:    [[TMP10:%.*]] = load [[STRUCT_FLOAT32X4X2_T]], ptr [[RETVAL]], align 16
// CHECK-NEXT:    store { [2 x <4 x i32>] } zeroinitializer, ptr @__msan_retval_tls, align 8
// CHECK-NEXT:    ret [[STRUCT_FLOAT32X4X2_T]] [[TMP10]]
//
float32x4x2_t test_vld2q_f32(float32_t const *a) {
  return vld2q_f32(a);
}

// CHECK-LABEL: define dso_local %struct.float64x2x2_t @test_vld2q_f64(
// CHECK-SAME: ptr noundef [[A:%.*]]) #[[ATTR0]] {
// CHECK-NEXT:  entry:
// CHECK-NEXT:    call void @llvm.donothing()
// CHECK-NEXT:    [[RETVAL:%.*]] = alloca [[STRUCT_FLOAT64X2X2_T:%.*]], align 16
// CHECK-NEXT:    [[TMP0:%.*]] = ptrtoint ptr [[RETVAL]] to i64
// CHECK-NEXT:    [[TMP1:%.*]] = xor i64 [[TMP0]], 193514046488576
// CHECK-NEXT:    [[TMP2:%.*]] = inttoptr i64 [[TMP1]] to ptr
// CHECK-NEXT:    call void @llvm.memset.p0.i64(ptr align 16 [[TMP2]], i8 0, i64 32, i1 false)
// CHECK-NEXT:    [[__RET:%.*]] = alloca [[STRUCT_FLOAT64X2X2_T]], align 16
// CHECK-NEXT:    [[TMP3:%.*]] = ptrtoint ptr [[__RET]] to i64
// CHECK-NEXT:    [[TMP4:%.*]] = xor i64 [[TMP3]], 193514046488576
// CHECK-NEXT:    [[TMP5:%.*]] = inttoptr i64 [[TMP4]] to ptr
// CHECK-NEXT:    call void @llvm.memset.p0.i64(ptr align 16 [[TMP5]], i8 0, i64 32, i1 false)
// CHECK-NEXT:    [[VLD2:%.*]] = call { <2 x double>, <2 x double> } @llvm.aarch64.neon.ld2.v2f64.p0(ptr [[A]])
// CHECK-NEXT:    [[TMP6:%.*]] = ptrtoint ptr [[__RET]] to i64
// CHECK-NEXT:    [[TMP7:%.*]] = xor i64 [[TMP6]], 193514046488576
// CHECK-NEXT:    [[TMP8:%.*]] = inttoptr i64 [[TMP7]] to ptr
// CHECK-NEXT:    store { <2 x i64>, <2 x i64> } zeroinitializer, ptr [[TMP8]], align 16
// CHECK-NEXT:    store { <2 x double>, <2 x double> } [[VLD2]], ptr [[__RET]], align 16
// CHECK-NEXT:    [[TMP9:%.*]] = call ptr @__msan_memcpy(ptr [[RETVAL]], ptr [[__RET]], i64 32)
// CHECK-NEXT:    [[TMP10:%.*]] = load [[STRUCT_FLOAT64X2X2_T]], ptr [[RETVAL]], align 16
// CHECK-NEXT:    store { [2 x <2 x i64>] } zeroinitializer, ptr @__msan_retval_tls, align 8
// CHECK-NEXT:    ret [[STRUCT_FLOAT64X2X2_T]] [[TMP10]]
//
float64x2x2_t test_vld2q_f64(float64_t const *a) {
  return vld2q_f64(a);
}

// CHECK-LABEL: define dso_local %struct.poly8x16x2_t @test_vld2q_p8(
// CHECK-SAME: ptr noundef [[A:%.*]]) #[[ATTR0]] {
// CHECK-NEXT:  entry:
// CHECK-NEXT:    call void @llvm.donothing()
// CHECK-NEXT:    [[RETVAL:%.*]] = alloca [[STRUCT_POLY8X16X2_T:%.*]], align 16
// CHECK-NEXT:    [[TMP0:%.*]] = ptrtoint ptr [[RETVAL]] to i64
// CHECK-NEXT:    [[TMP1:%.*]] = xor i64 [[TMP0]], 193514046488576
// CHECK-NEXT:    [[TMP2:%.*]] = inttoptr i64 [[TMP1]] to ptr
// CHECK-NEXT:    call void @llvm.memset.p0.i64(ptr align 16 [[TMP2]], i8 0, i64 32, i1 false)
// CHECK-NEXT:    [[__RET:%.*]] = alloca [[STRUCT_POLY8X16X2_T]], align 16
// CHECK-NEXT:    [[TMP3:%.*]] = ptrtoint ptr [[__RET]] to i64
// CHECK-NEXT:    [[TMP4:%.*]] = xor i64 [[TMP3]], 193514046488576
// CHECK-NEXT:    [[TMP5:%.*]] = inttoptr i64 [[TMP4]] to ptr
// CHECK-NEXT:    call void @llvm.memset.p0.i64(ptr align 16 [[TMP5]], i8 0, i64 32, i1 false)
// CHECK-NEXT:    [[VLD2:%.*]] = call { <16 x i8>, <16 x i8> } @llvm.aarch64.neon.ld2.v16i8.p0(ptr [[A]])
// CHECK-NEXT:    [[TMP6:%.*]] = ptrtoint ptr [[__RET]] to i64
// CHECK-NEXT:    [[TMP7:%.*]] = xor i64 [[TMP6]], 193514046488576
// CHECK-NEXT:    [[TMP8:%.*]] = inttoptr i64 [[TMP7]] to ptr
// CHECK-NEXT:    store { <16 x i8>, <16 x i8> } zeroinitializer, ptr [[TMP8]], align 16
// CHECK-NEXT:    store { <16 x i8>, <16 x i8> } [[VLD2]], ptr [[__RET]], align 16
// CHECK-NEXT:    [[TMP9:%.*]] = call ptr @__msan_memcpy(ptr [[RETVAL]], ptr [[__RET]], i64 32)
// CHECK-NEXT:    [[TMP10:%.*]] = load [[STRUCT_POLY8X16X2_T]], ptr [[RETVAL]], align 16
// CHECK-NEXT:    store { [2 x <16 x i8>] } zeroinitializer, ptr @__msan_retval_tls, align 8
// CHECK-NEXT:    ret [[STRUCT_POLY8X16X2_T]] [[TMP10]]
//
poly8x16x2_t test_vld2q_p8(poly8_t const *a) {
  return vld2q_p8(a);
}

// CHECK-LABEL: define dso_local %struct.poly16x8x2_t @test_vld2q_p16(
// CHECK-SAME: ptr noundef [[A:%.*]]) #[[ATTR0]] {
// CHECK-NEXT:  entry:
// CHECK-NEXT:    call void @llvm.donothing()
// CHECK-NEXT:    [[RETVAL:%.*]] = alloca [[STRUCT_POLY16X8X2_T:%.*]], align 16
// CHECK-NEXT:    [[TMP0:%.*]] = ptrtoint ptr [[RETVAL]] to i64
// CHECK-NEXT:    [[TMP1:%.*]] = xor i64 [[TMP0]], 193514046488576
// CHECK-NEXT:    [[TMP2:%.*]] = inttoptr i64 [[TMP1]] to ptr
// CHECK-NEXT:    call void @llvm.memset.p0.i64(ptr align 16 [[TMP2]], i8 0, i64 32, i1 false)
// CHECK-NEXT:    [[__RET:%.*]] = alloca [[STRUCT_POLY16X8X2_T]], align 16
// CHECK-NEXT:    [[TMP3:%.*]] = ptrtoint ptr [[__RET]] to i64
// CHECK-NEXT:    [[TMP4:%.*]] = xor i64 [[TMP3]], 193514046488576
// CHECK-NEXT:    [[TMP5:%.*]] = inttoptr i64 [[TMP4]] to ptr
// CHECK-NEXT:    call void @llvm.memset.p0.i64(ptr align 16 [[TMP5]], i8 0, i64 32, i1 false)
// CHECK-NEXT:    [[VLD2:%.*]] = call { <8 x i16>, <8 x i16> } @llvm.aarch64.neon.ld2.v8i16.p0(ptr [[A]])
// CHECK-NEXT:    [[TMP6:%.*]] = ptrtoint ptr [[__RET]] to i64
// CHECK-NEXT:    [[TMP7:%.*]] = xor i64 [[TMP6]], 193514046488576
// CHECK-NEXT:    [[TMP8:%.*]] = inttoptr i64 [[TMP7]] to ptr
// CHECK-NEXT:    store { <8 x i16>, <8 x i16> } zeroinitializer, ptr [[TMP8]], align 16
// CHECK-NEXT:    store { <8 x i16>, <8 x i16> } [[VLD2]], ptr [[__RET]], align 16
// CHECK-NEXT:    [[TMP9:%.*]] = call ptr @__msan_memcpy(ptr [[RETVAL]], ptr [[__RET]], i64 32)
// CHECK-NEXT:    [[TMP10:%.*]] = load [[STRUCT_POLY16X8X2_T]], ptr [[RETVAL]], align 16
// CHECK-NEXT:    store { [2 x <8 x i16>] } zeroinitializer, ptr @__msan_retval_tls, align 8
// CHECK-NEXT:    ret [[STRUCT_POLY16X8X2_T]] [[TMP10]]
//
poly16x8x2_t test_vld2q_p16(poly16_t const *a) {
  return vld2q_p16(a);
}

// CHECK-LABEL: define dso_local %struct.uint8x8x2_t @test_vld2_u8(
// CHECK-SAME: ptr noundef [[A:%.*]]) #[[ATTR0]] {
// CHECK-NEXT:  entry:
// CHECK-NEXT:    call void @llvm.donothing()
// CHECK-NEXT:    [[RETVAL:%.*]] = alloca [[STRUCT_UINT8X8X2_T:%.*]], align 8
// CHECK-NEXT:    [[TMP0:%.*]] = ptrtoint ptr [[RETVAL]] to i64
// CHECK-NEXT:    [[TMP1:%.*]] = xor i64 [[TMP0]], 193514046488576
// CHECK-NEXT:    [[TMP2:%.*]] = inttoptr i64 [[TMP1]] to ptr
// CHECK-NEXT:    call void @llvm.memset.p0.i64(ptr align 8 [[TMP2]], i8 0, i64 16, i1 false)
// CHECK-NEXT:    [[__RET:%.*]] = alloca [[STRUCT_UINT8X8X2_T]], align 8
// CHECK-NEXT:    [[TMP3:%.*]] = ptrtoint ptr [[__RET]] to i64
// CHECK-NEXT:    [[TMP4:%.*]] = xor i64 [[TMP3]], 193514046488576
// CHECK-NEXT:    [[TMP5:%.*]] = inttoptr i64 [[TMP4]] to ptr
// CHECK-NEXT:    call void @llvm.memset.p0.i64(ptr align 8 [[TMP5]], i8 0, i64 16, i1 false)
// CHECK-NEXT:    [[VLD2:%.*]] = call { <8 x i8>, <8 x i8> } @llvm.aarch64.neon.ld2.v8i8.p0(ptr [[A]])
// CHECK-NEXT:    [[TMP6:%.*]] = ptrtoint ptr [[__RET]] to i64
// CHECK-NEXT:    [[TMP7:%.*]] = xor i64 [[TMP6]], 193514046488576
// CHECK-NEXT:    [[TMP8:%.*]] = inttoptr i64 [[TMP7]] to ptr
// CHECK-NEXT:    store { <8 x i8>, <8 x i8> } zeroinitializer, ptr [[TMP8]], align 8
// CHECK-NEXT:    store { <8 x i8>, <8 x i8> } [[VLD2]], ptr [[__RET]], align 8
// CHECK-NEXT:    [[TMP9:%.*]] = call ptr @__msan_memcpy(ptr [[RETVAL]], ptr [[__RET]], i64 16)
// CHECK-NEXT:    [[TMP10:%.*]] = load [[STRUCT_UINT8X8X2_T]], ptr [[RETVAL]], align 8
// CHECK-NEXT:    store { [2 x <8 x i8>] } zeroinitializer, ptr @__msan_retval_tls, align 8
// CHECK-NEXT:    ret [[STRUCT_UINT8X8X2_T]] [[TMP10]]
//
uint8x8x2_t test_vld2_u8(uint8_t const *a) {
  return vld2_u8(a);
}

// CHECK-LABEL: define dso_local %struct.uint16x4x2_t @test_vld2_u16(
// CHECK-SAME: ptr noundef [[A:%.*]]) #[[ATTR0]] {
// CHECK-NEXT:  entry:
// CHECK-NEXT:    call void @llvm.donothing()
// CHECK-NEXT:    [[RETVAL:%.*]] = alloca [[STRUCT_UINT16X4X2_T:%.*]], align 8
// CHECK-NEXT:    [[TMP0:%.*]] = ptrtoint ptr [[RETVAL]] to i64
// CHECK-NEXT:    [[TMP1:%.*]] = xor i64 [[TMP0]], 193514046488576
// CHECK-NEXT:    [[TMP2:%.*]] = inttoptr i64 [[TMP1]] to ptr
// CHECK-NEXT:    call void @llvm.memset.p0.i64(ptr align 8 [[TMP2]], i8 0, i64 16, i1 false)
// CHECK-NEXT:    [[__RET:%.*]] = alloca [[STRUCT_UINT16X4X2_T]], align 8
// CHECK-NEXT:    [[TMP3:%.*]] = ptrtoint ptr [[__RET]] to i64
// CHECK-NEXT:    [[TMP4:%.*]] = xor i64 [[TMP3]], 193514046488576
// CHECK-NEXT:    [[TMP5:%.*]] = inttoptr i64 [[TMP4]] to ptr
// CHECK-NEXT:    call void @llvm.memset.p0.i64(ptr align 8 [[TMP5]], i8 0, i64 16, i1 false)
// CHECK-NEXT:    [[VLD2:%.*]] = call { <4 x i16>, <4 x i16> } @llvm.aarch64.neon.ld2.v4i16.p0(ptr [[A]])
// CHECK-NEXT:    [[TMP6:%.*]] = ptrtoint ptr [[__RET]] to i64
// CHECK-NEXT:    [[TMP7:%.*]] = xor i64 [[TMP6]], 193514046488576
// CHECK-NEXT:    [[TMP8:%.*]] = inttoptr i64 [[TMP7]] to ptr
// CHECK-NEXT:    store { <4 x i16>, <4 x i16> } zeroinitializer, ptr [[TMP8]], align 8
// CHECK-NEXT:    store { <4 x i16>, <4 x i16> } [[VLD2]], ptr [[__RET]], align 8
// CHECK-NEXT:    [[TMP9:%.*]] = call ptr @__msan_memcpy(ptr [[RETVAL]], ptr [[__RET]], i64 16)
// CHECK-NEXT:    [[TMP10:%.*]] = load [[STRUCT_UINT16X4X2_T]], ptr [[RETVAL]], align 8
// CHECK-NEXT:    store { [2 x <4 x i16>] } zeroinitializer, ptr @__msan_retval_tls, align 8
// CHECK-NEXT:    ret [[STRUCT_UINT16X4X2_T]] [[TMP10]]
//
uint16x4x2_t test_vld2_u16(uint16_t const *a) {
  return vld2_u16(a);
}

// CHECK-LABEL: define dso_local %struct.uint32x2x2_t @test_vld2_u32(
// CHECK-SAME: ptr noundef [[A:%.*]]) #[[ATTR0]] {
// CHECK-NEXT:  entry:
// CHECK-NEXT:    call void @llvm.donothing()
// CHECK-NEXT:    [[RETVAL:%.*]] = alloca [[STRUCT_UINT32X2X2_T:%.*]], align 8
// CHECK-NEXT:    [[TMP0:%.*]] = ptrtoint ptr [[RETVAL]] to i64
// CHECK-NEXT:    [[TMP1:%.*]] = xor i64 [[TMP0]], 193514046488576
// CHECK-NEXT:    [[TMP2:%.*]] = inttoptr i64 [[TMP1]] to ptr
// CHECK-NEXT:    call void @llvm.memset.p0.i64(ptr align 8 [[TMP2]], i8 0, i64 16, i1 false)
// CHECK-NEXT:    [[__RET:%.*]] = alloca [[STRUCT_UINT32X2X2_T]], align 8
// CHECK-NEXT:    [[TMP3:%.*]] = ptrtoint ptr [[__RET]] to i64
// CHECK-NEXT:    [[TMP4:%.*]] = xor i64 [[TMP3]], 193514046488576
// CHECK-NEXT:    [[TMP5:%.*]] = inttoptr i64 [[TMP4]] to ptr
// CHECK-NEXT:    call void @llvm.memset.p0.i64(ptr align 8 [[TMP5]], i8 0, i64 16, i1 false)
// CHECK-NEXT:    [[VLD2:%.*]] = call { <2 x i32>, <2 x i32> } @llvm.aarch64.neon.ld2.v2i32.p0(ptr [[A]])
// CHECK-NEXT:    [[TMP6:%.*]] = ptrtoint ptr [[__RET]] to i64
// CHECK-NEXT:    [[TMP7:%.*]] = xor i64 [[TMP6]], 193514046488576
// CHECK-NEXT:    [[TMP8:%.*]] = inttoptr i64 [[TMP7]] to ptr
// CHECK-NEXT:    store { <2 x i32>, <2 x i32> } zeroinitializer, ptr [[TMP8]], align 8
// CHECK-NEXT:    store { <2 x i32>, <2 x i32> } [[VLD2]], ptr [[__RET]], align 8
// CHECK-NEXT:    [[TMP9:%.*]] = call ptr @__msan_memcpy(ptr [[RETVAL]], ptr [[__RET]], i64 16)
// CHECK-NEXT:    [[TMP10:%.*]] = load [[STRUCT_UINT32X2X2_T]], ptr [[RETVAL]], align 8
// CHECK-NEXT:    store { [2 x <2 x i32>] } zeroinitializer, ptr @__msan_retval_tls, align 8
// CHECK-NEXT:    ret [[STRUCT_UINT32X2X2_T]] [[TMP10]]
//
uint32x2x2_t test_vld2_u32(uint32_t const *a) {
  return vld2_u32(a);
}

// CHECK-LABEL: define dso_local %struct.uint64x1x2_t @test_vld2_u64(
// CHECK-SAME: ptr noundef [[A:%.*]]) #[[ATTR0]] {
// CHECK-NEXT:  entry:
// CHECK-NEXT:    call void @llvm.donothing()
// CHECK-NEXT:    [[RETVAL:%.*]] = alloca [[STRUCT_UINT64X1X2_T:%.*]], align 8
// CHECK-NEXT:    [[TMP0:%.*]] = ptrtoint ptr [[RETVAL]] to i64
// CHECK-NEXT:    [[TMP1:%.*]] = xor i64 [[TMP0]], 193514046488576
// CHECK-NEXT:    [[TMP2:%.*]] = inttoptr i64 [[TMP1]] to ptr
// CHECK-NEXT:    call void @llvm.memset.p0.i64(ptr align 8 [[TMP2]], i8 0, i64 16, i1 false)
// CHECK-NEXT:    [[__RET:%.*]] = alloca [[STRUCT_UINT64X1X2_T]], align 8
// CHECK-NEXT:    [[TMP3:%.*]] = ptrtoint ptr [[__RET]] to i64
// CHECK-NEXT:    [[TMP4:%.*]] = xor i64 [[TMP3]], 193514046488576
// CHECK-NEXT:    [[TMP5:%.*]] = inttoptr i64 [[TMP4]] to ptr
// CHECK-NEXT:    call void @llvm.memset.p0.i64(ptr align 8 [[TMP5]], i8 0, i64 16, i1 false)
// CHECK-NEXT:    [[VLD2:%.*]] = call { <1 x i64>, <1 x i64> } @llvm.aarch64.neon.ld2.v1i64.p0(ptr [[A]])
// CHECK-NEXT:    [[TMP6:%.*]] = ptrtoint ptr [[__RET]] to i64
// CHECK-NEXT:    [[TMP7:%.*]] = xor i64 [[TMP6]], 193514046488576
// CHECK-NEXT:    [[TMP8:%.*]] = inttoptr i64 [[TMP7]] to ptr
// CHECK-NEXT:    store { <1 x i64>, <1 x i64> } zeroinitializer, ptr [[TMP8]], align 8
// CHECK-NEXT:    store { <1 x i64>, <1 x i64> } [[VLD2]], ptr [[__RET]], align 8
// CHECK-NEXT:    [[TMP9:%.*]] = call ptr @__msan_memcpy(ptr [[RETVAL]], ptr [[__RET]], i64 16)
// CHECK-NEXT:    [[TMP10:%.*]] = load [[STRUCT_UINT64X1X2_T]], ptr [[RETVAL]], align 8
// CHECK-NEXT:    store { [2 x <1 x i64>] } zeroinitializer, ptr @__msan_retval_tls, align 8
// CHECK-NEXT:    ret [[STRUCT_UINT64X1X2_T]] [[TMP10]]
//
uint64x1x2_t test_vld2_u64(uint64_t const *a) {
  return vld2_u64(a);
}

// CHECK-LABEL: define dso_local %struct.int8x8x2_t @test_vld2_s8(
// CHECK-SAME: ptr noundef [[A:%.*]]) #[[ATTR0]] {
// CHECK-NEXT:  entry:
// CHECK-NEXT:    call void @llvm.donothing()
// CHECK-NEXT:    [[RETVAL:%.*]] = alloca [[STRUCT_INT8X8X2_T:%.*]], align 8
// CHECK-NEXT:    [[TMP0:%.*]] = ptrtoint ptr [[RETVAL]] to i64
// CHECK-NEXT:    [[TMP1:%.*]] = xor i64 [[TMP0]], 193514046488576
// CHECK-NEXT:    [[TMP2:%.*]] = inttoptr i64 [[TMP1]] to ptr
// CHECK-NEXT:    call void @llvm.memset.p0.i64(ptr align 8 [[TMP2]], i8 0, i64 16, i1 false)
// CHECK-NEXT:    [[__RET:%.*]] = alloca [[STRUCT_INT8X8X2_T]], align 8
// CHECK-NEXT:    [[TMP3:%.*]] = ptrtoint ptr [[__RET]] to i64
// CHECK-NEXT:    [[TMP4:%.*]] = xor i64 [[TMP3]], 193514046488576
// CHECK-NEXT:    [[TMP5:%.*]] = inttoptr i64 [[TMP4]] to ptr
// CHECK-NEXT:    call void @llvm.memset.p0.i64(ptr align 8 [[TMP5]], i8 0, i64 16, i1 false)
// CHECK-NEXT:    [[VLD2:%.*]] = call { <8 x i8>, <8 x i8> } @llvm.aarch64.neon.ld2.v8i8.p0(ptr [[A]])
// CHECK-NEXT:    [[TMP6:%.*]] = ptrtoint ptr [[__RET]] to i64
// CHECK-NEXT:    [[TMP7:%.*]] = xor i64 [[TMP6]], 193514046488576
// CHECK-NEXT:    [[TMP8:%.*]] = inttoptr i64 [[TMP7]] to ptr
// CHECK-NEXT:    store { <8 x i8>, <8 x i8> } zeroinitializer, ptr [[TMP8]], align 8
// CHECK-NEXT:    store { <8 x i8>, <8 x i8> } [[VLD2]], ptr [[__RET]], align 8
// CHECK-NEXT:    [[TMP9:%.*]] = call ptr @__msan_memcpy(ptr [[RETVAL]], ptr [[__RET]], i64 16)
// CHECK-NEXT:    [[TMP10:%.*]] = load [[STRUCT_INT8X8X2_T]], ptr [[RETVAL]], align 8
// CHECK-NEXT:    store { [2 x <8 x i8>] } zeroinitializer, ptr @__msan_retval_tls, align 8
// CHECK-NEXT:    ret [[STRUCT_INT8X8X2_T]] [[TMP10]]
//
int8x8x2_t test_vld2_s8(int8_t const *a) {
  return vld2_s8(a);
}

// CHECK-LABEL: define dso_local %struct.int16x4x2_t @test_vld2_s16(
// CHECK-SAME: ptr noundef [[A:%.*]]) #[[ATTR0]] {
// CHECK-NEXT:  entry:
// CHECK-NEXT:    call void @llvm.donothing()
// CHECK-NEXT:    [[RETVAL:%.*]] = alloca [[STRUCT_INT16X4X2_T:%.*]], align 8
// CHECK-NEXT:    [[TMP0:%.*]] = ptrtoint ptr [[RETVAL]] to i64
// CHECK-NEXT:    [[TMP1:%.*]] = xor i64 [[TMP0]], 193514046488576
// CHECK-NEXT:    [[TMP2:%.*]] = inttoptr i64 [[TMP1]] to ptr
// CHECK-NEXT:    call void @llvm.memset.p0.i64(ptr align 8 [[TMP2]], i8 0, i64 16, i1 false)
// CHECK-NEXT:    [[__RET:%.*]] = alloca [[STRUCT_INT16X4X2_T]], align 8
// CHECK-NEXT:    [[TMP3:%.*]] = ptrtoint ptr [[__RET]] to i64
// CHECK-NEXT:    [[TMP4:%.*]] = xor i64 [[TMP3]], 193514046488576
// CHECK-NEXT:    [[TMP5:%.*]] = inttoptr i64 [[TMP4]] to ptr
// CHECK-NEXT:    call void @llvm.memset.p0.i64(ptr align 8 [[TMP5]], i8 0, i64 16, i1 false)
// CHECK-NEXT:    [[VLD2:%.*]] = call { <4 x i16>, <4 x i16> } @llvm.aarch64.neon.ld2.v4i16.p0(ptr [[A]])
// CHECK-NEXT:    [[TMP6:%.*]] = ptrtoint ptr [[__RET]] to i64
// CHECK-NEXT:    [[TMP7:%.*]] = xor i64 [[TMP6]], 193514046488576
// CHECK-NEXT:    [[TMP8:%.*]] = inttoptr i64 [[TMP7]] to ptr
// CHECK-NEXT:    store { <4 x i16>, <4 x i16> } zeroinitializer, ptr [[TMP8]], align 8
// CHECK-NEXT:    store { <4 x i16>, <4 x i16> } [[VLD2]], ptr [[__RET]], align 8
// CHECK-NEXT:    [[TMP9:%.*]] = call ptr @__msan_memcpy(ptr [[RETVAL]], ptr [[__RET]], i64 16)
// CHECK-NEXT:    [[TMP10:%.*]] = load [[STRUCT_INT16X4X2_T]], ptr [[RETVAL]], align 8
// CHECK-NEXT:    store { [2 x <4 x i16>] } zeroinitializer, ptr @__msan_retval_tls, align 8
// CHECK-NEXT:    ret [[STRUCT_INT16X4X2_T]] [[TMP10]]
//
int16x4x2_t test_vld2_s16(int16_t const *a) {
  return vld2_s16(a);
}

// CHECK-LABEL: define dso_local %struct.int32x2x2_t @test_vld2_s32(
// CHECK-SAME: ptr noundef [[A:%.*]]) #[[ATTR0]] {
// CHECK-NEXT:  entry:
// CHECK-NEXT:    call void @llvm.donothing()
// CHECK-NEXT:    [[RETVAL:%.*]] = alloca [[STRUCT_INT32X2X2_T:%.*]], align 8
// CHECK-NEXT:    [[TMP0:%.*]] = ptrtoint ptr [[RETVAL]] to i64
// CHECK-NEXT:    [[TMP1:%.*]] = xor i64 [[TMP0]], 193514046488576
// CHECK-NEXT:    [[TMP2:%.*]] = inttoptr i64 [[TMP1]] to ptr
// CHECK-NEXT:    call void @llvm.memset.p0.i64(ptr align 8 [[TMP2]], i8 0, i64 16, i1 false)
// CHECK-NEXT:    [[__RET:%.*]] = alloca [[STRUCT_INT32X2X2_T]], align 8
// CHECK-NEXT:    [[TMP3:%.*]] = ptrtoint ptr [[__RET]] to i64
// CHECK-NEXT:    [[TMP4:%.*]] = xor i64 [[TMP3]], 193514046488576
// CHECK-NEXT:    [[TMP5:%.*]] = inttoptr i64 [[TMP4]] to ptr
// CHECK-NEXT:    call void @llvm.memset.p0.i64(ptr align 8 [[TMP5]], i8 0, i64 16, i1 false)
// CHECK-NEXT:    [[VLD2:%.*]] = call { <2 x i32>, <2 x i32> } @llvm.aarch64.neon.ld2.v2i32.p0(ptr [[A]])
// CHECK-NEXT:    [[TMP6:%.*]] = ptrtoint ptr [[__RET]] to i64
// CHECK-NEXT:    [[TMP7:%.*]] = xor i64 [[TMP6]], 193514046488576
// CHECK-NEXT:    [[TMP8:%.*]] = inttoptr i64 [[TMP7]] to ptr
// CHECK-NEXT:    store { <2 x i32>, <2 x i32> } zeroinitializer, ptr [[TMP8]], align 8
// CHECK-NEXT:    store { <2 x i32>, <2 x i32> } [[VLD2]], ptr [[__RET]], align 8
// CHECK-NEXT:    [[TMP9:%.*]] = call ptr @__msan_memcpy(ptr [[RETVAL]], ptr [[__RET]], i64 16)
// CHECK-NEXT:    [[TMP10:%.*]] = load [[STRUCT_INT32X2X2_T]], ptr [[RETVAL]], align 8
// CHECK-NEXT:    store { [2 x <2 x i32>] } zeroinitializer, ptr @__msan_retval_tls, align 8
// CHECK-NEXT:    ret [[STRUCT_INT32X2X2_T]] [[TMP10]]
//
int32x2x2_t test_vld2_s32(int32_t const *a) {
  return vld2_s32(a);
}

// CHECK-LABEL: define dso_local %struct.int64x1x2_t @test_vld2_s64(
// CHECK-SAME: ptr noundef [[A:%.*]]) #[[ATTR0]] {
// CHECK-NEXT:  entry:
// CHECK-NEXT:    call void @llvm.donothing()
// CHECK-NEXT:    [[RETVAL:%.*]] = alloca [[STRUCT_INT64X1X2_T:%.*]], align 8
// CHECK-NEXT:    [[TMP0:%.*]] = ptrtoint ptr [[RETVAL]] to i64
// CHECK-NEXT:    [[TMP1:%.*]] = xor i64 [[TMP0]], 193514046488576
// CHECK-NEXT:    [[TMP2:%.*]] = inttoptr i64 [[TMP1]] to ptr
// CHECK-NEXT:    call void @llvm.memset.p0.i64(ptr align 8 [[TMP2]], i8 0, i64 16, i1 false)
// CHECK-NEXT:    [[__RET:%.*]] = alloca [[STRUCT_INT64X1X2_T]], align 8
// CHECK-NEXT:    [[TMP3:%.*]] = ptrtoint ptr [[__RET]] to i64
// CHECK-NEXT:    [[TMP4:%.*]] = xor i64 [[TMP3]], 193514046488576
// CHECK-NEXT:    [[TMP5:%.*]] = inttoptr i64 [[TMP4]] to ptr
// CHECK-NEXT:    call void @llvm.memset.p0.i64(ptr align 8 [[TMP5]], i8 0, i64 16, i1 false)
// CHECK-NEXT:    [[VLD2:%.*]] = call { <1 x i64>, <1 x i64> } @llvm.aarch64.neon.ld2.v1i64.p0(ptr [[A]])
// CHECK-NEXT:    [[TMP6:%.*]] = ptrtoint ptr [[__RET]] to i64
// CHECK-NEXT:    [[TMP7:%.*]] = xor i64 [[TMP6]], 193514046488576
// CHECK-NEXT:    [[TMP8:%.*]] = inttoptr i64 [[TMP7]] to ptr
// CHECK-NEXT:    store { <1 x i64>, <1 x i64> } zeroinitializer, ptr [[TMP8]], align 8
// CHECK-NEXT:    store { <1 x i64>, <1 x i64> } [[VLD2]], ptr [[__RET]], align 8
// CHECK-NEXT:    [[TMP9:%.*]] = call ptr @__msan_memcpy(ptr [[RETVAL]], ptr [[__RET]], i64 16)
// CHECK-NEXT:    [[TMP10:%.*]] = load [[STRUCT_INT64X1X2_T]], ptr [[RETVAL]], align 8
// CHECK-NEXT:    store { [2 x <1 x i64>] } zeroinitializer, ptr @__msan_retval_tls, align 8
// CHECK-NEXT:    ret [[STRUCT_INT64X1X2_T]] [[TMP10]]
//
int64x1x2_t test_vld2_s64(int64_t const *a) {
  return vld2_s64(a);
}

// CHECK-LABEL: define dso_local %struct.float16x4x2_t @test_vld2_f16(
// CHECK-SAME: ptr noundef [[A:%.*]]) #[[ATTR0]] {
// CHECK-NEXT:  entry:
// CHECK-NEXT:    call void @llvm.donothing()
// CHECK-NEXT:    [[RETVAL:%.*]] = alloca [[STRUCT_FLOAT16X4X2_T:%.*]], align 8
// CHECK-NEXT:    [[TMP0:%.*]] = ptrtoint ptr [[RETVAL]] to i64
// CHECK-NEXT:    [[TMP1:%.*]] = xor i64 [[TMP0]], 193514046488576
// CHECK-NEXT:    [[TMP2:%.*]] = inttoptr i64 [[TMP1]] to ptr
// CHECK-NEXT:    call void @llvm.memset.p0.i64(ptr align 8 [[TMP2]], i8 0, i64 16, i1 false)
// CHECK-NEXT:    [[__RET:%.*]] = alloca [[STRUCT_FLOAT16X4X2_T]], align 8
// CHECK-NEXT:    [[TMP3:%.*]] = ptrtoint ptr [[__RET]] to i64
// CHECK-NEXT:    [[TMP4:%.*]] = xor i64 [[TMP3]], 193514046488576
// CHECK-NEXT:    [[TMP5:%.*]] = inttoptr i64 [[TMP4]] to ptr
// CHECK-NEXT:    call void @llvm.memset.p0.i64(ptr align 8 [[TMP5]], i8 0, i64 16, i1 false)
// CHECK-NEXT:    [[VLD2:%.*]] = call { <4 x half>, <4 x half> } @llvm.aarch64.neon.ld2.v4f16.p0(ptr [[A]])
// CHECK-NEXT:    [[TMP6:%.*]] = ptrtoint ptr [[__RET]] to i64
// CHECK-NEXT:    [[TMP7:%.*]] = xor i64 [[TMP6]], 193514046488576
// CHECK-NEXT:    [[TMP8:%.*]] = inttoptr i64 [[TMP7]] to ptr
// CHECK-NEXT:    store { <4 x i16>, <4 x i16> } zeroinitializer, ptr [[TMP8]], align 8
// CHECK-NEXT:    store { <4 x half>, <4 x half> } [[VLD2]], ptr [[__RET]], align 8
// CHECK-NEXT:    [[TMP9:%.*]] = call ptr @__msan_memcpy(ptr [[RETVAL]], ptr [[__RET]], i64 16)
// CHECK-NEXT:    [[TMP10:%.*]] = load [[STRUCT_FLOAT16X4X2_T]], ptr [[RETVAL]], align 8
// CHECK-NEXT:    store { [2 x <4 x i16>] } zeroinitializer, ptr @__msan_retval_tls, align 8
// CHECK-NEXT:    ret [[STRUCT_FLOAT16X4X2_T]] [[TMP10]]
//
float16x4x2_t test_vld2_f16(float16_t const *a) {
  return vld2_f16(a);
}

// CHECK-LABEL: define dso_local %struct.float32x2x2_t @test_vld2_f32(
// CHECK-SAME: ptr noundef [[A:%.*]]) #[[ATTR0]] {
// CHECK-NEXT:  entry:
// CHECK-NEXT:    call void @llvm.donothing()
// CHECK-NEXT:    [[RETVAL:%.*]] = alloca [[STRUCT_FLOAT32X2X2_T:%.*]], align 8
// CHECK-NEXT:    [[TMP0:%.*]] = ptrtoint ptr [[RETVAL]] to i64
// CHECK-NEXT:    [[TMP1:%.*]] = xor i64 [[TMP0]], 193514046488576
// CHECK-NEXT:    [[TMP2:%.*]] = inttoptr i64 [[TMP1]] to ptr
// CHECK-NEXT:    call void @llvm.memset.p0.i64(ptr align 8 [[TMP2]], i8 0, i64 16, i1 false)
// CHECK-NEXT:    [[__RET:%.*]] = alloca [[STRUCT_FLOAT32X2X2_T]], align 8
// CHECK-NEXT:    [[TMP3:%.*]] = ptrtoint ptr [[__RET]] to i64
// CHECK-NEXT:    [[TMP4:%.*]] = xor i64 [[TMP3]], 193514046488576
// CHECK-NEXT:    [[TMP5:%.*]] = inttoptr i64 [[TMP4]] to ptr
// CHECK-NEXT:    call void @llvm.memset.p0.i64(ptr align 8 [[TMP5]], i8 0, i64 16, i1 false)
// CHECK-NEXT:    [[VLD2:%.*]] = call { <2 x float>, <2 x float> } @llvm.aarch64.neon.ld2.v2f32.p0(ptr [[A]])
// CHECK-NEXT:    [[TMP6:%.*]] = ptrtoint ptr [[__RET]] to i64
// CHECK-NEXT:    [[TMP7:%.*]] = xor i64 [[TMP6]], 193514046488576
// CHECK-NEXT:    [[TMP8:%.*]] = inttoptr i64 [[TMP7]] to ptr
// CHECK-NEXT:    store { <2 x i32>, <2 x i32> } zeroinitializer, ptr [[TMP8]], align 8
// CHECK-NEXT:    store { <2 x float>, <2 x float> } [[VLD2]], ptr [[__RET]], align 8
// CHECK-NEXT:    [[TMP9:%.*]] = call ptr @__msan_memcpy(ptr [[RETVAL]], ptr [[__RET]], i64 16)
// CHECK-NEXT:    [[TMP10:%.*]] = load [[STRUCT_FLOAT32X2X2_T]], ptr [[RETVAL]], align 8
// CHECK-NEXT:    store { [2 x <2 x i32>] } zeroinitializer, ptr @__msan_retval_tls, align 8
// CHECK-NEXT:    ret [[STRUCT_FLOAT32X2X2_T]] [[TMP10]]
//
float32x2x2_t test_vld2_f32(float32_t const *a) {
  return vld2_f32(a);
}

// CHECK-LABEL: define dso_local %struct.float64x1x2_t @test_vld2_f64(
// CHECK-SAME: ptr noundef [[A:%.*]]) #[[ATTR0]] {
// CHECK-NEXT:  entry:
// CHECK-NEXT:    call void @llvm.donothing()
// CHECK-NEXT:    [[RETVAL:%.*]] = alloca [[STRUCT_FLOAT64X1X2_T:%.*]], align 8
// CHECK-NEXT:    [[TMP0:%.*]] = ptrtoint ptr [[RETVAL]] to i64
// CHECK-NEXT:    [[TMP1:%.*]] = xor i64 [[TMP0]], 193514046488576
// CHECK-NEXT:    [[TMP2:%.*]] = inttoptr i64 [[TMP1]] to ptr
// CHECK-NEXT:    call void @llvm.memset.p0.i64(ptr align 8 [[TMP2]], i8 0, i64 16, i1 false)
// CHECK-NEXT:    [[__RET:%.*]] = alloca [[STRUCT_FLOAT64X1X2_T]], align 8
// CHECK-NEXT:    [[TMP3:%.*]] = ptrtoint ptr [[__RET]] to i64
// CHECK-NEXT:    [[TMP4:%.*]] = xor i64 [[TMP3]], 193514046488576
// CHECK-NEXT:    [[TMP5:%.*]] = inttoptr i64 [[TMP4]] to ptr
// CHECK-NEXT:    call void @llvm.memset.p0.i64(ptr align 8 [[TMP5]], i8 0, i64 16, i1 false)
// CHECK-NEXT:    [[VLD2:%.*]] = call { <1 x double>, <1 x double> } @llvm.aarch64.neon.ld2.v1f64.p0(ptr [[A]])
// CHECK-NEXT:    [[TMP6:%.*]] = ptrtoint ptr [[__RET]] to i64
// CHECK-NEXT:    [[TMP7:%.*]] = xor i64 [[TMP6]], 193514046488576
// CHECK-NEXT:    [[TMP8:%.*]] = inttoptr i64 [[TMP7]] to ptr
// CHECK-NEXT:    store { <1 x i64>, <1 x i64> } zeroinitializer, ptr [[TMP8]], align 8
// CHECK-NEXT:    store { <1 x double>, <1 x double> } [[VLD2]], ptr [[__RET]], align 8
// CHECK-NEXT:    [[TMP9:%.*]] = call ptr @__msan_memcpy(ptr [[RETVAL]], ptr [[__RET]], i64 16)
// CHECK-NEXT:    [[TMP10:%.*]] = load [[STRUCT_FLOAT64X1X2_T]], ptr [[RETVAL]], align 8
// CHECK-NEXT:    store { [2 x <1 x i64>] } zeroinitializer, ptr @__msan_retval_tls, align 8
// CHECK-NEXT:    ret [[STRUCT_FLOAT64X1X2_T]] [[TMP10]]
//
float64x1x2_t test_vld2_f64(float64_t const *a) {
  return vld2_f64(a);
}

// CHECK-LABEL: define dso_local %struct.poly8x8x2_t @test_vld2_p8(
// CHECK-SAME: ptr noundef [[A:%.*]]) #[[ATTR0]] {
// CHECK-NEXT:  entry:
// CHECK-NEXT:    call void @llvm.donothing()
// CHECK-NEXT:    [[RETVAL:%.*]] = alloca [[STRUCT_POLY8X8X2_T:%.*]], align 8
// CHECK-NEXT:    [[TMP0:%.*]] = ptrtoint ptr [[RETVAL]] to i64
// CHECK-NEXT:    [[TMP1:%.*]] = xor i64 [[TMP0]], 193514046488576
// CHECK-NEXT:    [[TMP2:%.*]] = inttoptr i64 [[TMP1]] to ptr
// CHECK-NEXT:    call void @llvm.memset.p0.i64(ptr align 8 [[TMP2]], i8 0, i64 16, i1 false)
// CHECK-NEXT:    [[__RET:%.*]] = alloca [[STRUCT_POLY8X8X2_T]], align 8
// CHECK-NEXT:    [[TMP3:%.*]] = ptrtoint ptr [[__RET]] to i64
// CHECK-NEXT:    [[TMP4:%.*]] = xor i64 [[TMP3]], 193514046488576
// CHECK-NEXT:    [[TMP5:%.*]] = inttoptr i64 [[TMP4]] to ptr
// CHECK-NEXT:    call void @llvm.memset.p0.i64(ptr align 8 [[TMP5]], i8 0, i64 16, i1 false)
// CHECK-NEXT:    [[VLD2:%.*]] = call { <8 x i8>, <8 x i8> } @llvm.aarch64.neon.ld2.v8i8.p0(ptr [[A]])
// CHECK-NEXT:    [[TMP6:%.*]] = ptrtoint ptr [[__RET]] to i64
// CHECK-NEXT:    [[TMP7:%.*]] = xor i64 [[TMP6]], 193514046488576
// CHECK-NEXT:    [[TMP8:%.*]] = inttoptr i64 [[TMP7]] to ptr
// CHECK-NEXT:    store { <8 x i8>, <8 x i8> } zeroinitializer, ptr [[TMP8]], align 8
// CHECK-NEXT:    store { <8 x i8>, <8 x i8> } [[VLD2]], ptr [[__RET]], align 8
// CHECK-NEXT:    [[TMP9:%.*]] = call ptr @__msan_memcpy(ptr [[RETVAL]], ptr [[__RET]], i64 16)
// CHECK-NEXT:    [[TMP10:%.*]] = load [[STRUCT_POLY8X8X2_T]], ptr [[RETVAL]], align 8
// CHECK-NEXT:    store { [2 x <8 x i8>] } zeroinitializer, ptr @__msan_retval_tls, align 8
// CHECK-NEXT:    ret [[STRUCT_POLY8X8X2_T]] [[TMP10]]
//
poly8x8x2_t test_vld2_p8(poly8_t const *a) {
  return vld2_p8(a);
}

// CHECK-LABEL: define dso_local %struct.poly16x4x2_t @test_vld2_p16(
// CHECK-SAME: ptr noundef [[A:%.*]]) #[[ATTR0]] {
// CHECK-NEXT:  entry:
// CHECK-NEXT:    call void @llvm.donothing()
// CHECK-NEXT:    [[RETVAL:%.*]] = alloca [[STRUCT_POLY16X4X2_T:%.*]], align 8
// CHECK-NEXT:    [[TMP0:%.*]] = ptrtoint ptr [[RETVAL]] to i64
// CHECK-NEXT:    [[TMP1:%.*]] = xor i64 [[TMP0]], 193514046488576
// CHECK-NEXT:    [[TMP2:%.*]] = inttoptr i64 [[TMP1]] to ptr
// CHECK-NEXT:    call void @llvm.memset.p0.i64(ptr align 8 [[TMP2]], i8 0, i64 16, i1 false)
// CHECK-NEXT:    [[__RET:%.*]] = alloca [[STRUCT_POLY16X4X2_T]], align 8
// CHECK-NEXT:    [[TMP3:%.*]] = ptrtoint ptr [[__RET]] to i64
// CHECK-NEXT:    [[TMP4:%.*]] = xor i64 [[TMP3]], 193514046488576
// CHECK-NEXT:    [[TMP5:%.*]] = inttoptr i64 [[TMP4]] to ptr
// CHECK-NEXT:    call void @llvm.memset.p0.i64(ptr align 8 [[TMP5]], i8 0, i64 16, i1 false)
// CHECK-NEXT:    [[VLD2:%.*]] = call { <4 x i16>, <4 x i16> } @llvm.aarch64.neon.ld2.v4i16.p0(ptr [[A]])
// CHECK-NEXT:    [[TMP6:%.*]] = ptrtoint ptr [[__RET]] to i64
// CHECK-NEXT:    [[TMP7:%.*]] = xor i64 [[TMP6]], 193514046488576
// CHECK-NEXT:    [[TMP8:%.*]] = inttoptr i64 [[TMP7]] to ptr
// CHECK-NEXT:    store { <4 x i16>, <4 x i16> } zeroinitializer, ptr [[TMP8]], align 8
// CHECK-NEXT:    store { <4 x i16>, <4 x i16> } [[VLD2]], ptr [[__RET]], align 8
// CHECK-NEXT:    [[TMP9:%.*]] = call ptr @__msan_memcpy(ptr [[RETVAL]], ptr [[__RET]], i64 16)
// CHECK-NEXT:    [[TMP10:%.*]] = load [[STRUCT_POLY16X4X2_T]], ptr [[RETVAL]], align 8
// CHECK-NEXT:    store { [2 x <4 x i16>] } zeroinitializer, ptr @__msan_retval_tls, align 8
// CHECK-NEXT:    ret [[STRUCT_POLY16X4X2_T]] [[TMP10]]
//
poly16x4x2_t test_vld2_p16(poly16_t const *a) {
  return vld2_p16(a);
}

// CHECK-LABEL: define dso_local %struct.uint8x16x3_t @test_vld3q_u8(
// CHECK-SAME: ptr noundef [[A:%.*]]) #[[ATTR0]] {
// CHECK-NEXT:  entry:
// CHECK-NEXT:    call void @llvm.donothing()
// CHECK-NEXT:    [[RETVAL:%.*]] = alloca [[STRUCT_UINT8X16X3_T:%.*]], align 16
// CHECK-NEXT:    [[TMP0:%.*]] = ptrtoint ptr [[RETVAL]] to i64
// CHECK-NEXT:    [[TMP1:%.*]] = xor i64 [[TMP0]], 193514046488576
// CHECK-NEXT:    [[TMP2:%.*]] = inttoptr i64 [[TMP1]] to ptr
// CHECK-NEXT:    call void @llvm.memset.p0.i64(ptr align 16 [[TMP2]], i8 0, i64 48, i1 false)
// CHECK-NEXT:    [[__RET:%.*]] = alloca [[STRUCT_UINT8X16X3_T]], align 16
// CHECK-NEXT:    [[TMP3:%.*]] = ptrtoint ptr [[__RET]] to i64
// CHECK-NEXT:    [[TMP4:%.*]] = xor i64 [[TMP3]], 193514046488576
// CHECK-NEXT:    [[TMP5:%.*]] = inttoptr i64 [[TMP4]] to ptr
// CHECK-NEXT:    call void @llvm.memset.p0.i64(ptr align 16 [[TMP5]], i8 0, i64 48, i1 false)
// CHECK-NEXT:    [[VLD3:%.*]] = call { <16 x i8>, <16 x i8>, <16 x i8> } @llvm.aarch64.neon.ld3.v16i8.p0(ptr [[A]])
// CHECK-NEXT:    [[TMP6:%.*]] = ptrtoint ptr [[__RET]] to i64
// CHECK-NEXT:    [[TMP7:%.*]] = xor i64 [[TMP6]], 193514046488576
// CHECK-NEXT:    [[TMP8:%.*]] = inttoptr i64 [[TMP7]] to ptr
// CHECK-NEXT:    store { <16 x i8>, <16 x i8>, <16 x i8> } zeroinitializer, ptr [[TMP8]], align 16
// CHECK-NEXT:    store { <16 x i8>, <16 x i8>, <16 x i8> } [[VLD3]], ptr [[__RET]], align 16
// CHECK-NEXT:    [[TMP9:%.*]] = call ptr @__msan_memcpy(ptr [[RETVAL]], ptr [[__RET]], i64 48)
// CHECK-NEXT:    [[TMP10:%.*]] = load [[STRUCT_UINT8X16X3_T]], ptr [[RETVAL]], align 16
// CHECK-NEXT:    store { [3 x <16 x i8>] } zeroinitializer, ptr @__msan_retval_tls, align 8
// CHECK-NEXT:    ret [[STRUCT_UINT8X16X3_T]] [[TMP10]]
//
uint8x16x3_t test_vld3q_u8(uint8_t const *a) {
  return vld3q_u8(a);
}

// CHECK-LABEL: define dso_local %struct.uint16x8x3_t @test_vld3q_u16(
// CHECK-SAME: ptr noundef [[A:%.*]]) #[[ATTR0]] {
// CHECK-NEXT:  entry:
// CHECK-NEXT:    call void @llvm.donothing()
// CHECK-NEXT:    [[RETVAL:%.*]] = alloca [[STRUCT_UINT16X8X3_T:%.*]], align 16
// CHECK-NEXT:    [[TMP0:%.*]] = ptrtoint ptr [[RETVAL]] to i64
// CHECK-NEXT:    [[TMP1:%.*]] = xor i64 [[TMP0]], 193514046488576
// CHECK-NEXT:    [[TMP2:%.*]] = inttoptr i64 [[TMP1]] to ptr
// CHECK-NEXT:    call void @llvm.memset.p0.i64(ptr align 16 [[TMP2]], i8 0, i64 48, i1 false)
// CHECK-NEXT:    [[__RET:%.*]] = alloca [[STRUCT_UINT16X8X3_T]], align 16
// CHECK-NEXT:    [[TMP3:%.*]] = ptrtoint ptr [[__RET]] to i64
// CHECK-NEXT:    [[TMP4:%.*]] = xor i64 [[TMP3]], 193514046488576
// CHECK-NEXT:    [[TMP5:%.*]] = inttoptr i64 [[TMP4]] to ptr
// CHECK-NEXT:    call void @llvm.memset.p0.i64(ptr align 16 [[TMP5]], i8 0, i64 48, i1 false)
// CHECK-NEXT:    [[VLD3:%.*]] = call { <8 x i16>, <8 x i16>, <8 x i16> } @llvm.aarch64.neon.ld3.v8i16.p0(ptr [[A]])
// CHECK-NEXT:    [[TMP6:%.*]] = ptrtoint ptr [[__RET]] to i64
// CHECK-NEXT:    [[TMP7:%.*]] = xor i64 [[TMP6]], 193514046488576
// CHECK-NEXT:    [[TMP8:%.*]] = inttoptr i64 [[TMP7]] to ptr
// CHECK-NEXT:    store { <8 x i16>, <8 x i16>, <8 x i16> } zeroinitializer, ptr [[TMP8]], align 16
// CHECK-NEXT:    store { <8 x i16>, <8 x i16>, <8 x i16> } [[VLD3]], ptr [[__RET]], align 16
// CHECK-NEXT:    [[TMP9:%.*]] = call ptr @__msan_memcpy(ptr [[RETVAL]], ptr [[__RET]], i64 48)
// CHECK-NEXT:    [[TMP10:%.*]] = load [[STRUCT_UINT16X8X3_T]], ptr [[RETVAL]], align 16
// CHECK-NEXT:    store { [3 x <8 x i16>] } zeroinitializer, ptr @__msan_retval_tls, align 8
// CHECK-NEXT:    ret [[STRUCT_UINT16X8X3_T]] [[TMP10]]
//
uint16x8x3_t test_vld3q_u16(uint16_t const *a) {
  return vld3q_u16(a);
}

// CHECK-LABEL: define dso_local %struct.uint32x4x3_t @test_vld3q_u32(
// CHECK-SAME: ptr noundef [[A:%.*]]) #[[ATTR0]] {
// CHECK-NEXT:  entry:
// CHECK-NEXT:    call void @llvm.donothing()
// CHECK-NEXT:    [[RETVAL:%.*]] = alloca [[STRUCT_UINT32X4X3_T:%.*]], align 16
// CHECK-NEXT:    [[TMP0:%.*]] = ptrtoint ptr [[RETVAL]] to i64
// CHECK-NEXT:    [[TMP1:%.*]] = xor i64 [[TMP0]], 193514046488576
// CHECK-NEXT:    [[TMP2:%.*]] = inttoptr i64 [[TMP1]] to ptr
// CHECK-NEXT:    call void @llvm.memset.p0.i64(ptr align 16 [[TMP2]], i8 0, i64 48, i1 false)
// CHECK-NEXT:    [[__RET:%.*]] = alloca [[STRUCT_UINT32X4X3_T]], align 16
// CHECK-NEXT:    [[TMP3:%.*]] = ptrtoint ptr [[__RET]] to i64
// CHECK-NEXT:    [[TMP4:%.*]] = xor i64 [[TMP3]], 193514046488576
// CHECK-NEXT:    [[TMP5:%.*]] = inttoptr i64 [[TMP4]] to ptr
// CHECK-NEXT:    call void @llvm.memset.p0.i64(ptr align 16 [[TMP5]], i8 0, i64 48, i1 false)
// CHECK-NEXT:    [[VLD3:%.*]] = call { <4 x i32>, <4 x i32>, <4 x i32> } @llvm.aarch64.neon.ld3.v4i32.p0(ptr [[A]])
// CHECK-NEXT:    [[TMP6:%.*]] = ptrtoint ptr [[__RET]] to i64
// CHECK-NEXT:    [[TMP7:%.*]] = xor i64 [[TMP6]], 193514046488576
// CHECK-NEXT:    [[TMP8:%.*]] = inttoptr i64 [[TMP7]] to ptr
// CHECK-NEXT:    store { <4 x i32>, <4 x i32>, <4 x i32> } zeroinitializer, ptr [[TMP8]], align 16
// CHECK-NEXT:    store { <4 x i32>, <4 x i32>, <4 x i32> } [[VLD3]], ptr [[__RET]], align 16
// CHECK-NEXT:    [[TMP9:%.*]] = call ptr @__msan_memcpy(ptr [[RETVAL]], ptr [[__RET]], i64 48)
// CHECK-NEXT:    [[TMP10:%.*]] = load [[STRUCT_UINT32X4X3_T]], ptr [[RETVAL]], align 16
// CHECK-NEXT:    store { [3 x <4 x i32>] } zeroinitializer, ptr @__msan_retval_tls, align 8
// CHECK-NEXT:    ret [[STRUCT_UINT32X4X3_T]] [[TMP10]]
//
uint32x4x3_t test_vld3q_u32(uint32_t const *a) {
  return vld3q_u32(a);
}

// CHECK-LABEL: define dso_local %struct.uint64x2x3_t @test_vld3q_u64(
// CHECK-SAME: ptr noundef [[A:%.*]]) #[[ATTR0]] {
// CHECK-NEXT:  entry:
// CHECK-NEXT:    call void @llvm.donothing()
// CHECK-NEXT:    [[RETVAL:%.*]] = alloca [[STRUCT_UINT64X2X3_T:%.*]], align 16
// CHECK-NEXT:    [[TMP0:%.*]] = ptrtoint ptr [[RETVAL]] to i64
// CHECK-NEXT:    [[TMP1:%.*]] = xor i64 [[TMP0]], 193514046488576
// CHECK-NEXT:    [[TMP2:%.*]] = inttoptr i64 [[TMP1]] to ptr
// CHECK-NEXT:    call void @llvm.memset.p0.i64(ptr align 16 [[TMP2]], i8 0, i64 48, i1 false)
// CHECK-NEXT:    [[__RET:%.*]] = alloca [[STRUCT_UINT64X2X3_T]], align 16
// CHECK-NEXT:    [[TMP3:%.*]] = ptrtoint ptr [[__RET]] to i64
// CHECK-NEXT:    [[TMP4:%.*]] = xor i64 [[TMP3]], 193514046488576
// CHECK-NEXT:    [[TMP5:%.*]] = inttoptr i64 [[TMP4]] to ptr
// CHECK-NEXT:    call void @llvm.memset.p0.i64(ptr align 16 [[TMP5]], i8 0, i64 48, i1 false)
// CHECK-NEXT:    [[VLD3:%.*]] = call { <2 x i64>, <2 x i64>, <2 x i64> } @llvm.aarch64.neon.ld3.v2i64.p0(ptr [[A]])
// CHECK-NEXT:    [[TMP6:%.*]] = ptrtoint ptr [[__RET]] to i64
// CHECK-NEXT:    [[TMP7:%.*]] = xor i64 [[TMP6]], 193514046488576
// CHECK-NEXT:    [[TMP8:%.*]] = inttoptr i64 [[TMP7]] to ptr
// CHECK-NEXT:    store { <2 x i64>, <2 x i64>, <2 x i64> } zeroinitializer, ptr [[TMP8]], align 16
// CHECK-NEXT:    store { <2 x i64>, <2 x i64>, <2 x i64> } [[VLD3]], ptr [[__RET]], align 16
// CHECK-NEXT:    [[TMP9:%.*]] = call ptr @__msan_memcpy(ptr [[RETVAL]], ptr [[__RET]], i64 48)
// CHECK-NEXT:    [[TMP10:%.*]] = load [[STRUCT_UINT64X2X3_T]], ptr [[RETVAL]], align 16
// CHECK-NEXT:    store { [3 x <2 x i64>] } zeroinitializer, ptr @__msan_retval_tls, align 8
// CHECK-NEXT:    ret [[STRUCT_UINT64X2X3_T]] [[TMP10]]
//
uint64x2x3_t test_vld3q_u64(uint64_t const *a) {
  return vld3q_u64(a);
}

// CHECK-LABEL: define dso_local %struct.int8x16x3_t @test_vld3q_s8(
// CHECK-SAME: ptr noundef [[A:%.*]]) #[[ATTR0]] {
// CHECK-NEXT:  entry:
// CHECK-NEXT:    call void @llvm.donothing()
// CHECK-NEXT:    [[RETVAL:%.*]] = alloca [[STRUCT_INT8X16X3_T:%.*]], align 16
// CHECK-NEXT:    [[TMP0:%.*]] = ptrtoint ptr [[RETVAL]] to i64
// CHECK-NEXT:    [[TMP1:%.*]] = xor i64 [[TMP0]], 193514046488576
// CHECK-NEXT:    [[TMP2:%.*]] = inttoptr i64 [[TMP1]] to ptr
// CHECK-NEXT:    call void @llvm.memset.p0.i64(ptr align 16 [[TMP2]], i8 0, i64 48, i1 false)
// CHECK-NEXT:    [[__RET:%.*]] = alloca [[STRUCT_INT8X16X3_T]], align 16
// CHECK-NEXT:    [[TMP3:%.*]] = ptrtoint ptr [[__RET]] to i64
// CHECK-NEXT:    [[TMP4:%.*]] = xor i64 [[TMP3]], 193514046488576
// CHECK-NEXT:    [[TMP5:%.*]] = inttoptr i64 [[TMP4]] to ptr
// CHECK-NEXT:    call void @llvm.memset.p0.i64(ptr align 16 [[TMP5]], i8 0, i64 48, i1 false)
// CHECK-NEXT:    [[VLD3:%.*]] = call { <16 x i8>, <16 x i8>, <16 x i8> } @llvm.aarch64.neon.ld3.v16i8.p0(ptr [[A]])
// CHECK-NEXT:    [[TMP6:%.*]] = ptrtoint ptr [[__RET]] to i64
// CHECK-NEXT:    [[TMP7:%.*]] = xor i64 [[TMP6]], 193514046488576
// CHECK-NEXT:    [[TMP8:%.*]] = inttoptr i64 [[TMP7]] to ptr
// CHECK-NEXT:    store { <16 x i8>, <16 x i8>, <16 x i8> } zeroinitializer, ptr [[TMP8]], align 16
// CHECK-NEXT:    store { <16 x i8>, <16 x i8>, <16 x i8> } [[VLD3]], ptr [[__RET]], align 16
// CHECK-NEXT:    [[TMP9:%.*]] = call ptr @__msan_memcpy(ptr [[RETVAL]], ptr [[__RET]], i64 48)
// CHECK-NEXT:    [[TMP10:%.*]] = load [[STRUCT_INT8X16X3_T]], ptr [[RETVAL]], align 16
// CHECK-NEXT:    store { [3 x <16 x i8>] } zeroinitializer, ptr @__msan_retval_tls, align 8
// CHECK-NEXT:    ret [[STRUCT_INT8X16X3_T]] [[TMP10]]
//
int8x16x3_t test_vld3q_s8(int8_t const *a) {
  return vld3q_s8(a);
}

// CHECK-LABEL: define dso_local %struct.int16x8x3_t @test_vld3q_s16(
// CHECK-SAME: ptr noundef [[A:%.*]]) #[[ATTR0]] {
// CHECK-NEXT:  entry:
// CHECK-NEXT:    call void @llvm.donothing()
// CHECK-NEXT:    [[RETVAL:%.*]] = alloca [[STRUCT_INT16X8X3_T:%.*]], align 16
// CHECK-NEXT:    [[TMP0:%.*]] = ptrtoint ptr [[RETVAL]] to i64
// CHECK-NEXT:    [[TMP1:%.*]] = xor i64 [[TMP0]], 193514046488576
// CHECK-NEXT:    [[TMP2:%.*]] = inttoptr i64 [[TMP1]] to ptr
// CHECK-NEXT:    call void @llvm.memset.p0.i64(ptr align 16 [[TMP2]], i8 0, i64 48, i1 false)
// CHECK-NEXT:    [[__RET:%.*]] = alloca [[STRUCT_INT16X8X3_T]], align 16
// CHECK-NEXT:    [[TMP3:%.*]] = ptrtoint ptr [[__RET]] to i64
// CHECK-NEXT:    [[TMP4:%.*]] = xor i64 [[TMP3]], 193514046488576
// CHECK-NEXT:    [[TMP5:%.*]] = inttoptr i64 [[TMP4]] to ptr
// CHECK-NEXT:    call void @llvm.memset.p0.i64(ptr align 16 [[TMP5]], i8 0, i64 48, i1 false)
// CHECK-NEXT:    [[VLD3:%.*]] = call { <8 x i16>, <8 x i16>, <8 x i16> } @llvm.aarch64.neon.ld3.v8i16.p0(ptr [[A]])
// CHECK-NEXT:    [[TMP6:%.*]] = ptrtoint ptr [[__RET]] to i64
// CHECK-NEXT:    [[TMP7:%.*]] = xor i64 [[TMP6]], 193514046488576
// CHECK-NEXT:    [[TMP8:%.*]] = inttoptr i64 [[TMP7]] to ptr
// CHECK-NEXT:    store { <8 x i16>, <8 x i16>, <8 x i16> } zeroinitializer, ptr [[TMP8]], align 16
// CHECK-NEXT:    store { <8 x i16>, <8 x i16>, <8 x i16> } [[VLD3]], ptr [[__RET]], align 16
// CHECK-NEXT:    [[TMP9:%.*]] = call ptr @__msan_memcpy(ptr [[RETVAL]], ptr [[__RET]], i64 48)
// CHECK-NEXT:    [[TMP10:%.*]] = load [[STRUCT_INT16X8X3_T]], ptr [[RETVAL]], align 16
// CHECK-NEXT:    store { [3 x <8 x i16>] } zeroinitializer, ptr @__msan_retval_tls, align 8
// CHECK-NEXT:    ret [[STRUCT_INT16X8X3_T]] [[TMP10]]
//
int16x8x3_t test_vld3q_s16(int16_t const *a) {
  return vld3q_s16(a);
}

// CHECK-LABEL: define dso_local %struct.int32x4x3_t @test_vld3q_s32(
// CHECK-SAME: ptr noundef [[A:%.*]]) #[[ATTR0]] {
// CHECK-NEXT:  entry:
// CHECK-NEXT:    call void @llvm.donothing()
// CHECK-NEXT:    [[RETVAL:%.*]] = alloca [[STRUCT_INT32X4X3_T:%.*]], align 16
// CHECK-NEXT:    [[TMP0:%.*]] = ptrtoint ptr [[RETVAL]] to i64
// CHECK-NEXT:    [[TMP1:%.*]] = xor i64 [[TMP0]], 193514046488576
// CHECK-NEXT:    [[TMP2:%.*]] = inttoptr i64 [[TMP1]] to ptr
// CHECK-NEXT:    call void @llvm.memset.p0.i64(ptr align 16 [[TMP2]], i8 0, i64 48, i1 false)
// CHECK-NEXT:    [[__RET:%.*]] = alloca [[STRUCT_INT32X4X3_T]], align 16
// CHECK-NEXT:    [[TMP3:%.*]] = ptrtoint ptr [[__RET]] to i64
// CHECK-NEXT:    [[TMP4:%.*]] = xor i64 [[TMP3]], 193514046488576
// CHECK-NEXT:    [[TMP5:%.*]] = inttoptr i64 [[TMP4]] to ptr
// CHECK-NEXT:    call void @llvm.memset.p0.i64(ptr align 16 [[TMP5]], i8 0, i64 48, i1 false)
// CHECK-NEXT:    [[VLD3:%.*]] = call { <4 x i32>, <4 x i32>, <4 x i32> } @llvm.aarch64.neon.ld3.v4i32.p0(ptr [[A]])
// CHECK-NEXT:    [[TMP6:%.*]] = ptrtoint ptr [[__RET]] to i64
// CHECK-NEXT:    [[TMP7:%.*]] = xor i64 [[TMP6]], 193514046488576
// CHECK-NEXT:    [[TMP8:%.*]] = inttoptr i64 [[TMP7]] to ptr
// CHECK-NEXT:    store { <4 x i32>, <4 x i32>, <4 x i32> } zeroinitializer, ptr [[TMP8]], align 16
// CHECK-NEXT:    store { <4 x i32>, <4 x i32>, <4 x i32> } [[VLD3]], ptr [[__RET]], align 16
// CHECK-NEXT:    [[TMP9:%.*]] = call ptr @__msan_memcpy(ptr [[RETVAL]], ptr [[__RET]], i64 48)
// CHECK-NEXT:    [[TMP10:%.*]] = load [[STRUCT_INT32X4X3_T]], ptr [[RETVAL]], align 16
// CHECK-NEXT:    store { [3 x <4 x i32>] } zeroinitializer, ptr @__msan_retval_tls, align 8
// CHECK-NEXT:    ret [[STRUCT_INT32X4X3_T]] [[TMP10]]
//
int32x4x3_t test_vld3q_s32(int32_t const *a) {
  return vld3q_s32(a);
}

// CHECK-LABEL: define dso_local %struct.int64x2x3_t @test_vld3q_s64(
// CHECK-SAME: ptr noundef [[A:%.*]]) #[[ATTR0]] {
// CHECK-NEXT:  entry:
// CHECK-NEXT:    call void @llvm.donothing()
// CHECK-NEXT:    [[RETVAL:%.*]] = alloca [[STRUCT_INT64X2X3_T:%.*]], align 16
// CHECK-NEXT:    [[TMP0:%.*]] = ptrtoint ptr [[RETVAL]] to i64
// CHECK-NEXT:    [[TMP1:%.*]] = xor i64 [[TMP0]], 193514046488576
// CHECK-NEXT:    [[TMP2:%.*]] = inttoptr i64 [[TMP1]] to ptr
// CHECK-NEXT:    call void @llvm.memset.p0.i64(ptr align 16 [[TMP2]], i8 0, i64 48, i1 false)
// CHECK-NEXT:    [[__RET:%.*]] = alloca [[STRUCT_INT64X2X3_T]], align 16
// CHECK-NEXT:    [[TMP3:%.*]] = ptrtoint ptr [[__RET]] to i64
// CHECK-NEXT:    [[TMP4:%.*]] = xor i64 [[TMP3]], 193514046488576
// CHECK-NEXT:    [[TMP5:%.*]] = inttoptr i64 [[TMP4]] to ptr
// CHECK-NEXT:    call void @llvm.memset.p0.i64(ptr align 16 [[TMP5]], i8 0, i64 48, i1 false)
// CHECK-NEXT:    [[VLD3:%.*]] = call { <2 x i64>, <2 x i64>, <2 x i64> } @llvm.aarch64.neon.ld3.v2i64.p0(ptr [[A]])
// CHECK-NEXT:    [[TMP6:%.*]] = ptrtoint ptr [[__RET]] to i64
// CHECK-NEXT:    [[TMP7:%.*]] = xor i64 [[TMP6]], 193514046488576
// CHECK-NEXT:    [[TMP8:%.*]] = inttoptr i64 [[TMP7]] to ptr
// CHECK-NEXT:    store { <2 x i64>, <2 x i64>, <2 x i64> } zeroinitializer, ptr [[TMP8]], align 16
// CHECK-NEXT:    store { <2 x i64>, <2 x i64>, <2 x i64> } [[VLD3]], ptr [[__RET]], align 16
// CHECK-NEXT:    [[TMP9:%.*]] = call ptr @__msan_memcpy(ptr [[RETVAL]], ptr [[__RET]], i64 48)
// CHECK-NEXT:    [[TMP10:%.*]] = load [[STRUCT_INT64X2X3_T]], ptr [[RETVAL]], align 16
// CHECK-NEXT:    store { [3 x <2 x i64>] } zeroinitializer, ptr @__msan_retval_tls, align 8
// CHECK-NEXT:    ret [[STRUCT_INT64X2X3_T]] [[TMP10]]
//
int64x2x3_t test_vld3q_s64(int64_t const *a) {
  return vld3q_s64(a);
}

// CHECK-LABEL: define dso_local %struct.float16x8x3_t @test_vld3q_f16(
// CHECK-SAME: ptr noundef [[A:%.*]]) #[[ATTR0]] {
// CHECK-NEXT:  entry:
// CHECK-NEXT:    call void @llvm.donothing()
// CHECK-NEXT:    [[RETVAL:%.*]] = alloca [[STRUCT_FLOAT16X8X3_T:%.*]], align 16
// CHECK-NEXT:    [[TMP0:%.*]] = ptrtoint ptr [[RETVAL]] to i64
// CHECK-NEXT:    [[TMP1:%.*]] = xor i64 [[TMP0]], 193514046488576
// CHECK-NEXT:    [[TMP2:%.*]] = inttoptr i64 [[TMP1]] to ptr
// CHECK-NEXT:    call void @llvm.memset.p0.i64(ptr align 16 [[TMP2]], i8 0, i64 48, i1 false)
// CHECK-NEXT:    [[__RET:%.*]] = alloca [[STRUCT_FLOAT16X8X3_T]], align 16
// CHECK-NEXT:    [[TMP3:%.*]] = ptrtoint ptr [[__RET]] to i64
// CHECK-NEXT:    [[TMP4:%.*]] = xor i64 [[TMP3]], 193514046488576
// CHECK-NEXT:    [[TMP5:%.*]] = inttoptr i64 [[TMP4]] to ptr
// CHECK-NEXT:    call void @llvm.memset.p0.i64(ptr align 16 [[TMP5]], i8 0, i64 48, i1 false)
// CHECK-NEXT:    [[VLD3:%.*]] = call { <8 x half>, <8 x half>, <8 x half> } @llvm.aarch64.neon.ld3.v8f16.p0(ptr [[A]])
// CHECK-NEXT:    [[TMP6:%.*]] = ptrtoint ptr [[__RET]] to i64
// CHECK-NEXT:    [[TMP7:%.*]] = xor i64 [[TMP6]], 193514046488576
// CHECK-NEXT:    [[TMP8:%.*]] = inttoptr i64 [[TMP7]] to ptr
// CHECK-NEXT:    store { <8 x i16>, <8 x i16>, <8 x i16> } zeroinitializer, ptr [[TMP8]], align 16
// CHECK-NEXT:    store { <8 x half>, <8 x half>, <8 x half> } [[VLD3]], ptr [[__RET]], align 16
// CHECK-NEXT:    [[TMP9:%.*]] = call ptr @__msan_memcpy(ptr [[RETVAL]], ptr [[__RET]], i64 48)
// CHECK-NEXT:    [[TMP10:%.*]] = load [[STRUCT_FLOAT16X8X3_T]], ptr [[RETVAL]], align 16
// CHECK-NEXT:    store { [3 x <8 x i16>] } zeroinitializer, ptr @__msan_retval_tls, align 8
// CHECK-NEXT:    ret [[STRUCT_FLOAT16X8X3_T]] [[TMP10]]
//
float16x8x3_t test_vld3q_f16(float16_t const *a) {
  return vld3q_f16(a);
}

// CHECK-LABEL: define dso_local %struct.float32x4x3_t @test_vld3q_f32(
// CHECK-SAME: ptr noundef [[A:%.*]]) #[[ATTR0]] {
// CHECK-NEXT:  entry:
// CHECK-NEXT:    call void @llvm.donothing()
// CHECK-NEXT:    [[RETVAL:%.*]] = alloca [[STRUCT_FLOAT32X4X3_T:%.*]], align 16
// CHECK-NEXT:    [[TMP0:%.*]] = ptrtoint ptr [[RETVAL]] to i64
// CHECK-NEXT:    [[TMP1:%.*]] = xor i64 [[TMP0]], 193514046488576
// CHECK-NEXT:    [[TMP2:%.*]] = inttoptr i64 [[TMP1]] to ptr
// CHECK-NEXT:    call void @llvm.memset.p0.i64(ptr align 16 [[TMP2]], i8 0, i64 48, i1 false)
// CHECK-NEXT:    [[__RET:%.*]] = alloca [[STRUCT_FLOAT32X4X3_T]], align 16
// CHECK-NEXT:    [[TMP3:%.*]] = ptrtoint ptr [[__RET]] to i64
// CHECK-NEXT:    [[TMP4:%.*]] = xor i64 [[TMP3]], 193514046488576
// CHECK-NEXT:    [[TMP5:%.*]] = inttoptr i64 [[TMP4]] to ptr
// CHECK-NEXT:    call void @llvm.memset.p0.i64(ptr align 16 [[TMP5]], i8 0, i64 48, i1 false)
// CHECK-NEXT:    [[VLD3:%.*]] = call { <4 x float>, <4 x float>, <4 x float> } @llvm.aarch64.neon.ld3.v4f32.p0(ptr [[A]])
// CHECK-NEXT:    [[TMP6:%.*]] = ptrtoint ptr [[__RET]] to i64
// CHECK-NEXT:    [[TMP7:%.*]] = xor i64 [[TMP6]], 193514046488576
// CHECK-NEXT:    [[TMP8:%.*]] = inttoptr i64 [[TMP7]] to ptr
// CHECK-NEXT:    store { <4 x i32>, <4 x i32>, <4 x i32> } zeroinitializer, ptr [[TMP8]], align 16
// CHECK-NEXT:    store { <4 x float>, <4 x float>, <4 x float> } [[VLD3]], ptr [[__RET]], align 16
// CHECK-NEXT:    [[TMP9:%.*]] = call ptr @__msan_memcpy(ptr [[RETVAL]], ptr [[__RET]], i64 48)
// CHECK-NEXT:    [[TMP10:%.*]] = load [[STRUCT_FLOAT32X4X3_T]], ptr [[RETVAL]], align 16
// CHECK-NEXT:    store { [3 x <4 x i32>] } zeroinitializer, ptr @__msan_retval_tls, align 8
// CHECK-NEXT:    ret [[STRUCT_FLOAT32X4X3_T]] [[TMP10]]
//
float32x4x3_t test_vld3q_f32(float32_t const *a) {
  return vld3q_f32(a);
}

// CHECK-LABEL: define dso_local %struct.float64x2x3_t @test_vld3q_f64(
// CHECK-SAME: ptr noundef [[A:%.*]]) #[[ATTR0]] {
// CHECK-NEXT:  entry:
// CHECK-NEXT:    call void @llvm.donothing()
// CHECK-NEXT:    [[RETVAL:%.*]] = alloca [[STRUCT_FLOAT64X2X3_T:%.*]], align 16
// CHECK-NEXT:    [[TMP0:%.*]] = ptrtoint ptr [[RETVAL]] to i64
// CHECK-NEXT:    [[TMP1:%.*]] = xor i64 [[TMP0]], 193514046488576
// CHECK-NEXT:    [[TMP2:%.*]] = inttoptr i64 [[TMP1]] to ptr
// CHECK-NEXT:    call void @llvm.memset.p0.i64(ptr align 16 [[TMP2]], i8 0, i64 48, i1 false)
// CHECK-NEXT:    [[__RET:%.*]] = alloca [[STRUCT_FLOAT64X2X3_T]], align 16
// CHECK-NEXT:    [[TMP3:%.*]] = ptrtoint ptr [[__RET]] to i64
// CHECK-NEXT:    [[TMP4:%.*]] = xor i64 [[TMP3]], 193514046488576
// CHECK-NEXT:    [[TMP5:%.*]] = inttoptr i64 [[TMP4]] to ptr
// CHECK-NEXT:    call void @llvm.memset.p0.i64(ptr align 16 [[TMP5]], i8 0, i64 48, i1 false)
// CHECK-NEXT:    [[VLD3:%.*]] = call { <2 x double>, <2 x double>, <2 x double> } @llvm.aarch64.neon.ld3.v2f64.p0(ptr [[A]])
// CHECK-NEXT:    [[TMP6:%.*]] = ptrtoint ptr [[__RET]] to i64
// CHECK-NEXT:    [[TMP7:%.*]] = xor i64 [[TMP6]], 193514046488576
// CHECK-NEXT:    [[TMP8:%.*]] = inttoptr i64 [[TMP7]] to ptr
// CHECK-NEXT:    store { <2 x i64>, <2 x i64>, <2 x i64> } zeroinitializer, ptr [[TMP8]], align 16
// CHECK-NEXT:    store { <2 x double>, <2 x double>, <2 x double> } [[VLD3]], ptr [[__RET]], align 16
// CHECK-NEXT:    [[TMP9:%.*]] = call ptr @__msan_memcpy(ptr [[RETVAL]], ptr [[__RET]], i64 48)
// CHECK-NEXT:    [[TMP10:%.*]] = load [[STRUCT_FLOAT64X2X3_T]], ptr [[RETVAL]], align 16
// CHECK-NEXT:    store { [3 x <2 x i64>] } zeroinitializer, ptr @__msan_retval_tls, align 8
// CHECK-NEXT:    ret [[STRUCT_FLOAT64X2X3_T]] [[TMP10]]
//
float64x2x3_t test_vld3q_f64(float64_t const *a) {
  return vld3q_f64(a);
}

// CHECK-LABEL: define dso_local %struct.poly8x16x3_t @test_vld3q_p8(
// CHECK-SAME: ptr noundef [[A:%.*]]) #[[ATTR0]] {
// CHECK-NEXT:  entry:
// CHECK-NEXT:    call void @llvm.donothing()
// CHECK-NEXT:    [[RETVAL:%.*]] = alloca [[STRUCT_POLY8X16X3_T:%.*]], align 16
// CHECK-NEXT:    [[TMP0:%.*]] = ptrtoint ptr [[RETVAL]] to i64
// CHECK-NEXT:    [[TMP1:%.*]] = xor i64 [[TMP0]], 193514046488576
// CHECK-NEXT:    [[TMP2:%.*]] = inttoptr i64 [[TMP1]] to ptr
// CHECK-NEXT:    call void @llvm.memset.p0.i64(ptr align 16 [[TMP2]], i8 0, i64 48, i1 false)
// CHECK-NEXT:    [[__RET:%.*]] = alloca [[STRUCT_POLY8X16X3_T]], align 16
// CHECK-NEXT:    [[TMP3:%.*]] = ptrtoint ptr [[__RET]] to i64
// CHECK-NEXT:    [[TMP4:%.*]] = xor i64 [[TMP3]], 193514046488576
// CHECK-NEXT:    [[TMP5:%.*]] = inttoptr i64 [[TMP4]] to ptr
// CHECK-NEXT:    call void @llvm.memset.p0.i64(ptr align 16 [[TMP5]], i8 0, i64 48, i1 false)
// CHECK-NEXT:    [[VLD3:%.*]] = call { <16 x i8>, <16 x i8>, <16 x i8> } @llvm.aarch64.neon.ld3.v16i8.p0(ptr [[A]])
// CHECK-NEXT:    [[TMP6:%.*]] = ptrtoint ptr [[__RET]] to i64
// CHECK-NEXT:    [[TMP7:%.*]] = xor i64 [[TMP6]], 193514046488576
// CHECK-NEXT:    [[TMP8:%.*]] = inttoptr i64 [[TMP7]] to ptr
// CHECK-NEXT:    store { <16 x i8>, <16 x i8>, <16 x i8> } zeroinitializer, ptr [[TMP8]], align 16
// CHECK-NEXT:    store { <16 x i8>, <16 x i8>, <16 x i8> } [[VLD3]], ptr [[__RET]], align 16
// CHECK-NEXT:    [[TMP9:%.*]] = call ptr @__msan_memcpy(ptr [[RETVAL]], ptr [[__RET]], i64 48)
// CHECK-NEXT:    [[TMP10:%.*]] = load [[STRUCT_POLY8X16X3_T]], ptr [[RETVAL]], align 16
// CHECK-NEXT:    store { [3 x <16 x i8>] } zeroinitializer, ptr @__msan_retval_tls, align 8
// CHECK-NEXT:    ret [[STRUCT_POLY8X16X3_T]] [[TMP10]]
//
poly8x16x3_t test_vld3q_p8(poly8_t const *a) {
  return vld3q_p8(a);
}

// CHECK-LABEL: define dso_local %struct.poly16x8x3_t @test_vld3q_p16(
// CHECK-SAME: ptr noundef [[A:%.*]]) #[[ATTR0]] {
// CHECK-NEXT:  entry:
// CHECK-NEXT:    call void @llvm.donothing()
// CHECK-NEXT:    [[RETVAL:%.*]] = alloca [[STRUCT_POLY16X8X3_T:%.*]], align 16
// CHECK-NEXT:    [[TMP0:%.*]] = ptrtoint ptr [[RETVAL]] to i64
// CHECK-NEXT:    [[TMP1:%.*]] = xor i64 [[TMP0]], 193514046488576
// CHECK-NEXT:    [[TMP2:%.*]] = inttoptr i64 [[TMP1]] to ptr
// CHECK-NEXT:    call void @llvm.memset.p0.i64(ptr align 16 [[TMP2]], i8 0, i64 48, i1 false)
// CHECK-NEXT:    [[__RET:%.*]] = alloca [[STRUCT_POLY16X8X3_T]], align 16
// CHECK-NEXT:    [[TMP3:%.*]] = ptrtoint ptr [[__RET]] to i64
// CHECK-NEXT:    [[TMP4:%.*]] = xor i64 [[TMP3]], 193514046488576
// CHECK-NEXT:    [[TMP5:%.*]] = inttoptr i64 [[TMP4]] to ptr
// CHECK-NEXT:    call void @llvm.memset.p0.i64(ptr align 16 [[TMP5]], i8 0, i64 48, i1 false)
// CHECK-NEXT:    [[VLD3:%.*]] = call { <8 x i16>, <8 x i16>, <8 x i16> } @llvm.aarch64.neon.ld3.v8i16.p0(ptr [[A]])
// CHECK-NEXT:    [[TMP6:%.*]] = ptrtoint ptr [[__RET]] to i64
// CHECK-NEXT:    [[TMP7:%.*]] = xor i64 [[TMP6]], 193514046488576
// CHECK-NEXT:    [[TMP8:%.*]] = inttoptr i64 [[TMP7]] to ptr
// CHECK-NEXT:    store { <8 x i16>, <8 x i16>, <8 x i16> } zeroinitializer, ptr [[TMP8]], align 16
// CHECK-NEXT:    store { <8 x i16>, <8 x i16>, <8 x i16> } [[VLD3]], ptr [[__RET]], align 16
// CHECK-NEXT:    [[TMP9:%.*]] = call ptr @__msan_memcpy(ptr [[RETVAL]], ptr [[__RET]], i64 48)
// CHECK-NEXT:    [[TMP10:%.*]] = load [[STRUCT_POLY16X8X3_T]], ptr [[RETVAL]], align 16
// CHECK-NEXT:    store { [3 x <8 x i16>] } zeroinitializer, ptr @__msan_retval_tls, align 8
// CHECK-NEXT:    ret [[STRUCT_POLY16X8X3_T]] [[TMP10]]
//
poly16x8x3_t test_vld3q_p16(poly16_t const *a) {
  return vld3q_p16(a);
}

// CHECK-LABEL: define dso_local %struct.uint8x8x3_t @test_vld3_u8(
// CHECK-SAME: ptr noundef [[A:%.*]]) #[[ATTR0]] {
// CHECK-NEXT:  entry:
// CHECK-NEXT:    call void @llvm.donothing()
// CHECK-NEXT:    [[RETVAL:%.*]] = alloca [[STRUCT_UINT8X8X3_T:%.*]], align 8
// CHECK-NEXT:    [[TMP0:%.*]] = ptrtoint ptr [[RETVAL]] to i64
// CHECK-NEXT:    [[TMP1:%.*]] = xor i64 [[TMP0]], 193514046488576
// CHECK-NEXT:    [[TMP2:%.*]] = inttoptr i64 [[TMP1]] to ptr
// CHECK-NEXT:    call void @llvm.memset.p0.i64(ptr align 8 [[TMP2]], i8 0, i64 24, i1 false)
// CHECK-NEXT:    [[__RET:%.*]] = alloca [[STRUCT_UINT8X8X3_T]], align 8
// CHECK-NEXT:    [[TMP3:%.*]] = ptrtoint ptr [[__RET]] to i64
// CHECK-NEXT:    [[TMP4:%.*]] = xor i64 [[TMP3]], 193514046488576
// CHECK-NEXT:    [[TMP5:%.*]] = inttoptr i64 [[TMP4]] to ptr
// CHECK-NEXT:    call void @llvm.memset.p0.i64(ptr align 8 [[TMP5]], i8 0, i64 24, i1 false)
// CHECK-NEXT:    [[VLD3:%.*]] = call { <8 x i8>, <8 x i8>, <8 x i8> } @llvm.aarch64.neon.ld3.v8i8.p0(ptr [[A]])
// CHECK-NEXT:    [[TMP6:%.*]] = ptrtoint ptr [[__RET]] to i64
// CHECK-NEXT:    [[TMP7:%.*]] = xor i64 [[TMP6]], 193514046488576
// CHECK-NEXT:    [[TMP8:%.*]] = inttoptr i64 [[TMP7]] to ptr
// CHECK-NEXT:    store { <8 x i8>, <8 x i8>, <8 x i8> } zeroinitializer, ptr [[TMP8]], align 8
// CHECK-NEXT:    store { <8 x i8>, <8 x i8>, <8 x i8> } [[VLD3]], ptr [[__RET]], align 8
// CHECK-NEXT:    [[TMP9:%.*]] = call ptr @__msan_memcpy(ptr [[RETVAL]], ptr [[__RET]], i64 24)
// CHECK-NEXT:    [[TMP10:%.*]] = load [[STRUCT_UINT8X8X3_T]], ptr [[RETVAL]], align 8
// CHECK-NEXT:    store { [3 x <8 x i8>] } zeroinitializer, ptr @__msan_retval_tls, align 8
// CHECK-NEXT:    ret [[STRUCT_UINT8X8X3_T]] [[TMP10]]
//
uint8x8x3_t test_vld3_u8(uint8_t const *a) {
  return vld3_u8(a);
}

// CHECK-LABEL: define dso_local %struct.uint16x4x3_t @test_vld3_u16(
// CHECK-SAME: ptr noundef [[A:%.*]]) #[[ATTR0]] {
// CHECK-NEXT:  entry:
// CHECK-NEXT:    call void @llvm.donothing()
// CHECK-NEXT:    [[RETVAL:%.*]] = alloca [[STRUCT_UINT16X4X3_T:%.*]], align 8
// CHECK-NEXT:    [[TMP0:%.*]] = ptrtoint ptr [[RETVAL]] to i64
// CHECK-NEXT:    [[TMP1:%.*]] = xor i64 [[TMP0]], 193514046488576
// CHECK-NEXT:    [[TMP2:%.*]] = inttoptr i64 [[TMP1]] to ptr
// CHECK-NEXT:    call void @llvm.memset.p0.i64(ptr align 8 [[TMP2]], i8 0, i64 24, i1 false)
// CHECK-NEXT:    [[__RET:%.*]] = alloca [[STRUCT_UINT16X4X3_T]], align 8
// CHECK-NEXT:    [[TMP3:%.*]] = ptrtoint ptr [[__RET]] to i64
// CHECK-NEXT:    [[TMP4:%.*]] = xor i64 [[TMP3]], 193514046488576
// CHECK-NEXT:    [[TMP5:%.*]] = inttoptr i64 [[TMP4]] to ptr
// CHECK-NEXT:    call void @llvm.memset.p0.i64(ptr align 8 [[TMP5]], i8 0, i64 24, i1 false)
// CHECK-NEXT:    [[VLD3:%.*]] = call { <4 x i16>, <4 x i16>, <4 x i16> } @llvm.aarch64.neon.ld3.v4i16.p0(ptr [[A]])
// CHECK-NEXT:    [[TMP6:%.*]] = ptrtoint ptr [[__RET]] to i64
// CHECK-NEXT:    [[TMP7:%.*]] = xor i64 [[TMP6]], 193514046488576
// CHECK-NEXT:    [[TMP8:%.*]] = inttoptr i64 [[TMP7]] to ptr
// CHECK-NEXT:    store { <4 x i16>, <4 x i16>, <4 x i16> } zeroinitializer, ptr [[TMP8]], align 8
// CHECK-NEXT:    store { <4 x i16>, <4 x i16>, <4 x i16> } [[VLD3]], ptr [[__RET]], align 8
// CHECK-NEXT:    [[TMP9:%.*]] = call ptr @__msan_memcpy(ptr [[RETVAL]], ptr [[__RET]], i64 24)
// CHECK-NEXT:    [[TMP10:%.*]] = load [[STRUCT_UINT16X4X3_T]], ptr [[RETVAL]], align 8
// CHECK-NEXT:    store { [3 x <4 x i16>] } zeroinitializer, ptr @__msan_retval_tls, align 8
// CHECK-NEXT:    ret [[STRUCT_UINT16X4X3_T]] [[TMP10]]
//
uint16x4x3_t test_vld3_u16(uint16_t const *a) {
  return vld3_u16(a);
}

// CHECK-LABEL: define dso_local %struct.uint32x2x3_t @test_vld3_u32(
// CHECK-SAME: ptr noundef [[A:%.*]]) #[[ATTR0]] {
// CHECK-NEXT:  entry:
// CHECK-NEXT:    call void @llvm.donothing()
// CHECK-NEXT:    [[RETVAL:%.*]] = alloca [[STRUCT_UINT32X2X3_T:%.*]], align 8
// CHECK-NEXT:    [[TMP0:%.*]] = ptrtoint ptr [[RETVAL]] to i64
// CHECK-NEXT:    [[TMP1:%.*]] = xor i64 [[TMP0]], 193514046488576
// CHECK-NEXT:    [[TMP2:%.*]] = inttoptr i64 [[TMP1]] to ptr
// CHECK-NEXT:    call void @llvm.memset.p0.i64(ptr align 8 [[TMP2]], i8 0, i64 24, i1 false)
// CHECK-NEXT:    [[__RET:%.*]] = alloca [[STRUCT_UINT32X2X3_T]], align 8
// CHECK-NEXT:    [[TMP3:%.*]] = ptrtoint ptr [[__RET]] to i64
// CHECK-NEXT:    [[TMP4:%.*]] = xor i64 [[TMP3]], 193514046488576
// CHECK-NEXT:    [[TMP5:%.*]] = inttoptr i64 [[TMP4]] to ptr
// CHECK-NEXT:    call void @llvm.memset.p0.i64(ptr align 8 [[TMP5]], i8 0, i64 24, i1 false)
// CHECK-NEXT:    [[VLD3:%.*]] = call { <2 x i32>, <2 x i32>, <2 x i32> } @llvm.aarch64.neon.ld3.v2i32.p0(ptr [[A]])
// CHECK-NEXT:    [[TMP6:%.*]] = ptrtoint ptr [[__RET]] to i64
// CHECK-NEXT:    [[TMP7:%.*]] = xor i64 [[TMP6]], 193514046488576
// CHECK-NEXT:    [[TMP8:%.*]] = inttoptr i64 [[TMP7]] to ptr
// CHECK-NEXT:    store { <2 x i32>, <2 x i32>, <2 x i32> } zeroinitializer, ptr [[TMP8]], align 8
// CHECK-NEXT:    store { <2 x i32>, <2 x i32>, <2 x i32> } [[VLD3]], ptr [[__RET]], align 8
// CHECK-NEXT:    [[TMP9:%.*]] = call ptr @__msan_memcpy(ptr [[RETVAL]], ptr [[__RET]], i64 24)
// CHECK-NEXT:    [[TMP10:%.*]] = load [[STRUCT_UINT32X2X3_T]], ptr [[RETVAL]], align 8
// CHECK-NEXT:    store { [3 x <2 x i32>] } zeroinitializer, ptr @__msan_retval_tls, align 8
// CHECK-NEXT:    ret [[STRUCT_UINT32X2X3_T]] [[TMP10]]
//
uint32x2x3_t test_vld3_u32(uint32_t const *a) {
  return vld3_u32(a);
}

// CHECK-LABEL: define dso_local %struct.uint64x1x3_t @test_vld3_u64(
// CHECK-SAME: ptr noundef [[A:%.*]]) #[[ATTR0]] {
// CHECK-NEXT:  entry:
// CHECK-NEXT:    call void @llvm.donothing()
// CHECK-NEXT:    [[RETVAL:%.*]] = alloca [[STRUCT_UINT64X1X3_T:%.*]], align 8
// CHECK-NEXT:    [[TMP0:%.*]] = ptrtoint ptr [[RETVAL]] to i64
// CHECK-NEXT:    [[TMP1:%.*]] = xor i64 [[TMP0]], 193514046488576
// CHECK-NEXT:    [[TMP2:%.*]] = inttoptr i64 [[TMP1]] to ptr
// CHECK-NEXT:    call void @llvm.memset.p0.i64(ptr align 8 [[TMP2]], i8 0, i64 24, i1 false)
// CHECK-NEXT:    [[__RET:%.*]] = alloca [[STRUCT_UINT64X1X3_T]], align 8
// CHECK-NEXT:    [[TMP3:%.*]] = ptrtoint ptr [[__RET]] to i64
// CHECK-NEXT:    [[TMP4:%.*]] = xor i64 [[TMP3]], 193514046488576
// CHECK-NEXT:    [[TMP5:%.*]] = inttoptr i64 [[TMP4]] to ptr
// CHECK-NEXT:    call void @llvm.memset.p0.i64(ptr align 8 [[TMP5]], i8 0, i64 24, i1 false)
// CHECK-NEXT:    [[VLD3:%.*]] = call { <1 x i64>, <1 x i64>, <1 x i64> } @llvm.aarch64.neon.ld3.v1i64.p0(ptr [[A]])
// CHECK-NEXT:    [[TMP6:%.*]] = ptrtoint ptr [[__RET]] to i64
// CHECK-NEXT:    [[TMP7:%.*]] = xor i64 [[TMP6]], 193514046488576
// CHECK-NEXT:    [[TMP8:%.*]] = inttoptr i64 [[TMP7]] to ptr
// CHECK-NEXT:    store { <1 x i64>, <1 x i64>, <1 x i64> } zeroinitializer, ptr [[TMP8]], align 8
// CHECK-NEXT:    store { <1 x i64>, <1 x i64>, <1 x i64> } [[VLD3]], ptr [[__RET]], align 8
// CHECK-NEXT:    [[TMP9:%.*]] = call ptr @__msan_memcpy(ptr [[RETVAL]], ptr [[__RET]], i64 24)
// CHECK-NEXT:    [[TMP10:%.*]] = load [[STRUCT_UINT64X1X3_T]], ptr [[RETVAL]], align 8
// CHECK-NEXT:    store { [3 x <1 x i64>] } zeroinitializer, ptr @__msan_retval_tls, align 8
// CHECK-NEXT:    ret [[STRUCT_UINT64X1X3_T]] [[TMP10]]
//
uint64x1x3_t test_vld3_u64(uint64_t const *a) {
  return vld3_u64(a);
}

// CHECK-LABEL: define dso_local %struct.int8x8x3_t @test_vld3_s8(
// CHECK-SAME: ptr noundef [[A:%.*]]) #[[ATTR0]] {
// CHECK-NEXT:  entry:
// CHECK-NEXT:    call void @llvm.donothing()
// CHECK-NEXT:    [[RETVAL:%.*]] = alloca [[STRUCT_INT8X8X3_T:%.*]], align 8
// CHECK-NEXT:    [[TMP0:%.*]] = ptrtoint ptr [[RETVAL]] to i64
// CHECK-NEXT:    [[TMP1:%.*]] = xor i64 [[TMP0]], 193514046488576
// CHECK-NEXT:    [[TMP2:%.*]] = inttoptr i64 [[TMP1]] to ptr
// CHECK-NEXT:    call void @llvm.memset.p0.i64(ptr align 8 [[TMP2]], i8 0, i64 24, i1 false)
// CHECK-NEXT:    [[__RET:%.*]] = alloca [[STRUCT_INT8X8X3_T]], align 8
// CHECK-NEXT:    [[TMP3:%.*]] = ptrtoint ptr [[__RET]] to i64
// CHECK-NEXT:    [[TMP4:%.*]] = xor i64 [[TMP3]], 193514046488576
// CHECK-NEXT:    [[TMP5:%.*]] = inttoptr i64 [[TMP4]] to ptr
// CHECK-NEXT:    call void @llvm.memset.p0.i64(ptr align 8 [[TMP5]], i8 0, i64 24, i1 false)
// CHECK-NEXT:    [[VLD3:%.*]] = call { <8 x i8>, <8 x i8>, <8 x i8> } @llvm.aarch64.neon.ld3.v8i8.p0(ptr [[A]])
// CHECK-NEXT:    [[TMP6:%.*]] = ptrtoint ptr [[__RET]] to i64
// CHECK-NEXT:    [[TMP7:%.*]] = xor i64 [[TMP6]], 193514046488576
// CHECK-NEXT:    [[TMP8:%.*]] = inttoptr i64 [[TMP7]] to ptr
// CHECK-NEXT:    store { <8 x i8>, <8 x i8>, <8 x i8> } zeroinitializer, ptr [[TMP8]], align 8
// CHECK-NEXT:    store { <8 x i8>, <8 x i8>, <8 x i8> } [[VLD3]], ptr [[__RET]], align 8
// CHECK-NEXT:    [[TMP9:%.*]] = call ptr @__msan_memcpy(ptr [[RETVAL]], ptr [[__RET]], i64 24)
// CHECK-NEXT:    [[TMP10:%.*]] = load [[STRUCT_INT8X8X3_T]], ptr [[RETVAL]], align 8
// CHECK-NEXT:    store { [3 x <8 x i8>] } zeroinitializer, ptr @__msan_retval_tls, align 8
// CHECK-NEXT:    ret [[STRUCT_INT8X8X3_T]] [[TMP10]]
//
int8x8x3_t test_vld3_s8(int8_t const *a) {
  return vld3_s8(a);
}

// CHECK-LABEL: define dso_local %struct.int16x4x3_t @test_vld3_s16(
// CHECK-SAME: ptr noundef [[A:%.*]]) #[[ATTR0]] {
// CHECK-NEXT:  entry:
// CHECK-NEXT:    call void @llvm.donothing()
// CHECK-NEXT:    [[RETVAL:%.*]] = alloca [[STRUCT_INT16X4X3_T:%.*]], align 8
// CHECK-NEXT:    [[TMP0:%.*]] = ptrtoint ptr [[RETVAL]] to i64
// CHECK-NEXT:    [[TMP1:%.*]] = xor i64 [[TMP0]], 193514046488576
// CHECK-NEXT:    [[TMP2:%.*]] = inttoptr i64 [[TMP1]] to ptr
// CHECK-NEXT:    call void @llvm.memset.p0.i64(ptr align 8 [[TMP2]], i8 0, i64 24, i1 false)
// CHECK-NEXT:    [[__RET:%.*]] = alloca [[STRUCT_INT16X4X3_T]], align 8
// CHECK-NEXT:    [[TMP3:%.*]] = ptrtoint ptr [[__RET]] to i64
// CHECK-NEXT:    [[TMP4:%.*]] = xor i64 [[TMP3]], 193514046488576
// CHECK-NEXT:    [[TMP5:%.*]] = inttoptr i64 [[TMP4]] to ptr
// CHECK-NEXT:    call void @llvm.memset.p0.i64(ptr align 8 [[TMP5]], i8 0, i64 24, i1 false)
// CHECK-NEXT:    [[VLD3:%.*]] = call { <4 x i16>, <4 x i16>, <4 x i16> } @llvm.aarch64.neon.ld3.v4i16.p0(ptr [[A]])
// CHECK-NEXT:    [[TMP6:%.*]] = ptrtoint ptr [[__RET]] to i64
// CHECK-NEXT:    [[TMP7:%.*]] = xor i64 [[TMP6]], 193514046488576
// CHECK-NEXT:    [[TMP8:%.*]] = inttoptr i64 [[TMP7]] to ptr
// CHECK-NEXT:    store { <4 x i16>, <4 x i16>, <4 x i16> } zeroinitializer, ptr [[TMP8]], align 8
// CHECK-NEXT:    store { <4 x i16>, <4 x i16>, <4 x i16> } [[VLD3]], ptr [[__RET]], align 8
// CHECK-NEXT:    [[TMP9:%.*]] = call ptr @__msan_memcpy(ptr [[RETVAL]], ptr [[__RET]], i64 24)
// CHECK-NEXT:    [[TMP10:%.*]] = load [[STRUCT_INT16X4X3_T]], ptr [[RETVAL]], align 8
// CHECK-NEXT:    store { [3 x <4 x i16>] } zeroinitializer, ptr @__msan_retval_tls, align 8
// CHECK-NEXT:    ret [[STRUCT_INT16X4X3_T]] [[TMP10]]
//
int16x4x3_t test_vld3_s16(int16_t const *a) {
  return vld3_s16(a);
}

// CHECK-LABEL: define dso_local %struct.int32x2x3_t @test_vld3_s32(
// CHECK-SAME: ptr noundef [[A:%.*]]) #[[ATTR0]] {
// CHECK-NEXT:  entry:
// CHECK-NEXT:    call void @llvm.donothing()
// CHECK-NEXT:    [[RETVAL:%.*]] = alloca [[STRUCT_INT32X2X3_T:%.*]], align 8
// CHECK-NEXT:    [[TMP0:%.*]] = ptrtoint ptr [[RETVAL]] to i64
// CHECK-NEXT:    [[TMP1:%.*]] = xor i64 [[TMP0]], 193514046488576
// CHECK-NEXT:    [[TMP2:%.*]] = inttoptr i64 [[TMP1]] to ptr
// CHECK-NEXT:    call void @llvm.memset.p0.i64(ptr align 8 [[TMP2]], i8 0, i64 24, i1 false)
// CHECK-NEXT:    [[__RET:%.*]] = alloca [[STRUCT_INT32X2X3_T]], align 8
// CHECK-NEXT:    [[TMP3:%.*]] = ptrtoint ptr [[__RET]] to i64
// CHECK-NEXT:    [[TMP4:%.*]] = xor i64 [[TMP3]], 193514046488576
// CHECK-NEXT:    [[TMP5:%.*]] = inttoptr i64 [[TMP4]] to ptr
// CHECK-NEXT:    call void @llvm.memset.p0.i64(ptr align 8 [[TMP5]], i8 0, i64 24, i1 false)
// CHECK-NEXT:    [[VLD3:%.*]] = call { <2 x i32>, <2 x i32>, <2 x i32> } @llvm.aarch64.neon.ld3.v2i32.p0(ptr [[A]])
// CHECK-NEXT:    [[TMP6:%.*]] = ptrtoint ptr [[__RET]] to i64
// CHECK-NEXT:    [[TMP7:%.*]] = xor i64 [[TMP6]], 193514046488576
// CHECK-NEXT:    [[TMP8:%.*]] = inttoptr i64 [[TMP7]] to ptr
// CHECK-NEXT:    store { <2 x i32>, <2 x i32>, <2 x i32> } zeroinitializer, ptr [[TMP8]], align 8
// CHECK-NEXT:    store { <2 x i32>, <2 x i32>, <2 x i32> } [[VLD3]], ptr [[__RET]], align 8
// CHECK-NEXT:    [[TMP9:%.*]] = call ptr @__msan_memcpy(ptr [[RETVAL]], ptr [[__RET]], i64 24)
// CHECK-NEXT:    [[TMP10:%.*]] = load [[STRUCT_INT32X2X3_T]], ptr [[RETVAL]], align 8
// CHECK-NEXT:    store { [3 x <2 x i32>] } zeroinitializer, ptr @__msan_retval_tls, align 8
// CHECK-NEXT:    ret [[STRUCT_INT32X2X3_T]] [[TMP10]]
//
int32x2x3_t test_vld3_s32(int32_t const *a) {
  return vld3_s32(a);
}

// CHECK-LABEL: define dso_local %struct.int64x1x3_t @test_vld3_s64(
// CHECK-SAME: ptr noundef [[A:%.*]]) #[[ATTR0]] {
// CHECK-NEXT:  entry:
// CHECK-NEXT:    call void @llvm.donothing()
// CHECK-NEXT:    [[RETVAL:%.*]] = alloca [[STRUCT_INT64X1X3_T:%.*]], align 8
// CHECK-NEXT:    [[TMP0:%.*]] = ptrtoint ptr [[RETVAL]] to i64
// CHECK-NEXT:    [[TMP1:%.*]] = xor i64 [[TMP0]], 193514046488576
// CHECK-NEXT:    [[TMP2:%.*]] = inttoptr i64 [[TMP1]] to ptr
// CHECK-NEXT:    call void @llvm.memset.p0.i64(ptr align 8 [[TMP2]], i8 0, i64 24, i1 false)
// CHECK-NEXT:    [[__RET:%.*]] = alloca [[STRUCT_INT64X1X3_T]], align 8
// CHECK-NEXT:    [[TMP3:%.*]] = ptrtoint ptr [[__RET]] to i64
// CHECK-NEXT:    [[TMP4:%.*]] = xor i64 [[TMP3]], 193514046488576
// CHECK-NEXT:    [[TMP5:%.*]] = inttoptr i64 [[TMP4]] to ptr
// CHECK-NEXT:    call void @llvm.memset.p0.i64(ptr align 8 [[TMP5]], i8 0, i64 24, i1 false)
// CHECK-NEXT:    [[VLD3:%.*]] = call { <1 x i64>, <1 x i64>, <1 x i64> } @llvm.aarch64.neon.ld3.v1i64.p0(ptr [[A]])
// CHECK-NEXT:    [[TMP6:%.*]] = ptrtoint ptr [[__RET]] to i64
// CHECK-NEXT:    [[TMP7:%.*]] = xor i64 [[TMP6]], 193514046488576
// CHECK-NEXT:    [[TMP8:%.*]] = inttoptr i64 [[TMP7]] to ptr
// CHECK-NEXT:    store { <1 x i64>, <1 x i64>, <1 x i64> } zeroinitializer, ptr [[TMP8]], align 8
// CHECK-NEXT:    store { <1 x i64>, <1 x i64>, <1 x i64> } [[VLD3]], ptr [[__RET]], align 8
// CHECK-NEXT:    [[TMP9:%.*]] = call ptr @__msan_memcpy(ptr [[RETVAL]], ptr [[__RET]], i64 24)
// CHECK-NEXT:    [[TMP10:%.*]] = load [[STRUCT_INT64X1X3_T]], ptr [[RETVAL]], align 8
// CHECK-NEXT:    store { [3 x <1 x i64>] } zeroinitializer, ptr @__msan_retval_tls, align 8
// CHECK-NEXT:    ret [[STRUCT_INT64X1X3_T]] [[TMP10]]
//
int64x1x3_t test_vld3_s64(int64_t const *a) {
  return vld3_s64(a);
}

// CHECK-LABEL: define dso_local %struct.float16x4x3_t @test_vld3_f16(
// CHECK-SAME: ptr noundef [[A:%.*]]) #[[ATTR0]] {
// CHECK-NEXT:  entry:
// CHECK-NEXT:    call void @llvm.donothing()
// CHECK-NEXT:    [[RETVAL:%.*]] = alloca [[STRUCT_FLOAT16X4X3_T:%.*]], align 8
// CHECK-NEXT:    [[TMP0:%.*]] = ptrtoint ptr [[RETVAL]] to i64
// CHECK-NEXT:    [[TMP1:%.*]] = xor i64 [[TMP0]], 193514046488576
// CHECK-NEXT:    [[TMP2:%.*]] = inttoptr i64 [[TMP1]] to ptr
// CHECK-NEXT:    call void @llvm.memset.p0.i64(ptr align 8 [[TMP2]], i8 0, i64 24, i1 false)
// CHECK-NEXT:    [[__RET:%.*]] = alloca [[STRUCT_FLOAT16X4X3_T]], align 8
// CHECK-NEXT:    [[TMP3:%.*]] = ptrtoint ptr [[__RET]] to i64
// CHECK-NEXT:    [[TMP4:%.*]] = xor i64 [[TMP3]], 193514046488576
// CHECK-NEXT:    [[TMP5:%.*]] = inttoptr i64 [[TMP4]] to ptr
// CHECK-NEXT:    call void @llvm.memset.p0.i64(ptr align 8 [[TMP5]], i8 0, i64 24, i1 false)
// CHECK-NEXT:    [[VLD3:%.*]] = call { <4 x half>, <4 x half>, <4 x half> } @llvm.aarch64.neon.ld3.v4f16.p0(ptr [[A]])
// CHECK-NEXT:    [[TMP6:%.*]] = ptrtoint ptr [[__RET]] to i64
// CHECK-NEXT:    [[TMP7:%.*]] = xor i64 [[TMP6]], 193514046488576
// CHECK-NEXT:    [[TMP8:%.*]] = inttoptr i64 [[TMP7]] to ptr
// CHECK-NEXT:    store { <4 x i16>, <4 x i16>, <4 x i16> } zeroinitializer, ptr [[TMP8]], align 8
// CHECK-NEXT:    store { <4 x half>, <4 x half>, <4 x half> } [[VLD3]], ptr [[__RET]], align 8
// CHECK-NEXT:    [[TMP9:%.*]] = call ptr @__msan_memcpy(ptr [[RETVAL]], ptr [[__RET]], i64 24)
// CHECK-NEXT:    [[TMP10:%.*]] = load [[STRUCT_FLOAT16X4X3_T]], ptr [[RETVAL]], align 8
// CHECK-NEXT:    store { [3 x <4 x i16>] } zeroinitializer, ptr @__msan_retval_tls, align 8
// CHECK-NEXT:    ret [[STRUCT_FLOAT16X4X3_T]] [[TMP10]]
//
float16x4x3_t test_vld3_f16(float16_t const *a) {
  return vld3_f16(a);
}

// CHECK-LABEL: define dso_local %struct.float32x2x3_t @test_vld3_f32(
// CHECK-SAME: ptr noundef [[A:%.*]]) #[[ATTR0]] {
// CHECK-NEXT:  entry:
// CHECK-NEXT:    call void @llvm.donothing()
// CHECK-NEXT:    [[RETVAL:%.*]] = alloca [[STRUCT_FLOAT32X2X3_T:%.*]], align 8
// CHECK-NEXT:    [[TMP0:%.*]] = ptrtoint ptr [[RETVAL]] to i64
// CHECK-NEXT:    [[TMP1:%.*]] = xor i64 [[TMP0]], 193514046488576
// CHECK-NEXT:    [[TMP2:%.*]] = inttoptr i64 [[TMP1]] to ptr
// CHECK-NEXT:    call void @llvm.memset.p0.i64(ptr align 8 [[TMP2]], i8 0, i64 24, i1 false)
// CHECK-NEXT:    [[__RET:%.*]] = alloca [[STRUCT_FLOAT32X2X3_T]], align 8
// CHECK-NEXT:    [[TMP3:%.*]] = ptrtoint ptr [[__RET]] to i64
// CHECK-NEXT:    [[TMP4:%.*]] = xor i64 [[TMP3]], 193514046488576
// CHECK-NEXT:    [[TMP5:%.*]] = inttoptr i64 [[TMP4]] to ptr
// CHECK-NEXT:    call void @llvm.memset.p0.i64(ptr align 8 [[TMP5]], i8 0, i64 24, i1 false)
// CHECK-NEXT:    [[VLD3:%.*]] = call { <2 x float>, <2 x float>, <2 x float> } @llvm.aarch64.neon.ld3.v2f32.p0(ptr [[A]])
// CHECK-NEXT:    [[TMP6:%.*]] = ptrtoint ptr [[__RET]] to i64
// CHECK-NEXT:    [[TMP7:%.*]] = xor i64 [[TMP6]], 193514046488576
// CHECK-NEXT:    [[TMP8:%.*]] = inttoptr i64 [[TMP7]] to ptr
// CHECK-NEXT:    store { <2 x i32>, <2 x i32>, <2 x i32> } zeroinitializer, ptr [[TMP8]], align 8
// CHECK-NEXT:    store { <2 x float>, <2 x float>, <2 x float> } [[VLD3]], ptr [[__RET]], align 8
// CHECK-NEXT:    [[TMP9:%.*]] = call ptr @__msan_memcpy(ptr [[RETVAL]], ptr [[__RET]], i64 24)
// CHECK-NEXT:    [[TMP10:%.*]] = load [[STRUCT_FLOAT32X2X3_T]], ptr [[RETVAL]], align 8
// CHECK-NEXT:    store { [3 x <2 x i32>] } zeroinitializer, ptr @__msan_retval_tls, align 8
// CHECK-NEXT:    ret [[STRUCT_FLOAT32X2X3_T]] [[TMP10]]
//
float32x2x3_t test_vld3_f32(float32_t const *a) {
  return vld3_f32(a);
}

// CHECK-LABEL: define dso_local %struct.float64x1x3_t @test_vld3_f64(
// CHECK-SAME: ptr noundef [[A:%.*]]) #[[ATTR0]] {
// CHECK-NEXT:  entry:
// CHECK-NEXT:    call void @llvm.donothing()
// CHECK-NEXT:    [[RETVAL:%.*]] = alloca [[STRUCT_FLOAT64X1X3_T:%.*]], align 8
// CHECK-NEXT:    [[TMP0:%.*]] = ptrtoint ptr [[RETVAL]] to i64
// CHECK-NEXT:    [[TMP1:%.*]] = xor i64 [[TMP0]], 193514046488576
// CHECK-NEXT:    [[TMP2:%.*]] = inttoptr i64 [[TMP1]] to ptr
// CHECK-NEXT:    call void @llvm.memset.p0.i64(ptr align 8 [[TMP2]], i8 0, i64 24, i1 false)
// CHECK-NEXT:    [[__RET:%.*]] = alloca [[STRUCT_FLOAT64X1X3_T]], align 8
// CHECK-NEXT:    [[TMP3:%.*]] = ptrtoint ptr [[__RET]] to i64
// CHECK-NEXT:    [[TMP4:%.*]] = xor i64 [[TMP3]], 193514046488576
// CHECK-NEXT:    [[TMP5:%.*]] = inttoptr i64 [[TMP4]] to ptr
// CHECK-NEXT:    call void @llvm.memset.p0.i64(ptr align 8 [[TMP5]], i8 0, i64 24, i1 false)
// CHECK-NEXT:    [[VLD3:%.*]] = call { <1 x double>, <1 x double>, <1 x double> } @llvm.aarch64.neon.ld3.v1f64.p0(ptr [[A]])
// CHECK-NEXT:    [[TMP6:%.*]] = ptrtoint ptr [[__RET]] to i64
// CHECK-NEXT:    [[TMP7:%.*]] = xor i64 [[TMP6]], 193514046488576
// CHECK-NEXT:    [[TMP8:%.*]] = inttoptr i64 [[TMP7]] to ptr
// CHECK-NEXT:    store { <1 x i64>, <1 x i64>, <1 x i64> } zeroinitializer, ptr [[TMP8]], align 8
// CHECK-NEXT:    store { <1 x double>, <1 x double>, <1 x double> } [[VLD3]], ptr [[__RET]], align 8
// CHECK-NEXT:    [[TMP9:%.*]] = call ptr @__msan_memcpy(ptr [[RETVAL]], ptr [[__RET]], i64 24)
// CHECK-NEXT:    [[TMP10:%.*]] = load [[STRUCT_FLOAT64X1X3_T]], ptr [[RETVAL]], align 8
// CHECK-NEXT:    store { [3 x <1 x i64>] } zeroinitializer, ptr @__msan_retval_tls, align 8
// CHECK-NEXT:    ret [[STRUCT_FLOAT64X1X3_T]] [[TMP10]]
//
float64x1x3_t test_vld3_f64(float64_t const *a) {
  return vld3_f64(a);
}

// CHECK-LABEL: define dso_local %struct.poly8x8x3_t @test_vld3_p8(
// CHECK-SAME: ptr noundef [[A:%.*]]) #[[ATTR0]] {
// CHECK-NEXT:  entry:
// CHECK-NEXT:    call void @llvm.donothing()
// CHECK-NEXT:    [[RETVAL:%.*]] = alloca [[STRUCT_POLY8X8X3_T:%.*]], align 8
// CHECK-NEXT:    [[TMP0:%.*]] = ptrtoint ptr [[RETVAL]] to i64
// CHECK-NEXT:    [[TMP1:%.*]] = xor i64 [[TMP0]], 193514046488576
// CHECK-NEXT:    [[TMP2:%.*]] = inttoptr i64 [[TMP1]] to ptr
// CHECK-NEXT:    call void @llvm.memset.p0.i64(ptr align 8 [[TMP2]], i8 0, i64 24, i1 false)
// CHECK-NEXT:    [[__RET:%.*]] = alloca [[STRUCT_POLY8X8X3_T]], align 8
// CHECK-NEXT:    [[TMP3:%.*]] = ptrtoint ptr [[__RET]] to i64
// CHECK-NEXT:    [[TMP4:%.*]] = xor i64 [[TMP3]], 193514046488576
// CHECK-NEXT:    [[TMP5:%.*]] = inttoptr i64 [[TMP4]] to ptr
// CHECK-NEXT:    call void @llvm.memset.p0.i64(ptr align 8 [[TMP5]], i8 0, i64 24, i1 false)
// CHECK-NEXT:    [[VLD3:%.*]] = call { <8 x i8>, <8 x i8>, <8 x i8> } @llvm.aarch64.neon.ld3.v8i8.p0(ptr [[A]])
// CHECK-NEXT:    [[TMP6:%.*]] = ptrtoint ptr [[__RET]] to i64
// CHECK-NEXT:    [[TMP7:%.*]] = xor i64 [[TMP6]], 193514046488576
// CHECK-NEXT:    [[TMP8:%.*]] = inttoptr i64 [[TMP7]] to ptr
// CHECK-NEXT:    store { <8 x i8>, <8 x i8>, <8 x i8> } zeroinitializer, ptr [[TMP8]], align 8
// CHECK-NEXT:    store { <8 x i8>, <8 x i8>, <8 x i8> } [[VLD3]], ptr [[__RET]], align 8
// CHECK-NEXT:    [[TMP9:%.*]] = call ptr @__msan_memcpy(ptr [[RETVAL]], ptr [[__RET]], i64 24)
// CHECK-NEXT:    [[TMP10:%.*]] = load [[STRUCT_POLY8X8X3_T]], ptr [[RETVAL]], align 8
// CHECK-NEXT:    store { [3 x <8 x i8>] } zeroinitializer, ptr @__msan_retval_tls, align 8
// CHECK-NEXT:    ret [[STRUCT_POLY8X8X3_T]] [[TMP10]]
//
poly8x8x3_t test_vld3_p8(poly8_t const *a) {
  return vld3_p8(a);
}

// CHECK-LABEL: define dso_local %struct.poly16x4x3_t @test_vld3_p16(
// CHECK-SAME: ptr noundef [[A:%.*]]) #[[ATTR0]] {
// CHECK-NEXT:  entry:
// CHECK-NEXT:    call void @llvm.donothing()
// CHECK-NEXT:    [[RETVAL:%.*]] = alloca [[STRUCT_POLY16X4X3_T:%.*]], align 8
// CHECK-NEXT:    [[TMP0:%.*]] = ptrtoint ptr [[RETVAL]] to i64
// CHECK-NEXT:    [[TMP1:%.*]] = xor i64 [[TMP0]], 193514046488576
// CHECK-NEXT:    [[TMP2:%.*]] = inttoptr i64 [[TMP1]] to ptr
// CHECK-NEXT:    call void @llvm.memset.p0.i64(ptr align 8 [[TMP2]], i8 0, i64 24, i1 false)
// CHECK-NEXT:    [[__RET:%.*]] = alloca [[STRUCT_POLY16X4X3_T]], align 8
// CHECK-NEXT:    [[TMP3:%.*]] = ptrtoint ptr [[__RET]] to i64
// CHECK-NEXT:    [[TMP4:%.*]] = xor i64 [[TMP3]], 193514046488576
// CHECK-NEXT:    [[TMP5:%.*]] = inttoptr i64 [[TMP4]] to ptr
// CHECK-NEXT:    call void @llvm.memset.p0.i64(ptr align 8 [[TMP5]], i8 0, i64 24, i1 false)
// CHECK-NEXT:    [[VLD3:%.*]] = call { <4 x i16>, <4 x i16>, <4 x i16> } @llvm.aarch64.neon.ld3.v4i16.p0(ptr [[A]])
// CHECK-NEXT:    [[TMP6:%.*]] = ptrtoint ptr [[__RET]] to i64
// CHECK-NEXT:    [[TMP7:%.*]] = xor i64 [[TMP6]], 193514046488576
// CHECK-NEXT:    [[TMP8:%.*]] = inttoptr i64 [[TMP7]] to ptr
// CHECK-NEXT:    store { <4 x i16>, <4 x i16>, <4 x i16> } zeroinitializer, ptr [[TMP8]], align 8
// CHECK-NEXT:    store { <4 x i16>, <4 x i16>, <4 x i16> } [[VLD3]], ptr [[__RET]], align 8
// CHECK-NEXT:    [[TMP9:%.*]] = call ptr @__msan_memcpy(ptr [[RETVAL]], ptr [[__RET]], i64 24)
// CHECK-NEXT:    [[TMP10:%.*]] = load [[STRUCT_POLY16X4X3_T]], ptr [[RETVAL]], align 8
// CHECK-NEXT:    store { [3 x <4 x i16>] } zeroinitializer, ptr @__msan_retval_tls, align 8
// CHECK-NEXT:    ret [[STRUCT_POLY16X4X3_T]] [[TMP10]]
//
poly16x4x3_t test_vld3_p16(poly16_t const *a) {
  return vld3_p16(a);
}

// CHECK-LABEL: define dso_local %struct.uint8x16x4_t @test_vld4q_u8(
// CHECK-SAME: ptr noundef [[A:%.*]]) #[[ATTR0]] {
// CHECK-NEXT:  entry:
// CHECK-NEXT:    call void @llvm.donothing()
// CHECK-NEXT:    [[RETVAL:%.*]] = alloca [[STRUCT_UINT8X16X4_T:%.*]], align 16
// CHECK-NEXT:    [[TMP0:%.*]] = ptrtoint ptr [[RETVAL]] to i64
// CHECK-NEXT:    [[TMP1:%.*]] = xor i64 [[TMP0]], 193514046488576
// CHECK-NEXT:    [[TMP2:%.*]] = inttoptr i64 [[TMP1]] to ptr
// CHECK-NEXT:    call void @llvm.memset.p0.i64(ptr align 16 [[TMP2]], i8 0, i64 64, i1 false)
// CHECK-NEXT:    [[__RET:%.*]] = alloca [[STRUCT_UINT8X16X4_T]], align 16
// CHECK-NEXT:    [[TMP3:%.*]] = ptrtoint ptr [[__RET]] to i64
// CHECK-NEXT:    [[TMP4:%.*]] = xor i64 [[TMP3]], 193514046488576
// CHECK-NEXT:    [[TMP5:%.*]] = inttoptr i64 [[TMP4]] to ptr
// CHECK-NEXT:    call void @llvm.memset.p0.i64(ptr align 16 [[TMP5]], i8 0, i64 64, i1 false)
// CHECK-NEXT:    [[VLD4:%.*]] = call { <16 x i8>, <16 x i8>, <16 x i8>, <16 x i8> } @llvm.aarch64.neon.ld4.v16i8.p0(ptr [[A]])
// CHECK-NEXT:    [[TMP6:%.*]] = ptrtoint ptr [[__RET]] to i64
// CHECK-NEXT:    [[TMP7:%.*]] = xor i64 [[TMP6]], 193514046488576
// CHECK-NEXT:    [[TMP8:%.*]] = inttoptr i64 [[TMP7]] to ptr
// CHECK-NEXT:    store { <16 x i8>, <16 x i8>, <16 x i8>, <16 x i8> } zeroinitializer, ptr [[TMP8]], align 16
// CHECK-NEXT:    store { <16 x i8>, <16 x i8>, <16 x i8>, <16 x i8> } [[VLD4]], ptr [[__RET]], align 16
// CHECK-NEXT:    [[TMP9:%.*]] = call ptr @__msan_memcpy(ptr [[RETVAL]], ptr [[__RET]], i64 64)
// CHECK-NEXT:    [[TMP10:%.*]] = load [[STRUCT_UINT8X16X4_T]], ptr [[RETVAL]], align 16
// CHECK-NEXT:    store { [4 x <16 x i8>] } zeroinitializer, ptr @__msan_retval_tls, align 8
// CHECK-NEXT:    ret [[STRUCT_UINT8X16X4_T]] [[TMP10]]
//
uint8x16x4_t test_vld4q_u8(uint8_t const *a) {
  return vld4q_u8(a);
}

// CHECK-LABEL: define dso_local %struct.uint16x8x4_t @test_vld4q_u16(
// CHECK-SAME: ptr noundef [[A:%.*]]) #[[ATTR0]] {
// CHECK-NEXT:  entry:
// CHECK-NEXT:    call void @llvm.donothing()
// CHECK-NEXT:    [[RETVAL:%.*]] = alloca [[STRUCT_UINT16X8X4_T:%.*]], align 16
// CHECK-NEXT:    [[TMP0:%.*]] = ptrtoint ptr [[RETVAL]] to i64
// CHECK-NEXT:    [[TMP1:%.*]] = xor i64 [[TMP0]], 193514046488576
// CHECK-NEXT:    [[TMP2:%.*]] = inttoptr i64 [[TMP1]] to ptr
// CHECK-NEXT:    call void @llvm.memset.p0.i64(ptr align 16 [[TMP2]], i8 0, i64 64, i1 false)
// CHECK-NEXT:    [[__RET:%.*]] = alloca [[STRUCT_UINT16X8X4_T]], align 16
// CHECK-NEXT:    [[TMP3:%.*]] = ptrtoint ptr [[__RET]] to i64
// CHECK-NEXT:    [[TMP4:%.*]] = xor i64 [[TMP3]], 193514046488576
// CHECK-NEXT:    [[TMP5:%.*]] = inttoptr i64 [[TMP4]] to ptr
// CHECK-NEXT:    call void @llvm.memset.p0.i64(ptr align 16 [[TMP5]], i8 0, i64 64, i1 false)
// CHECK-NEXT:    [[VLD4:%.*]] = call { <8 x i16>, <8 x i16>, <8 x i16>, <8 x i16> } @llvm.aarch64.neon.ld4.v8i16.p0(ptr [[A]])
// CHECK-NEXT:    [[TMP6:%.*]] = ptrtoint ptr [[__RET]] to i64
// CHECK-NEXT:    [[TMP7:%.*]] = xor i64 [[TMP6]], 193514046488576
// CHECK-NEXT:    [[TMP8:%.*]] = inttoptr i64 [[TMP7]] to ptr
// CHECK-NEXT:    store { <8 x i16>, <8 x i16>, <8 x i16>, <8 x i16> } zeroinitializer, ptr [[TMP8]], align 16
// CHECK-NEXT:    store { <8 x i16>, <8 x i16>, <8 x i16>, <8 x i16> } [[VLD4]], ptr [[__RET]], align 16
// CHECK-NEXT:    [[TMP9:%.*]] = call ptr @__msan_memcpy(ptr [[RETVAL]], ptr [[__RET]], i64 64)
// CHECK-NEXT:    [[TMP10:%.*]] = load [[STRUCT_UINT16X8X4_T]], ptr [[RETVAL]], align 16
// CHECK-NEXT:    store { [4 x <8 x i16>] } zeroinitializer, ptr @__msan_retval_tls, align 8
// CHECK-NEXT:    ret [[STRUCT_UINT16X8X4_T]] [[TMP10]]
//
uint16x8x4_t test_vld4q_u16(uint16_t const *a) {
  return vld4q_u16(a);
}

// CHECK-LABEL: define dso_local %struct.uint32x4x4_t @test_vld4q_u32(
// CHECK-SAME: ptr noundef [[A:%.*]]) #[[ATTR0]] {
// CHECK-NEXT:  entry:
// CHECK-NEXT:    call void @llvm.donothing()
// CHECK-NEXT:    [[RETVAL:%.*]] = alloca [[STRUCT_UINT32X4X4_T:%.*]], align 16
// CHECK-NEXT:    [[TMP0:%.*]] = ptrtoint ptr [[RETVAL]] to i64
// CHECK-NEXT:    [[TMP1:%.*]] = xor i64 [[TMP0]], 193514046488576
// CHECK-NEXT:    [[TMP2:%.*]] = inttoptr i64 [[TMP1]] to ptr
// CHECK-NEXT:    call void @llvm.memset.p0.i64(ptr align 16 [[TMP2]], i8 0, i64 64, i1 false)
// CHECK-NEXT:    [[__RET:%.*]] = alloca [[STRUCT_UINT32X4X4_T]], align 16
// CHECK-NEXT:    [[TMP3:%.*]] = ptrtoint ptr [[__RET]] to i64
// CHECK-NEXT:    [[TMP4:%.*]] = xor i64 [[TMP3]], 193514046488576
// CHECK-NEXT:    [[TMP5:%.*]] = inttoptr i64 [[TMP4]] to ptr
// CHECK-NEXT:    call void @llvm.memset.p0.i64(ptr align 16 [[TMP5]], i8 0, i64 64, i1 false)
// CHECK-NEXT:    [[VLD4:%.*]] = call { <4 x i32>, <4 x i32>, <4 x i32>, <4 x i32> } @llvm.aarch64.neon.ld4.v4i32.p0(ptr [[A]])
// CHECK-NEXT:    [[TMP6:%.*]] = ptrtoint ptr [[__RET]] to i64
// CHECK-NEXT:    [[TMP7:%.*]] = xor i64 [[TMP6]], 193514046488576
// CHECK-NEXT:    [[TMP8:%.*]] = inttoptr i64 [[TMP7]] to ptr
// CHECK-NEXT:    store { <4 x i32>, <4 x i32>, <4 x i32>, <4 x i32> } zeroinitializer, ptr [[TMP8]], align 16
// CHECK-NEXT:    store { <4 x i32>, <4 x i32>, <4 x i32>, <4 x i32> } [[VLD4]], ptr [[__RET]], align 16
// CHECK-NEXT:    [[TMP9:%.*]] = call ptr @__msan_memcpy(ptr [[RETVAL]], ptr [[__RET]], i64 64)
// CHECK-NEXT:    [[TMP10:%.*]] = load [[STRUCT_UINT32X4X4_T]], ptr [[RETVAL]], align 16
// CHECK-NEXT:    store { [4 x <4 x i32>] } zeroinitializer, ptr @__msan_retval_tls, align 8
// CHECK-NEXT:    ret [[STRUCT_UINT32X4X4_T]] [[TMP10]]
//
uint32x4x4_t test_vld4q_u32(uint32_t const *a) {
  return vld4q_u32(a);
}

// CHECK-LABEL: define dso_local %struct.uint64x2x4_t @test_vld4q_u64(
// CHECK-SAME: ptr noundef [[A:%.*]]) #[[ATTR0]] {
// CHECK-NEXT:  entry:
// CHECK-NEXT:    call void @llvm.donothing()
// CHECK-NEXT:    [[RETVAL:%.*]] = alloca [[STRUCT_UINT64X2X4_T:%.*]], align 16
// CHECK-NEXT:    [[TMP0:%.*]] = ptrtoint ptr [[RETVAL]] to i64
// CHECK-NEXT:    [[TMP1:%.*]] = xor i64 [[TMP0]], 193514046488576
// CHECK-NEXT:    [[TMP2:%.*]] = inttoptr i64 [[TMP1]] to ptr
// CHECK-NEXT:    call void @llvm.memset.p0.i64(ptr align 16 [[TMP2]], i8 0, i64 64, i1 false)
// CHECK-NEXT:    [[__RET:%.*]] = alloca [[STRUCT_UINT64X2X4_T]], align 16
// CHECK-NEXT:    [[TMP3:%.*]] = ptrtoint ptr [[__RET]] to i64
// CHECK-NEXT:    [[TMP4:%.*]] = xor i64 [[TMP3]], 193514046488576
// CHECK-NEXT:    [[TMP5:%.*]] = inttoptr i64 [[TMP4]] to ptr
// CHECK-NEXT:    call void @llvm.memset.p0.i64(ptr align 16 [[TMP5]], i8 0, i64 64, i1 false)
// CHECK-NEXT:    [[VLD4:%.*]] = call { <2 x i64>, <2 x i64>, <2 x i64>, <2 x i64> } @llvm.aarch64.neon.ld4.v2i64.p0(ptr [[A]])
// CHECK-NEXT:    [[TMP6:%.*]] = ptrtoint ptr [[__RET]] to i64
// CHECK-NEXT:    [[TMP7:%.*]] = xor i64 [[TMP6]], 193514046488576
// CHECK-NEXT:    [[TMP8:%.*]] = inttoptr i64 [[TMP7]] to ptr
// CHECK-NEXT:    store { <2 x i64>, <2 x i64>, <2 x i64>, <2 x i64> } zeroinitializer, ptr [[TMP8]], align 16
// CHECK-NEXT:    store { <2 x i64>, <2 x i64>, <2 x i64>, <2 x i64> } [[VLD4]], ptr [[__RET]], align 16
// CHECK-NEXT:    [[TMP9:%.*]] = call ptr @__msan_memcpy(ptr [[RETVAL]], ptr [[__RET]], i64 64)
// CHECK-NEXT:    [[TMP10:%.*]] = load [[STRUCT_UINT64X2X4_T]], ptr [[RETVAL]], align 16
// CHECK-NEXT:    store { [4 x <2 x i64>] } zeroinitializer, ptr @__msan_retval_tls, align 8
// CHECK-NEXT:    ret [[STRUCT_UINT64X2X4_T]] [[TMP10]]
//
uint64x2x4_t test_vld4q_u64(uint64_t const *a) {
  return vld4q_u64(a);
}

// CHECK-LABEL: define dso_local %struct.int8x16x4_t @test_vld4q_s8(
// CHECK-SAME: ptr noundef [[A:%.*]]) #[[ATTR0]] {
// CHECK-NEXT:  entry:
// CHECK-NEXT:    call void @llvm.donothing()
// CHECK-NEXT:    [[RETVAL:%.*]] = alloca [[STRUCT_INT8X16X4_T:%.*]], align 16
// CHECK-NEXT:    [[TMP0:%.*]] = ptrtoint ptr [[RETVAL]] to i64
// CHECK-NEXT:    [[TMP1:%.*]] = xor i64 [[TMP0]], 193514046488576
// CHECK-NEXT:    [[TMP2:%.*]] = inttoptr i64 [[TMP1]] to ptr
// CHECK-NEXT:    call void @llvm.memset.p0.i64(ptr align 16 [[TMP2]], i8 0, i64 64, i1 false)
// CHECK-NEXT:    [[__RET:%.*]] = alloca [[STRUCT_INT8X16X4_T]], align 16
// CHECK-NEXT:    [[TMP3:%.*]] = ptrtoint ptr [[__RET]] to i64
// CHECK-NEXT:    [[TMP4:%.*]] = xor i64 [[TMP3]], 193514046488576
// CHECK-NEXT:    [[TMP5:%.*]] = inttoptr i64 [[TMP4]] to ptr
// CHECK-NEXT:    call void @llvm.memset.p0.i64(ptr align 16 [[TMP5]], i8 0, i64 64, i1 false)
// CHECK-NEXT:    [[VLD4:%.*]] = call { <16 x i8>, <16 x i8>, <16 x i8>, <16 x i8> } @llvm.aarch64.neon.ld4.v16i8.p0(ptr [[A]])
// CHECK-NEXT:    [[TMP6:%.*]] = ptrtoint ptr [[__RET]] to i64
// CHECK-NEXT:    [[TMP7:%.*]] = xor i64 [[TMP6]], 193514046488576
// CHECK-NEXT:    [[TMP8:%.*]] = inttoptr i64 [[TMP7]] to ptr
// CHECK-NEXT:    store { <16 x i8>, <16 x i8>, <16 x i8>, <16 x i8> } zeroinitializer, ptr [[TMP8]], align 16
// CHECK-NEXT:    store { <16 x i8>, <16 x i8>, <16 x i8>, <16 x i8> } [[VLD4]], ptr [[__RET]], align 16
// CHECK-NEXT:    [[TMP9:%.*]] = call ptr @__msan_memcpy(ptr [[RETVAL]], ptr [[__RET]], i64 64)
// CHECK-NEXT:    [[TMP10:%.*]] = load [[STRUCT_INT8X16X4_T]], ptr [[RETVAL]], align 16
// CHECK-NEXT:    store { [4 x <16 x i8>] } zeroinitializer, ptr @__msan_retval_tls, align 8
// CHECK-NEXT:    ret [[STRUCT_INT8X16X4_T]] [[TMP10]]
//
int8x16x4_t test_vld4q_s8(int8_t const *a) {
  return vld4q_s8(a);
}

// CHECK-LABEL: define dso_local %struct.int16x8x4_t @test_vld4q_s16(
// CHECK-SAME: ptr noundef [[A:%.*]]) #[[ATTR0]] {
// CHECK-NEXT:  entry:
// CHECK-NEXT:    call void @llvm.donothing()
// CHECK-NEXT:    [[RETVAL:%.*]] = alloca [[STRUCT_INT16X8X4_T:%.*]], align 16
// CHECK-NEXT:    [[TMP0:%.*]] = ptrtoint ptr [[RETVAL]] to i64
// CHECK-NEXT:    [[TMP1:%.*]] = xor i64 [[TMP0]], 193514046488576
// CHECK-NEXT:    [[TMP2:%.*]] = inttoptr i64 [[TMP1]] to ptr
// CHECK-NEXT:    call void @llvm.memset.p0.i64(ptr align 16 [[TMP2]], i8 0, i64 64, i1 false)
// CHECK-NEXT:    [[__RET:%.*]] = alloca [[STRUCT_INT16X8X4_T]], align 16
// CHECK-NEXT:    [[TMP3:%.*]] = ptrtoint ptr [[__RET]] to i64
// CHECK-NEXT:    [[TMP4:%.*]] = xor i64 [[TMP3]], 193514046488576
// CHECK-NEXT:    [[TMP5:%.*]] = inttoptr i64 [[TMP4]] to ptr
// CHECK-NEXT:    call void @llvm.memset.p0.i64(ptr align 16 [[TMP5]], i8 0, i64 64, i1 false)
// CHECK-NEXT:    [[VLD4:%.*]] = call { <8 x i16>, <8 x i16>, <8 x i16>, <8 x i16> } @llvm.aarch64.neon.ld4.v8i16.p0(ptr [[A]])
// CHECK-NEXT:    [[TMP6:%.*]] = ptrtoint ptr [[__RET]] to i64
// CHECK-NEXT:    [[TMP7:%.*]] = xor i64 [[TMP6]], 193514046488576
// CHECK-NEXT:    [[TMP8:%.*]] = inttoptr i64 [[TMP7]] to ptr
// CHECK-NEXT:    store { <8 x i16>, <8 x i16>, <8 x i16>, <8 x i16> } zeroinitializer, ptr [[TMP8]], align 16
// CHECK-NEXT:    store { <8 x i16>, <8 x i16>, <8 x i16>, <8 x i16> } [[VLD4]], ptr [[__RET]], align 16
// CHECK-NEXT:    [[TMP9:%.*]] = call ptr @__msan_memcpy(ptr [[RETVAL]], ptr [[__RET]], i64 64)
// CHECK-NEXT:    [[TMP10:%.*]] = load [[STRUCT_INT16X8X4_T]], ptr [[RETVAL]], align 16
// CHECK-NEXT:    store { [4 x <8 x i16>] } zeroinitializer, ptr @__msan_retval_tls, align 8
// CHECK-NEXT:    ret [[STRUCT_INT16X8X4_T]] [[TMP10]]
//
int16x8x4_t test_vld4q_s16(int16_t const *a) {
  return vld4q_s16(a);
}

// CHECK-LABEL: define dso_local %struct.int32x4x4_t @test_vld4q_s32(
// CHECK-SAME: ptr noundef [[A:%.*]]) #[[ATTR0]] {
// CHECK-NEXT:  entry:
// CHECK-NEXT:    call void @llvm.donothing()
// CHECK-NEXT:    [[RETVAL:%.*]] = alloca [[STRUCT_INT32X4X4_T:%.*]], align 16
// CHECK-NEXT:    [[TMP0:%.*]] = ptrtoint ptr [[RETVAL]] to i64
// CHECK-NEXT:    [[TMP1:%.*]] = xor i64 [[TMP0]], 193514046488576
// CHECK-NEXT:    [[TMP2:%.*]] = inttoptr i64 [[TMP1]] to ptr
// CHECK-NEXT:    call void @llvm.memset.p0.i64(ptr align 16 [[TMP2]], i8 0, i64 64, i1 false)
// CHECK-NEXT:    [[__RET:%.*]] = alloca [[STRUCT_INT32X4X4_T]], align 16
// CHECK-NEXT:    [[TMP3:%.*]] = ptrtoint ptr [[__RET]] to i64
// CHECK-NEXT:    [[TMP4:%.*]] = xor i64 [[TMP3]], 193514046488576
// CHECK-NEXT:    [[TMP5:%.*]] = inttoptr i64 [[TMP4]] to ptr
// CHECK-NEXT:    call void @llvm.memset.p0.i64(ptr align 16 [[TMP5]], i8 0, i64 64, i1 false)
// CHECK-NEXT:    [[VLD4:%.*]] = call { <4 x i32>, <4 x i32>, <4 x i32>, <4 x i32> } @llvm.aarch64.neon.ld4.v4i32.p0(ptr [[A]])
// CHECK-NEXT:    [[TMP6:%.*]] = ptrtoint ptr [[__RET]] to i64
// CHECK-NEXT:    [[TMP7:%.*]] = xor i64 [[TMP6]], 193514046488576
// CHECK-NEXT:    [[TMP8:%.*]] = inttoptr i64 [[TMP7]] to ptr
// CHECK-NEXT:    store { <4 x i32>, <4 x i32>, <4 x i32>, <4 x i32> } zeroinitializer, ptr [[TMP8]], align 16
// CHECK-NEXT:    store { <4 x i32>, <4 x i32>, <4 x i32>, <4 x i32> } [[VLD4]], ptr [[__RET]], align 16
// CHECK-NEXT:    [[TMP9:%.*]] = call ptr @__msan_memcpy(ptr [[RETVAL]], ptr [[__RET]], i64 64)
// CHECK-NEXT:    [[TMP10:%.*]] = load [[STRUCT_INT32X4X4_T]], ptr [[RETVAL]], align 16
// CHECK-NEXT:    store { [4 x <4 x i32>] } zeroinitializer, ptr @__msan_retval_tls, align 8
// CHECK-NEXT:    ret [[STRUCT_INT32X4X4_T]] [[TMP10]]
//
int32x4x4_t test_vld4q_s32(int32_t const *a) {
  return vld4q_s32(a);
}

// CHECK-LABEL: define dso_local %struct.int64x2x4_t @test_vld4q_s64(
// CHECK-SAME: ptr noundef [[A:%.*]]) #[[ATTR0]] {
// CHECK-NEXT:  entry:
// CHECK-NEXT:    call void @llvm.donothing()
// CHECK-NEXT:    [[RETVAL:%.*]] = alloca [[STRUCT_INT64X2X4_T:%.*]], align 16
// CHECK-NEXT:    [[TMP0:%.*]] = ptrtoint ptr [[RETVAL]] to i64
// CHECK-NEXT:    [[TMP1:%.*]] = xor i64 [[TMP0]], 193514046488576
// CHECK-NEXT:    [[TMP2:%.*]] = inttoptr i64 [[TMP1]] to ptr
// CHECK-NEXT:    call void @llvm.memset.p0.i64(ptr align 16 [[TMP2]], i8 0, i64 64, i1 false)
// CHECK-NEXT:    [[__RET:%.*]] = alloca [[STRUCT_INT64X2X4_T]], align 16
// CHECK-NEXT:    [[TMP3:%.*]] = ptrtoint ptr [[__RET]] to i64
// CHECK-NEXT:    [[TMP4:%.*]] = xor i64 [[TMP3]], 193514046488576
// CHECK-NEXT:    [[TMP5:%.*]] = inttoptr i64 [[TMP4]] to ptr
// CHECK-NEXT:    call void @llvm.memset.p0.i64(ptr align 16 [[TMP5]], i8 0, i64 64, i1 false)
// CHECK-NEXT:    [[VLD4:%.*]] = call { <2 x i64>, <2 x i64>, <2 x i64>, <2 x i64> } @llvm.aarch64.neon.ld4.v2i64.p0(ptr [[A]])
// CHECK-NEXT:    [[TMP6:%.*]] = ptrtoint ptr [[__RET]] to i64
// CHECK-NEXT:    [[TMP7:%.*]] = xor i64 [[TMP6]], 193514046488576
// CHECK-NEXT:    [[TMP8:%.*]] = inttoptr i64 [[TMP7]] to ptr
// CHECK-NEXT:    store { <2 x i64>, <2 x i64>, <2 x i64>, <2 x i64> } zeroinitializer, ptr [[TMP8]], align 16
// CHECK-NEXT:    store { <2 x i64>, <2 x i64>, <2 x i64>, <2 x i64> } [[VLD4]], ptr [[__RET]], align 16
// CHECK-NEXT:    [[TMP9:%.*]] = call ptr @__msan_memcpy(ptr [[RETVAL]], ptr [[__RET]], i64 64)
// CHECK-NEXT:    [[TMP10:%.*]] = load [[STRUCT_INT64X2X4_T]], ptr [[RETVAL]], align 16
// CHECK-NEXT:    store { [4 x <2 x i64>] } zeroinitializer, ptr @__msan_retval_tls, align 8
// CHECK-NEXT:    ret [[STRUCT_INT64X2X4_T]] [[TMP10]]
//
int64x2x4_t test_vld4q_s64(int64_t const *a) {
  return vld4q_s64(a);
}

// CHECK-LABEL: define dso_local %struct.float16x8x4_t @test_vld4q_f16(
// CHECK-SAME: ptr noundef [[A:%.*]]) #[[ATTR0]] {
// CHECK-NEXT:  entry:
// CHECK-NEXT:    call void @llvm.donothing()
// CHECK-NEXT:    [[RETVAL:%.*]] = alloca [[STRUCT_FLOAT16X8X4_T:%.*]], align 16
// CHECK-NEXT:    [[TMP0:%.*]] = ptrtoint ptr [[RETVAL]] to i64
// CHECK-NEXT:    [[TMP1:%.*]] = xor i64 [[TMP0]], 193514046488576
// CHECK-NEXT:    [[TMP2:%.*]] = inttoptr i64 [[TMP1]] to ptr
// CHECK-NEXT:    call void @llvm.memset.p0.i64(ptr align 16 [[TMP2]], i8 0, i64 64, i1 false)
// CHECK-NEXT:    [[__RET:%.*]] = alloca [[STRUCT_FLOAT16X8X4_T]], align 16
// CHECK-NEXT:    [[TMP3:%.*]] = ptrtoint ptr [[__RET]] to i64
// CHECK-NEXT:    [[TMP4:%.*]] = xor i64 [[TMP3]], 193514046488576
// CHECK-NEXT:    [[TMP5:%.*]] = inttoptr i64 [[TMP4]] to ptr
// CHECK-NEXT:    call void @llvm.memset.p0.i64(ptr align 16 [[TMP5]], i8 0, i64 64, i1 false)
// CHECK-NEXT:    [[VLD4:%.*]] = call { <8 x half>, <8 x half>, <8 x half>, <8 x half> } @llvm.aarch64.neon.ld4.v8f16.p0(ptr [[A]])
// CHECK-NEXT:    [[TMP6:%.*]] = ptrtoint ptr [[__RET]] to i64
// CHECK-NEXT:    [[TMP7:%.*]] = xor i64 [[TMP6]], 193514046488576
// CHECK-NEXT:    [[TMP8:%.*]] = inttoptr i64 [[TMP7]] to ptr
// CHECK-NEXT:    store { <8 x i16>, <8 x i16>, <8 x i16>, <8 x i16> } zeroinitializer, ptr [[TMP8]], align 16
// CHECK-NEXT:    store { <8 x half>, <8 x half>, <8 x half>, <8 x half> } [[VLD4]], ptr [[__RET]], align 16
// CHECK-NEXT:    [[TMP9:%.*]] = call ptr @__msan_memcpy(ptr [[RETVAL]], ptr [[__RET]], i64 64)
// CHECK-NEXT:    [[TMP10:%.*]] = load [[STRUCT_FLOAT16X8X4_T]], ptr [[RETVAL]], align 16
// CHECK-NEXT:    store { [4 x <8 x i16>] } zeroinitializer, ptr @__msan_retval_tls, align 8
// CHECK-NEXT:    ret [[STRUCT_FLOAT16X8X4_T]] [[TMP10]]
//
float16x8x4_t test_vld4q_f16(float16_t const *a) {
  return vld4q_f16(a);
}

// CHECK-LABEL: define dso_local %struct.float32x4x4_t @test_vld4q_f32(
// CHECK-SAME: ptr noundef [[A:%.*]]) #[[ATTR0]] {
// CHECK-NEXT:  entry:
// CHECK-NEXT:    call void @llvm.donothing()
// CHECK-NEXT:    [[RETVAL:%.*]] = alloca [[STRUCT_FLOAT32X4X4_T:%.*]], align 16
// CHECK-NEXT:    [[TMP0:%.*]] = ptrtoint ptr [[RETVAL]] to i64
// CHECK-NEXT:    [[TMP1:%.*]] = xor i64 [[TMP0]], 193514046488576
// CHECK-NEXT:    [[TMP2:%.*]] = inttoptr i64 [[TMP1]] to ptr
// CHECK-NEXT:    call void @llvm.memset.p0.i64(ptr align 16 [[TMP2]], i8 0, i64 64, i1 false)
// CHECK-NEXT:    [[__RET:%.*]] = alloca [[STRUCT_FLOAT32X4X4_T]], align 16
// CHECK-NEXT:    [[TMP3:%.*]] = ptrtoint ptr [[__RET]] to i64
// CHECK-NEXT:    [[TMP4:%.*]] = xor i64 [[TMP3]], 193514046488576
// CHECK-NEXT:    [[TMP5:%.*]] = inttoptr i64 [[TMP4]] to ptr
// CHECK-NEXT:    call void @llvm.memset.p0.i64(ptr align 16 [[TMP5]], i8 0, i64 64, i1 false)
// CHECK-NEXT:    [[VLD4:%.*]] = call { <4 x float>, <4 x float>, <4 x float>, <4 x float> } @llvm.aarch64.neon.ld4.v4f32.p0(ptr [[A]])
// CHECK-NEXT:    [[TMP6:%.*]] = ptrtoint ptr [[__RET]] to i64
// CHECK-NEXT:    [[TMP7:%.*]] = xor i64 [[TMP6]], 193514046488576
// CHECK-NEXT:    [[TMP8:%.*]] = inttoptr i64 [[TMP7]] to ptr
// CHECK-NEXT:    store { <4 x i32>, <4 x i32>, <4 x i32>, <4 x i32> } zeroinitializer, ptr [[TMP8]], align 16
// CHECK-NEXT:    store { <4 x float>, <4 x float>, <4 x float>, <4 x float> } [[VLD4]], ptr [[__RET]], align 16
// CHECK-NEXT:    [[TMP9:%.*]] = call ptr @__msan_memcpy(ptr [[RETVAL]], ptr [[__RET]], i64 64)
// CHECK-NEXT:    [[TMP10:%.*]] = load [[STRUCT_FLOAT32X4X4_T]], ptr [[RETVAL]], align 16
// CHECK-NEXT:    store { [4 x <4 x i32>] } zeroinitializer, ptr @__msan_retval_tls, align 8
// CHECK-NEXT:    ret [[STRUCT_FLOAT32X4X4_T]] [[TMP10]]
//
float32x4x4_t test_vld4q_f32(float32_t const *a) {
  return vld4q_f32(a);
}

// CHECK-LABEL: define dso_local %struct.float64x2x4_t @test_vld4q_f64(
// CHECK-SAME: ptr noundef [[A:%.*]]) #[[ATTR0]] {
// CHECK-NEXT:  entry:
// CHECK-NEXT:    call void @llvm.donothing()
// CHECK-NEXT:    [[RETVAL:%.*]] = alloca [[STRUCT_FLOAT64X2X4_T:%.*]], align 16
// CHECK-NEXT:    [[TMP0:%.*]] = ptrtoint ptr [[RETVAL]] to i64
// CHECK-NEXT:    [[TMP1:%.*]] = xor i64 [[TMP0]], 193514046488576
// CHECK-NEXT:    [[TMP2:%.*]] = inttoptr i64 [[TMP1]] to ptr
// CHECK-NEXT:    call void @llvm.memset.p0.i64(ptr align 16 [[TMP2]], i8 0, i64 64, i1 false)
// CHECK-NEXT:    [[__RET:%.*]] = alloca [[STRUCT_FLOAT64X2X4_T]], align 16
// CHECK-NEXT:    [[TMP3:%.*]] = ptrtoint ptr [[__RET]] to i64
// CHECK-NEXT:    [[TMP4:%.*]] = xor i64 [[TMP3]], 193514046488576
// CHECK-NEXT:    [[TMP5:%.*]] = inttoptr i64 [[TMP4]] to ptr
// CHECK-NEXT:    call void @llvm.memset.p0.i64(ptr align 16 [[TMP5]], i8 0, i64 64, i1 false)
// CHECK-NEXT:    [[VLD4:%.*]] = call { <2 x double>, <2 x double>, <2 x double>, <2 x double> } @llvm.aarch64.neon.ld4.v2f64.p0(ptr [[A]])
// CHECK-NEXT:    [[TMP6:%.*]] = ptrtoint ptr [[__RET]] to i64
// CHECK-NEXT:    [[TMP7:%.*]] = xor i64 [[TMP6]], 193514046488576
// CHECK-NEXT:    [[TMP8:%.*]] = inttoptr i64 [[TMP7]] to ptr
// CHECK-NEXT:    store { <2 x i64>, <2 x i64>, <2 x i64>, <2 x i64> } zeroinitializer, ptr [[TMP8]], align 16
// CHECK-NEXT:    store { <2 x double>, <2 x double>, <2 x double>, <2 x double> } [[VLD4]], ptr [[__RET]], align 16
// CHECK-NEXT:    [[TMP9:%.*]] = call ptr @__msan_memcpy(ptr [[RETVAL]], ptr [[__RET]], i64 64)
// CHECK-NEXT:    [[TMP10:%.*]] = load [[STRUCT_FLOAT64X2X4_T]], ptr [[RETVAL]], align 16
// CHECK-NEXT:    store { [4 x <2 x i64>] } zeroinitializer, ptr @__msan_retval_tls, align 8
// CHECK-NEXT:    ret [[STRUCT_FLOAT64X2X4_T]] [[TMP10]]
//
float64x2x4_t test_vld4q_f64(float64_t const *a) {
  return vld4q_f64(a);
}

// CHECK-LABEL: define dso_local %struct.poly8x16x4_t @test_vld4q_p8(
// CHECK-SAME: ptr noundef [[A:%.*]]) #[[ATTR0]] {
// CHECK-NEXT:  entry:
// CHECK-NEXT:    call void @llvm.donothing()
// CHECK-NEXT:    [[RETVAL:%.*]] = alloca [[STRUCT_POLY8X16X4_T:%.*]], align 16
// CHECK-NEXT:    [[TMP0:%.*]] = ptrtoint ptr [[RETVAL]] to i64
// CHECK-NEXT:    [[TMP1:%.*]] = xor i64 [[TMP0]], 193514046488576
// CHECK-NEXT:    [[TMP2:%.*]] = inttoptr i64 [[TMP1]] to ptr
// CHECK-NEXT:    call void @llvm.memset.p0.i64(ptr align 16 [[TMP2]], i8 0, i64 64, i1 false)
// CHECK-NEXT:    [[__RET:%.*]] = alloca [[STRUCT_POLY8X16X4_T]], align 16
// CHECK-NEXT:    [[TMP3:%.*]] = ptrtoint ptr [[__RET]] to i64
// CHECK-NEXT:    [[TMP4:%.*]] = xor i64 [[TMP3]], 193514046488576
// CHECK-NEXT:    [[TMP5:%.*]] = inttoptr i64 [[TMP4]] to ptr
// CHECK-NEXT:    call void @llvm.memset.p0.i64(ptr align 16 [[TMP5]], i8 0, i64 64, i1 false)
// CHECK-NEXT:    [[VLD4:%.*]] = call { <16 x i8>, <16 x i8>, <16 x i8>, <16 x i8> } @llvm.aarch64.neon.ld4.v16i8.p0(ptr [[A]])
// CHECK-NEXT:    [[TMP6:%.*]] = ptrtoint ptr [[__RET]] to i64
// CHECK-NEXT:    [[TMP7:%.*]] = xor i64 [[TMP6]], 193514046488576
// CHECK-NEXT:    [[TMP8:%.*]] = inttoptr i64 [[TMP7]] to ptr
// CHECK-NEXT:    store { <16 x i8>, <16 x i8>, <16 x i8>, <16 x i8> } zeroinitializer, ptr [[TMP8]], align 16
// CHECK-NEXT:    store { <16 x i8>, <16 x i8>, <16 x i8>, <16 x i8> } [[VLD4]], ptr [[__RET]], align 16
// CHECK-NEXT:    [[TMP9:%.*]] = call ptr @__msan_memcpy(ptr [[RETVAL]], ptr [[__RET]], i64 64)
// CHECK-NEXT:    [[TMP10:%.*]] = load [[STRUCT_POLY8X16X4_T]], ptr [[RETVAL]], align 16
// CHECK-NEXT:    store { [4 x <16 x i8>] } zeroinitializer, ptr @__msan_retval_tls, align 8
// CHECK-NEXT:    ret [[STRUCT_POLY8X16X4_T]] [[TMP10]]
//
poly8x16x4_t test_vld4q_p8(poly8_t const *a) {
  return vld4q_p8(a);
}

// CHECK-LABEL: define dso_local %struct.poly16x8x4_t @test_vld4q_p16(
// CHECK-SAME: ptr noundef [[A:%.*]]) #[[ATTR0]] {
// CHECK-NEXT:  entry:
// CHECK-NEXT:    call void @llvm.donothing()
// CHECK-NEXT:    [[RETVAL:%.*]] = alloca [[STRUCT_POLY16X8X4_T:%.*]], align 16
// CHECK-NEXT:    [[TMP0:%.*]] = ptrtoint ptr [[RETVAL]] to i64
// CHECK-NEXT:    [[TMP1:%.*]] = xor i64 [[TMP0]], 193514046488576
// CHECK-NEXT:    [[TMP2:%.*]] = inttoptr i64 [[TMP1]] to ptr
// CHECK-NEXT:    call void @llvm.memset.p0.i64(ptr align 16 [[TMP2]], i8 0, i64 64, i1 false)
// CHECK-NEXT:    [[__RET:%.*]] = alloca [[STRUCT_POLY16X8X4_T]], align 16
// CHECK-NEXT:    [[TMP3:%.*]] = ptrtoint ptr [[__RET]] to i64
// CHECK-NEXT:    [[TMP4:%.*]] = xor i64 [[TMP3]], 193514046488576
// CHECK-NEXT:    [[TMP5:%.*]] = inttoptr i64 [[TMP4]] to ptr
// CHECK-NEXT:    call void @llvm.memset.p0.i64(ptr align 16 [[TMP5]], i8 0, i64 64, i1 false)
// CHECK-NEXT:    [[VLD4:%.*]] = call { <8 x i16>, <8 x i16>, <8 x i16>, <8 x i16> } @llvm.aarch64.neon.ld4.v8i16.p0(ptr [[A]])
// CHECK-NEXT:    [[TMP6:%.*]] = ptrtoint ptr [[__RET]] to i64
// CHECK-NEXT:    [[TMP7:%.*]] = xor i64 [[TMP6]], 193514046488576
// CHECK-NEXT:    [[TMP8:%.*]] = inttoptr i64 [[TMP7]] to ptr
// CHECK-NEXT:    store { <8 x i16>, <8 x i16>, <8 x i16>, <8 x i16> } zeroinitializer, ptr [[TMP8]], align 16
// CHECK-NEXT:    store { <8 x i16>, <8 x i16>, <8 x i16>, <8 x i16> } [[VLD4]], ptr [[__RET]], align 16
// CHECK-NEXT:    [[TMP9:%.*]] = call ptr @__msan_memcpy(ptr [[RETVAL]], ptr [[__RET]], i64 64)
// CHECK-NEXT:    [[TMP10:%.*]] = load [[STRUCT_POLY16X8X4_T]], ptr [[RETVAL]], align 16
// CHECK-NEXT:    store { [4 x <8 x i16>] } zeroinitializer, ptr @__msan_retval_tls, align 8
// CHECK-NEXT:    ret [[STRUCT_POLY16X8X4_T]] [[TMP10]]
//
poly16x8x4_t test_vld4q_p16(poly16_t const *a) {
  return vld4q_p16(a);
}

// CHECK-LABEL: define dso_local %struct.uint8x8x4_t @test_vld4_u8(
// CHECK-SAME: ptr noundef [[A:%.*]]) #[[ATTR0]] {
// CHECK-NEXT:  entry:
// CHECK-NEXT:    call void @llvm.donothing()
// CHECK-NEXT:    [[RETVAL:%.*]] = alloca [[STRUCT_UINT8X8X4_T:%.*]], align 8
// CHECK-NEXT:    [[TMP0:%.*]] = ptrtoint ptr [[RETVAL]] to i64
// CHECK-NEXT:    [[TMP1:%.*]] = xor i64 [[TMP0]], 193514046488576
// CHECK-NEXT:    [[TMP2:%.*]] = inttoptr i64 [[TMP1]] to ptr
// CHECK-NEXT:    call void @llvm.memset.p0.i64(ptr align 8 [[TMP2]], i8 0, i64 32, i1 false)
// CHECK-NEXT:    [[__RET:%.*]] = alloca [[STRUCT_UINT8X8X4_T]], align 8
// CHECK-NEXT:    [[TMP3:%.*]] = ptrtoint ptr [[__RET]] to i64
// CHECK-NEXT:    [[TMP4:%.*]] = xor i64 [[TMP3]], 193514046488576
// CHECK-NEXT:    [[TMP5:%.*]] = inttoptr i64 [[TMP4]] to ptr
// CHECK-NEXT:    call void @llvm.memset.p0.i64(ptr align 8 [[TMP5]], i8 0, i64 32, i1 false)
// CHECK-NEXT:    [[VLD4:%.*]] = call { <8 x i8>, <8 x i8>, <8 x i8>, <8 x i8> } @llvm.aarch64.neon.ld4.v8i8.p0(ptr [[A]])
// CHECK-NEXT:    [[TMP6:%.*]] = ptrtoint ptr [[__RET]] to i64
// CHECK-NEXT:    [[TMP7:%.*]] = xor i64 [[TMP6]], 193514046488576
// CHECK-NEXT:    [[TMP8:%.*]] = inttoptr i64 [[TMP7]] to ptr
// CHECK-NEXT:    store { <8 x i8>, <8 x i8>, <8 x i8>, <8 x i8> } zeroinitializer, ptr [[TMP8]], align 8
// CHECK-NEXT:    store { <8 x i8>, <8 x i8>, <8 x i8>, <8 x i8> } [[VLD4]], ptr [[__RET]], align 8
// CHECK-NEXT:    [[TMP9:%.*]] = call ptr @__msan_memcpy(ptr [[RETVAL]], ptr [[__RET]], i64 32)
// CHECK-NEXT:    [[TMP10:%.*]] = load [[STRUCT_UINT8X8X4_T]], ptr [[RETVAL]], align 8
// CHECK-NEXT:    store { [4 x <8 x i8>] } zeroinitializer, ptr @__msan_retval_tls, align 8
// CHECK-NEXT:    ret [[STRUCT_UINT8X8X4_T]] [[TMP10]]
//
uint8x8x4_t test_vld4_u8(uint8_t const *a) {
  return vld4_u8(a);
}

// CHECK-LABEL: define dso_local %struct.uint16x4x4_t @test_vld4_u16(
// CHECK-SAME: ptr noundef [[A:%.*]]) #[[ATTR0]] {
// CHECK-NEXT:  entry:
// CHECK-NEXT:    call void @llvm.donothing()
// CHECK-NEXT:    [[RETVAL:%.*]] = alloca [[STRUCT_UINT16X4X4_T:%.*]], align 8
// CHECK-NEXT:    [[TMP0:%.*]] = ptrtoint ptr [[RETVAL]] to i64
// CHECK-NEXT:    [[TMP1:%.*]] = xor i64 [[TMP0]], 193514046488576
// CHECK-NEXT:    [[TMP2:%.*]] = inttoptr i64 [[TMP1]] to ptr
// CHECK-NEXT:    call void @llvm.memset.p0.i64(ptr align 8 [[TMP2]], i8 0, i64 32, i1 false)
// CHECK-NEXT:    [[__RET:%.*]] = alloca [[STRUCT_UINT16X4X4_T]], align 8
// CHECK-NEXT:    [[TMP3:%.*]] = ptrtoint ptr [[__RET]] to i64
// CHECK-NEXT:    [[TMP4:%.*]] = xor i64 [[TMP3]], 193514046488576
// CHECK-NEXT:    [[TMP5:%.*]] = inttoptr i64 [[TMP4]] to ptr
// CHECK-NEXT:    call void @llvm.memset.p0.i64(ptr align 8 [[TMP5]], i8 0, i64 32, i1 false)
// CHECK-NEXT:    [[VLD4:%.*]] = call { <4 x i16>, <4 x i16>, <4 x i16>, <4 x i16> } @llvm.aarch64.neon.ld4.v4i16.p0(ptr [[A]])
// CHECK-NEXT:    [[TMP6:%.*]] = ptrtoint ptr [[__RET]] to i64
// CHECK-NEXT:    [[TMP7:%.*]] = xor i64 [[TMP6]], 193514046488576
// CHECK-NEXT:    [[TMP8:%.*]] = inttoptr i64 [[TMP7]] to ptr
// CHECK-NEXT:    store { <4 x i16>, <4 x i16>, <4 x i16>, <4 x i16> } zeroinitializer, ptr [[TMP8]], align 8
// CHECK-NEXT:    store { <4 x i16>, <4 x i16>, <4 x i16>, <4 x i16> } [[VLD4]], ptr [[__RET]], align 8
// CHECK-NEXT:    [[TMP9:%.*]] = call ptr @__msan_memcpy(ptr [[RETVAL]], ptr [[__RET]], i64 32)
// CHECK-NEXT:    [[TMP10:%.*]] = load [[STRUCT_UINT16X4X4_T]], ptr [[RETVAL]], align 8
// CHECK-NEXT:    store { [4 x <4 x i16>] } zeroinitializer, ptr @__msan_retval_tls, align 8
// CHECK-NEXT:    ret [[STRUCT_UINT16X4X4_T]] [[TMP10]]
//
uint16x4x4_t test_vld4_u16(uint16_t const *a) {
  return vld4_u16(a);
}

// CHECK-LABEL: define dso_local %struct.uint32x2x4_t @test_vld4_u32(
// CHECK-SAME: ptr noundef [[A:%.*]]) #[[ATTR0]] {
// CHECK-NEXT:  entry:
// CHECK-NEXT:    call void @llvm.donothing()
// CHECK-NEXT:    [[RETVAL:%.*]] = alloca [[STRUCT_UINT32X2X4_T:%.*]], align 8
// CHECK-NEXT:    [[TMP0:%.*]] = ptrtoint ptr [[RETVAL]] to i64
// CHECK-NEXT:    [[TMP1:%.*]] = xor i64 [[TMP0]], 193514046488576
// CHECK-NEXT:    [[TMP2:%.*]] = inttoptr i64 [[TMP1]] to ptr
// CHECK-NEXT:    call void @llvm.memset.p0.i64(ptr align 8 [[TMP2]], i8 0, i64 32, i1 false)
// CHECK-NEXT:    [[__RET:%.*]] = alloca [[STRUCT_UINT32X2X4_T]], align 8
// CHECK-NEXT:    [[TMP3:%.*]] = ptrtoint ptr [[__RET]] to i64
// CHECK-NEXT:    [[TMP4:%.*]] = xor i64 [[TMP3]], 193514046488576
// CHECK-NEXT:    [[TMP5:%.*]] = inttoptr i64 [[TMP4]] to ptr
// CHECK-NEXT:    call void @llvm.memset.p0.i64(ptr align 8 [[TMP5]], i8 0, i64 32, i1 false)
// CHECK-NEXT:    [[VLD4:%.*]] = call { <2 x i32>, <2 x i32>, <2 x i32>, <2 x i32> } @llvm.aarch64.neon.ld4.v2i32.p0(ptr [[A]])
// CHECK-NEXT:    [[TMP6:%.*]] = ptrtoint ptr [[__RET]] to i64
// CHECK-NEXT:    [[TMP7:%.*]] = xor i64 [[TMP6]], 193514046488576
// CHECK-NEXT:    [[TMP8:%.*]] = inttoptr i64 [[TMP7]] to ptr
// CHECK-NEXT:    store { <2 x i32>, <2 x i32>, <2 x i32>, <2 x i32> } zeroinitializer, ptr [[TMP8]], align 8
// CHECK-NEXT:    store { <2 x i32>, <2 x i32>, <2 x i32>, <2 x i32> } [[VLD4]], ptr [[__RET]], align 8
// CHECK-NEXT:    [[TMP9:%.*]] = call ptr @__msan_memcpy(ptr [[RETVAL]], ptr [[__RET]], i64 32)
// CHECK-NEXT:    [[TMP10:%.*]] = load [[STRUCT_UINT32X2X4_T]], ptr [[RETVAL]], align 8
// CHECK-NEXT:    store { [4 x <2 x i32>] } zeroinitializer, ptr @__msan_retval_tls, align 8
// CHECK-NEXT:    ret [[STRUCT_UINT32X2X4_T]] [[TMP10]]
//
uint32x2x4_t test_vld4_u32(uint32_t const *a) {
  return vld4_u32(a);
}

// CHECK-LABEL: define dso_local %struct.uint64x1x4_t @test_vld4_u64(
// CHECK-SAME: ptr noundef [[A:%.*]]) #[[ATTR0]] {
// CHECK-NEXT:  entry:
// CHECK-NEXT:    call void @llvm.donothing()
// CHECK-NEXT:    [[RETVAL:%.*]] = alloca [[STRUCT_UINT64X1X4_T:%.*]], align 8
// CHECK-NEXT:    [[TMP0:%.*]] = ptrtoint ptr [[RETVAL]] to i64
// CHECK-NEXT:    [[TMP1:%.*]] = xor i64 [[TMP0]], 193514046488576
// CHECK-NEXT:    [[TMP2:%.*]] = inttoptr i64 [[TMP1]] to ptr
// CHECK-NEXT:    call void @llvm.memset.p0.i64(ptr align 8 [[TMP2]], i8 0, i64 32, i1 false)
// CHECK-NEXT:    [[__RET:%.*]] = alloca [[STRUCT_UINT64X1X4_T]], align 8
// CHECK-NEXT:    [[TMP3:%.*]] = ptrtoint ptr [[__RET]] to i64
// CHECK-NEXT:    [[TMP4:%.*]] = xor i64 [[TMP3]], 193514046488576
// CHECK-NEXT:    [[TMP5:%.*]] = inttoptr i64 [[TMP4]] to ptr
// CHECK-NEXT:    call void @llvm.memset.p0.i64(ptr align 8 [[TMP5]], i8 0, i64 32, i1 false)
// CHECK-NEXT:    [[VLD4:%.*]] = call { <1 x i64>, <1 x i64>, <1 x i64>, <1 x i64> } @llvm.aarch64.neon.ld4.v1i64.p0(ptr [[A]])
// CHECK-NEXT:    [[TMP6:%.*]] = ptrtoint ptr [[__RET]] to i64
// CHECK-NEXT:    [[TMP7:%.*]] = xor i64 [[TMP6]], 193514046488576
// CHECK-NEXT:    [[TMP8:%.*]] = inttoptr i64 [[TMP7]] to ptr
// CHECK-NEXT:    store { <1 x i64>, <1 x i64>, <1 x i64>, <1 x i64> } zeroinitializer, ptr [[TMP8]], align 8
// CHECK-NEXT:    store { <1 x i64>, <1 x i64>, <1 x i64>, <1 x i64> } [[VLD4]], ptr [[__RET]], align 8
// CHECK-NEXT:    [[TMP9:%.*]] = call ptr @__msan_memcpy(ptr [[RETVAL]], ptr [[__RET]], i64 32)
// CHECK-NEXT:    [[TMP10:%.*]] = load [[STRUCT_UINT64X1X4_T]], ptr [[RETVAL]], align 8
// CHECK-NEXT:    store { [4 x <1 x i64>] } zeroinitializer, ptr @__msan_retval_tls, align 8
// CHECK-NEXT:    ret [[STRUCT_UINT64X1X4_T]] [[TMP10]]
//
uint64x1x4_t test_vld4_u64(uint64_t const *a) {
  return vld4_u64(a);
}

// CHECK-LABEL: define dso_local %struct.int8x8x4_t @test_vld4_s8(
// CHECK-SAME: ptr noundef [[A:%.*]]) #[[ATTR0]] {
// CHECK-NEXT:  entry:
// CHECK-NEXT:    call void @llvm.donothing()
// CHECK-NEXT:    [[RETVAL:%.*]] = alloca [[STRUCT_INT8X8X4_T:%.*]], align 8
// CHECK-NEXT:    [[TMP0:%.*]] = ptrtoint ptr [[RETVAL]] to i64
// CHECK-NEXT:    [[TMP1:%.*]] = xor i64 [[TMP0]], 193514046488576
// CHECK-NEXT:    [[TMP2:%.*]] = inttoptr i64 [[TMP1]] to ptr
// CHECK-NEXT:    call void @llvm.memset.p0.i64(ptr align 8 [[TMP2]], i8 0, i64 32, i1 false)
// CHECK-NEXT:    [[__RET:%.*]] = alloca [[STRUCT_INT8X8X4_T]], align 8
// CHECK-NEXT:    [[TMP3:%.*]] = ptrtoint ptr [[__RET]] to i64
// CHECK-NEXT:    [[TMP4:%.*]] = xor i64 [[TMP3]], 193514046488576
// CHECK-NEXT:    [[TMP5:%.*]] = inttoptr i64 [[TMP4]] to ptr
// CHECK-NEXT:    call void @llvm.memset.p0.i64(ptr align 8 [[TMP5]], i8 0, i64 32, i1 false)
// CHECK-NEXT:    [[VLD4:%.*]] = call { <8 x i8>, <8 x i8>, <8 x i8>, <8 x i8> } @llvm.aarch64.neon.ld4.v8i8.p0(ptr [[A]])
// CHECK-NEXT:    [[TMP6:%.*]] = ptrtoint ptr [[__RET]] to i64
// CHECK-NEXT:    [[TMP7:%.*]] = xor i64 [[TMP6]], 193514046488576
// CHECK-NEXT:    [[TMP8:%.*]] = inttoptr i64 [[TMP7]] to ptr
// CHECK-NEXT:    store { <8 x i8>, <8 x i8>, <8 x i8>, <8 x i8> } zeroinitializer, ptr [[TMP8]], align 8
// CHECK-NEXT:    store { <8 x i8>, <8 x i8>, <8 x i8>, <8 x i8> } [[VLD4]], ptr [[__RET]], align 8
// CHECK-NEXT:    [[TMP9:%.*]] = call ptr @__msan_memcpy(ptr [[RETVAL]], ptr [[__RET]], i64 32)
// CHECK-NEXT:    [[TMP10:%.*]] = load [[STRUCT_INT8X8X4_T]], ptr [[RETVAL]], align 8
// CHECK-NEXT:    store { [4 x <8 x i8>] } zeroinitializer, ptr @__msan_retval_tls, align 8
// CHECK-NEXT:    ret [[STRUCT_INT8X8X4_T]] [[TMP10]]
//
int8x8x4_t test_vld4_s8(int8_t const *a) {
  return vld4_s8(a);
}

// CHECK-LABEL: define dso_local %struct.int16x4x4_t @test_vld4_s16(
// CHECK-SAME: ptr noundef [[A:%.*]]) #[[ATTR0]] {
// CHECK-NEXT:  entry:
// CHECK-NEXT:    call void @llvm.donothing()
// CHECK-NEXT:    [[RETVAL:%.*]] = alloca [[STRUCT_INT16X4X4_T:%.*]], align 8
// CHECK-NEXT:    [[TMP0:%.*]] = ptrtoint ptr [[RETVAL]] to i64
// CHECK-NEXT:    [[TMP1:%.*]] = xor i64 [[TMP0]], 193514046488576
// CHECK-NEXT:    [[TMP2:%.*]] = inttoptr i64 [[TMP1]] to ptr
// CHECK-NEXT:    call void @llvm.memset.p0.i64(ptr align 8 [[TMP2]], i8 0, i64 32, i1 false)
// CHECK-NEXT:    [[__RET:%.*]] = alloca [[STRUCT_INT16X4X4_T]], align 8
// CHECK-NEXT:    [[TMP3:%.*]] = ptrtoint ptr [[__RET]] to i64
// CHECK-NEXT:    [[TMP4:%.*]] = xor i64 [[TMP3]], 193514046488576
// CHECK-NEXT:    [[TMP5:%.*]] = inttoptr i64 [[TMP4]] to ptr
// CHECK-NEXT:    call void @llvm.memset.p0.i64(ptr align 8 [[TMP5]], i8 0, i64 32, i1 false)
// CHECK-NEXT:    [[VLD4:%.*]] = call { <4 x i16>, <4 x i16>, <4 x i16>, <4 x i16> } @llvm.aarch64.neon.ld4.v4i16.p0(ptr [[A]])
// CHECK-NEXT:    [[TMP6:%.*]] = ptrtoint ptr [[__RET]] to i64
// CHECK-NEXT:    [[TMP7:%.*]] = xor i64 [[TMP6]], 193514046488576
// CHECK-NEXT:    [[TMP8:%.*]] = inttoptr i64 [[TMP7]] to ptr
// CHECK-NEXT:    store { <4 x i16>, <4 x i16>, <4 x i16>, <4 x i16> } zeroinitializer, ptr [[TMP8]], align 8
// CHECK-NEXT:    store { <4 x i16>, <4 x i16>, <4 x i16>, <4 x i16> } [[VLD4]], ptr [[__RET]], align 8
// CHECK-NEXT:    [[TMP9:%.*]] = call ptr @__msan_memcpy(ptr [[RETVAL]], ptr [[__RET]], i64 32)
// CHECK-NEXT:    [[TMP10:%.*]] = load [[STRUCT_INT16X4X4_T]], ptr [[RETVAL]], align 8
// CHECK-NEXT:    store { [4 x <4 x i16>] } zeroinitializer, ptr @__msan_retval_tls, align 8
// CHECK-NEXT:    ret [[STRUCT_INT16X4X4_T]] [[TMP10]]
//
int16x4x4_t test_vld4_s16(int16_t const *a) {
  return vld4_s16(a);
}

// CHECK-LABEL: define dso_local %struct.int32x2x4_t @test_vld4_s32(
// CHECK-SAME: ptr noundef [[A:%.*]]) #[[ATTR0]] {
// CHECK-NEXT:  entry:
// CHECK-NEXT:    call void @llvm.donothing()
// CHECK-NEXT:    [[RETVAL:%.*]] = alloca [[STRUCT_INT32X2X4_T:%.*]], align 8
// CHECK-NEXT:    [[TMP0:%.*]] = ptrtoint ptr [[RETVAL]] to i64
// CHECK-NEXT:    [[TMP1:%.*]] = xor i64 [[TMP0]], 193514046488576
// CHECK-NEXT:    [[TMP2:%.*]] = inttoptr i64 [[TMP1]] to ptr
// CHECK-NEXT:    call void @llvm.memset.p0.i64(ptr align 8 [[TMP2]], i8 0, i64 32, i1 false)
// CHECK-NEXT:    [[__RET:%.*]] = alloca [[STRUCT_INT32X2X4_T]], align 8
// CHECK-NEXT:    [[TMP3:%.*]] = ptrtoint ptr [[__RET]] to i64
// CHECK-NEXT:    [[TMP4:%.*]] = xor i64 [[TMP3]], 193514046488576
// CHECK-NEXT:    [[TMP5:%.*]] = inttoptr i64 [[TMP4]] to ptr
// CHECK-NEXT:    call void @llvm.memset.p0.i64(ptr align 8 [[TMP5]], i8 0, i64 32, i1 false)
// CHECK-NEXT:    [[VLD4:%.*]] = call { <2 x i32>, <2 x i32>, <2 x i32>, <2 x i32> } @llvm.aarch64.neon.ld4.v2i32.p0(ptr [[A]])
// CHECK-NEXT:    [[TMP6:%.*]] = ptrtoint ptr [[__RET]] to i64
// CHECK-NEXT:    [[TMP7:%.*]] = xor i64 [[TMP6]], 193514046488576
// CHECK-NEXT:    [[TMP8:%.*]] = inttoptr i64 [[TMP7]] to ptr
// CHECK-NEXT:    store { <2 x i32>, <2 x i32>, <2 x i32>, <2 x i32> } zeroinitializer, ptr [[TMP8]], align 8
// CHECK-NEXT:    store { <2 x i32>, <2 x i32>, <2 x i32>, <2 x i32> } [[VLD4]], ptr [[__RET]], align 8
// CHECK-NEXT:    [[TMP9:%.*]] = call ptr @__msan_memcpy(ptr [[RETVAL]], ptr [[__RET]], i64 32)
// CHECK-NEXT:    [[TMP10:%.*]] = load [[STRUCT_INT32X2X4_T]], ptr [[RETVAL]], align 8
// CHECK-NEXT:    store { [4 x <2 x i32>] } zeroinitializer, ptr @__msan_retval_tls, align 8
// CHECK-NEXT:    ret [[STRUCT_INT32X2X4_T]] [[TMP10]]
//
int32x2x4_t test_vld4_s32(int32_t const *a) {
  return vld4_s32(a);
}

// CHECK-LABEL: define dso_local %struct.int64x1x4_t @test_vld4_s64(
// CHECK-SAME: ptr noundef [[A:%.*]]) #[[ATTR0]] {
// CHECK-NEXT:  entry:
// CHECK-NEXT:    call void @llvm.donothing()
// CHECK-NEXT:    [[RETVAL:%.*]] = alloca [[STRUCT_INT64X1X4_T:%.*]], align 8
// CHECK-NEXT:    [[TMP0:%.*]] = ptrtoint ptr [[RETVAL]] to i64
// CHECK-NEXT:    [[TMP1:%.*]] = xor i64 [[TMP0]], 193514046488576
// CHECK-NEXT:    [[TMP2:%.*]] = inttoptr i64 [[TMP1]] to ptr
// CHECK-NEXT:    call void @llvm.memset.p0.i64(ptr align 8 [[TMP2]], i8 0, i64 32, i1 false)
// CHECK-NEXT:    [[__RET:%.*]] = alloca [[STRUCT_INT64X1X4_T]], align 8
// CHECK-NEXT:    [[TMP3:%.*]] = ptrtoint ptr [[__RET]] to i64
// CHECK-NEXT:    [[TMP4:%.*]] = xor i64 [[TMP3]], 193514046488576
// CHECK-NEXT:    [[TMP5:%.*]] = inttoptr i64 [[TMP4]] to ptr
// CHECK-NEXT:    call void @llvm.memset.p0.i64(ptr align 8 [[TMP5]], i8 0, i64 32, i1 false)
// CHECK-NEXT:    [[VLD4:%.*]] = call { <1 x i64>, <1 x i64>, <1 x i64>, <1 x i64> } @llvm.aarch64.neon.ld4.v1i64.p0(ptr [[A]])
// CHECK-NEXT:    [[TMP6:%.*]] = ptrtoint ptr [[__RET]] to i64
// CHECK-NEXT:    [[TMP7:%.*]] = xor i64 [[TMP6]], 193514046488576
// CHECK-NEXT:    [[TMP8:%.*]] = inttoptr i64 [[TMP7]] to ptr
// CHECK-NEXT:    store { <1 x i64>, <1 x i64>, <1 x i64>, <1 x i64> } zeroinitializer, ptr [[TMP8]], align 8
// CHECK-NEXT:    store { <1 x i64>, <1 x i64>, <1 x i64>, <1 x i64> } [[VLD4]], ptr [[__RET]], align 8
// CHECK-NEXT:    [[TMP9:%.*]] = call ptr @__msan_memcpy(ptr [[RETVAL]], ptr [[__RET]], i64 32)
// CHECK-NEXT:    [[TMP10:%.*]] = load [[STRUCT_INT64X1X4_T]], ptr [[RETVAL]], align 8
// CHECK-NEXT:    store { [4 x <1 x i64>] } zeroinitializer, ptr @__msan_retval_tls, align 8
// CHECK-NEXT:    ret [[STRUCT_INT64X1X4_T]] [[TMP10]]
//
int64x1x4_t test_vld4_s64(int64_t const *a) {
  return vld4_s64(a);
}

// CHECK-LABEL: define dso_local %struct.float16x4x4_t @test_vld4_f16(
// CHECK-SAME: ptr noundef [[A:%.*]]) #[[ATTR0]] {
// CHECK-NEXT:  entry:
// CHECK-NEXT:    call void @llvm.donothing()
// CHECK-NEXT:    [[RETVAL:%.*]] = alloca [[STRUCT_FLOAT16X4X4_T:%.*]], align 8
// CHECK-NEXT:    [[TMP0:%.*]] = ptrtoint ptr [[RETVAL]] to i64
// CHECK-NEXT:    [[TMP1:%.*]] = xor i64 [[TMP0]], 193514046488576
// CHECK-NEXT:    [[TMP2:%.*]] = inttoptr i64 [[TMP1]] to ptr
// CHECK-NEXT:    call void @llvm.memset.p0.i64(ptr align 8 [[TMP2]], i8 0, i64 32, i1 false)
// CHECK-NEXT:    [[__RET:%.*]] = alloca [[STRUCT_FLOAT16X4X4_T]], align 8
// CHECK-NEXT:    [[TMP3:%.*]] = ptrtoint ptr [[__RET]] to i64
// CHECK-NEXT:    [[TMP4:%.*]] = xor i64 [[TMP3]], 193514046488576
// CHECK-NEXT:    [[TMP5:%.*]] = inttoptr i64 [[TMP4]] to ptr
// CHECK-NEXT:    call void @llvm.memset.p0.i64(ptr align 8 [[TMP5]], i8 0, i64 32, i1 false)
// CHECK-NEXT:    [[VLD4:%.*]] = call { <4 x half>, <4 x half>, <4 x half>, <4 x half> } @llvm.aarch64.neon.ld4.v4f16.p0(ptr [[A]])
// CHECK-NEXT:    [[TMP6:%.*]] = ptrtoint ptr [[__RET]] to i64
// CHECK-NEXT:    [[TMP7:%.*]] = xor i64 [[TMP6]], 193514046488576
// CHECK-NEXT:    [[TMP8:%.*]] = inttoptr i64 [[TMP7]] to ptr
// CHECK-NEXT:    store { <4 x i16>, <4 x i16>, <4 x i16>, <4 x i16> } zeroinitializer, ptr [[TMP8]], align 8
// CHECK-NEXT:    store { <4 x half>, <4 x half>, <4 x half>, <4 x half> } [[VLD4]], ptr [[__RET]], align 8
// CHECK-NEXT:    [[TMP9:%.*]] = call ptr @__msan_memcpy(ptr [[RETVAL]], ptr [[__RET]], i64 32)
// CHECK-NEXT:    [[TMP10:%.*]] = load [[STRUCT_FLOAT16X4X4_T]], ptr [[RETVAL]], align 8
// CHECK-NEXT:    store { [4 x <4 x i16>] } zeroinitializer, ptr @__msan_retval_tls, align 8
// CHECK-NEXT:    ret [[STRUCT_FLOAT16X4X4_T]] [[TMP10]]
//
float16x4x4_t test_vld4_f16(float16_t const *a) {
  return vld4_f16(a);
}

// CHECK-LABEL: define dso_local %struct.float32x2x4_t @test_vld4_f32(
// CHECK-SAME: ptr noundef [[A:%.*]]) #[[ATTR0]] {
// CHECK-NEXT:  entry:
// CHECK-NEXT:    call void @llvm.donothing()
// CHECK-NEXT:    [[RETVAL:%.*]] = alloca [[STRUCT_FLOAT32X2X4_T:%.*]], align 8
// CHECK-NEXT:    [[TMP0:%.*]] = ptrtoint ptr [[RETVAL]] to i64
// CHECK-NEXT:    [[TMP1:%.*]] = xor i64 [[TMP0]], 193514046488576
// CHECK-NEXT:    [[TMP2:%.*]] = inttoptr i64 [[TMP1]] to ptr
// CHECK-NEXT:    call void @llvm.memset.p0.i64(ptr align 8 [[TMP2]], i8 0, i64 32, i1 false)
// CHECK-NEXT:    [[__RET:%.*]] = alloca [[STRUCT_FLOAT32X2X4_T]], align 8
// CHECK-NEXT:    [[TMP3:%.*]] = ptrtoint ptr [[__RET]] to i64
// CHECK-NEXT:    [[TMP4:%.*]] = xor i64 [[TMP3]], 193514046488576
// CHECK-NEXT:    [[TMP5:%.*]] = inttoptr i64 [[TMP4]] to ptr
// CHECK-NEXT:    call void @llvm.memset.p0.i64(ptr align 8 [[TMP5]], i8 0, i64 32, i1 false)
// CHECK-NEXT:    [[VLD4:%.*]] = call { <2 x float>, <2 x float>, <2 x float>, <2 x float> } @llvm.aarch64.neon.ld4.v2f32.p0(ptr [[A]])
// CHECK-NEXT:    [[TMP6:%.*]] = ptrtoint ptr [[__RET]] to i64
// CHECK-NEXT:    [[TMP7:%.*]] = xor i64 [[TMP6]], 193514046488576
// CHECK-NEXT:    [[TMP8:%.*]] = inttoptr i64 [[TMP7]] to ptr
// CHECK-NEXT:    store { <2 x i32>, <2 x i32>, <2 x i32>, <2 x i32> } zeroinitializer, ptr [[TMP8]], align 8
// CHECK-NEXT:    store { <2 x float>, <2 x float>, <2 x float>, <2 x float> } [[VLD4]], ptr [[__RET]], align 8
// CHECK-NEXT:    [[TMP9:%.*]] = call ptr @__msan_memcpy(ptr [[RETVAL]], ptr [[__RET]], i64 32)
// CHECK-NEXT:    [[TMP10:%.*]] = load [[STRUCT_FLOAT32X2X4_T]], ptr [[RETVAL]], align 8
// CHECK-NEXT:    store { [4 x <2 x i32>] } zeroinitializer, ptr @__msan_retval_tls, align 8
// CHECK-NEXT:    ret [[STRUCT_FLOAT32X2X4_T]] [[TMP10]]
//
float32x2x4_t test_vld4_f32(float32_t const *a) {
  return vld4_f32(a);
}

// CHECK-LABEL: define dso_local %struct.float64x1x4_t @test_vld4_f64(
// CHECK-SAME: ptr noundef [[A:%.*]]) #[[ATTR0]] {
// CHECK-NEXT:  entry:
// CHECK-NEXT:    call void @llvm.donothing()
// CHECK-NEXT:    [[RETVAL:%.*]] = alloca [[STRUCT_FLOAT64X1X4_T:%.*]], align 8
// CHECK-NEXT:    [[TMP0:%.*]] = ptrtoint ptr [[RETVAL]] to i64
// CHECK-NEXT:    [[TMP1:%.*]] = xor i64 [[TMP0]], 193514046488576
// CHECK-NEXT:    [[TMP2:%.*]] = inttoptr i64 [[TMP1]] to ptr
// CHECK-NEXT:    call void @llvm.memset.p0.i64(ptr align 8 [[TMP2]], i8 0, i64 32, i1 false)
// CHECK-NEXT:    [[__RET:%.*]] = alloca [[STRUCT_FLOAT64X1X4_T]], align 8
// CHECK-NEXT:    [[TMP3:%.*]] = ptrtoint ptr [[__RET]] to i64
// CHECK-NEXT:    [[TMP4:%.*]] = xor i64 [[TMP3]], 193514046488576
// CHECK-NEXT:    [[TMP5:%.*]] = inttoptr i64 [[TMP4]] to ptr
// CHECK-NEXT:    call void @llvm.memset.p0.i64(ptr align 8 [[TMP5]], i8 0, i64 32, i1 false)
// CHECK-NEXT:    [[VLD4:%.*]] = call { <1 x double>, <1 x double>, <1 x double>, <1 x double> } @llvm.aarch64.neon.ld4.v1f64.p0(ptr [[A]])
// CHECK-NEXT:    [[TMP6:%.*]] = ptrtoint ptr [[__RET]] to i64
// CHECK-NEXT:    [[TMP7:%.*]] = xor i64 [[TMP6]], 193514046488576
// CHECK-NEXT:    [[TMP8:%.*]] = inttoptr i64 [[TMP7]] to ptr
// CHECK-NEXT:    store { <1 x i64>, <1 x i64>, <1 x i64>, <1 x i64> } zeroinitializer, ptr [[TMP8]], align 8
// CHECK-NEXT:    store { <1 x double>, <1 x double>, <1 x double>, <1 x double> } [[VLD4]], ptr [[__RET]], align 8
// CHECK-NEXT:    [[TMP9:%.*]] = call ptr @__msan_memcpy(ptr [[RETVAL]], ptr [[__RET]], i64 32)
// CHECK-NEXT:    [[TMP10:%.*]] = load [[STRUCT_FLOAT64X1X4_T]], ptr [[RETVAL]], align 8
// CHECK-NEXT:    store { [4 x <1 x i64>] } zeroinitializer, ptr @__msan_retval_tls, align 8
// CHECK-NEXT:    ret [[STRUCT_FLOAT64X1X4_T]] [[TMP10]]
//
float64x1x4_t test_vld4_f64(float64_t const *a) {
  return vld4_f64(a);
}

// CHECK-LABEL: define dso_local %struct.poly8x8x4_t @test_vld4_p8(
// CHECK-SAME: ptr noundef [[A:%.*]]) #[[ATTR0]] {
// CHECK-NEXT:  entry:
// CHECK-NEXT:    call void @llvm.donothing()
// CHECK-NEXT:    [[RETVAL:%.*]] = alloca [[STRUCT_POLY8X8X4_T:%.*]], align 8
// CHECK-NEXT:    [[TMP0:%.*]] = ptrtoint ptr [[RETVAL]] to i64
// CHECK-NEXT:    [[TMP1:%.*]] = xor i64 [[TMP0]], 193514046488576
// CHECK-NEXT:    [[TMP2:%.*]] = inttoptr i64 [[TMP1]] to ptr
// CHECK-NEXT:    call void @llvm.memset.p0.i64(ptr align 8 [[TMP2]], i8 0, i64 32, i1 false)
// CHECK-NEXT:    [[__RET:%.*]] = alloca [[STRUCT_POLY8X8X4_T]], align 8
// CHECK-NEXT:    [[TMP3:%.*]] = ptrtoint ptr [[__RET]] to i64
// CHECK-NEXT:    [[TMP4:%.*]] = xor i64 [[TMP3]], 193514046488576
// CHECK-NEXT:    [[TMP5:%.*]] = inttoptr i64 [[TMP4]] to ptr
// CHECK-NEXT:    call void @llvm.memset.p0.i64(ptr align 8 [[TMP5]], i8 0, i64 32, i1 false)
// CHECK-NEXT:    [[VLD4:%.*]] = call { <8 x i8>, <8 x i8>, <8 x i8>, <8 x i8> } @llvm.aarch64.neon.ld4.v8i8.p0(ptr [[A]])
// CHECK-NEXT:    [[TMP6:%.*]] = ptrtoint ptr [[__RET]] to i64
// CHECK-NEXT:    [[TMP7:%.*]] = xor i64 [[TMP6]], 193514046488576
// CHECK-NEXT:    [[TMP8:%.*]] = inttoptr i64 [[TMP7]] to ptr
// CHECK-NEXT:    store { <8 x i8>, <8 x i8>, <8 x i8>, <8 x i8> } zeroinitializer, ptr [[TMP8]], align 8
// CHECK-NEXT:    store { <8 x i8>, <8 x i8>, <8 x i8>, <8 x i8> } [[VLD4]], ptr [[__RET]], align 8
// CHECK-NEXT:    [[TMP9:%.*]] = call ptr @__msan_memcpy(ptr [[RETVAL]], ptr [[__RET]], i64 32)
// CHECK-NEXT:    [[TMP10:%.*]] = load [[STRUCT_POLY8X8X4_T]], ptr [[RETVAL]], align 8
// CHECK-NEXT:    store { [4 x <8 x i8>] } zeroinitializer, ptr @__msan_retval_tls, align 8
// CHECK-NEXT:    ret [[STRUCT_POLY8X8X4_T]] [[TMP10]]
//
poly8x8x4_t test_vld4_p8(poly8_t const *a) {
  return vld4_p8(a);
}

// CHECK-LABEL: define dso_local %struct.poly16x4x4_t @test_vld4_p16(
// CHECK-SAME: ptr noundef [[A:%.*]]) #[[ATTR0]] {
// CHECK-NEXT:  entry:
// CHECK-NEXT:    call void @llvm.donothing()
// CHECK-NEXT:    [[RETVAL:%.*]] = alloca [[STRUCT_POLY16X4X4_T:%.*]], align 8
// CHECK-NEXT:    [[TMP0:%.*]] = ptrtoint ptr [[RETVAL]] to i64
// CHECK-NEXT:    [[TMP1:%.*]] = xor i64 [[TMP0]], 193514046488576
// CHECK-NEXT:    [[TMP2:%.*]] = inttoptr i64 [[TMP1]] to ptr
// CHECK-NEXT:    call void @llvm.memset.p0.i64(ptr align 8 [[TMP2]], i8 0, i64 32, i1 false)
// CHECK-NEXT:    [[__RET:%.*]] = alloca [[STRUCT_POLY16X4X4_T]], align 8
// CHECK-NEXT:    [[TMP3:%.*]] = ptrtoint ptr [[__RET]] to i64
// CHECK-NEXT:    [[TMP4:%.*]] = xor i64 [[TMP3]], 193514046488576
// CHECK-NEXT:    [[TMP5:%.*]] = inttoptr i64 [[TMP4]] to ptr
// CHECK-NEXT:    call void @llvm.memset.p0.i64(ptr align 8 [[TMP5]], i8 0, i64 32, i1 false)
// CHECK-NEXT:    [[VLD4:%.*]] = call { <4 x i16>, <4 x i16>, <4 x i16>, <4 x i16> } @llvm.aarch64.neon.ld4.v4i16.p0(ptr [[A]])
// CHECK-NEXT:    [[TMP6:%.*]] = ptrtoint ptr [[__RET]] to i64
// CHECK-NEXT:    [[TMP7:%.*]] = xor i64 [[TMP6]], 193514046488576
// CHECK-NEXT:    [[TMP8:%.*]] = inttoptr i64 [[TMP7]] to ptr
// CHECK-NEXT:    store { <4 x i16>, <4 x i16>, <4 x i16>, <4 x i16> } zeroinitializer, ptr [[TMP8]], align 8
// CHECK-NEXT:    store { <4 x i16>, <4 x i16>, <4 x i16>, <4 x i16> } [[VLD4]], ptr [[__RET]], align 8
// CHECK-NEXT:    [[TMP9:%.*]] = call ptr @__msan_memcpy(ptr [[RETVAL]], ptr [[__RET]], i64 32)
// CHECK-NEXT:    [[TMP10:%.*]] = load [[STRUCT_POLY16X4X4_T]], ptr [[RETVAL]], align 8
// CHECK-NEXT:    store { [4 x <4 x i16>] } zeroinitializer, ptr @__msan_retval_tls, align 8
// CHECK-NEXT:    ret [[STRUCT_POLY16X4X4_T]] [[TMP10]]
//
poly16x4x4_t test_vld4_p16(poly16_t const *a) {
  return vld4_p16(a);
}

// CHECK-LABEL: define dso_local void @test_vst1q_u8(
// CHECK-SAME: ptr noundef [[A:%.*]], <16 x i8> noundef [[B:%.*]]) #[[ATTR0]] {
// CHECK-NEXT:  entry:
// CHECK-NEXT:    call void @llvm.donothing()
// CHECK-NEXT:    [[TMP0:%.*]] = ptrtoint ptr [[A]] to i64
// CHECK-NEXT:    [[TMP1:%.*]] = xor i64 [[TMP0]], 193514046488576
// CHECK-NEXT:    [[TMP2:%.*]] = inttoptr i64 [[TMP1]] to ptr
// CHECK-NEXT:    store <16 x i8> zeroinitializer, ptr [[TMP2]], align 1
// CHECK-NEXT:    store <16 x i8> [[B]], ptr [[A]], align 1
// CHECK-NEXT:    ret void
//
void test_vst1q_u8(uint8_t *a, uint8x16_t b) {
  vst1q_u8(a, b);
}

// CHECK-LABEL: define dso_local void @test_vst1q_u16(
// CHECK-SAME: ptr noundef [[A:%.*]], <8 x i16> noundef [[B:%.*]]) #[[ATTR0]] {
// CHECK-NEXT:  entry:
// CHECK-NEXT:    call void @llvm.donothing()
// CHECK-NEXT:    [[TMP0:%.*]] = bitcast <8 x i16> [[B]] to <16 x i8>
// CHECK-NEXT:    [[TMP1:%.*]] = bitcast <16 x i8> [[TMP0]] to <8 x i16>
// CHECK-NEXT:    [[TMP2:%.*]] = ptrtoint ptr [[A]] to i64
// CHECK-NEXT:    [[TMP3:%.*]] = xor i64 [[TMP2]], 193514046488576
// CHECK-NEXT:    [[TMP4:%.*]] = inttoptr i64 [[TMP3]] to ptr
// CHECK-NEXT:    store <8 x i16> zeroinitializer, ptr [[TMP4]], align 2
// CHECK-NEXT:    store <8 x i16> [[TMP1]], ptr [[A]], align 2
// CHECK-NEXT:    ret void
//
void test_vst1q_u16(uint16_t *a, uint16x8_t b) {
  vst1q_u16(a, b);
}

// CHECK-LABEL: define dso_local void @test_vst1q_u32(
// CHECK-SAME: ptr noundef [[A:%.*]], <4 x i32> noundef [[B:%.*]]) #[[ATTR0]] {
// CHECK-NEXT:  entry:
// CHECK-NEXT:    call void @llvm.donothing()
// CHECK-NEXT:    [[TMP0:%.*]] = bitcast <4 x i32> [[B]] to <16 x i8>
// CHECK-NEXT:    [[TMP1:%.*]] = bitcast <16 x i8> [[TMP0]] to <4 x i32>
// CHECK-NEXT:    [[TMP2:%.*]] = ptrtoint ptr [[A]] to i64
// CHECK-NEXT:    [[TMP3:%.*]] = xor i64 [[TMP2]], 193514046488576
// CHECK-NEXT:    [[TMP4:%.*]] = inttoptr i64 [[TMP3]] to ptr
// CHECK-NEXT:    store <4 x i32> zeroinitializer, ptr [[TMP4]], align 4
// CHECK-NEXT:    store <4 x i32> [[TMP1]], ptr [[A]], align 4
// CHECK-NEXT:    ret void
//
void test_vst1q_u32(uint32_t *a, uint32x4_t b) {
  vst1q_u32(a, b);
}

// CHECK-LABEL: define dso_local void @test_vst1q_u64(
// CHECK-SAME: ptr noundef [[A:%.*]], <2 x i64> noundef [[B:%.*]]) #[[ATTR0]] {
// CHECK-NEXT:  entry:
// CHECK-NEXT:    call void @llvm.donothing()
// CHECK-NEXT:    [[TMP0:%.*]] = bitcast <2 x i64> [[B]] to <16 x i8>
// CHECK-NEXT:    [[TMP1:%.*]] = bitcast <16 x i8> [[TMP0]] to <2 x i64>
// CHECK-NEXT:    [[TMP2:%.*]] = ptrtoint ptr [[A]] to i64
// CHECK-NEXT:    [[TMP3:%.*]] = xor i64 [[TMP2]], 193514046488576
// CHECK-NEXT:    [[TMP4:%.*]] = inttoptr i64 [[TMP3]] to ptr
// CHECK-NEXT:    store <2 x i64> zeroinitializer, ptr [[TMP4]], align 8
// CHECK-NEXT:    store <2 x i64> [[TMP1]], ptr [[A]], align 8
// CHECK-NEXT:    ret void
//
void test_vst1q_u64(uint64_t *a, uint64x2_t b) {
  vst1q_u64(a, b);
}

// CHECK-LABEL: define dso_local void @test_vst1q_s8(
// CHECK-SAME: ptr noundef [[A:%.*]], <16 x i8> noundef [[B:%.*]]) #[[ATTR0]] {
// CHECK-NEXT:  entry:
// CHECK-NEXT:    call void @llvm.donothing()
// CHECK-NEXT:    [[TMP0:%.*]] = ptrtoint ptr [[A]] to i64
// CHECK-NEXT:    [[TMP1:%.*]] = xor i64 [[TMP0]], 193514046488576
// CHECK-NEXT:    [[TMP2:%.*]] = inttoptr i64 [[TMP1]] to ptr
// CHECK-NEXT:    store <16 x i8> zeroinitializer, ptr [[TMP2]], align 1
// CHECK-NEXT:    store <16 x i8> [[B]], ptr [[A]], align 1
// CHECK-NEXT:    ret void
//
void test_vst1q_s8(int8_t *a, int8x16_t b) {
  vst1q_s8(a, b);
}

// CHECK-LABEL: define dso_local void @test_vst1q_s16(
// CHECK-SAME: ptr noundef [[A:%.*]], <8 x i16> noundef [[B:%.*]]) #[[ATTR0]] {
// CHECK-NEXT:  entry:
// CHECK-NEXT:    call void @llvm.donothing()
// CHECK-NEXT:    [[TMP0:%.*]] = bitcast <8 x i16> [[B]] to <16 x i8>
// CHECK-NEXT:    [[TMP1:%.*]] = bitcast <16 x i8> [[TMP0]] to <8 x i16>
// CHECK-NEXT:    [[TMP2:%.*]] = ptrtoint ptr [[A]] to i64
// CHECK-NEXT:    [[TMP3:%.*]] = xor i64 [[TMP2]], 193514046488576
// CHECK-NEXT:    [[TMP4:%.*]] = inttoptr i64 [[TMP3]] to ptr
// CHECK-NEXT:    store <8 x i16> zeroinitializer, ptr [[TMP4]], align 2
// CHECK-NEXT:    store <8 x i16> [[TMP1]], ptr [[A]], align 2
// CHECK-NEXT:    ret void
//
void test_vst1q_s16(int16_t *a, int16x8_t b) {
  vst1q_s16(a, b);
}

// CHECK-LABEL: define dso_local void @test_vst1q_s32(
// CHECK-SAME: ptr noundef [[A:%.*]], <4 x i32> noundef [[B:%.*]]) #[[ATTR0]] {
// CHECK-NEXT:  entry:
// CHECK-NEXT:    call void @llvm.donothing()
// CHECK-NEXT:    [[TMP0:%.*]] = bitcast <4 x i32> [[B]] to <16 x i8>
// CHECK-NEXT:    [[TMP1:%.*]] = bitcast <16 x i8> [[TMP0]] to <4 x i32>
// CHECK-NEXT:    [[TMP2:%.*]] = ptrtoint ptr [[A]] to i64
// CHECK-NEXT:    [[TMP3:%.*]] = xor i64 [[TMP2]], 193514046488576
// CHECK-NEXT:    [[TMP4:%.*]] = inttoptr i64 [[TMP3]] to ptr
// CHECK-NEXT:    store <4 x i32> zeroinitializer, ptr [[TMP4]], align 4
// CHECK-NEXT:    store <4 x i32> [[TMP1]], ptr [[A]], align 4
// CHECK-NEXT:    ret void
//
void test_vst1q_s32(int32_t *a, int32x4_t b) {
  vst1q_s32(a, b);
}

// CHECK-LABEL: define dso_local void @test_vst1q_s64(
// CHECK-SAME: ptr noundef [[A:%.*]], <2 x i64> noundef [[B:%.*]]) #[[ATTR0]] {
// CHECK-NEXT:  entry:
// CHECK-NEXT:    call void @llvm.donothing()
// CHECK-NEXT:    [[TMP0:%.*]] = bitcast <2 x i64> [[B]] to <16 x i8>
// CHECK-NEXT:    [[TMP1:%.*]] = bitcast <16 x i8> [[TMP0]] to <2 x i64>
// CHECK-NEXT:    [[TMP2:%.*]] = ptrtoint ptr [[A]] to i64
// CHECK-NEXT:    [[TMP3:%.*]] = xor i64 [[TMP2]], 193514046488576
// CHECK-NEXT:    [[TMP4:%.*]] = inttoptr i64 [[TMP3]] to ptr
// CHECK-NEXT:    store <2 x i64> zeroinitializer, ptr [[TMP4]], align 8
// CHECK-NEXT:    store <2 x i64> [[TMP1]], ptr [[A]], align 8
// CHECK-NEXT:    ret void
//
void test_vst1q_s64(int64_t *a, int64x2_t b) {
  vst1q_s64(a, b);
}

// CHECK-LABEL: define dso_local void @test_vst1q_f16(
// CHECK-SAME: ptr noundef [[A:%.*]], <8 x half> noundef [[B:%.*]]) #[[ATTR0]] {
// CHECK-NEXT:  entry:
// CHECK-NEXT:    call void @llvm.donothing()
// CHECK-NEXT:    [[TMP0:%.*]] = bitcast <8 x half> [[B]] to <16 x i8>
// CHECK-NEXT:    [[TMP1:%.*]] = bitcast <16 x i8> [[TMP0]] to <8 x half>
// CHECK-NEXT:    [[TMP2:%.*]] = ptrtoint ptr [[A]] to i64
// CHECK-NEXT:    [[TMP3:%.*]] = xor i64 [[TMP2]], 193514046488576
// CHECK-NEXT:    [[TMP4:%.*]] = inttoptr i64 [[TMP3]] to ptr
// CHECK-NEXT:    store <8 x i16> zeroinitializer, ptr [[TMP4]], align 2
// CHECK-NEXT:    store <8 x half> [[TMP1]], ptr [[A]], align 2
// CHECK-NEXT:    ret void
//
void test_vst1q_f16(float16_t *a, float16x8_t b) {
  vst1q_f16(a, b);
}

// CHECK-LABEL: define dso_local void @test_vst1q_f32(
// CHECK-SAME: ptr noundef [[A:%.*]], <4 x float> noundef [[B:%.*]]) #[[ATTR0]] {
// CHECK-NEXT:  entry:
// CHECK-NEXT:    call void @llvm.donothing()
// CHECK-NEXT:    [[TMP0:%.*]] = bitcast <4 x float> [[B]] to <16 x i8>
// CHECK-NEXT:    [[TMP1:%.*]] = bitcast <16 x i8> [[TMP0]] to <4 x float>
// CHECK-NEXT:    [[TMP2:%.*]] = ptrtoint ptr [[A]] to i64
// CHECK-NEXT:    [[TMP3:%.*]] = xor i64 [[TMP2]], 193514046488576
// CHECK-NEXT:    [[TMP4:%.*]] = inttoptr i64 [[TMP3]] to ptr
// CHECK-NEXT:    store <4 x i32> zeroinitializer, ptr [[TMP4]], align 4
// CHECK-NEXT:    store <4 x float> [[TMP1]], ptr [[A]], align 4
// CHECK-NEXT:    ret void
//
void test_vst1q_f32(float32_t *a, float32x4_t b) {
  vst1q_f32(a, b);
}

// CHECK-LABEL: define dso_local void @test_vst1q_f64(
// CHECK-SAME: ptr noundef [[A:%.*]], <2 x double> noundef [[B:%.*]]) #[[ATTR0]] {
// CHECK-NEXT:  entry:
// CHECK-NEXT:    call void @llvm.donothing()
// CHECK-NEXT:    [[TMP0:%.*]] = bitcast <2 x double> [[B]] to <16 x i8>
// CHECK-NEXT:    [[TMP1:%.*]] = bitcast <16 x i8> [[TMP0]] to <2 x double>
// CHECK-NEXT:    [[TMP2:%.*]] = ptrtoint ptr [[A]] to i64
// CHECK-NEXT:    [[TMP3:%.*]] = xor i64 [[TMP2]], 193514046488576
// CHECK-NEXT:    [[TMP4:%.*]] = inttoptr i64 [[TMP3]] to ptr
// CHECK-NEXT:    store <2 x i64> zeroinitializer, ptr [[TMP4]], align 8
// CHECK-NEXT:    store <2 x double> [[TMP1]], ptr [[A]], align 8
// CHECK-NEXT:    ret void
//
void test_vst1q_f64(float64_t *a, float64x2_t b) {
  vst1q_f64(a, b);
}

// CHECK-LABEL: define dso_local void @test_vst1q_p8(
// CHECK-SAME: ptr noundef [[A:%.*]], <16 x i8> noundef [[B:%.*]]) #[[ATTR0]] {
// CHECK-NEXT:  entry:
// CHECK-NEXT:    call void @llvm.donothing()
// CHECK-NEXT:    [[TMP0:%.*]] = ptrtoint ptr [[A]] to i64
// CHECK-NEXT:    [[TMP1:%.*]] = xor i64 [[TMP0]], 193514046488576
// CHECK-NEXT:    [[TMP2:%.*]] = inttoptr i64 [[TMP1]] to ptr
// CHECK-NEXT:    store <16 x i8> zeroinitializer, ptr [[TMP2]], align 1
// CHECK-NEXT:    store <16 x i8> [[B]], ptr [[A]], align 1
// CHECK-NEXT:    ret void
//
void test_vst1q_p8(poly8_t *a, poly8x16_t b) {
  vst1q_p8(a, b);
}

// CHECK-LABEL: define dso_local void @test_vst1q_p16(
// CHECK-SAME: ptr noundef [[A:%.*]], <8 x i16> noundef [[B:%.*]]) #[[ATTR0]] {
// CHECK-NEXT:  entry:
// CHECK-NEXT:    call void @llvm.donothing()
// CHECK-NEXT:    [[TMP0:%.*]] = bitcast <8 x i16> [[B]] to <16 x i8>
// CHECK-NEXT:    [[TMP1:%.*]] = bitcast <16 x i8> [[TMP0]] to <8 x i16>
// CHECK-NEXT:    [[TMP2:%.*]] = ptrtoint ptr [[A]] to i64
// CHECK-NEXT:    [[TMP3:%.*]] = xor i64 [[TMP2]], 193514046488576
// CHECK-NEXT:    [[TMP4:%.*]] = inttoptr i64 [[TMP3]] to ptr
// CHECK-NEXT:    store <8 x i16> zeroinitializer, ptr [[TMP4]], align 2
// CHECK-NEXT:    store <8 x i16> [[TMP1]], ptr [[A]], align 2
// CHECK-NEXT:    ret void
//
void test_vst1q_p16(poly16_t *a, poly16x8_t b) {
  vst1q_p16(a, b);
}

// CHECK-LABEL: define dso_local void @test_vst1_u8(
// CHECK-SAME: ptr noundef [[A:%.*]], <8 x i8> noundef [[B:%.*]]) #[[ATTR0]] {
// CHECK-NEXT:  entry:
// CHECK-NEXT:    call void @llvm.donothing()
// CHECK-NEXT:    [[TMP0:%.*]] = ptrtoint ptr [[A]] to i64
// CHECK-NEXT:    [[TMP1:%.*]] = xor i64 [[TMP0]], 193514046488576
// CHECK-NEXT:    [[TMP2:%.*]] = inttoptr i64 [[TMP1]] to ptr
// CHECK-NEXT:    store <8 x i8> zeroinitializer, ptr [[TMP2]], align 1
// CHECK-NEXT:    store <8 x i8> [[B]], ptr [[A]], align 1
// CHECK-NEXT:    ret void
//
void test_vst1_u8(uint8_t *a, uint8x8_t b) {
  vst1_u8(a, b);
}

// CHECK-LABEL: define dso_local void @test_vst1_u16(
// CHECK-SAME: ptr noundef [[A:%.*]], <4 x i16> noundef [[B:%.*]]) #[[ATTR0]] {
// CHECK-NEXT:  entry:
// CHECK-NEXT:    call void @llvm.donothing()
// CHECK-NEXT:    [[TMP0:%.*]] = bitcast <4 x i16> [[B]] to <8 x i8>
// CHECK-NEXT:    [[TMP1:%.*]] = bitcast <8 x i8> [[TMP0]] to <4 x i16>
// CHECK-NEXT:    [[TMP2:%.*]] = ptrtoint ptr [[A]] to i64
// CHECK-NEXT:    [[TMP3:%.*]] = xor i64 [[TMP2]], 193514046488576
// CHECK-NEXT:    [[TMP4:%.*]] = inttoptr i64 [[TMP3]] to ptr
// CHECK-NEXT:    store <4 x i16> zeroinitializer, ptr [[TMP4]], align 2
// CHECK-NEXT:    store <4 x i16> [[TMP1]], ptr [[A]], align 2
// CHECK-NEXT:    ret void
//
void test_vst1_u16(uint16_t *a, uint16x4_t b) {
  vst1_u16(a, b);
}

// CHECK-LABEL: define dso_local void @test_vst1_u32(
// CHECK-SAME: ptr noundef [[A:%.*]], <2 x i32> noundef [[B:%.*]]) #[[ATTR0]] {
// CHECK-NEXT:  entry:
// CHECK-NEXT:    call void @llvm.donothing()
// CHECK-NEXT:    [[TMP0:%.*]] = bitcast <2 x i32> [[B]] to <8 x i8>
// CHECK-NEXT:    [[TMP1:%.*]] = bitcast <8 x i8> [[TMP0]] to <2 x i32>
// CHECK-NEXT:    [[TMP2:%.*]] = ptrtoint ptr [[A]] to i64
// CHECK-NEXT:    [[TMP3:%.*]] = xor i64 [[TMP2]], 193514046488576
// CHECK-NEXT:    [[TMP4:%.*]] = inttoptr i64 [[TMP3]] to ptr
// CHECK-NEXT:    store <2 x i32> zeroinitializer, ptr [[TMP4]], align 4
// CHECK-NEXT:    store <2 x i32> [[TMP1]], ptr [[A]], align 4
// CHECK-NEXT:    ret void
//
void test_vst1_u32(uint32_t *a, uint32x2_t b) {
  vst1_u32(a, b);
}

// CHECK-LABEL: define dso_local void @test_vst1_u64(
// CHECK-SAME: ptr noundef [[A:%.*]], <1 x i64> noundef [[B:%.*]]) #[[ATTR0]] {
// CHECK-NEXT:  entry:
// CHECK-NEXT:    call void @llvm.donothing()
// CHECK-NEXT:    [[TMP0:%.*]] = bitcast <1 x i64> [[B]] to <8 x i8>
// CHECK-NEXT:    [[TMP1:%.*]] = bitcast <8 x i8> [[TMP0]] to <1 x i64>
// CHECK-NEXT:    [[TMP2:%.*]] = ptrtoint ptr [[A]] to i64
// CHECK-NEXT:    [[TMP3:%.*]] = xor i64 [[TMP2]], 193514046488576
// CHECK-NEXT:    [[TMP4:%.*]] = inttoptr i64 [[TMP3]] to ptr
// CHECK-NEXT:    store <1 x i64> zeroinitializer, ptr [[TMP4]], align 8
// CHECK-NEXT:    store <1 x i64> [[TMP1]], ptr [[A]], align 8
// CHECK-NEXT:    ret void
//
void test_vst1_u64(uint64_t *a, uint64x1_t b) {
  vst1_u64(a, b);
}

// CHECK-LABEL: define dso_local void @test_vst1_s8(
// CHECK-SAME: ptr noundef [[A:%.*]], <8 x i8> noundef [[B:%.*]]) #[[ATTR0]] {
// CHECK-NEXT:  entry:
// CHECK-NEXT:    call void @llvm.donothing()
// CHECK-NEXT:    [[TMP0:%.*]] = ptrtoint ptr [[A]] to i64
// CHECK-NEXT:    [[TMP1:%.*]] = xor i64 [[TMP0]], 193514046488576
// CHECK-NEXT:    [[TMP2:%.*]] = inttoptr i64 [[TMP1]] to ptr
// CHECK-NEXT:    store <8 x i8> zeroinitializer, ptr [[TMP2]], align 1
// CHECK-NEXT:    store <8 x i8> [[B]], ptr [[A]], align 1
// CHECK-NEXT:    ret void
//
void test_vst1_s8(int8_t *a, int8x8_t b) {
  vst1_s8(a, b);
}

// CHECK-LABEL: define dso_local void @test_vst1_s16(
// CHECK-SAME: ptr noundef [[A:%.*]], <4 x i16> noundef [[B:%.*]]) #[[ATTR0]] {
// CHECK-NEXT:  entry:
// CHECK-NEXT:    call void @llvm.donothing()
// CHECK-NEXT:    [[TMP0:%.*]] = bitcast <4 x i16> [[B]] to <8 x i8>
// CHECK-NEXT:    [[TMP1:%.*]] = bitcast <8 x i8> [[TMP0]] to <4 x i16>
// CHECK-NEXT:    [[TMP2:%.*]] = ptrtoint ptr [[A]] to i64
// CHECK-NEXT:    [[TMP3:%.*]] = xor i64 [[TMP2]], 193514046488576
// CHECK-NEXT:    [[TMP4:%.*]] = inttoptr i64 [[TMP3]] to ptr
// CHECK-NEXT:    store <4 x i16> zeroinitializer, ptr [[TMP4]], align 2
// CHECK-NEXT:    store <4 x i16> [[TMP1]], ptr [[A]], align 2
// CHECK-NEXT:    ret void
//
void test_vst1_s16(int16_t *a, int16x4_t b) {
  vst1_s16(a, b);
}

// CHECK-LABEL: define dso_local void @test_vst1_s32(
// CHECK-SAME: ptr noundef [[A:%.*]], <2 x i32> noundef [[B:%.*]]) #[[ATTR0]] {
// CHECK-NEXT:  entry:
// CHECK-NEXT:    call void @llvm.donothing()
// CHECK-NEXT:    [[TMP0:%.*]] = bitcast <2 x i32> [[B]] to <8 x i8>
// CHECK-NEXT:    [[TMP1:%.*]] = bitcast <8 x i8> [[TMP0]] to <2 x i32>
// CHECK-NEXT:    [[TMP2:%.*]] = ptrtoint ptr [[A]] to i64
// CHECK-NEXT:    [[TMP3:%.*]] = xor i64 [[TMP2]], 193514046488576
// CHECK-NEXT:    [[TMP4:%.*]] = inttoptr i64 [[TMP3]] to ptr
// CHECK-NEXT:    store <2 x i32> zeroinitializer, ptr [[TMP4]], align 4
// CHECK-NEXT:    store <2 x i32> [[TMP1]], ptr [[A]], align 4
// CHECK-NEXT:    ret void
//
void test_vst1_s32(int32_t *a, int32x2_t b) {
  vst1_s32(a, b);
}

// CHECK-LABEL: define dso_local void @test_vst1_s64(
// CHECK-SAME: ptr noundef [[A:%.*]], <1 x i64> noundef [[B:%.*]]) #[[ATTR0]] {
// CHECK-NEXT:  entry:
// CHECK-NEXT:    call void @llvm.donothing()
// CHECK-NEXT:    [[TMP0:%.*]] = bitcast <1 x i64> [[B]] to <8 x i8>
// CHECK-NEXT:    [[TMP1:%.*]] = bitcast <8 x i8> [[TMP0]] to <1 x i64>
// CHECK-NEXT:    [[TMP2:%.*]] = ptrtoint ptr [[A]] to i64
// CHECK-NEXT:    [[TMP3:%.*]] = xor i64 [[TMP2]], 193514046488576
// CHECK-NEXT:    [[TMP4:%.*]] = inttoptr i64 [[TMP3]] to ptr
// CHECK-NEXT:    store <1 x i64> zeroinitializer, ptr [[TMP4]], align 8
// CHECK-NEXT:    store <1 x i64> [[TMP1]], ptr [[A]], align 8
// CHECK-NEXT:    ret void
//
void test_vst1_s64(int64_t *a, int64x1_t b) {
  vst1_s64(a, b);
}

// CHECK-LABEL: define dso_local void @test_vst1_f16(
// CHECK-SAME: ptr noundef [[A:%.*]], <4 x half> noundef [[B:%.*]]) #[[ATTR0]] {
// CHECK-NEXT:  entry:
// CHECK-NEXT:    call void @llvm.donothing()
// CHECK-NEXT:    [[TMP0:%.*]] = bitcast <4 x half> [[B]] to <8 x i8>
// CHECK-NEXT:    [[TMP1:%.*]] = bitcast <8 x i8> [[TMP0]] to <4 x half>
// CHECK-NEXT:    [[TMP2:%.*]] = ptrtoint ptr [[A]] to i64
// CHECK-NEXT:    [[TMP3:%.*]] = xor i64 [[TMP2]], 193514046488576
// CHECK-NEXT:    [[TMP4:%.*]] = inttoptr i64 [[TMP3]] to ptr
// CHECK-NEXT:    store <4 x i16> zeroinitializer, ptr [[TMP4]], align 2
// CHECK-NEXT:    store <4 x half> [[TMP1]], ptr [[A]], align 2
// CHECK-NEXT:    ret void
//
void test_vst1_f16(float16_t *a, float16x4_t b) {
  vst1_f16(a, b);
}

// CHECK-LABEL: define dso_local void @test_vst1_f32(
// CHECK-SAME: ptr noundef [[A:%.*]], <2 x float> noundef [[B:%.*]]) #[[ATTR0]] {
// CHECK-NEXT:  entry:
// CHECK-NEXT:    call void @llvm.donothing()
// CHECK-NEXT:    [[TMP0:%.*]] = bitcast <2 x float> [[B]] to <8 x i8>
// CHECK-NEXT:    [[TMP1:%.*]] = bitcast <8 x i8> [[TMP0]] to <2 x float>
// CHECK-NEXT:    [[TMP2:%.*]] = ptrtoint ptr [[A]] to i64
// CHECK-NEXT:    [[TMP3:%.*]] = xor i64 [[TMP2]], 193514046488576
// CHECK-NEXT:    [[TMP4:%.*]] = inttoptr i64 [[TMP3]] to ptr
// CHECK-NEXT:    store <2 x i32> zeroinitializer, ptr [[TMP4]], align 4
// CHECK-NEXT:    store <2 x float> [[TMP1]], ptr [[A]], align 4
// CHECK-NEXT:    ret void
//
void test_vst1_f32(float32_t *a, float32x2_t b) {
  vst1_f32(a, b);
}

// CHECK-LABEL: define dso_local void @test_vst1_f64(
// CHECK-SAME: ptr noundef [[A:%.*]], <1 x double> noundef [[B:%.*]]) #[[ATTR0]] {
// CHECK-NEXT:  entry:
// CHECK-NEXT:    call void @llvm.donothing()
// CHECK-NEXT:    [[TMP0:%.*]] = bitcast <1 x double> [[B]] to <8 x i8>
// CHECK-NEXT:    [[TMP1:%.*]] = bitcast <8 x i8> [[TMP0]] to <1 x double>
// CHECK-NEXT:    [[TMP2:%.*]] = ptrtoint ptr [[A]] to i64
// CHECK-NEXT:    [[TMP3:%.*]] = xor i64 [[TMP2]], 193514046488576
// CHECK-NEXT:    [[TMP4:%.*]] = inttoptr i64 [[TMP3]] to ptr
// CHECK-NEXT:    store <1 x i64> zeroinitializer, ptr [[TMP4]], align 8
// CHECK-NEXT:    store <1 x double> [[TMP1]], ptr [[A]], align 8
// CHECK-NEXT:    ret void
//
void test_vst1_f64(float64_t *a, float64x1_t b) {
  vst1_f64(a, b);
}

// CHECK-LABEL: define dso_local void @test_vst1_p8(
// CHECK-SAME: ptr noundef [[A:%.*]], <8 x i8> noundef [[B:%.*]]) #[[ATTR0]] {
// CHECK-NEXT:  entry:
// CHECK-NEXT:    call void @llvm.donothing()
// CHECK-NEXT:    [[TMP0:%.*]] = ptrtoint ptr [[A]] to i64
// CHECK-NEXT:    [[TMP1:%.*]] = xor i64 [[TMP0]], 193514046488576
// CHECK-NEXT:    [[TMP2:%.*]] = inttoptr i64 [[TMP1]] to ptr
// CHECK-NEXT:    store <8 x i8> zeroinitializer, ptr [[TMP2]], align 1
// CHECK-NEXT:    store <8 x i8> [[B]], ptr [[A]], align 1
// CHECK-NEXT:    ret void
//
void test_vst1_p8(poly8_t *a, poly8x8_t b) {
  vst1_p8(a, b);
}

// CHECK-LABEL: define dso_local void @test_vst1_p16(
// CHECK-SAME: ptr noundef [[A:%.*]], <4 x i16> noundef [[B:%.*]]) #[[ATTR0]] {
// CHECK-NEXT:  entry:
// CHECK-NEXT:    call void @llvm.donothing()
// CHECK-NEXT:    [[TMP0:%.*]] = bitcast <4 x i16> [[B]] to <8 x i8>
// CHECK-NEXT:    [[TMP1:%.*]] = bitcast <8 x i8> [[TMP0]] to <4 x i16>
// CHECK-NEXT:    [[TMP2:%.*]] = ptrtoint ptr [[A]] to i64
// CHECK-NEXT:    [[TMP3:%.*]] = xor i64 [[TMP2]], 193514046488576
// CHECK-NEXT:    [[TMP4:%.*]] = inttoptr i64 [[TMP3]] to ptr
// CHECK-NEXT:    store <4 x i16> zeroinitializer, ptr [[TMP4]], align 2
// CHECK-NEXT:    store <4 x i16> [[TMP1]], ptr [[A]], align 2
// CHECK-NEXT:    ret void
//
void test_vst1_p16(poly16_t *a, poly16x4_t b) {
  vst1_p16(a, b);
}

// CHECK-LABEL: define dso_local void @test_vst2q_u8(
// CHECK-SAME: ptr noundef [[A:%.*]], [2 x <16 x i8>] alignstack(16) [[B_COERCE:%.*]]) #[[ATTR0]] {
// CHECK-NEXT:  entry:
// CHECK-NEXT:    call void @llvm.donothing()
// CHECK-NEXT:    [[B:%.*]] = alloca [[STRUCT_UINT8X16X2_T:%.*]], align 16
// CHECK-NEXT:    [[TMP0:%.*]] = ptrtoint ptr [[B]] to i64
// CHECK-NEXT:    [[TMP1:%.*]] = xor i64 [[TMP0]], 193514046488576
// CHECK-NEXT:    [[TMP2:%.*]] = inttoptr i64 [[TMP1]] to ptr
// CHECK-NEXT:    call void @llvm.memset.p0.i64(ptr align 16 [[TMP2]], i8 0, i64 32, i1 false)
// CHECK-NEXT:    [[__S1:%.*]] = alloca [[STRUCT_UINT8X16X2_T]], align 16
// CHECK-NEXT:    [[TMP3:%.*]] = ptrtoint ptr [[__S1]] to i64
// CHECK-NEXT:    [[TMP4:%.*]] = xor i64 [[TMP3]], 193514046488576
// CHECK-NEXT:    [[TMP5:%.*]] = inttoptr i64 [[TMP4]] to ptr
// CHECK-NEXT:    call void @llvm.memset.p0.i64(ptr align 16 [[TMP5]], i8 0, i64 32, i1 false)
// CHECK-NEXT:    [[COERCE_DIVE:%.*]] = getelementptr inbounds [[STRUCT_UINT8X16X2_T]], ptr [[B]], i32 0, i32 0
// CHECK-NEXT:    [[TMP6:%.*]] = ptrtoint ptr [[COERCE_DIVE]] to i64
// CHECK-NEXT:    [[TMP7:%.*]] = xor i64 [[TMP6]], 193514046488576
// CHECK-NEXT:    [[TMP8:%.*]] = inttoptr i64 [[TMP7]] to ptr
// CHECK-NEXT:    store [2 x <16 x i8>] zeroinitializer, ptr [[TMP8]], align 16
// CHECK-NEXT:    store [2 x <16 x i8>] [[B_COERCE]], ptr [[COERCE_DIVE]], align 16
// CHECK-NEXT:    [[TMP9:%.*]] = call ptr @__msan_memcpy(ptr [[__S1]], ptr [[B]], i64 32)
// CHECK-NEXT:    [[VAL:%.*]] = getelementptr inbounds [[STRUCT_UINT8X16X2_T]], ptr [[__S1]], i32 0, i32 0
// CHECK-NEXT:    [[ARRAYIDX:%.*]] = getelementptr inbounds [2 x <16 x i8>], ptr [[VAL]], i64 0, i64 0
// CHECK-NEXT:    [[TMP10:%.*]] = load <16 x i8>, ptr [[ARRAYIDX]], align 16
// CHECK-NEXT:    [[VAL1:%.*]] = getelementptr inbounds [[STRUCT_UINT8X16X2_T]], ptr [[__S1]], i32 0, i32 0
// CHECK-NEXT:    [[ARRAYIDX2:%.*]] = getelementptr inbounds [2 x <16 x i8>], ptr [[VAL1]], i64 0, i64 1
// CHECK-NEXT:    [[TMP11:%.*]] = load <16 x i8>, ptr [[ARRAYIDX2]], align 16
// CHECK-NEXT:    [[TMP12:%.*]] = ptrtoint ptr [[A]] to i64
// CHECK-NEXT:    [[TMP13:%.*]] = xor i64 [[TMP12]], 193514046488576
// CHECK-NEXT:    [[TMP14:%.*]] = inttoptr i64 [[TMP13]] to ptr
// CHECK-NEXT:    store <32 x i8> zeroinitializer, ptr [[TMP14]], align 1
// CHECK-NEXT:    call void @llvm.aarch64.neon.st2.v16i8.p0(<16 x i8> [[TMP10]], <16 x i8> [[TMP11]], ptr [[A]])
// CHECK-NEXT:    ret void
//
void test_vst2q_u8(uint8_t *a, uint8x16x2_t b) {
  vst2q_u8(a, b);
}

// CHECK-LABEL: define dso_local void @test_vst2q_u16(
// CHECK-SAME: ptr noundef [[A:%.*]], [2 x <8 x i16>] alignstack(16) [[B_COERCE:%.*]]) #[[ATTR0]] {
// CHECK-NEXT:  entry:
// CHECK-NEXT:    call void @llvm.donothing()
// CHECK-NEXT:    [[B:%.*]] = alloca [[STRUCT_UINT16X8X2_T:%.*]], align 16
// CHECK-NEXT:    [[TMP0:%.*]] = ptrtoint ptr [[B]] to i64
// CHECK-NEXT:    [[TMP1:%.*]] = xor i64 [[TMP0]], 193514046488576
// CHECK-NEXT:    [[TMP2:%.*]] = inttoptr i64 [[TMP1]] to ptr
// CHECK-NEXT:    call void @llvm.memset.p0.i64(ptr align 16 [[TMP2]], i8 0, i64 32, i1 false)
// CHECK-NEXT:    [[__S1:%.*]] = alloca [[STRUCT_UINT16X8X2_T]], align 16
// CHECK-NEXT:    [[TMP3:%.*]] = ptrtoint ptr [[__S1]] to i64
// CHECK-NEXT:    [[TMP4:%.*]] = xor i64 [[TMP3]], 193514046488576
// CHECK-NEXT:    [[TMP5:%.*]] = inttoptr i64 [[TMP4]] to ptr
// CHECK-NEXT:    call void @llvm.memset.p0.i64(ptr align 16 [[TMP5]], i8 0, i64 32, i1 false)
// CHECK-NEXT:    [[COERCE_DIVE:%.*]] = getelementptr inbounds [[STRUCT_UINT16X8X2_T]], ptr [[B]], i32 0, i32 0
// CHECK-NEXT:    [[TMP6:%.*]] = ptrtoint ptr [[COERCE_DIVE]] to i64
// CHECK-NEXT:    [[TMP7:%.*]] = xor i64 [[TMP6]], 193514046488576
// CHECK-NEXT:    [[TMP8:%.*]] = inttoptr i64 [[TMP7]] to ptr
// CHECK-NEXT:    store [2 x <8 x i16>] zeroinitializer, ptr [[TMP8]], align 16
// CHECK-NEXT:    store [2 x <8 x i16>] [[B_COERCE]], ptr [[COERCE_DIVE]], align 16
// CHECK-NEXT:    [[TMP9:%.*]] = call ptr @__msan_memcpy(ptr [[__S1]], ptr [[B]], i64 32)
// CHECK-NEXT:    [[VAL:%.*]] = getelementptr inbounds [[STRUCT_UINT16X8X2_T]], ptr [[__S1]], i32 0, i32 0
// CHECK-NEXT:    [[ARRAYIDX:%.*]] = getelementptr inbounds [2 x <8 x i16>], ptr [[VAL]], i64 0, i64 0
// CHECK-NEXT:    [[TMP10:%.*]] = load <8 x i16>, ptr [[ARRAYIDX]], align 16
// CHECK-NEXT:    [[TMP11:%.*]] = bitcast <8 x i16> [[TMP10]] to <16 x i8>
// CHECK-NEXT:    [[VAL1:%.*]] = getelementptr inbounds [[STRUCT_UINT16X8X2_T]], ptr [[__S1]], i32 0, i32 0
// CHECK-NEXT:    [[ARRAYIDX2:%.*]] = getelementptr inbounds [2 x <8 x i16>], ptr [[VAL1]], i64 0, i64 1
// CHECK-NEXT:    [[TMP12:%.*]] = load <8 x i16>, ptr [[ARRAYIDX2]], align 16
// CHECK-NEXT:    [[TMP13:%.*]] = bitcast <8 x i16> [[TMP12]] to <16 x i8>
// CHECK-NEXT:    [[TMP14:%.*]] = bitcast <16 x i8> [[TMP11]] to <8 x i16>
// CHECK-NEXT:    [[TMP15:%.*]] = bitcast <16 x i8> [[TMP13]] to <8 x i16>
// CHECK-NEXT:    [[TMP16:%.*]] = ptrtoint ptr [[A]] to i64
// CHECK-NEXT:    [[TMP17:%.*]] = xor i64 [[TMP16]], 193514046488576
// CHECK-NEXT:    [[TMP18:%.*]] = inttoptr i64 [[TMP17]] to ptr
// CHECK-NEXT:    store <16 x i16> zeroinitializer, ptr [[TMP18]], align 1
// CHECK-NEXT:    call void @llvm.aarch64.neon.st2.v8i16.p0(<8 x i16> [[TMP14]], <8 x i16> [[TMP15]], ptr [[A]])
// CHECK-NEXT:    ret void
//
void test_vst2q_u16(uint16_t *a, uint16x8x2_t b) {
  vst2q_u16(a, b);
}

// CHECK-LABEL: define dso_local void @test_vst2q_u32(
// CHECK-SAME: ptr noundef [[A:%.*]], [2 x <4 x i32>] alignstack(16) [[B_COERCE:%.*]]) #[[ATTR0]] {
// CHECK-NEXT:  entry:
// CHECK-NEXT:    call void @llvm.donothing()
// CHECK-NEXT:    [[B:%.*]] = alloca [[STRUCT_UINT32X4X2_T:%.*]], align 16
// CHECK-NEXT:    [[TMP0:%.*]] = ptrtoint ptr [[B]] to i64
// CHECK-NEXT:    [[TMP1:%.*]] = xor i64 [[TMP0]], 193514046488576
// CHECK-NEXT:    [[TMP2:%.*]] = inttoptr i64 [[TMP1]] to ptr
// CHECK-NEXT:    call void @llvm.memset.p0.i64(ptr align 16 [[TMP2]], i8 0, i64 32, i1 false)
// CHECK-NEXT:    [[__S1:%.*]] = alloca [[STRUCT_UINT32X4X2_T]], align 16
// CHECK-NEXT:    [[TMP3:%.*]] = ptrtoint ptr [[__S1]] to i64
// CHECK-NEXT:    [[TMP4:%.*]] = xor i64 [[TMP3]], 193514046488576
// CHECK-NEXT:    [[TMP5:%.*]] = inttoptr i64 [[TMP4]] to ptr
// CHECK-NEXT:    call void @llvm.memset.p0.i64(ptr align 16 [[TMP5]], i8 0, i64 32, i1 false)
// CHECK-NEXT:    [[COERCE_DIVE:%.*]] = getelementptr inbounds [[STRUCT_UINT32X4X2_T]], ptr [[B]], i32 0, i32 0
// CHECK-NEXT:    [[TMP6:%.*]] = ptrtoint ptr [[COERCE_DIVE]] to i64
// CHECK-NEXT:    [[TMP7:%.*]] = xor i64 [[TMP6]], 193514046488576
// CHECK-NEXT:    [[TMP8:%.*]] = inttoptr i64 [[TMP7]] to ptr
// CHECK-NEXT:    store [2 x <4 x i32>] zeroinitializer, ptr [[TMP8]], align 16
// CHECK-NEXT:    store [2 x <4 x i32>] [[B_COERCE]], ptr [[COERCE_DIVE]], align 16
// CHECK-NEXT:    [[TMP9:%.*]] = call ptr @__msan_memcpy(ptr [[__S1]], ptr [[B]], i64 32)
// CHECK-NEXT:    [[VAL:%.*]] = getelementptr inbounds [[STRUCT_UINT32X4X2_T]], ptr [[__S1]], i32 0, i32 0
// CHECK-NEXT:    [[ARRAYIDX:%.*]] = getelementptr inbounds [2 x <4 x i32>], ptr [[VAL]], i64 0, i64 0
// CHECK-NEXT:    [[TMP10:%.*]] = load <4 x i32>, ptr [[ARRAYIDX]], align 16
// CHECK-NEXT:    [[TMP11:%.*]] = bitcast <4 x i32> [[TMP10]] to <16 x i8>
// CHECK-NEXT:    [[VAL1:%.*]] = getelementptr inbounds [[STRUCT_UINT32X4X2_T]], ptr [[__S1]], i32 0, i32 0
// CHECK-NEXT:    [[ARRAYIDX2:%.*]] = getelementptr inbounds [2 x <4 x i32>], ptr [[VAL1]], i64 0, i64 1
// CHECK-NEXT:    [[TMP12:%.*]] = load <4 x i32>, ptr [[ARRAYIDX2]], align 16
// CHECK-NEXT:    [[TMP13:%.*]] = bitcast <4 x i32> [[TMP12]] to <16 x i8>
// CHECK-NEXT:    [[TMP14:%.*]] = bitcast <16 x i8> [[TMP11]] to <4 x i32>
// CHECK-NEXT:    [[TMP15:%.*]] = bitcast <16 x i8> [[TMP13]] to <4 x i32>
// CHECK-NEXT:    [[TMP16:%.*]] = ptrtoint ptr [[A]] to i64
// CHECK-NEXT:    [[TMP17:%.*]] = xor i64 [[TMP16]], 193514046488576
// CHECK-NEXT:    [[TMP18:%.*]] = inttoptr i64 [[TMP17]] to ptr
// CHECK-NEXT:    store <8 x i32> zeroinitializer, ptr [[TMP18]], align 1
// CHECK-NEXT:    call void @llvm.aarch64.neon.st2.v4i32.p0(<4 x i32> [[TMP14]], <4 x i32> [[TMP15]], ptr [[A]])
// CHECK-NEXT:    ret void
//
void test_vst2q_u32(uint32_t *a, uint32x4x2_t b) {
  vst2q_u32(a, b);
}

// CHECK-LABEL: define dso_local void @test_vst2q_u64(
// CHECK-SAME: ptr noundef [[A:%.*]], [2 x <2 x i64>] alignstack(16) [[B_COERCE:%.*]]) #[[ATTR0]] {
// CHECK-NEXT:  entry:
// CHECK-NEXT:    call void @llvm.donothing()
// CHECK-NEXT:    [[B:%.*]] = alloca [[STRUCT_UINT64X2X2_T:%.*]], align 16
// CHECK-NEXT:    [[TMP0:%.*]] = ptrtoint ptr [[B]] to i64
// CHECK-NEXT:    [[TMP1:%.*]] = xor i64 [[TMP0]], 193514046488576
// CHECK-NEXT:    [[TMP2:%.*]] = inttoptr i64 [[TMP1]] to ptr
// CHECK-NEXT:    call void @llvm.memset.p0.i64(ptr align 16 [[TMP2]], i8 0, i64 32, i1 false)
// CHECK-NEXT:    [[__S1:%.*]] = alloca [[STRUCT_UINT64X2X2_T]], align 16
// CHECK-NEXT:    [[TMP3:%.*]] = ptrtoint ptr [[__S1]] to i64
// CHECK-NEXT:    [[TMP4:%.*]] = xor i64 [[TMP3]], 193514046488576
// CHECK-NEXT:    [[TMP5:%.*]] = inttoptr i64 [[TMP4]] to ptr
// CHECK-NEXT:    call void @llvm.memset.p0.i64(ptr align 16 [[TMP5]], i8 0, i64 32, i1 false)
// CHECK-NEXT:    [[COERCE_DIVE:%.*]] = getelementptr inbounds [[STRUCT_UINT64X2X2_T]], ptr [[B]], i32 0, i32 0
// CHECK-NEXT:    [[TMP6:%.*]] = ptrtoint ptr [[COERCE_DIVE]] to i64
// CHECK-NEXT:    [[TMP7:%.*]] = xor i64 [[TMP6]], 193514046488576
// CHECK-NEXT:    [[TMP8:%.*]] = inttoptr i64 [[TMP7]] to ptr
// CHECK-NEXT:    store [2 x <2 x i64>] zeroinitializer, ptr [[TMP8]], align 16
// CHECK-NEXT:    store [2 x <2 x i64>] [[B_COERCE]], ptr [[COERCE_DIVE]], align 16
// CHECK-NEXT:    [[TMP9:%.*]] = call ptr @__msan_memcpy(ptr [[__S1]], ptr [[B]], i64 32)
// CHECK-NEXT:    [[VAL:%.*]] = getelementptr inbounds [[STRUCT_UINT64X2X2_T]], ptr [[__S1]], i32 0, i32 0
// CHECK-NEXT:    [[ARRAYIDX:%.*]] = getelementptr inbounds [2 x <2 x i64>], ptr [[VAL]], i64 0, i64 0
// CHECK-NEXT:    [[TMP10:%.*]] = load <2 x i64>, ptr [[ARRAYIDX]], align 16
// CHECK-NEXT:    [[TMP11:%.*]] = bitcast <2 x i64> [[TMP10]] to <16 x i8>
// CHECK-NEXT:    [[VAL1:%.*]] = getelementptr inbounds [[STRUCT_UINT64X2X2_T]], ptr [[__S1]], i32 0, i32 0
// CHECK-NEXT:    [[ARRAYIDX2:%.*]] = getelementptr inbounds [2 x <2 x i64>], ptr [[VAL1]], i64 0, i64 1
// CHECK-NEXT:    [[TMP12:%.*]] = load <2 x i64>, ptr [[ARRAYIDX2]], align 16
// CHECK-NEXT:    [[TMP13:%.*]] = bitcast <2 x i64> [[TMP12]] to <16 x i8>
// CHECK-NEXT:    [[TMP14:%.*]] = bitcast <16 x i8> [[TMP11]] to <2 x i64>
// CHECK-NEXT:    [[TMP15:%.*]] = bitcast <16 x i8> [[TMP13]] to <2 x i64>
// CHECK-NEXT:    [[TMP16:%.*]] = ptrtoint ptr [[A]] to i64
// CHECK-NEXT:    [[TMP17:%.*]] = xor i64 [[TMP16]], 193514046488576
// CHECK-NEXT:    [[TMP18:%.*]] = inttoptr i64 [[TMP17]] to ptr
// CHECK-NEXT:    store <4 x i64> zeroinitializer, ptr [[TMP18]], align 1
// CHECK-NEXT:    call void @llvm.aarch64.neon.st2.v2i64.p0(<2 x i64> [[TMP14]], <2 x i64> [[TMP15]], ptr [[A]])
// CHECK-NEXT:    ret void
//
void test_vst2q_u64(uint64_t *a, uint64x2x2_t b) {
  vst2q_u64(a, b);
}

// CHECK-LABEL: define dso_local void @test_vst2q_s8(
// CHECK-SAME: ptr noundef [[A:%.*]], [2 x <16 x i8>] alignstack(16) [[B_COERCE:%.*]]) #[[ATTR0]] {
// CHECK-NEXT:  entry:
// CHECK-NEXT:    call void @llvm.donothing()
// CHECK-NEXT:    [[B:%.*]] = alloca [[STRUCT_INT8X16X2_T:%.*]], align 16
// CHECK-NEXT:    [[TMP0:%.*]] = ptrtoint ptr [[B]] to i64
// CHECK-NEXT:    [[TMP1:%.*]] = xor i64 [[TMP0]], 193514046488576
// CHECK-NEXT:    [[TMP2:%.*]] = inttoptr i64 [[TMP1]] to ptr
// CHECK-NEXT:    call void @llvm.memset.p0.i64(ptr align 16 [[TMP2]], i8 0, i64 32, i1 false)
// CHECK-NEXT:    [[__S1:%.*]] = alloca [[STRUCT_INT8X16X2_T]], align 16
// CHECK-NEXT:    [[TMP3:%.*]] = ptrtoint ptr [[__S1]] to i64
// CHECK-NEXT:    [[TMP4:%.*]] = xor i64 [[TMP3]], 193514046488576
// CHECK-NEXT:    [[TMP5:%.*]] = inttoptr i64 [[TMP4]] to ptr
// CHECK-NEXT:    call void @llvm.memset.p0.i64(ptr align 16 [[TMP5]], i8 0, i64 32, i1 false)
// CHECK-NEXT:    [[COERCE_DIVE:%.*]] = getelementptr inbounds [[STRUCT_INT8X16X2_T]], ptr [[B]], i32 0, i32 0
// CHECK-NEXT:    [[TMP6:%.*]] = ptrtoint ptr [[COERCE_DIVE]] to i64
// CHECK-NEXT:    [[TMP7:%.*]] = xor i64 [[TMP6]], 193514046488576
// CHECK-NEXT:    [[TMP8:%.*]] = inttoptr i64 [[TMP7]] to ptr
// CHECK-NEXT:    store [2 x <16 x i8>] zeroinitializer, ptr [[TMP8]], align 16
// CHECK-NEXT:    store [2 x <16 x i8>] [[B_COERCE]], ptr [[COERCE_DIVE]], align 16
// CHECK-NEXT:    [[TMP9:%.*]] = call ptr @__msan_memcpy(ptr [[__S1]], ptr [[B]], i64 32)
// CHECK-NEXT:    [[VAL:%.*]] = getelementptr inbounds [[STRUCT_INT8X16X2_T]], ptr [[__S1]], i32 0, i32 0
// CHECK-NEXT:    [[ARRAYIDX:%.*]] = getelementptr inbounds [2 x <16 x i8>], ptr [[VAL]], i64 0, i64 0
// CHECK-NEXT:    [[TMP10:%.*]] = load <16 x i8>, ptr [[ARRAYIDX]], align 16
// CHECK-NEXT:    [[VAL1:%.*]] = getelementptr inbounds [[STRUCT_INT8X16X2_T]], ptr [[__S1]], i32 0, i32 0
// CHECK-NEXT:    [[ARRAYIDX2:%.*]] = getelementptr inbounds [2 x <16 x i8>], ptr [[VAL1]], i64 0, i64 1
// CHECK-NEXT:    [[TMP11:%.*]] = load <16 x i8>, ptr [[ARRAYIDX2]], align 16
// CHECK-NEXT:    [[TMP12:%.*]] = ptrtoint ptr [[A]] to i64
// CHECK-NEXT:    [[TMP13:%.*]] = xor i64 [[TMP12]], 193514046488576
// CHECK-NEXT:    [[TMP14:%.*]] = inttoptr i64 [[TMP13]] to ptr
// CHECK-NEXT:    store <32 x i8> zeroinitializer, ptr [[TMP14]], align 1
// CHECK-NEXT:    call void @llvm.aarch64.neon.st2.v16i8.p0(<16 x i8> [[TMP10]], <16 x i8> [[TMP11]], ptr [[A]])
// CHECK-NEXT:    ret void
//
void test_vst2q_s8(int8_t *a, int8x16x2_t b) {
  vst2q_s8(a, b);
}

// CHECK-LABEL: define dso_local void @test_vst2q_s16(
// CHECK-SAME: ptr noundef [[A:%.*]], [2 x <8 x i16>] alignstack(16) [[B_COERCE:%.*]]) #[[ATTR0]] {
// CHECK-NEXT:  entry:
// CHECK-NEXT:    call void @llvm.donothing()
// CHECK-NEXT:    [[B:%.*]] = alloca [[STRUCT_INT16X8X2_T:%.*]], align 16
// CHECK-NEXT:    [[TMP0:%.*]] = ptrtoint ptr [[B]] to i64
// CHECK-NEXT:    [[TMP1:%.*]] = xor i64 [[TMP0]], 193514046488576
// CHECK-NEXT:    [[TMP2:%.*]] = inttoptr i64 [[TMP1]] to ptr
// CHECK-NEXT:    call void @llvm.memset.p0.i64(ptr align 16 [[TMP2]], i8 0, i64 32, i1 false)
// CHECK-NEXT:    [[__S1:%.*]] = alloca [[STRUCT_INT16X8X2_T]], align 16
// CHECK-NEXT:    [[TMP3:%.*]] = ptrtoint ptr [[__S1]] to i64
// CHECK-NEXT:    [[TMP4:%.*]] = xor i64 [[TMP3]], 193514046488576
// CHECK-NEXT:    [[TMP5:%.*]] = inttoptr i64 [[TMP4]] to ptr
// CHECK-NEXT:    call void @llvm.memset.p0.i64(ptr align 16 [[TMP5]], i8 0, i64 32, i1 false)
// CHECK-NEXT:    [[COERCE_DIVE:%.*]] = getelementptr inbounds [[STRUCT_INT16X8X2_T]], ptr [[B]], i32 0, i32 0
// CHECK-NEXT:    [[TMP6:%.*]] = ptrtoint ptr [[COERCE_DIVE]] to i64
// CHECK-NEXT:    [[TMP7:%.*]] = xor i64 [[TMP6]], 193514046488576
// CHECK-NEXT:    [[TMP8:%.*]] = inttoptr i64 [[TMP7]] to ptr
// CHECK-NEXT:    store [2 x <8 x i16>] zeroinitializer, ptr [[TMP8]], align 16
// CHECK-NEXT:    store [2 x <8 x i16>] [[B_COERCE]], ptr [[COERCE_DIVE]], align 16
// CHECK-NEXT:    [[TMP9:%.*]] = call ptr @__msan_memcpy(ptr [[__S1]], ptr [[B]], i64 32)
// CHECK-NEXT:    [[VAL:%.*]] = getelementptr inbounds [[STRUCT_INT16X8X2_T]], ptr [[__S1]], i32 0, i32 0
// CHECK-NEXT:    [[ARRAYIDX:%.*]] = getelementptr inbounds [2 x <8 x i16>], ptr [[VAL]], i64 0, i64 0
// CHECK-NEXT:    [[TMP10:%.*]] = load <8 x i16>, ptr [[ARRAYIDX]], align 16
// CHECK-NEXT:    [[TMP11:%.*]] = bitcast <8 x i16> [[TMP10]] to <16 x i8>
// CHECK-NEXT:    [[VAL1:%.*]] = getelementptr inbounds [[STRUCT_INT16X8X2_T]], ptr [[__S1]], i32 0, i32 0
// CHECK-NEXT:    [[ARRAYIDX2:%.*]] = getelementptr inbounds [2 x <8 x i16>], ptr [[VAL1]], i64 0, i64 1
// CHECK-NEXT:    [[TMP12:%.*]] = load <8 x i16>, ptr [[ARRAYIDX2]], align 16
// CHECK-NEXT:    [[TMP13:%.*]] = bitcast <8 x i16> [[TMP12]] to <16 x i8>
// CHECK-NEXT:    [[TMP14:%.*]] = bitcast <16 x i8> [[TMP11]] to <8 x i16>
// CHECK-NEXT:    [[TMP15:%.*]] = bitcast <16 x i8> [[TMP13]] to <8 x i16>
// CHECK-NEXT:    [[TMP16:%.*]] = ptrtoint ptr [[A]] to i64
// CHECK-NEXT:    [[TMP17:%.*]] = xor i64 [[TMP16]], 193514046488576
// CHECK-NEXT:    [[TMP18:%.*]] = inttoptr i64 [[TMP17]] to ptr
// CHECK-NEXT:    store <16 x i16> zeroinitializer, ptr [[TMP18]], align 1
// CHECK-NEXT:    call void @llvm.aarch64.neon.st2.v8i16.p0(<8 x i16> [[TMP14]], <8 x i16> [[TMP15]], ptr [[A]])
// CHECK-NEXT:    ret void
//
void test_vst2q_s16(int16_t *a, int16x8x2_t b) {
  vst2q_s16(a, b);
}

// CHECK-LABEL: define dso_local void @test_vst2q_s32(
// CHECK-SAME: ptr noundef [[A:%.*]], [2 x <4 x i32>] alignstack(16) [[B_COERCE:%.*]]) #[[ATTR0]] {
// CHECK-NEXT:  entry:
// CHECK-NEXT:    call void @llvm.donothing()
// CHECK-NEXT:    [[B:%.*]] = alloca [[STRUCT_INT32X4X2_T:%.*]], align 16
// CHECK-NEXT:    [[TMP0:%.*]] = ptrtoint ptr [[B]] to i64
// CHECK-NEXT:    [[TMP1:%.*]] = xor i64 [[TMP0]], 193514046488576
// CHECK-NEXT:    [[TMP2:%.*]] = inttoptr i64 [[TMP1]] to ptr
// CHECK-NEXT:    call void @llvm.memset.p0.i64(ptr align 16 [[TMP2]], i8 0, i64 32, i1 false)
// CHECK-NEXT:    [[__S1:%.*]] = alloca [[STRUCT_INT32X4X2_T]], align 16
// CHECK-NEXT:    [[TMP3:%.*]] = ptrtoint ptr [[__S1]] to i64
// CHECK-NEXT:    [[TMP4:%.*]] = xor i64 [[TMP3]], 193514046488576
// CHECK-NEXT:    [[TMP5:%.*]] = inttoptr i64 [[TMP4]] to ptr
// CHECK-NEXT:    call void @llvm.memset.p0.i64(ptr align 16 [[TMP5]], i8 0, i64 32, i1 false)
// CHECK-NEXT:    [[COERCE_DIVE:%.*]] = getelementptr inbounds [[STRUCT_INT32X4X2_T]], ptr [[B]], i32 0, i32 0
// CHECK-NEXT:    [[TMP6:%.*]] = ptrtoint ptr [[COERCE_DIVE]] to i64
// CHECK-NEXT:    [[TMP7:%.*]] = xor i64 [[TMP6]], 193514046488576
// CHECK-NEXT:    [[TMP8:%.*]] = inttoptr i64 [[TMP7]] to ptr
// CHECK-NEXT:    store [2 x <4 x i32>] zeroinitializer, ptr [[TMP8]], align 16
// CHECK-NEXT:    store [2 x <4 x i32>] [[B_COERCE]], ptr [[COERCE_DIVE]], align 16
// CHECK-NEXT:    [[TMP9:%.*]] = call ptr @__msan_memcpy(ptr [[__S1]], ptr [[B]], i64 32)
// CHECK-NEXT:    [[VAL:%.*]] = getelementptr inbounds [[STRUCT_INT32X4X2_T]], ptr [[__S1]], i32 0, i32 0
// CHECK-NEXT:    [[ARRAYIDX:%.*]] = getelementptr inbounds [2 x <4 x i32>], ptr [[VAL]], i64 0, i64 0
// CHECK-NEXT:    [[TMP10:%.*]] = load <4 x i32>, ptr [[ARRAYIDX]], align 16
// CHECK-NEXT:    [[TMP11:%.*]] = bitcast <4 x i32> [[TMP10]] to <16 x i8>
// CHECK-NEXT:    [[VAL1:%.*]] = getelementptr inbounds [[STRUCT_INT32X4X2_T]], ptr [[__S1]], i32 0, i32 0
// CHECK-NEXT:    [[ARRAYIDX2:%.*]] = getelementptr inbounds [2 x <4 x i32>], ptr [[VAL1]], i64 0, i64 1
// CHECK-NEXT:    [[TMP12:%.*]] = load <4 x i32>, ptr [[ARRAYIDX2]], align 16
// CHECK-NEXT:    [[TMP13:%.*]] = bitcast <4 x i32> [[TMP12]] to <16 x i8>
// CHECK-NEXT:    [[TMP14:%.*]] = bitcast <16 x i8> [[TMP11]] to <4 x i32>
// CHECK-NEXT:    [[TMP15:%.*]] = bitcast <16 x i8> [[TMP13]] to <4 x i32>
// CHECK-NEXT:    [[TMP16:%.*]] = ptrtoint ptr [[A]] to i64
// CHECK-NEXT:    [[TMP17:%.*]] = xor i64 [[TMP16]], 193514046488576
// CHECK-NEXT:    [[TMP18:%.*]] = inttoptr i64 [[TMP17]] to ptr
// CHECK-NEXT:    store <8 x i32> zeroinitializer, ptr [[TMP18]], align 1
// CHECK-NEXT:    call void @llvm.aarch64.neon.st2.v4i32.p0(<4 x i32> [[TMP14]], <4 x i32> [[TMP15]], ptr [[A]])
// CHECK-NEXT:    ret void
//
void test_vst2q_s32(int32_t *a, int32x4x2_t b) {
  vst2q_s32(a, b);
}

// CHECK-LABEL: define dso_local void @test_vst2q_s64(
// CHECK-SAME: ptr noundef [[A:%.*]], [2 x <2 x i64>] alignstack(16) [[B_COERCE:%.*]]) #[[ATTR0]] {
// CHECK-NEXT:  entry:
// CHECK-NEXT:    call void @llvm.donothing()
// CHECK-NEXT:    [[B:%.*]] = alloca [[STRUCT_INT64X2X2_T:%.*]], align 16
// CHECK-NEXT:    [[TMP0:%.*]] = ptrtoint ptr [[B]] to i64
// CHECK-NEXT:    [[TMP1:%.*]] = xor i64 [[TMP0]], 193514046488576
// CHECK-NEXT:    [[TMP2:%.*]] = inttoptr i64 [[TMP1]] to ptr
// CHECK-NEXT:    call void @llvm.memset.p0.i64(ptr align 16 [[TMP2]], i8 0, i64 32, i1 false)
// CHECK-NEXT:    [[__S1:%.*]] = alloca [[STRUCT_INT64X2X2_T]], align 16
// CHECK-NEXT:    [[TMP3:%.*]] = ptrtoint ptr [[__S1]] to i64
// CHECK-NEXT:    [[TMP4:%.*]] = xor i64 [[TMP3]], 193514046488576
// CHECK-NEXT:    [[TMP5:%.*]] = inttoptr i64 [[TMP4]] to ptr
// CHECK-NEXT:    call void @llvm.memset.p0.i64(ptr align 16 [[TMP5]], i8 0, i64 32, i1 false)
// CHECK-NEXT:    [[COERCE_DIVE:%.*]] = getelementptr inbounds [[STRUCT_INT64X2X2_T]], ptr [[B]], i32 0, i32 0
// CHECK-NEXT:    [[TMP6:%.*]] = ptrtoint ptr [[COERCE_DIVE]] to i64
// CHECK-NEXT:    [[TMP7:%.*]] = xor i64 [[TMP6]], 193514046488576
// CHECK-NEXT:    [[TMP8:%.*]] = inttoptr i64 [[TMP7]] to ptr
// CHECK-NEXT:    store [2 x <2 x i64>] zeroinitializer, ptr [[TMP8]], align 16
// CHECK-NEXT:    store [2 x <2 x i64>] [[B_COERCE]], ptr [[COERCE_DIVE]], align 16
// CHECK-NEXT:    [[TMP9:%.*]] = call ptr @__msan_memcpy(ptr [[__S1]], ptr [[B]], i64 32)
// CHECK-NEXT:    [[VAL:%.*]] = getelementptr inbounds [[STRUCT_INT64X2X2_T]], ptr [[__S1]], i32 0, i32 0
// CHECK-NEXT:    [[ARRAYIDX:%.*]] = getelementptr inbounds [2 x <2 x i64>], ptr [[VAL]], i64 0, i64 0
// CHECK-NEXT:    [[TMP10:%.*]] = load <2 x i64>, ptr [[ARRAYIDX]], align 16
// CHECK-NEXT:    [[TMP11:%.*]] = bitcast <2 x i64> [[TMP10]] to <16 x i8>
// CHECK-NEXT:    [[VAL1:%.*]] = getelementptr inbounds [[STRUCT_INT64X2X2_T]], ptr [[__S1]], i32 0, i32 0
// CHECK-NEXT:    [[ARRAYIDX2:%.*]] = getelementptr inbounds [2 x <2 x i64>], ptr [[VAL1]], i64 0, i64 1
// CHECK-NEXT:    [[TMP12:%.*]] = load <2 x i64>, ptr [[ARRAYIDX2]], align 16
// CHECK-NEXT:    [[TMP13:%.*]] = bitcast <2 x i64> [[TMP12]] to <16 x i8>
// CHECK-NEXT:    [[TMP14:%.*]] = bitcast <16 x i8> [[TMP11]] to <2 x i64>
// CHECK-NEXT:    [[TMP15:%.*]] = bitcast <16 x i8> [[TMP13]] to <2 x i64>
// CHECK-NEXT:    [[TMP16:%.*]] = ptrtoint ptr [[A]] to i64
// CHECK-NEXT:    [[TMP17:%.*]] = xor i64 [[TMP16]], 193514046488576
// CHECK-NEXT:    [[TMP18:%.*]] = inttoptr i64 [[TMP17]] to ptr
// CHECK-NEXT:    store <4 x i64> zeroinitializer, ptr [[TMP18]], align 1
// CHECK-NEXT:    call void @llvm.aarch64.neon.st2.v2i64.p0(<2 x i64> [[TMP14]], <2 x i64> [[TMP15]], ptr [[A]])
// CHECK-NEXT:    ret void
//
void test_vst2q_s64(int64_t *a, int64x2x2_t b) {
  vst2q_s64(a, b);
}

// CHECK-LABEL: define dso_local void @test_vst2q_f16(
// CHECK-SAME: ptr noundef [[A:%.*]], [2 x <8 x half>] alignstack(16) [[B_COERCE:%.*]]) #[[ATTR0]] {
// CHECK-NEXT:  entry:
// CHECK-NEXT:    call void @llvm.donothing()
// CHECK-NEXT:    [[B:%.*]] = alloca [[STRUCT_FLOAT16X8X2_T:%.*]], align 16
// CHECK-NEXT:    [[TMP0:%.*]] = ptrtoint ptr [[B]] to i64
// CHECK-NEXT:    [[TMP1:%.*]] = xor i64 [[TMP0]], 193514046488576
// CHECK-NEXT:    [[TMP2:%.*]] = inttoptr i64 [[TMP1]] to ptr
// CHECK-NEXT:    call void @llvm.memset.p0.i64(ptr align 16 [[TMP2]], i8 0, i64 32, i1 false)
// CHECK-NEXT:    [[__S1:%.*]] = alloca [[STRUCT_FLOAT16X8X2_T]], align 16
// CHECK-NEXT:    [[TMP3:%.*]] = ptrtoint ptr [[__S1]] to i64
// CHECK-NEXT:    [[TMP4:%.*]] = xor i64 [[TMP3]], 193514046488576
// CHECK-NEXT:    [[TMP5:%.*]] = inttoptr i64 [[TMP4]] to ptr
// CHECK-NEXT:    call void @llvm.memset.p0.i64(ptr align 16 [[TMP5]], i8 0, i64 32, i1 false)
// CHECK-NEXT:    [[COERCE_DIVE:%.*]] = getelementptr inbounds [[STRUCT_FLOAT16X8X2_T]], ptr [[B]], i32 0, i32 0
// CHECK-NEXT:    [[TMP6:%.*]] = ptrtoint ptr [[COERCE_DIVE]] to i64
// CHECK-NEXT:    [[TMP7:%.*]] = xor i64 [[TMP6]], 193514046488576
// CHECK-NEXT:    [[TMP8:%.*]] = inttoptr i64 [[TMP7]] to ptr
// CHECK-NEXT:    store [2 x <8 x i16>] zeroinitializer, ptr [[TMP8]], align 16
// CHECK-NEXT:    store [2 x <8 x half>] [[B_COERCE]], ptr [[COERCE_DIVE]], align 16
// CHECK-NEXT:    [[TMP9:%.*]] = call ptr @__msan_memcpy(ptr [[__S1]], ptr [[B]], i64 32)
// CHECK-NEXT:    [[VAL:%.*]] = getelementptr inbounds [[STRUCT_FLOAT16X8X2_T]], ptr [[__S1]], i32 0, i32 0
// CHECK-NEXT:    [[ARRAYIDX:%.*]] = getelementptr inbounds [2 x <8 x half>], ptr [[VAL]], i64 0, i64 0
// CHECK-NEXT:    [[TMP10:%.*]] = load <8 x half>, ptr [[ARRAYIDX]], align 16
// CHECK-NEXT:    [[TMP11:%.*]] = bitcast <8 x half> [[TMP10]] to <16 x i8>
// CHECK-NEXT:    [[VAL1:%.*]] = getelementptr inbounds [[STRUCT_FLOAT16X8X2_T]], ptr [[__S1]], i32 0, i32 0
// CHECK-NEXT:    [[ARRAYIDX2:%.*]] = getelementptr inbounds [2 x <8 x half>], ptr [[VAL1]], i64 0, i64 1
// CHECK-NEXT:    [[TMP12:%.*]] = load <8 x half>, ptr [[ARRAYIDX2]], align 16
// CHECK-NEXT:    [[TMP13:%.*]] = bitcast <8 x half> [[TMP12]] to <16 x i8>
// CHECK-NEXT:    [[TMP14:%.*]] = bitcast <16 x i8> [[TMP11]] to <8 x half>
// CHECK-NEXT:    [[TMP15:%.*]] = bitcast <16 x i8> [[TMP13]] to <8 x half>
// CHECK-NEXT:    [[TMP16:%.*]] = ptrtoint ptr [[A]] to i64
// CHECK-NEXT:    [[TMP17:%.*]] = xor i64 [[TMP16]], 193514046488576
// CHECK-NEXT:    [[TMP18:%.*]] = inttoptr i64 [[TMP17]] to ptr
// CHECK-NEXT:    store <16 x i16> zeroinitializer, ptr [[TMP18]], align 1
// CHECK-NEXT:    call void @llvm.aarch64.neon.st2.v8f16.p0(<8 x half> [[TMP14]], <8 x half> [[TMP15]], ptr [[A]])
// CHECK-NEXT:    ret void
//
void test_vst2q_f16(float16_t *a, float16x8x2_t b) {
  vst2q_f16(a, b);
}

// CHECK-LABEL: define dso_local void @test_vst2q_f32(
// CHECK-SAME: ptr noundef [[A:%.*]], [2 x <4 x float>] alignstack(16) [[B_COERCE:%.*]]) #[[ATTR0]] {
// CHECK-NEXT:  entry:
// CHECK-NEXT:    call void @llvm.donothing()
// CHECK-NEXT:    [[B:%.*]] = alloca [[STRUCT_FLOAT32X4X2_T:%.*]], align 16
// CHECK-NEXT:    [[TMP0:%.*]] = ptrtoint ptr [[B]] to i64
// CHECK-NEXT:    [[TMP1:%.*]] = xor i64 [[TMP0]], 193514046488576
// CHECK-NEXT:    [[TMP2:%.*]] = inttoptr i64 [[TMP1]] to ptr
// CHECK-NEXT:    call void @llvm.memset.p0.i64(ptr align 16 [[TMP2]], i8 0, i64 32, i1 false)
// CHECK-NEXT:    [[__S1:%.*]] = alloca [[STRUCT_FLOAT32X4X2_T]], align 16
// CHECK-NEXT:    [[TMP3:%.*]] = ptrtoint ptr [[__S1]] to i64
// CHECK-NEXT:    [[TMP4:%.*]] = xor i64 [[TMP3]], 193514046488576
// CHECK-NEXT:    [[TMP5:%.*]] = inttoptr i64 [[TMP4]] to ptr
// CHECK-NEXT:    call void @llvm.memset.p0.i64(ptr align 16 [[TMP5]], i8 0, i64 32, i1 false)
// CHECK-NEXT:    [[COERCE_DIVE:%.*]] = getelementptr inbounds [[STRUCT_FLOAT32X4X2_T]], ptr [[B]], i32 0, i32 0
// CHECK-NEXT:    [[TMP6:%.*]] = ptrtoint ptr [[COERCE_DIVE]] to i64
// CHECK-NEXT:    [[TMP7:%.*]] = xor i64 [[TMP6]], 193514046488576
// CHECK-NEXT:    [[TMP8:%.*]] = inttoptr i64 [[TMP7]] to ptr
// CHECK-NEXT:    store [2 x <4 x i32>] zeroinitializer, ptr [[TMP8]], align 16
// CHECK-NEXT:    store [2 x <4 x float>] [[B_COERCE]], ptr [[COERCE_DIVE]], align 16
// CHECK-NEXT:    [[TMP9:%.*]] = call ptr @__msan_memcpy(ptr [[__S1]], ptr [[B]], i64 32)
// CHECK-NEXT:    [[VAL:%.*]] = getelementptr inbounds [[STRUCT_FLOAT32X4X2_T]], ptr [[__S1]], i32 0, i32 0
// CHECK-NEXT:    [[ARRAYIDX:%.*]] = getelementptr inbounds [2 x <4 x float>], ptr [[VAL]], i64 0, i64 0
// CHECK-NEXT:    [[TMP10:%.*]] = load <4 x float>, ptr [[ARRAYIDX]], align 16
// CHECK-NEXT:    [[TMP11:%.*]] = bitcast <4 x float> [[TMP10]] to <16 x i8>
// CHECK-NEXT:    [[VAL1:%.*]] = getelementptr inbounds [[STRUCT_FLOAT32X4X2_T]], ptr [[__S1]], i32 0, i32 0
// CHECK-NEXT:    [[ARRAYIDX2:%.*]] = getelementptr inbounds [2 x <4 x float>], ptr [[VAL1]], i64 0, i64 1
// CHECK-NEXT:    [[TMP12:%.*]] = load <4 x float>, ptr [[ARRAYIDX2]], align 16
// CHECK-NEXT:    [[TMP13:%.*]] = bitcast <4 x float> [[TMP12]] to <16 x i8>
// CHECK-NEXT:    [[TMP14:%.*]] = bitcast <16 x i8> [[TMP11]] to <4 x float>
// CHECK-NEXT:    [[TMP15:%.*]] = bitcast <16 x i8> [[TMP13]] to <4 x float>
// CHECK-NEXT:    [[TMP16:%.*]] = ptrtoint ptr [[A]] to i64
// CHECK-NEXT:    [[TMP17:%.*]] = xor i64 [[TMP16]], 193514046488576
// CHECK-NEXT:    [[TMP18:%.*]] = inttoptr i64 [[TMP17]] to ptr
// CHECK-NEXT:    store <8 x i32> zeroinitializer, ptr [[TMP18]], align 1
// CHECK-NEXT:    call void @llvm.aarch64.neon.st2.v4f32.p0(<4 x float> [[TMP14]], <4 x float> [[TMP15]], ptr [[A]])
// CHECK-NEXT:    ret void
//
void test_vst2q_f32(float32_t *a, float32x4x2_t b) {
  vst2q_f32(a, b);
}

// CHECK-LABEL: define dso_local void @test_vst2q_f64(
// CHECK-SAME: ptr noundef [[A:%.*]], [2 x <2 x double>] alignstack(16) [[B_COERCE:%.*]]) #[[ATTR0]] {
// CHECK-NEXT:  entry:
// CHECK-NEXT:    call void @llvm.donothing()
// CHECK-NEXT:    [[B:%.*]] = alloca [[STRUCT_FLOAT64X2X2_T:%.*]], align 16
// CHECK-NEXT:    [[TMP0:%.*]] = ptrtoint ptr [[B]] to i64
// CHECK-NEXT:    [[TMP1:%.*]] = xor i64 [[TMP0]], 193514046488576
// CHECK-NEXT:    [[TMP2:%.*]] = inttoptr i64 [[TMP1]] to ptr
// CHECK-NEXT:    call void @llvm.memset.p0.i64(ptr align 16 [[TMP2]], i8 0, i64 32, i1 false)
// CHECK-NEXT:    [[__S1:%.*]] = alloca [[STRUCT_FLOAT64X2X2_T]], align 16
// CHECK-NEXT:    [[TMP3:%.*]] = ptrtoint ptr [[__S1]] to i64
// CHECK-NEXT:    [[TMP4:%.*]] = xor i64 [[TMP3]], 193514046488576
// CHECK-NEXT:    [[TMP5:%.*]] = inttoptr i64 [[TMP4]] to ptr
// CHECK-NEXT:    call void @llvm.memset.p0.i64(ptr align 16 [[TMP5]], i8 0, i64 32, i1 false)
// CHECK-NEXT:    [[COERCE_DIVE:%.*]] = getelementptr inbounds [[STRUCT_FLOAT64X2X2_T]], ptr [[B]], i32 0, i32 0
// CHECK-NEXT:    [[TMP6:%.*]] = ptrtoint ptr [[COERCE_DIVE]] to i64
// CHECK-NEXT:    [[TMP7:%.*]] = xor i64 [[TMP6]], 193514046488576
// CHECK-NEXT:    [[TMP8:%.*]] = inttoptr i64 [[TMP7]] to ptr
// CHECK-NEXT:    store [2 x <2 x i64>] zeroinitializer, ptr [[TMP8]], align 16
// CHECK-NEXT:    store [2 x <2 x double>] [[B_COERCE]], ptr [[COERCE_DIVE]], align 16
// CHECK-NEXT:    [[TMP9:%.*]] = call ptr @__msan_memcpy(ptr [[__S1]], ptr [[B]], i64 32)
// CHECK-NEXT:    [[VAL:%.*]] = getelementptr inbounds [[STRUCT_FLOAT64X2X2_T]], ptr [[__S1]], i32 0, i32 0
// CHECK-NEXT:    [[ARRAYIDX:%.*]] = getelementptr inbounds [2 x <2 x double>], ptr [[VAL]], i64 0, i64 0
// CHECK-NEXT:    [[TMP10:%.*]] = load <2 x double>, ptr [[ARRAYIDX]], align 16
// CHECK-NEXT:    [[TMP11:%.*]] = bitcast <2 x double> [[TMP10]] to <16 x i8>
// CHECK-NEXT:    [[VAL1:%.*]] = getelementptr inbounds [[STRUCT_FLOAT64X2X2_T]], ptr [[__S1]], i32 0, i32 0
// CHECK-NEXT:    [[ARRAYIDX2:%.*]] = getelementptr inbounds [2 x <2 x double>], ptr [[VAL1]], i64 0, i64 1
// CHECK-NEXT:    [[TMP12:%.*]] = load <2 x double>, ptr [[ARRAYIDX2]], align 16
// CHECK-NEXT:    [[TMP13:%.*]] = bitcast <2 x double> [[TMP12]] to <16 x i8>
// CHECK-NEXT:    [[TMP14:%.*]] = bitcast <16 x i8> [[TMP11]] to <2 x double>
// CHECK-NEXT:    [[TMP15:%.*]] = bitcast <16 x i8> [[TMP13]] to <2 x double>
// CHECK-NEXT:    [[TMP16:%.*]] = ptrtoint ptr [[A]] to i64
// CHECK-NEXT:    [[TMP17:%.*]] = xor i64 [[TMP16]], 193514046488576
// CHECK-NEXT:    [[TMP18:%.*]] = inttoptr i64 [[TMP17]] to ptr
// CHECK-NEXT:    store <4 x i64> zeroinitializer, ptr [[TMP18]], align 1
// CHECK-NEXT:    call void @llvm.aarch64.neon.st2.v2f64.p0(<2 x double> [[TMP14]], <2 x double> [[TMP15]], ptr [[A]])
// CHECK-NEXT:    ret void
//
void test_vst2q_f64(float64_t *a, float64x2x2_t b) {
  vst2q_f64(a, b);
}

// CHECK-LABEL: define dso_local void @test_vst2q_p8(
// CHECK-SAME: ptr noundef [[A:%.*]], [2 x <16 x i8>] alignstack(16) [[B_COERCE:%.*]]) #[[ATTR0]] {
// CHECK-NEXT:  entry:
// CHECK-NEXT:    call void @llvm.donothing()
// CHECK-NEXT:    [[B:%.*]] = alloca [[STRUCT_POLY8X16X2_T:%.*]], align 16
// CHECK-NEXT:    [[TMP0:%.*]] = ptrtoint ptr [[B]] to i64
// CHECK-NEXT:    [[TMP1:%.*]] = xor i64 [[TMP0]], 193514046488576
// CHECK-NEXT:    [[TMP2:%.*]] = inttoptr i64 [[TMP1]] to ptr
// CHECK-NEXT:    call void @llvm.memset.p0.i64(ptr align 16 [[TMP2]], i8 0, i64 32, i1 false)
// CHECK-NEXT:    [[__S1:%.*]] = alloca [[STRUCT_POLY8X16X2_T]], align 16
// CHECK-NEXT:    [[TMP3:%.*]] = ptrtoint ptr [[__S1]] to i64
// CHECK-NEXT:    [[TMP4:%.*]] = xor i64 [[TMP3]], 193514046488576
// CHECK-NEXT:    [[TMP5:%.*]] = inttoptr i64 [[TMP4]] to ptr
// CHECK-NEXT:    call void @llvm.memset.p0.i64(ptr align 16 [[TMP5]], i8 0, i64 32, i1 false)
// CHECK-NEXT:    [[COERCE_DIVE:%.*]] = getelementptr inbounds [[STRUCT_POLY8X16X2_T]], ptr [[B]], i32 0, i32 0
// CHECK-NEXT:    [[TMP6:%.*]] = ptrtoint ptr [[COERCE_DIVE]] to i64
// CHECK-NEXT:    [[TMP7:%.*]] = xor i64 [[TMP6]], 193514046488576
// CHECK-NEXT:    [[TMP8:%.*]] = inttoptr i64 [[TMP7]] to ptr
// CHECK-NEXT:    store [2 x <16 x i8>] zeroinitializer, ptr [[TMP8]], align 16
// CHECK-NEXT:    store [2 x <16 x i8>] [[B_COERCE]], ptr [[COERCE_DIVE]], align 16
// CHECK-NEXT:    [[TMP9:%.*]] = call ptr @__msan_memcpy(ptr [[__S1]], ptr [[B]], i64 32)
// CHECK-NEXT:    [[VAL:%.*]] = getelementptr inbounds [[STRUCT_POLY8X16X2_T]], ptr [[__S1]], i32 0, i32 0
// CHECK-NEXT:    [[ARRAYIDX:%.*]] = getelementptr inbounds [2 x <16 x i8>], ptr [[VAL]], i64 0, i64 0
// CHECK-NEXT:    [[TMP10:%.*]] = load <16 x i8>, ptr [[ARRAYIDX]], align 16
// CHECK-NEXT:    [[VAL1:%.*]] = getelementptr inbounds [[STRUCT_POLY8X16X2_T]], ptr [[__S1]], i32 0, i32 0
// CHECK-NEXT:    [[ARRAYIDX2:%.*]] = getelementptr inbounds [2 x <16 x i8>], ptr [[VAL1]], i64 0, i64 1
// CHECK-NEXT:    [[TMP11:%.*]] = load <16 x i8>, ptr [[ARRAYIDX2]], align 16
// CHECK-NEXT:    [[TMP12:%.*]] = ptrtoint ptr [[A]] to i64
// CHECK-NEXT:    [[TMP13:%.*]] = xor i64 [[TMP12]], 193514046488576
// CHECK-NEXT:    [[TMP14:%.*]] = inttoptr i64 [[TMP13]] to ptr
// CHECK-NEXT:    store <32 x i8> zeroinitializer, ptr [[TMP14]], align 1
// CHECK-NEXT:    call void @llvm.aarch64.neon.st2.v16i8.p0(<16 x i8> [[TMP10]], <16 x i8> [[TMP11]], ptr [[A]])
// CHECK-NEXT:    ret void
//
void test_vst2q_p8(poly8_t *a, poly8x16x2_t b) {
  vst2q_p8(a, b);
}

// CHECK-LABEL: define dso_local void @test_vst2q_p16(
// CHECK-SAME: ptr noundef [[A:%.*]], [2 x <8 x i16>] alignstack(16) [[B_COERCE:%.*]]) #[[ATTR0]] {
// CHECK-NEXT:  entry:
// CHECK-NEXT:    call void @llvm.donothing()
// CHECK-NEXT:    [[B:%.*]] = alloca [[STRUCT_POLY16X8X2_T:%.*]], align 16
// CHECK-NEXT:    [[TMP0:%.*]] = ptrtoint ptr [[B]] to i64
// CHECK-NEXT:    [[TMP1:%.*]] = xor i64 [[TMP0]], 193514046488576
// CHECK-NEXT:    [[TMP2:%.*]] = inttoptr i64 [[TMP1]] to ptr
// CHECK-NEXT:    call void @llvm.memset.p0.i64(ptr align 16 [[TMP2]], i8 0, i64 32, i1 false)
// CHECK-NEXT:    [[__S1:%.*]] = alloca [[STRUCT_POLY16X8X2_T]], align 16
// CHECK-NEXT:    [[TMP3:%.*]] = ptrtoint ptr [[__S1]] to i64
// CHECK-NEXT:    [[TMP4:%.*]] = xor i64 [[TMP3]], 193514046488576
// CHECK-NEXT:    [[TMP5:%.*]] = inttoptr i64 [[TMP4]] to ptr
// CHECK-NEXT:    call void @llvm.memset.p0.i64(ptr align 16 [[TMP5]], i8 0, i64 32, i1 false)
// CHECK-NEXT:    [[COERCE_DIVE:%.*]] = getelementptr inbounds [[STRUCT_POLY16X8X2_T]], ptr [[B]], i32 0, i32 0
// CHECK-NEXT:    [[TMP6:%.*]] = ptrtoint ptr [[COERCE_DIVE]] to i64
// CHECK-NEXT:    [[TMP7:%.*]] = xor i64 [[TMP6]], 193514046488576
// CHECK-NEXT:    [[TMP8:%.*]] = inttoptr i64 [[TMP7]] to ptr
// CHECK-NEXT:    store [2 x <8 x i16>] zeroinitializer, ptr [[TMP8]], align 16
// CHECK-NEXT:    store [2 x <8 x i16>] [[B_COERCE]], ptr [[COERCE_DIVE]], align 16
// CHECK-NEXT:    [[TMP9:%.*]] = call ptr @__msan_memcpy(ptr [[__S1]], ptr [[B]], i64 32)
// CHECK-NEXT:    [[VAL:%.*]] = getelementptr inbounds [[STRUCT_POLY16X8X2_T]], ptr [[__S1]], i32 0, i32 0
// CHECK-NEXT:    [[ARRAYIDX:%.*]] = getelementptr inbounds [2 x <8 x i16>], ptr [[VAL]], i64 0, i64 0
// CHECK-NEXT:    [[TMP10:%.*]] = load <8 x i16>, ptr [[ARRAYIDX]], align 16
// CHECK-NEXT:    [[TMP11:%.*]] = bitcast <8 x i16> [[TMP10]] to <16 x i8>
// CHECK-NEXT:    [[VAL1:%.*]] = getelementptr inbounds [[STRUCT_POLY16X8X2_T]], ptr [[__S1]], i32 0, i32 0
// CHECK-NEXT:    [[ARRAYIDX2:%.*]] = getelementptr inbounds [2 x <8 x i16>], ptr [[VAL1]], i64 0, i64 1
// CHECK-NEXT:    [[TMP12:%.*]] = load <8 x i16>, ptr [[ARRAYIDX2]], align 16
// CHECK-NEXT:    [[TMP13:%.*]] = bitcast <8 x i16> [[TMP12]] to <16 x i8>
// CHECK-NEXT:    [[TMP14:%.*]] = bitcast <16 x i8> [[TMP11]] to <8 x i16>
// CHECK-NEXT:    [[TMP15:%.*]] = bitcast <16 x i8> [[TMP13]] to <8 x i16>
// CHECK-NEXT:    [[TMP16:%.*]] = ptrtoint ptr [[A]] to i64
// CHECK-NEXT:    [[TMP17:%.*]] = xor i64 [[TMP16]], 193514046488576
// CHECK-NEXT:    [[TMP18:%.*]] = inttoptr i64 [[TMP17]] to ptr
// CHECK-NEXT:    store <16 x i16> zeroinitializer, ptr [[TMP18]], align 1
// CHECK-NEXT:    call void @llvm.aarch64.neon.st2.v8i16.p0(<8 x i16> [[TMP14]], <8 x i16> [[TMP15]], ptr [[A]])
// CHECK-NEXT:    ret void
//
void test_vst2q_p16(poly16_t *a, poly16x8x2_t b) {
  vst2q_p16(a, b);
}

// CHECK-LABEL: define dso_local void @test_vst2_u8(
// CHECK-SAME: ptr noundef [[A:%.*]], [2 x <8 x i8>] alignstack(8) [[B_COERCE:%.*]]) #[[ATTR0]] {
// CHECK-NEXT:  entry:
// CHECK-NEXT:    call void @llvm.donothing()
// CHECK-NEXT:    [[B:%.*]] = alloca [[STRUCT_UINT8X8X2_T:%.*]], align 8
// CHECK-NEXT:    [[TMP0:%.*]] = ptrtoint ptr [[B]] to i64
// CHECK-NEXT:    [[TMP1:%.*]] = xor i64 [[TMP0]], 193514046488576
// CHECK-NEXT:    [[TMP2:%.*]] = inttoptr i64 [[TMP1]] to ptr
// CHECK-NEXT:    call void @llvm.memset.p0.i64(ptr align 8 [[TMP2]], i8 0, i64 16, i1 false)
// CHECK-NEXT:    [[__S1:%.*]] = alloca [[STRUCT_UINT8X8X2_T]], align 8
// CHECK-NEXT:    [[TMP3:%.*]] = ptrtoint ptr [[__S1]] to i64
// CHECK-NEXT:    [[TMP4:%.*]] = xor i64 [[TMP3]], 193514046488576
// CHECK-NEXT:    [[TMP5:%.*]] = inttoptr i64 [[TMP4]] to ptr
// CHECK-NEXT:    call void @llvm.memset.p0.i64(ptr align 8 [[TMP5]], i8 0, i64 16, i1 false)
// CHECK-NEXT:    [[COERCE_DIVE:%.*]] = getelementptr inbounds [[STRUCT_UINT8X8X2_T]], ptr [[B]], i32 0, i32 0
// CHECK-NEXT:    [[TMP6:%.*]] = ptrtoint ptr [[COERCE_DIVE]] to i64
// CHECK-NEXT:    [[TMP7:%.*]] = xor i64 [[TMP6]], 193514046488576
// CHECK-NEXT:    [[TMP8:%.*]] = inttoptr i64 [[TMP7]] to ptr
// CHECK-NEXT:    store [2 x <8 x i8>] zeroinitializer, ptr [[TMP8]], align 8
// CHECK-NEXT:    store [2 x <8 x i8>] [[B_COERCE]], ptr [[COERCE_DIVE]], align 8
// CHECK-NEXT:    [[TMP9:%.*]] = call ptr @__msan_memcpy(ptr [[__S1]], ptr [[B]], i64 16)
// CHECK-NEXT:    [[VAL:%.*]] = getelementptr inbounds [[STRUCT_UINT8X8X2_T]], ptr [[__S1]], i32 0, i32 0
// CHECK-NEXT:    [[ARRAYIDX:%.*]] = getelementptr inbounds [2 x <8 x i8>], ptr [[VAL]], i64 0, i64 0
// CHECK-NEXT:    [[TMP10:%.*]] = load <8 x i8>, ptr [[ARRAYIDX]], align 8
// CHECK-NEXT:    [[VAL1:%.*]] = getelementptr inbounds [[STRUCT_UINT8X8X2_T]], ptr [[__S1]], i32 0, i32 0
// CHECK-NEXT:    [[ARRAYIDX2:%.*]] = getelementptr inbounds [2 x <8 x i8>], ptr [[VAL1]], i64 0, i64 1
// CHECK-NEXT:    [[TMP11:%.*]] = load <8 x i8>, ptr [[ARRAYIDX2]], align 8
// CHECK-NEXT:    [[TMP12:%.*]] = ptrtoint ptr [[A]] to i64
// CHECK-NEXT:    [[TMP13:%.*]] = xor i64 [[TMP12]], 193514046488576
// CHECK-NEXT:    [[TMP14:%.*]] = inttoptr i64 [[TMP13]] to ptr
// CHECK-NEXT:    store <16 x i8> zeroinitializer, ptr [[TMP14]], align 1
// CHECK-NEXT:    call void @llvm.aarch64.neon.st2.v8i8.p0(<8 x i8> [[TMP10]], <8 x i8> [[TMP11]], ptr [[A]])
// CHECK-NEXT:    ret void
//
void test_vst2_u8(uint8_t *a, uint8x8x2_t b) {
  vst2_u8(a, b);
}

// CHECK-LABEL: define dso_local void @test_vst2_u16(
// CHECK-SAME: ptr noundef [[A:%.*]], [2 x <4 x i16>] alignstack(8) [[B_COERCE:%.*]]) #[[ATTR0]] {
// CHECK-NEXT:  entry:
// CHECK-NEXT:    call void @llvm.donothing()
// CHECK-NEXT:    [[B:%.*]] = alloca [[STRUCT_UINT16X4X2_T:%.*]], align 8
// CHECK-NEXT:    [[TMP0:%.*]] = ptrtoint ptr [[B]] to i64
// CHECK-NEXT:    [[TMP1:%.*]] = xor i64 [[TMP0]], 193514046488576
// CHECK-NEXT:    [[TMP2:%.*]] = inttoptr i64 [[TMP1]] to ptr
// CHECK-NEXT:    call void @llvm.memset.p0.i64(ptr align 8 [[TMP2]], i8 0, i64 16, i1 false)
// CHECK-NEXT:    [[__S1:%.*]] = alloca [[STRUCT_UINT16X4X2_T]], align 8
// CHECK-NEXT:    [[TMP3:%.*]] = ptrtoint ptr [[__S1]] to i64
// CHECK-NEXT:    [[TMP4:%.*]] = xor i64 [[TMP3]], 193514046488576
// CHECK-NEXT:    [[TMP5:%.*]] = inttoptr i64 [[TMP4]] to ptr
// CHECK-NEXT:    call void @llvm.memset.p0.i64(ptr align 8 [[TMP5]], i8 0, i64 16, i1 false)
// CHECK-NEXT:    [[COERCE_DIVE:%.*]] = getelementptr inbounds [[STRUCT_UINT16X4X2_T]], ptr [[B]], i32 0, i32 0
// CHECK-NEXT:    [[TMP6:%.*]] = ptrtoint ptr [[COERCE_DIVE]] to i64
// CHECK-NEXT:    [[TMP7:%.*]] = xor i64 [[TMP6]], 193514046488576
// CHECK-NEXT:    [[TMP8:%.*]] = inttoptr i64 [[TMP7]] to ptr
// CHECK-NEXT:    store [2 x <4 x i16>] zeroinitializer, ptr [[TMP8]], align 8
// CHECK-NEXT:    store [2 x <4 x i16>] [[B_COERCE]], ptr [[COERCE_DIVE]], align 8
// CHECK-NEXT:    [[TMP9:%.*]] = call ptr @__msan_memcpy(ptr [[__S1]], ptr [[B]], i64 16)
// CHECK-NEXT:    [[VAL:%.*]] = getelementptr inbounds [[STRUCT_UINT16X4X2_T]], ptr [[__S1]], i32 0, i32 0
// CHECK-NEXT:    [[ARRAYIDX:%.*]] = getelementptr inbounds [2 x <4 x i16>], ptr [[VAL]], i64 0, i64 0
// CHECK-NEXT:    [[TMP10:%.*]] = load <4 x i16>, ptr [[ARRAYIDX]], align 8
// CHECK-NEXT:    [[TMP11:%.*]] = bitcast <4 x i16> [[TMP10]] to <8 x i8>
// CHECK-NEXT:    [[VAL1:%.*]] = getelementptr inbounds [[STRUCT_UINT16X4X2_T]], ptr [[__S1]], i32 0, i32 0
// CHECK-NEXT:    [[ARRAYIDX2:%.*]] = getelementptr inbounds [2 x <4 x i16>], ptr [[VAL1]], i64 0, i64 1
// CHECK-NEXT:    [[TMP12:%.*]] = load <4 x i16>, ptr [[ARRAYIDX2]], align 8
// CHECK-NEXT:    [[TMP13:%.*]] = bitcast <4 x i16> [[TMP12]] to <8 x i8>
// CHECK-NEXT:    [[TMP14:%.*]] = bitcast <8 x i8> [[TMP11]] to <4 x i16>
// CHECK-NEXT:    [[TMP15:%.*]] = bitcast <8 x i8> [[TMP13]] to <4 x i16>
// CHECK-NEXT:    [[TMP16:%.*]] = ptrtoint ptr [[A]] to i64
// CHECK-NEXT:    [[TMP17:%.*]] = xor i64 [[TMP16]], 193514046488576
// CHECK-NEXT:    [[TMP18:%.*]] = inttoptr i64 [[TMP17]] to ptr
// CHECK-NEXT:    store <8 x i16> zeroinitializer, ptr [[TMP18]], align 1
// CHECK-NEXT:    call void @llvm.aarch64.neon.st2.v4i16.p0(<4 x i16> [[TMP14]], <4 x i16> [[TMP15]], ptr [[A]])
// CHECK-NEXT:    ret void
//
void test_vst2_u16(uint16_t *a, uint16x4x2_t b) {
  vst2_u16(a, b);
}

// CHECK-LABEL: define dso_local void @test_vst2_u32(
// CHECK-SAME: ptr noundef [[A:%.*]], [2 x <2 x i32>] alignstack(8) [[B_COERCE:%.*]]) #[[ATTR0]] {
// CHECK-NEXT:  entry:
// CHECK-NEXT:    call void @llvm.donothing()
// CHECK-NEXT:    [[B:%.*]] = alloca [[STRUCT_UINT32X2X2_T:%.*]], align 8
// CHECK-NEXT:    [[TMP0:%.*]] = ptrtoint ptr [[B]] to i64
// CHECK-NEXT:    [[TMP1:%.*]] = xor i64 [[TMP0]], 193514046488576
// CHECK-NEXT:    [[TMP2:%.*]] = inttoptr i64 [[TMP1]] to ptr
// CHECK-NEXT:    call void @llvm.memset.p0.i64(ptr align 8 [[TMP2]], i8 0, i64 16, i1 false)
// CHECK-NEXT:    [[__S1:%.*]] = alloca [[STRUCT_UINT32X2X2_T]], align 8
// CHECK-NEXT:    [[TMP3:%.*]] = ptrtoint ptr [[__S1]] to i64
// CHECK-NEXT:    [[TMP4:%.*]] = xor i64 [[TMP3]], 193514046488576
// CHECK-NEXT:    [[TMP5:%.*]] = inttoptr i64 [[TMP4]] to ptr
// CHECK-NEXT:    call void @llvm.memset.p0.i64(ptr align 8 [[TMP5]], i8 0, i64 16, i1 false)
// CHECK-NEXT:    [[COERCE_DIVE:%.*]] = getelementptr inbounds [[STRUCT_UINT32X2X2_T]], ptr [[B]], i32 0, i32 0
// CHECK-NEXT:    [[TMP6:%.*]] = ptrtoint ptr [[COERCE_DIVE]] to i64
// CHECK-NEXT:    [[TMP7:%.*]] = xor i64 [[TMP6]], 193514046488576
// CHECK-NEXT:    [[TMP8:%.*]] = inttoptr i64 [[TMP7]] to ptr
// CHECK-NEXT:    store [2 x <2 x i32>] zeroinitializer, ptr [[TMP8]], align 8
// CHECK-NEXT:    store [2 x <2 x i32>] [[B_COERCE]], ptr [[COERCE_DIVE]], align 8
// CHECK-NEXT:    [[TMP9:%.*]] = call ptr @__msan_memcpy(ptr [[__S1]], ptr [[B]], i64 16)
// CHECK-NEXT:    [[VAL:%.*]] = getelementptr inbounds [[STRUCT_UINT32X2X2_T]], ptr [[__S1]], i32 0, i32 0
// CHECK-NEXT:    [[ARRAYIDX:%.*]] = getelementptr inbounds [2 x <2 x i32>], ptr [[VAL]], i64 0, i64 0
// CHECK-NEXT:    [[TMP10:%.*]] = load <2 x i32>, ptr [[ARRAYIDX]], align 8
// CHECK-NEXT:    [[TMP11:%.*]] = bitcast <2 x i32> [[TMP10]] to <8 x i8>
// CHECK-NEXT:    [[VAL1:%.*]] = getelementptr inbounds [[STRUCT_UINT32X2X2_T]], ptr [[__S1]], i32 0, i32 0
// CHECK-NEXT:    [[ARRAYIDX2:%.*]] = getelementptr inbounds [2 x <2 x i32>], ptr [[VAL1]], i64 0, i64 1
// CHECK-NEXT:    [[TMP12:%.*]] = load <2 x i32>, ptr [[ARRAYIDX2]], align 8
// CHECK-NEXT:    [[TMP13:%.*]] = bitcast <2 x i32> [[TMP12]] to <8 x i8>
// CHECK-NEXT:    [[TMP14:%.*]] = bitcast <8 x i8> [[TMP11]] to <2 x i32>
// CHECK-NEXT:    [[TMP15:%.*]] = bitcast <8 x i8> [[TMP13]] to <2 x i32>
// CHECK-NEXT:    [[TMP16:%.*]] = ptrtoint ptr [[A]] to i64
// CHECK-NEXT:    [[TMP17:%.*]] = xor i64 [[TMP16]], 193514046488576
// CHECK-NEXT:    [[TMP18:%.*]] = inttoptr i64 [[TMP17]] to ptr
// CHECK-NEXT:    store <4 x i32> zeroinitializer, ptr [[TMP18]], align 1
// CHECK-NEXT:    call void @llvm.aarch64.neon.st2.v2i32.p0(<2 x i32> [[TMP14]], <2 x i32> [[TMP15]], ptr [[A]])
// CHECK-NEXT:    ret void
//
void test_vst2_u32(uint32_t *a, uint32x2x2_t b) {
  vst2_u32(a, b);
}

// CHECK-LABEL: define dso_local void @test_vst2_u64(
// CHECK-SAME: ptr noundef [[A:%.*]], [2 x <1 x i64>] alignstack(8) [[B_COERCE:%.*]]) #[[ATTR0]] {
// CHECK-NEXT:  entry:
// CHECK-NEXT:    call void @llvm.donothing()
// CHECK-NEXT:    [[B:%.*]] = alloca [[STRUCT_UINT64X1X2_T:%.*]], align 8
// CHECK-NEXT:    [[TMP0:%.*]] = ptrtoint ptr [[B]] to i64
// CHECK-NEXT:    [[TMP1:%.*]] = xor i64 [[TMP0]], 193514046488576
// CHECK-NEXT:    [[TMP2:%.*]] = inttoptr i64 [[TMP1]] to ptr
// CHECK-NEXT:    call void @llvm.memset.p0.i64(ptr align 8 [[TMP2]], i8 0, i64 16, i1 false)
// CHECK-NEXT:    [[__S1:%.*]] = alloca [[STRUCT_UINT64X1X2_T]], align 8
// CHECK-NEXT:    [[TMP3:%.*]] = ptrtoint ptr [[__S1]] to i64
// CHECK-NEXT:    [[TMP4:%.*]] = xor i64 [[TMP3]], 193514046488576
// CHECK-NEXT:    [[TMP5:%.*]] = inttoptr i64 [[TMP4]] to ptr
// CHECK-NEXT:    call void @llvm.memset.p0.i64(ptr align 8 [[TMP5]], i8 0, i64 16, i1 false)
// CHECK-NEXT:    [[COERCE_DIVE:%.*]] = getelementptr inbounds [[STRUCT_UINT64X1X2_T]], ptr [[B]], i32 0, i32 0
// CHECK-NEXT:    [[TMP6:%.*]] = ptrtoint ptr [[COERCE_DIVE]] to i64
// CHECK-NEXT:    [[TMP7:%.*]] = xor i64 [[TMP6]], 193514046488576
// CHECK-NEXT:    [[TMP8:%.*]] = inttoptr i64 [[TMP7]] to ptr
// CHECK-NEXT:    store [2 x <1 x i64>] zeroinitializer, ptr [[TMP8]], align 8
// CHECK-NEXT:    store [2 x <1 x i64>] [[B_COERCE]], ptr [[COERCE_DIVE]], align 8
// CHECK-NEXT:    [[TMP9:%.*]] = call ptr @__msan_memcpy(ptr [[__S1]], ptr [[B]], i64 16)
// CHECK-NEXT:    [[VAL:%.*]] = getelementptr inbounds [[STRUCT_UINT64X1X2_T]], ptr [[__S1]], i32 0, i32 0
// CHECK-NEXT:    [[ARRAYIDX:%.*]] = getelementptr inbounds [2 x <1 x i64>], ptr [[VAL]], i64 0, i64 0
// CHECK-NEXT:    [[TMP10:%.*]] = load <1 x i64>, ptr [[ARRAYIDX]], align 8
// CHECK-NEXT:    [[TMP11:%.*]] = bitcast <1 x i64> [[TMP10]] to <8 x i8>
// CHECK-NEXT:    [[VAL1:%.*]] = getelementptr inbounds [[STRUCT_UINT64X1X2_T]], ptr [[__S1]], i32 0, i32 0
// CHECK-NEXT:    [[ARRAYIDX2:%.*]] = getelementptr inbounds [2 x <1 x i64>], ptr [[VAL1]], i64 0, i64 1
// CHECK-NEXT:    [[TMP12:%.*]] = load <1 x i64>, ptr [[ARRAYIDX2]], align 8
// CHECK-NEXT:    [[TMP13:%.*]] = bitcast <1 x i64> [[TMP12]] to <8 x i8>
// CHECK-NEXT:    [[TMP14:%.*]] = bitcast <8 x i8> [[TMP11]] to <1 x i64>
// CHECK-NEXT:    [[TMP15:%.*]] = bitcast <8 x i8> [[TMP13]] to <1 x i64>
// CHECK-NEXT:    [[TMP16:%.*]] = ptrtoint ptr [[A]] to i64
// CHECK-NEXT:    [[TMP17:%.*]] = xor i64 [[TMP16]], 193514046488576
// CHECK-NEXT:    [[TMP18:%.*]] = inttoptr i64 [[TMP17]] to ptr
// CHECK-NEXT:    store <2 x i64> zeroinitializer, ptr [[TMP18]], align 1
// CHECK-NEXT:    call void @llvm.aarch64.neon.st2.v1i64.p0(<1 x i64> [[TMP14]], <1 x i64> [[TMP15]], ptr [[A]])
// CHECK-NEXT:    ret void
//
void test_vst2_u64(uint64_t *a, uint64x1x2_t b) {
  vst2_u64(a, b);
}

// CHECK-LABEL: define dso_local void @test_vst2_s8(
// CHECK-SAME: ptr noundef [[A:%.*]], [2 x <8 x i8>] alignstack(8) [[B_COERCE:%.*]]) #[[ATTR0]] {
// CHECK-NEXT:  entry:
// CHECK-NEXT:    call void @llvm.donothing()
// CHECK-NEXT:    [[B:%.*]] = alloca [[STRUCT_INT8X8X2_T:%.*]], align 8
// CHECK-NEXT:    [[TMP0:%.*]] = ptrtoint ptr [[B]] to i64
// CHECK-NEXT:    [[TMP1:%.*]] = xor i64 [[TMP0]], 193514046488576
// CHECK-NEXT:    [[TMP2:%.*]] = inttoptr i64 [[TMP1]] to ptr
// CHECK-NEXT:    call void @llvm.memset.p0.i64(ptr align 8 [[TMP2]], i8 0, i64 16, i1 false)
// CHECK-NEXT:    [[__S1:%.*]] = alloca [[STRUCT_INT8X8X2_T]], align 8
// CHECK-NEXT:    [[TMP3:%.*]] = ptrtoint ptr [[__S1]] to i64
// CHECK-NEXT:    [[TMP4:%.*]] = xor i64 [[TMP3]], 193514046488576
// CHECK-NEXT:    [[TMP5:%.*]] = inttoptr i64 [[TMP4]] to ptr
// CHECK-NEXT:    call void @llvm.memset.p0.i64(ptr align 8 [[TMP5]], i8 0, i64 16, i1 false)
// CHECK-NEXT:    [[COERCE_DIVE:%.*]] = getelementptr inbounds [[STRUCT_INT8X8X2_T]], ptr [[B]], i32 0, i32 0
// CHECK-NEXT:    [[TMP6:%.*]] = ptrtoint ptr [[COERCE_DIVE]] to i64
// CHECK-NEXT:    [[TMP7:%.*]] = xor i64 [[TMP6]], 193514046488576
// CHECK-NEXT:    [[TMP8:%.*]] = inttoptr i64 [[TMP7]] to ptr
// CHECK-NEXT:    store [2 x <8 x i8>] zeroinitializer, ptr [[TMP8]], align 8
// CHECK-NEXT:    store [2 x <8 x i8>] [[B_COERCE]], ptr [[COERCE_DIVE]], align 8
// CHECK-NEXT:    [[TMP9:%.*]] = call ptr @__msan_memcpy(ptr [[__S1]], ptr [[B]], i64 16)
// CHECK-NEXT:    [[VAL:%.*]] = getelementptr inbounds [[STRUCT_INT8X8X2_T]], ptr [[__S1]], i32 0, i32 0
// CHECK-NEXT:    [[ARRAYIDX:%.*]] = getelementptr inbounds [2 x <8 x i8>], ptr [[VAL]], i64 0, i64 0
// CHECK-NEXT:    [[TMP10:%.*]] = load <8 x i8>, ptr [[ARRAYIDX]], align 8
// CHECK-NEXT:    [[VAL1:%.*]] = getelementptr inbounds [[STRUCT_INT8X8X2_T]], ptr [[__S1]], i32 0, i32 0
// CHECK-NEXT:    [[ARRAYIDX2:%.*]] = getelementptr inbounds [2 x <8 x i8>], ptr [[VAL1]], i64 0, i64 1
// CHECK-NEXT:    [[TMP11:%.*]] = load <8 x i8>, ptr [[ARRAYIDX2]], align 8
// CHECK-NEXT:    [[TMP12:%.*]] = ptrtoint ptr [[A]] to i64
// CHECK-NEXT:    [[TMP13:%.*]] = xor i64 [[TMP12]], 193514046488576
// CHECK-NEXT:    [[TMP14:%.*]] = inttoptr i64 [[TMP13]] to ptr
// CHECK-NEXT:    store <16 x i8> zeroinitializer, ptr [[TMP14]], align 1
// CHECK-NEXT:    call void @llvm.aarch64.neon.st2.v8i8.p0(<8 x i8> [[TMP10]], <8 x i8> [[TMP11]], ptr [[A]])
// CHECK-NEXT:    ret void
//
void test_vst2_s8(int8_t *a, int8x8x2_t b) {
  vst2_s8(a, b);
}

// CHECK-LABEL: define dso_local void @test_vst2_s16(
// CHECK-SAME: ptr noundef [[A:%.*]], [2 x <4 x i16>] alignstack(8) [[B_COERCE:%.*]]) #[[ATTR0]] {
// CHECK-NEXT:  entry:
// CHECK-NEXT:    call void @llvm.donothing()
// CHECK-NEXT:    [[B:%.*]] = alloca [[STRUCT_INT16X4X2_T:%.*]], align 8
// CHECK-NEXT:    [[TMP0:%.*]] = ptrtoint ptr [[B]] to i64
// CHECK-NEXT:    [[TMP1:%.*]] = xor i64 [[TMP0]], 193514046488576
// CHECK-NEXT:    [[TMP2:%.*]] = inttoptr i64 [[TMP1]] to ptr
// CHECK-NEXT:    call void @llvm.memset.p0.i64(ptr align 8 [[TMP2]], i8 0, i64 16, i1 false)
// CHECK-NEXT:    [[__S1:%.*]] = alloca [[STRUCT_INT16X4X2_T]], align 8
// CHECK-NEXT:    [[TMP3:%.*]] = ptrtoint ptr [[__S1]] to i64
// CHECK-NEXT:    [[TMP4:%.*]] = xor i64 [[TMP3]], 193514046488576
// CHECK-NEXT:    [[TMP5:%.*]] = inttoptr i64 [[TMP4]] to ptr
// CHECK-NEXT:    call void @llvm.memset.p0.i64(ptr align 8 [[TMP5]], i8 0, i64 16, i1 false)
// CHECK-NEXT:    [[COERCE_DIVE:%.*]] = getelementptr inbounds [[STRUCT_INT16X4X2_T]], ptr [[B]], i32 0, i32 0
// CHECK-NEXT:    [[TMP6:%.*]] = ptrtoint ptr [[COERCE_DIVE]] to i64
// CHECK-NEXT:    [[TMP7:%.*]] = xor i64 [[TMP6]], 193514046488576
// CHECK-NEXT:    [[TMP8:%.*]] = inttoptr i64 [[TMP7]] to ptr
// CHECK-NEXT:    store [2 x <4 x i16>] zeroinitializer, ptr [[TMP8]], align 8
// CHECK-NEXT:    store [2 x <4 x i16>] [[B_COERCE]], ptr [[COERCE_DIVE]], align 8
// CHECK-NEXT:    [[TMP9:%.*]] = call ptr @__msan_memcpy(ptr [[__S1]], ptr [[B]], i64 16)
// CHECK-NEXT:    [[VAL:%.*]] = getelementptr inbounds [[STRUCT_INT16X4X2_T]], ptr [[__S1]], i32 0, i32 0
// CHECK-NEXT:    [[ARRAYIDX:%.*]] = getelementptr inbounds [2 x <4 x i16>], ptr [[VAL]], i64 0, i64 0
// CHECK-NEXT:    [[TMP10:%.*]] = load <4 x i16>, ptr [[ARRAYIDX]], align 8
// CHECK-NEXT:    [[TMP11:%.*]] = bitcast <4 x i16> [[TMP10]] to <8 x i8>
// CHECK-NEXT:    [[VAL1:%.*]] = getelementptr inbounds [[STRUCT_INT16X4X2_T]], ptr [[__S1]], i32 0, i32 0
// CHECK-NEXT:    [[ARRAYIDX2:%.*]] = getelementptr inbounds [2 x <4 x i16>], ptr [[VAL1]], i64 0, i64 1
// CHECK-NEXT:    [[TMP12:%.*]] = load <4 x i16>, ptr [[ARRAYIDX2]], align 8
// CHECK-NEXT:    [[TMP13:%.*]] = bitcast <4 x i16> [[TMP12]] to <8 x i8>
// CHECK-NEXT:    [[TMP14:%.*]] = bitcast <8 x i8> [[TMP11]] to <4 x i16>
// CHECK-NEXT:    [[TMP15:%.*]] = bitcast <8 x i8> [[TMP13]] to <4 x i16>
// CHECK-NEXT:    [[TMP16:%.*]] = ptrtoint ptr [[A]] to i64
// CHECK-NEXT:    [[TMP17:%.*]] = xor i64 [[TMP16]], 193514046488576
// CHECK-NEXT:    [[TMP18:%.*]] = inttoptr i64 [[TMP17]] to ptr
// CHECK-NEXT:    store <8 x i16> zeroinitializer, ptr [[TMP18]], align 1
// CHECK-NEXT:    call void @llvm.aarch64.neon.st2.v4i16.p0(<4 x i16> [[TMP14]], <4 x i16> [[TMP15]], ptr [[A]])
// CHECK-NEXT:    ret void
//
void test_vst2_s16(int16_t *a, int16x4x2_t b) {
  vst2_s16(a, b);
}

// CHECK-LABEL: define dso_local void @test_vst2_s32(
// CHECK-SAME: ptr noundef [[A:%.*]], [2 x <2 x i32>] alignstack(8) [[B_COERCE:%.*]]) #[[ATTR0]] {
// CHECK-NEXT:  entry:
// CHECK-NEXT:    call void @llvm.donothing()
// CHECK-NEXT:    [[B:%.*]] = alloca [[STRUCT_INT32X2X2_T:%.*]], align 8
// CHECK-NEXT:    [[TMP0:%.*]] = ptrtoint ptr [[B]] to i64
// CHECK-NEXT:    [[TMP1:%.*]] = xor i64 [[TMP0]], 193514046488576
// CHECK-NEXT:    [[TMP2:%.*]] = inttoptr i64 [[TMP1]] to ptr
// CHECK-NEXT:    call void @llvm.memset.p0.i64(ptr align 8 [[TMP2]], i8 0, i64 16, i1 false)
// CHECK-NEXT:    [[__S1:%.*]] = alloca [[STRUCT_INT32X2X2_T]], align 8
// CHECK-NEXT:    [[TMP3:%.*]] = ptrtoint ptr [[__S1]] to i64
// CHECK-NEXT:    [[TMP4:%.*]] = xor i64 [[TMP3]], 193514046488576
// CHECK-NEXT:    [[TMP5:%.*]] = inttoptr i64 [[TMP4]] to ptr
// CHECK-NEXT:    call void @llvm.memset.p0.i64(ptr align 8 [[TMP5]], i8 0, i64 16, i1 false)
// CHECK-NEXT:    [[COERCE_DIVE:%.*]] = getelementptr inbounds [[STRUCT_INT32X2X2_T]], ptr [[B]], i32 0, i32 0
// CHECK-NEXT:    [[TMP6:%.*]] = ptrtoint ptr [[COERCE_DIVE]] to i64
// CHECK-NEXT:    [[TMP7:%.*]] = xor i64 [[TMP6]], 193514046488576
// CHECK-NEXT:    [[TMP8:%.*]] = inttoptr i64 [[TMP7]] to ptr
// CHECK-NEXT:    store [2 x <2 x i32>] zeroinitializer, ptr [[TMP8]], align 8
// CHECK-NEXT:    store [2 x <2 x i32>] [[B_COERCE]], ptr [[COERCE_DIVE]], align 8
// CHECK-NEXT:    [[TMP9:%.*]] = call ptr @__msan_memcpy(ptr [[__S1]], ptr [[B]], i64 16)
// CHECK-NEXT:    [[VAL:%.*]] = getelementptr inbounds [[STRUCT_INT32X2X2_T]], ptr [[__S1]], i32 0, i32 0
// CHECK-NEXT:    [[ARRAYIDX:%.*]] = getelementptr inbounds [2 x <2 x i32>], ptr [[VAL]], i64 0, i64 0
// CHECK-NEXT:    [[TMP10:%.*]] = load <2 x i32>, ptr [[ARRAYIDX]], align 8
// CHECK-NEXT:    [[TMP11:%.*]] = bitcast <2 x i32> [[TMP10]] to <8 x i8>
// CHECK-NEXT:    [[VAL1:%.*]] = getelementptr inbounds [[STRUCT_INT32X2X2_T]], ptr [[__S1]], i32 0, i32 0
// CHECK-NEXT:    [[ARRAYIDX2:%.*]] = getelementptr inbounds [2 x <2 x i32>], ptr [[VAL1]], i64 0, i64 1
// CHECK-NEXT:    [[TMP12:%.*]] = load <2 x i32>, ptr [[ARRAYIDX2]], align 8
// CHECK-NEXT:    [[TMP13:%.*]] = bitcast <2 x i32> [[TMP12]] to <8 x i8>
// CHECK-NEXT:    [[TMP14:%.*]] = bitcast <8 x i8> [[TMP11]] to <2 x i32>
// CHECK-NEXT:    [[TMP15:%.*]] = bitcast <8 x i8> [[TMP13]] to <2 x i32>
// CHECK-NEXT:    [[TMP16:%.*]] = ptrtoint ptr [[A]] to i64
// CHECK-NEXT:    [[TMP17:%.*]] = xor i64 [[TMP16]], 193514046488576
// CHECK-NEXT:    [[TMP18:%.*]] = inttoptr i64 [[TMP17]] to ptr
// CHECK-NEXT:    store <4 x i32> zeroinitializer, ptr [[TMP18]], align 1
// CHECK-NEXT:    call void @llvm.aarch64.neon.st2.v2i32.p0(<2 x i32> [[TMP14]], <2 x i32> [[TMP15]], ptr [[A]])
// CHECK-NEXT:    ret void
//
void test_vst2_s32(int32_t *a, int32x2x2_t b) {
  vst2_s32(a, b);
}

// CHECK-LABEL: define dso_local void @test_vst2_s64(
// CHECK-SAME: ptr noundef [[A:%.*]], [2 x <1 x i64>] alignstack(8) [[B_COERCE:%.*]]) #[[ATTR0]] {
// CHECK-NEXT:  entry:
// CHECK-NEXT:    call void @llvm.donothing()
// CHECK-NEXT:    [[B:%.*]] = alloca [[STRUCT_INT64X1X2_T:%.*]], align 8
// CHECK-NEXT:    [[TMP0:%.*]] = ptrtoint ptr [[B]] to i64
// CHECK-NEXT:    [[TMP1:%.*]] = xor i64 [[TMP0]], 193514046488576
// CHECK-NEXT:    [[TMP2:%.*]] = inttoptr i64 [[TMP1]] to ptr
// CHECK-NEXT:    call void @llvm.memset.p0.i64(ptr align 8 [[TMP2]], i8 0, i64 16, i1 false)
// CHECK-NEXT:    [[__S1:%.*]] = alloca [[STRUCT_INT64X1X2_T]], align 8
// CHECK-NEXT:    [[TMP3:%.*]] = ptrtoint ptr [[__S1]] to i64
// CHECK-NEXT:    [[TMP4:%.*]] = xor i64 [[TMP3]], 193514046488576
// CHECK-NEXT:    [[TMP5:%.*]] = inttoptr i64 [[TMP4]] to ptr
// CHECK-NEXT:    call void @llvm.memset.p0.i64(ptr align 8 [[TMP5]], i8 0, i64 16, i1 false)
// CHECK-NEXT:    [[COERCE_DIVE:%.*]] = getelementptr inbounds [[STRUCT_INT64X1X2_T]], ptr [[B]], i32 0, i32 0
// CHECK-NEXT:    [[TMP6:%.*]] = ptrtoint ptr [[COERCE_DIVE]] to i64
// CHECK-NEXT:    [[TMP7:%.*]] = xor i64 [[TMP6]], 193514046488576
// CHECK-NEXT:    [[TMP8:%.*]] = inttoptr i64 [[TMP7]] to ptr
// CHECK-NEXT:    store [2 x <1 x i64>] zeroinitializer, ptr [[TMP8]], align 8
// CHECK-NEXT:    store [2 x <1 x i64>] [[B_COERCE]], ptr [[COERCE_DIVE]], align 8
// CHECK-NEXT:    [[TMP9:%.*]] = call ptr @__msan_memcpy(ptr [[__S1]], ptr [[B]], i64 16)
// CHECK-NEXT:    [[VAL:%.*]] = getelementptr inbounds [[STRUCT_INT64X1X2_T]], ptr [[__S1]], i32 0, i32 0
// CHECK-NEXT:    [[ARRAYIDX:%.*]] = getelementptr inbounds [2 x <1 x i64>], ptr [[VAL]], i64 0, i64 0
// CHECK-NEXT:    [[TMP10:%.*]] = load <1 x i64>, ptr [[ARRAYIDX]], align 8
// CHECK-NEXT:    [[TMP11:%.*]] = bitcast <1 x i64> [[TMP10]] to <8 x i8>
// CHECK-NEXT:    [[VAL1:%.*]] = getelementptr inbounds [[STRUCT_INT64X1X2_T]], ptr [[__S1]], i32 0, i32 0
// CHECK-NEXT:    [[ARRAYIDX2:%.*]] = getelementptr inbounds [2 x <1 x i64>], ptr [[VAL1]], i64 0, i64 1
// CHECK-NEXT:    [[TMP12:%.*]] = load <1 x i64>, ptr [[ARRAYIDX2]], align 8
// CHECK-NEXT:    [[TMP13:%.*]] = bitcast <1 x i64> [[TMP12]] to <8 x i8>
// CHECK-NEXT:    [[TMP14:%.*]] = bitcast <8 x i8> [[TMP11]] to <1 x i64>
// CHECK-NEXT:    [[TMP15:%.*]] = bitcast <8 x i8> [[TMP13]] to <1 x i64>
// CHECK-NEXT:    [[TMP16:%.*]] = ptrtoint ptr [[A]] to i64
// CHECK-NEXT:    [[TMP17:%.*]] = xor i64 [[TMP16]], 193514046488576
// CHECK-NEXT:    [[TMP18:%.*]] = inttoptr i64 [[TMP17]] to ptr
// CHECK-NEXT:    store <2 x i64> zeroinitializer, ptr [[TMP18]], align 1
// CHECK-NEXT:    call void @llvm.aarch64.neon.st2.v1i64.p0(<1 x i64> [[TMP14]], <1 x i64> [[TMP15]], ptr [[A]])
// CHECK-NEXT:    ret void
//
void test_vst2_s64(int64_t *a, int64x1x2_t b) {
  vst2_s64(a, b);
}

// CHECK-LABEL: define dso_local void @test_vst2_f16(
// CHECK-SAME: ptr noundef [[A:%.*]], [2 x <4 x half>] alignstack(8) [[B_COERCE:%.*]]) #[[ATTR0]] {
// CHECK-NEXT:  entry:
// CHECK-NEXT:    call void @llvm.donothing()
// CHECK-NEXT:    [[B:%.*]] = alloca [[STRUCT_FLOAT16X4X2_T:%.*]], align 8
// CHECK-NEXT:    [[TMP0:%.*]] = ptrtoint ptr [[B]] to i64
// CHECK-NEXT:    [[TMP1:%.*]] = xor i64 [[TMP0]], 193514046488576
// CHECK-NEXT:    [[TMP2:%.*]] = inttoptr i64 [[TMP1]] to ptr
// CHECK-NEXT:    call void @llvm.memset.p0.i64(ptr align 8 [[TMP2]], i8 0, i64 16, i1 false)
// CHECK-NEXT:    [[__S1:%.*]] = alloca [[STRUCT_FLOAT16X4X2_T]], align 8
// CHECK-NEXT:    [[TMP3:%.*]] = ptrtoint ptr [[__S1]] to i64
// CHECK-NEXT:    [[TMP4:%.*]] = xor i64 [[TMP3]], 193514046488576
// CHECK-NEXT:    [[TMP5:%.*]] = inttoptr i64 [[TMP4]] to ptr
// CHECK-NEXT:    call void @llvm.memset.p0.i64(ptr align 8 [[TMP5]], i8 0, i64 16, i1 false)
// CHECK-NEXT:    [[COERCE_DIVE:%.*]] = getelementptr inbounds [[STRUCT_FLOAT16X4X2_T]], ptr [[B]], i32 0, i32 0
// CHECK-NEXT:    [[TMP6:%.*]] = ptrtoint ptr [[COERCE_DIVE]] to i64
// CHECK-NEXT:    [[TMP7:%.*]] = xor i64 [[TMP6]], 193514046488576
// CHECK-NEXT:    [[TMP8:%.*]] = inttoptr i64 [[TMP7]] to ptr
// CHECK-NEXT:    store [2 x <4 x i16>] zeroinitializer, ptr [[TMP8]], align 8
// CHECK-NEXT:    store [2 x <4 x half>] [[B_COERCE]], ptr [[COERCE_DIVE]], align 8
// CHECK-NEXT:    [[TMP9:%.*]] = call ptr @__msan_memcpy(ptr [[__S1]], ptr [[B]], i64 16)
// CHECK-NEXT:    [[VAL:%.*]] = getelementptr inbounds [[STRUCT_FLOAT16X4X2_T]], ptr [[__S1]], i32 0, i32 0
// CHECK-NEXT:    [[ARRAYIDX:%.*]] = getelementptr inbounds [2 x <4 x half>], ptr [[VAL]], i64 0, i64 0
// CHECK-NEXT:    [[TMP10:%.*]] = load <4 x half>, ptr [[ARRAYIDX]], align 8
// CHECK-NEXT:    [[TMP11:%.*]] = bitcast <4 x half> [[TMP10]] to <8 x i8>
// CHECK-NEXT:    [[VAL1:%.*]] = getelementptr inbounds [[STRUCT_FLOAT16X4X2_T]], ptr [[__S1]], i32 0, i32 0
// CHECK-NEXT:    [[ARRAYIDX2:%.*]] = getelementptr inbounds [2 x <4 x half>], ptr [[VAL1]], i64 0, i64 1
// CHECK-NEXT:    [[TMP12:%.*]] = load <4 x half>, ptr [[ARRAYIDX2]], align 8
// CHECK-NEXT:    [[TMP13:%.*]] = bitcast <4 x half> [[TMP12]] to <8 x i8>
// CHECK-NEXT:    [[TMP14:%.*]] = bitcast <8 x i8> [[TMP11]] to <4 x half>
// CHECK-NEXT:    [[TMP15:%.*]] = bitcast <8 x i8> [[TMP13]] to <4 x half>
// CHECK-NEXT:    [[TMP16:%.*]] = ptrtoint ptr [[A]] to i64
// CHECK-NEXT:    [[TMP17:%.*]] = xor i64 [[TMP16]], 193514046488576
// CHECK-NEXT:    [[TMP18:%.*]] = inttoptr i64 [[TMP17]] to ptr
// CHECK-NEXT:    store <8 x i16> zeroinitializer, ptr [[TMP18]], align 1
// CHECK-NEXT:    call void @llvm.aarch64.neon.st2.v4f16.p0(<4 x half> [[TMP14]], <4 x half> [[TMP15]], ptr [[A]])
// CHECK-NEXT:    ret void
//
void test_vst2_f16(float16_t *a, float16x4x2_t b) {
  vst2_f16(a, b);
}

// CHECK-LABEL: define dso_local void @test_vst2_f32(
// CHECK-SAME: ptr noundef [[A:%.*]], [2 x <2 x float>] alignstack(8) [[B_COERCE:%.*]]) #[[ATTR0]] {
// CHECK-NEXT:  entry:
// CHECK-NEXT:    call void @llvm.donothing()
// CHECK-NEXT:    [[B:%.*]] = alloca [[STRUCT_FLOAT32X2X2_T:%.*]], align 8
// CHECK-NEXT:    [[TMP0:%.*]] = ptrtoint ptr [[B]] to i64
// CHECK-NEXT:    [[TMP1:%.*]] = xor i64 [[TMP0]], 193514046488576
// CHECK-NEXT:    [[TMP2:%.*]] = inttoptr i64 [[TMP1]] to ptr
// CHECK-NEXT:    call void @llvm.memset.p0.i64(ptr align 8 [[TMP2]], i8 0, i64 16, i1 false)
// CHECK-NEXT:    [[__S1:%.*]] = alloca [[STRUCT_FLOAT32X2X2_T]], align 8
// CHECK-NEXT:    [[TMP3:%.*]] = ptrtoint ptr [[__S1]] to i64
// CHECK-NEXT:    [[TMP4:%.*]] = xor i64 [[TMP3]], 193514046488576
// CHECK-NEXT:    [[TMP5:%.*]] = inttoptr i64 [[TMP4]] to ptr
// CHECK-NEXT:    call void @llvm.memset.p0.i64(ptr align 8 [[TMP5]], i8 0, i64 16, i1 false)
// CHECK-NEXT:    [[COERCE_DIVE:%.*]] = getelementptr inbounds [[STRUCT_FLOAT32X2X2_T]], ptr [[B]], i32 0, i32 0
// CHECK-NEXT:    [[TMP6:%.*]] = ptrtoint ptr [[COERCE_DIVE]] to i64
// CHECK-NEXT:    [[TMP7:%.*]] = xor i64 [[TMP6]], 193514046488576
// CHECK-NEXT:    [[TMP8:%.*]] = inttoptr i64 [[TMP7]] to ptr
// CHECK-NEXT:    store [2 x <2 x i32>] zeroinitializer, ptr [[TMP8]], align 8
// CHECK-NEXT:    store [2 x <2 x float>] [[B_COERCE]], ptr [[COERCE_DIVE]], align 8
// CHECK-NEXT:    [[TMP9:%.*]] = call ptr @__msan_memcpy(ptr [[__S1]], ptr [[B]], i64 16)
// CHECK-NEXT:    [[VAL:%.*]] = getelementptr inbounds [[STRUCT_FLOAT32X2X2_T]], ptr [[__S1]], i32 0, i32 0
// CHECK-NEXT:    [[ARRAYIDX:%.*]] = getelementptr inbounds [2 x <2 x float>], ptr [[VAL]], i64 0, i64 0
// CHECK-NEXT:    [[TMP10:%.*]] = load <2 x float>, ptr [[ARRAYIDX]], align 8
// CHECK-NEXT:    [[TMP11:%.*]] = bitcast <2 x float> [[TMP10]] to <8 x i8>
// CHECK-NEXT:    [[VAL1:%.*]] = getelementptr inbounds [[STRUCT_FLOAT32X2X2_T]], ptr [[__S1]], i32 0, i32 0
// CHECK-NEXT:    [[ARRAYIDX2:%.*]] = getelementptr inbounds [2 x <2 x float>], ptr [[VAL1]], i64 0, i64 1
// CHECK-NEXT:    [[TMP12:%.*]] = load <2 x float>, ptr [[ARRAYIDX2]], align 8
// CHECK-NEXT:    [[TMP13:%.*]] = bitcast <2 x float> [[TMP12]] to <8 x i8>
// CHECK-NEXT:    [[TMP14:%.*]] = bitcast <8 x i8> [[TMP11]] to <2 x float>
// CHECK-NEXT:    [[TMP15:%.*]] = bitcast <8 x i8> [[TMP13]] to <2 x float>
// CHECK-NEXT:    [[TMP16:%.*]] = ptrtoint ptr [[A]] to i64
// CHECK-NEXT:    [[TMP17:%.*]] = xor i64 [[TMP16]], 193514046488576
// CHECK-NEXT:    [[TMP18:%.*]] = inttoptr i64 [[TMP17]] to ptr
// CHECK-NEXT:    store <4 x i32> zeroinitializer, ptr [[TMP18]], align 1
// CHECK-NEXT:    call void @llvm.aarch64.neon.st2.v2f32.p0(<2 x float> [[TMP14]], <2 x float> [[TMP15]], ptr [[A]])
// CHECK-NEXT:    ret void
//
void test_vst2_f32(float32_t *a, float32x2x2_t b) {
  vst2_f32(a, b);
}

// CHECK-LABEL: define dso_local void @test_vst2_f64(
// CHECK-SAME: ptr noundef [[A:%.*]], [2 x <1 x double>] alignstack(8) [[B_COERCE:%.*]]) #[[ATTR0]] {
// CHECK-NEXT:  entry:
// CHECK-NEXT:    call void @llvm.donothing()
// CHECK-NEXT:    [[B:%.*]] = alloca [[STRUCT_FLOAT64X1X2_T:%.*]], align 8
// CHECK-NEXT:    [[TMP0:%.*]] = ptrtoint ptr [[B]] to i64
// CHECK-NEXT:    [[TMP1:%.*]] = xor i64 [[TMP0]], 193514046488576
// CHECK-NEXT:    [[TMP2:%.*]] = inttoptr i64 [[TMP1]] to ptr
// CHECK-NEXT:    call void @llvm.memset.p0.i64(ptr align 8 [[TMP2]], i8 0, i64 16, i1 false)
// CHECK-NEXT:    [[__S1:%.*]] = alloca [[STRUCT_FLOAT64X1X2_T]], align 8
// CHECK-NEXT:    [[TMP3:%.*]] = ptrtoint ptr [[__S1]] to i64
// CHECK-NEXT:    [[TMP4:%.*]] = xor i64 [[TMP3]], 193514046488576
// CHECK-NEXT:    [[TMP5:%.*]] = inttoptr i64 [[TMP4]] to ptr
// CHECK-NEXT:    call void @llvm.memset.p0.i64(ptr align 8 [[TMP5]], i8 0, i64 16, i1 false)
// CHECK-NEXT:    [[COERCE_DIVE:%.*]] = getelementptr inbounds [[STRUCT_FLOAT64X1X2_T]], ptr [[B]], i32 0, i32 0
// CHECK-NEXT:    [[TMP6:%.*]] = ptrtoint ptr [[COERCE_DIVE]] to i64
// CHECK-NEXT:    [[TMP7:%.*]] = xor i64 [[TMP6]], 193514046488576
// CHECK-NEXT:    [[TMP8:%.*]] = inttoptr i64 [[TMP7]] to ptr
// CHECK-NEXT:    store [2 x <1 x i64>] zeroinitializer, ptr [[TMP8]], align 8
// CHECK-NEXT:    store [2 x <1 x double>] [[B_COERCE]], ptr [[COERCE_DIVE]], align 8
// CHECK-NEXT:    [[TMP9:%.*]] = call ptr @__msan_memcpy(ptr [[__S1]], ptr [[B]], i64 16)
// CHECK-NEXT:    [[VAL:%.*]] = getelementptr inbounds [[STRUCT_FLOAT64X1X2_T]], ptr [[__S1]], i32 0, i32 0
// CHECK-NEXT:    [[ARRAYIDX:%.*]] = getelementptr inbounds [2 x <1 x double>], ptr [[VAL]], i64 0, i64 0
// CHECK-NEXT:    [[TMP10:%.*]] = load <1 x double>, ptr [[ARRAYIDX]], align 8
// CHECK-NEXT:    [[TMP11:%.*]] = bitcast <1 x double> [[TMP10]] to <8 x i8>
// CHECK-NEXT:    [[VAL1:%.*]] = getelementptr inbounds [[STRUCT_FLOAT64X1X2_T]], ptr [[__S1]], i32 0, i32 0
// CHECK-NEXT:    [[ARRAYIDX2:%.*]] = getelementptr inbounds [2 x <1 x double>], ptr [[VAL1]], i64 0, i64 1
// CHECK-NEXT:    [[TMP12:%.*]] = load <1 x double>, ptr [[ARRAYIDX2]], align 8
// CHECK-NEXT:    [[TMP13:%.*]] = bitcast <1 x double> [[TMP12]] to <8 x i8>
// CHECK-NEXT:    [[TMP14:%.*]] = bitcast <8 x i8> [[TMP11]] to <1 x double>
// CHECK-NEXT:    [[TMP15:%.*]] = bitcast <8 x i8> [[TMP13]] to <1 x double>
// CHECK-NEXT:    [[TMP16:%.*]] = ptrtoint ptr [[A]] to i64
// CHECK-NEXT:    [[TMP17:%.*]] = xor i64 [[TMP16]], 193514046488576
// CHECK-NEXT:    [[TMP18:%.*]] = inttoptr i64 [[TMP17]] to ptr
// CHECK-NEXT:    store <2 x i64> zeroinitializer, ptr [[TMP18]], align 1
// CHECK-NEXT:    call void @llvm.aarch64.neon.st2.v1f64.p0(<1 x double> [[TMP14]], <1 x double> [[TMP15]], ptr [[A]])
// CHECK-NEXT:    ret void
//
void test_vst2_f64(float64_t *a, float64x1x2_t b) {
  vst2_f64(a, b);
}

// CHECK-LABEL: define dso_local void @test_vst2_p8(
// CHECK-SAME: ptr noundef [[A:%.*]], [2 x <8 x i8>] alignstack(8) [[B_COERCE:%.*]]) #[[ATTR0]] {
// CHECK-NEXT:  entry:
// CHECK-NEXT:    call void @llvm.donothing()
// CHECK-NEXT:    [[B:%.*]] = alloca [[STRUCT_POLY8X8X2_T:%.*]], align 8
// CHECK-NEXT:    [[TMP0:%.*]] = ptrtoint ptr [[B]] to i64
// CHECK-NEXT:    [[TMP1:%.*]] = xor i64 [[TMP0]], 193514046488576
// CHECK-NEXT:    [[TMP2:%.*]] = inttoptr i64 [[TMP1]] to ptr
// CHECK-NEXT:    call void @llvm.memset.p0.i64(ptr align 8 [[TMP2]], i8 0, i64 16, i1 false)
// CHECK-NEXT:    [[__S1:%.*]] = alloca [[STRUCT_POLY8X8X2_T]], align 8
// CHECK-NEXT:    [[TMP3:%.*]] = ptrtoint ptr [[__S1]] to i64
// CHECK-NEXT:    [[TMP4:%.*]] = xor i64 [[TMP3]], 193514046488576
// CHECK-NEXT:    [[TMP5:%.*]] = inttoptr i64 [[TMP4]] to ptr
// CHECK-NEXT:    call void @llvm.memset.p0.i64(ptr align 8 [[TMP5]], i8 0, i64 16, i1 false)
// CHECK-NEXT:    [[COERCE_DIVE:%.*]] = getelementptr inbounds [[STRUCT_POLY8X8X2_T]], ptr [[B]], i32 0, i32 0
// CHECK-NEXT:    [[TMP6:%.*]] = ptrtoint ptr [[COERCE_DIVE]] to i64
// CHECK-NEXT:    [[TMP7:%.*]] = xor i64 [[TMP6]], 193514046488576
// CHECK-NEXT:    [[TMP8:%.*]] = inttoptr i64 [[TMP7]] to ptr
// CHECK-NEXT:    store [2 x <8 x i8>] zeroinitializer, ptr [[TMP8]], align 8
// CHECK-NEXT:    store [2 x <8 x i8>] [[B_COERCE]], ptr [[COERCE_DIVE]], align 8
// CHECK-NEXT:    [[TMP9:%.*]] = call ptr @__msan_memcpy(ptr [[__S1]], ptr [[B]], i64 16)
// CHECK-NEXT:    [[VAL:%.*]] = getelementptr inbounds [[STRUCT_POLY8X8X2_T]], ptr [[__S1]], i32 0, i32 0
// CHECK-NEXT:    [[ARRAYIDX:%.*]] = getelementptr inbounds [2 x <8 x i8>], ptr [[VAL]], i64 0, i64 0
// CHECK-NEXT:    [[TMP10:%.*]] = load <8 x i8>, ptr [[ARRAYIDX]], align 8
// CHECK-NEXT:    [[VAL1:%.*]] = getelementptr inbounds [[STRUCT_POLY8X8X2_T]], ptr [[__S1]], i32 0, i32 0
// CHECK-NEXT:    [[ARRAYIDX2:%.*]] = getelementptr inbounds [2 x <8 x i8>], ptr [[VAL1]], i64 0, i64 1
// CHECK-NEXT:    [[TMP11:%.*]] = load <8 x i8>, ptr [[ARRAYIDX2]], align 8
// CHECK-NEXT:    [[TMP12:%.*]] = ptrtoint ptr [[A]] to i64
// CHECK-NEXT:    [[TMP13:%.*]] = xor i64 [[TMP12]], 193514046488576
// CHECK-NEXT:    [[TMP14:%.*]] = inttoptr i64 [[TMP13]] to ptr
// CHECK-NEXT:    store <16 x i8> zeroinitializer, ptr [[TMP14]], align 1
// CHECK-NEXT:    call void @llvm.aarch64.neon.st2.v8i8.p0(<8 x i8> [[TMP10]], <8 x i8> [[TMP11]], ptr [[A]])
// CHECK-NEXT:    ret void
//
void test_vst2_p8(poly8_t *a, poly8x8x2_t b) {
  vst2_p8(a, b);
}

// CHECK-LABEL: define dso_local void @test_vst2_p16(
// CHECK-SAME: ptr noundef [[A:%.*]], [2 x <4 x i16>] alignstack(8) [[B_COERCE:%.*]]) #[[ATTR0]] {
// CHECK-NEXT:  entry:
// CHECK-NEXT:    call void @llvm.donothing()
// CHECK-NEXT:    [[B:%.*]] = alloca [[STRUCT_POLY16X4X2_T:%.*]], align 8
// CHECK-NEXT:    [[TMP0:%.*]] = ptrtoint ptr [[B]] to i64
// CHECK-NEXT:    [[TMP1:%.*]] = xor i64 [[TMP0]], 193514046488576
// CHECK-NEXT:    [[TMP2:%.*]] = inttoptr i64 [[TMP1]] to ptr
// CHECK-NEXT:    call void @llvm.memset.p0.i64(ptr align 8 [[TMP2]], i8 0, i64 16, i1 false)
// CHECK-NEXT:    [[__S1:%.*]] = alloca [[STRUCT_POLY16X4X2_T]], align 8
// CHECK-NEXT:    [[TMP3:%.*]] = ptrtoint ptr [[__S1]] to i64
// CHECK-NEXT:    [[TMP4:%.*]] = xor i64 [[TMP3]], 193514046488576
// CHECK-NEXT:    [[TMP5:%.*]] = inttoptr i64 [[TMP4]] to ptr
// CHECK-NEXT:    call void @llvm.memset.p0.i64(ptr align 8 [[TMP5]], i8 0, i64 16, i1 false)
// CHECK-NEXT:    [[COERCE_DIVE:%.*]] = getelementptr inbounds [[STRUCT_POLY16X4X2_T]], ptr [[B]], i32 0, i32 0
// CHECK-NEXT:    [[TMP6:%.*]] = ptrtoint ptr [[COERCE_DIVE]] to i64
// CHECK-NEXT:    [[TMP7:%.*]] = xor i64 [[TMP6]], 193514046488576
// CHECK-NEXT:    [[TMP8:%.*]] = inttoptr i64 [[TMP7]] to ptr
// CHECK-NEXT:    store [2 x <4 x i16>] zeroinitializer, ptr [[TMP8]], align 8
// CHECK-NEXT:    store [2 x <4 x i16>] [[B_COERCE]], ptr [[COERCE_DIVE]], align 8
// CHECK-NEXT:    [[TMP9:%.*]] = call ptr @__msan_memcpy(ptr [[__S1]], ptr [[B]], i64 16)
// CHECK-NEXT:    [[VAL:%.*]] = getelementptr inbounds [[STRUCT_POLY16X4X2_T]], ptr [[__S1]], i32 0, i32 0
// CHECK-NEXT:    [[ARRAYIDX:%.*]] = getelementptr inbounds [2 x <4 x i16>], ptr [[VAL]], i64 0, i64 0
// CHECK-NEXT:    [[TMP10:%.*]] = load <4 x i16>, ptr [[ARRAYIDX]], align 8
// CHECK-NEXT:    [[TMP11:%.*]] = bitcast <4 x i16> [[TMP10]] to <8 x i8>
// CHECK-NEXT:    [[VAL1:%.*]] = getelementptr inbounds [[STRUCT_POLY16X4X2_T]], ptr [[__S1]], i32 0, i32 0
// CHECK-NEXT:    [[ARRAYIDX2:%.*]] = getelementptr inbounds [2 x <4 x i16>], ptr [[VAL1]], i64 0, i64 1
// CHECK-NEXT:    [[TMP12:%.*]] = load <4 x i16>, ptr [[ARRAYIDX2]], align 8
// CHECK-NEXT:    [[TMP13:%.*]] = bitcast <4 x i16> [[TMP12]] to <8 x i8>
// CHECK-NEXT:    [[TMP14:%.*]] = bitcast <8 x i8> [[TMP11]] to <4 x i16>
// CHECK-NEXT:    [[TMP15:%.*]] = bitcast <8 x i8> [[TMP13]] to <4 x i16>
// CHECK-NEXT:    [[TMP16:%.*]] = ptrtoint ptr [[A]] to i64
// CHECK-NEXT:    [[TMP17:%.*]] = xor i64 [[TMP16]], 193514046488576
// CHECK-NEXT:    [[TMP18:%.*]] = inttoptr i64 [[TMP17]] to ptr
// CHECK-NEXT:    store <8 x i16> zeroinitializer, ptr [[TMP18]], align 1
// CHECK-NEXT:    call void @llvm.aarch64.neon.st2.v4i16.p0(<4 x i16> [[TMP14]], <4 x i16> [[TMP15]], ptr [[A]])
// CHECK-NEXT:    ret void
//
void test_vst2_p16(poly16_t *a, poly16x4x2_t b) {
  vst2_p16(a, b);
}

// CHECK-LABEL: define dso_local void @test_vst3q_u8(
// CHECK-SAME: ptr noundef [[A:%.*]], [3 x <16 x i8>] alignstack(16) [[B_COERCE:%.*]]) #[[ATTR0]] {
// CHECK-NEXT:  entry:
// CHECK-NEXT:    call void @llvm.donothing()
// CHECK-NEXT:    [[B:%.*]] = alloca [[STRUCT_UINT8X16X3_T:%.*]], align 16
// CHECK-NEXT:    [[TMP0:%.*]] = ptrtoint ptr [[B]] to i64
// CHECK-NEXT:    [[TMP1:%.*]] = xor i64 [[TMP0]], 193514046488576
// CHECK-NEXT:    [[TMP2:%.*]] = inttoptr i64 [[TMP1]] to ptr
// CHECK-NEXT:    call void @llvm.memset.p0.i64(ptr align 16 [[TMP2]], i8 0, i64 48, i1 false)
// CHECK-NEXT:    [[__S1:%.*]] = alloca [[STRUCT_UINT8X16X3_T]], align 16
// CHECK-NEXT:    [[TMP3:%.*]] = ptrtoint ptr [[__S1]] to i64
// CHECK-NEXT:    [[TMP4:%.*]] = xor i64 [[TMP3]], 193514046488576
// CHECK-NEXT:    [[TMP5:%.*]] = inttoptr i64 [[TMP4]] to ptr
// CHECK-NEXT:    call void @llvm.memset.p0.i64(ptr align 16 [[TMP5]], i8 0, i64 48, i1 false)
// CHECK-NEXT:    [[COERCE_DIVE:%.*]] = getelementptr inbounds [[STRUCT_UINT8X16X3_T]], ptr [[B]], i32 0, i32 0
// CHECK-NEXT:    [[TMP6:%.*]] = ptrtoint ptr [[COERCE_DIVE]] to i64
// CHECK-NEXT:    [[TMP7:%.*]] = xor i64 [[TMP6]], 193514046488576
// CHECK-NEXT:    [[TMP8:%.*]] = inttoptr i64 [[TMP7]] to ptr
// CHECK-NEXT:    store [3 x <16 x i8>] zeroinitializer, ptr [[TMP8]], align 16
// CHECK-NEXT:    store [3 x <16 x i8>] [[B_COERCE]], ptr [[COERCE_DIVE]], align 16
// CHECK-NEXT:    [[TMP9:%.*]] = call ptr @__msan_memcpy(ptr [[__S1]], ptr [[B]], i64 48)
// CHECK-NEXT:    [[VAL:%.*]] = getelementptr inbounds [[STRUCT_UINT8X16X3_T]], ptr [[__S1]], i32 0, i32 0
// CHECK-NEXT:    [[ARRAYIDX:%.*]] = getelementptr inbounds [3 x <16 x i8>], ptr [[VAL]], i64 0, i64 0
// CHECK-NEXT:    [[TMP10:%.*]] = load <16 x i8>, ptr [[ARRAYIDX]], align 16
// CHECK-NEXT:    [[VAL1:%.*]] = getelementptr inbounds [[STRUCT_UINT8X16X3_T]], ptr [[__S1]], i32 0, i32 0
// CHECK-NEXT:    [[ARRAYIDX2:%.*]] = getelementptr inbounds [3 x <16 x i8>], ptr [[VAL1]], i64 0, i64 1
// CHECK-NEXT:    [[TMP11:%.*]] = load <16 x i8>, ptr [[ARRAYIDX2]], align 16
// CHECK-NEXT:    [[VAL3:%.*]] = getelementptr inbounds [[STRUCT_UINT8X16X3_T]], ptr [[__S1]], i32 0, i32 0
// CHECK-NEXT:    [[ARRAYIDX4:%.*]] = getelementptr inbounds [3 x <16 x i8>], ptr [[VAL3]], i64 0, i64 2
// CHECK-NEXT:    [[TMP12:%.*]] = load <16 x i8>, ptr [[ARRAYIDX4]], align 16
// CHECK-NEXT:    [[TMP13:%.*]] = ptrtoint ptr [[A]] to i64
// CHECK-NEXT:    [[TMP14:%.*]] = xor i64 [[TMP13]], 193514046488576
// CHECK-NEXT:    [[TMP15:%.*]] = inttoptr i64 [[TMP14]] to ptr
// CHECK-NEXT:    store <48 x i8> zeroinitializer, ptr [[TMP15]], align 1
// CHECK-NEXT:    call void @llvm.aarch64.neon.st3.v16i8.p0(<16 x i8> [[TMP10]], <16 x i8> [[TMP11]], <16 x i8> [[TMP12]], ptr [[A]])
// CHECK-NEXT:    ret void
//
void test_vst3q_u8(uint8_t *a, uint8x16x3_t b) {
  vst3q_u8(a, b);
}

// CHECK-LABEL: define dso_local void @test_vst3q_u16(
// CHECK-SAME: ptr noundef [[A:%.*]], [3 x <8 x i16>] alignstack(16) [[B_COERCE:%.*]]) #[[ATTR0]] {
// CHECK-NEXT:  entry:
// CHECK-NEXT:    call void @llvm.donothing()
// CHECK-NEXT:    [[B:%.*]] = alloca [[STRUCT_UINT16X8X3_T:%.*]], align 16
// CHECK-NEXT:    [[TMP0:%.*]] = ptrtoint ptr [[B]] to i64
// CHECK-NEXT:    [[TMP1:%.*]] = xor i64 [[TMP0]], 193514046488576
// CHECK-NEXT:    [[TMP2:%.*]] = inttoptr i64 [[TMP1]] to ptr
// CHECK-NEXT:    call void @llvm.memset.p0.i64(ptr align 16 [[TMP2]], i8 0, i64 48, i1 false)
// CHECK-NEXT:    [[__S1:%.*]] = alloca [[STRUCT_UINT16X8X3_T]], align 16
// CHECK-NEXT:    [[TMP3:%.*]] = ptrtoint ptr [[__S1]] to i64
// CHECK-NEXT:    [[TMP4:%.*]] = xor i64 [[TMP3]], 193514046488576
// CHECK-NEXT:    [[TMP5:%.*]] = inttoptr i64 [[TMP4]] to ptr
// CHECK-NEXT:    call void @llvm.memset.p0.i64(ptr align 16 [[TMP5]], i8 0, i64 48, i1 false)
// CHECK-NEXT:    [[COERCE_DIVE:%.*]] = getelementptr inbounds [[STRUCT_UINT16X8X3_T]], ptr [[B]], i32 0, i32 0
// CHECK-NEXT:    [[TMP6:%.*]] = ptrtoint ptr [[COERCE_DIVE]] to i64
// CHECK-NEXT:    [[TMP7:%.*]] = xor i64 [[TMP6]], 193514046488576
// CHECK-NEXT:    [[TMP8:%.*]] = inttoptr i64 [[TMP7]] to ptr
// CHECK-NEXT:    store [3 x <8 x i16>] zeroinitializer, ptr [[TMP8]], align 16
// CHECK-NEXT:    store [3 x <8 x i16>] [[B_COERCE]], ptr [[COERCE_DIVE]], align 16
// CHECK-NEXT:    [[TMP9:%.*]] = call ptr @__msan_memcpy(ptr [[__S1]], ptr [[B]], i64 48)
// CHECK-NEXT:    [[VAL:%.*]] = getelementptr inbounds [[STRUCT_UINT16X8X3_T]], ptr [[__S1]], i32 0, i32 0
// CHECK-NEXT:    [[ARRAYIDX:%.*]] = getelementptr inbounds [3 x <8 x i16>], ptr [[VAL]], i64 0, i64 0
// CHECK-NEXT:    [[TMP10:%.*]] = load <8 x i16>, ptr [[ARRAYIDX]], align 16
// CHECK-NEXT:    [[TMP11:%.*]] = bitcast <8 x i16> [[TMP10]] to <16 x i8>
// CHECK-NEXT:    [[VAL1:%.*]] = getelementptr inbounds [[STRUCT_UINT16X8X3_T]], ptr [[__S1]], i32 0, i32 0
// CHECK-NEXT:    [[ARRAYIDX2:%.*]] = getelementptr inbounds [3 x <8 x i16>], ptr [[VAL1]], i64 0, i64 1
// CHECK-NEXT:    [[TMP12:%.*]] = load <8 x i16>, ptr [[ARRAYIDX2]], align 16
// CHECK-NEXT:    [[TMP13:%.*]] = bitcast <8 x i16> [[TMP12]] to <16 x i8>
// CHECK-NEXT:    [[VAL3:%.*]] = getelementptr inbounds [[STRUCT_UINT16X8X3_T]], ptr [[__S1]], i32 0, i32 0
// CHECK-NEXT:    [[ARRAYIDX4:%.*]] = getelementptr inbounds [3 x <8 x i16>], ptr [[VAL3]], i64 0, i64 2
// CHECK-NEXT:    [[TMP14:%.*]] = load <8 x i16>, ptr [[ARRAYIDX4]], align 16
// CHECK-NEXT:    [[TMP15:%.*]] = bitcast <8 x i16> [[TMP14]] to <16 x i8>
// CHECK-NEXT:    [[TMP16:%.*]] = bitcast <16 x i8> [[TMP11]] to <8 x i16>
// CHECK-NEXT:    [[TMP17:%.*]] = bitcast <16 x i8> [[TMP13]] to <8 x i16>
// CHECK-NEXT:    [[TMP18:%.*]] = bitcast <16 x i8> [[TMP15]] to <8 x i16>
// CHECK-NEXT:    [[TMP19:%.*]] = ptrtoint ptr [[A]] to i64
// CHECK-NEXT:    [[TMP20:%.*]] = xor i64 [[TMP19]], 193514046488576
// CHECK-NEXT:    [[TMP21:%.*]] = inttoptr i64 [[TMP20]] to ptr
// CHECK-NEXT:    store <24 x i16> zeroinitializer, ptr [[TMP21]], align 1
// CHECK-NEXT:    call void @llvm.aarch64.neon.st3.v8i16.p0(<8 x i16> [[TMP16]], <8 x i16> [[TMP17]], <8 x i16> [[TMP18]], ptr [[A]])
// CHECK-NEXT:    ret void
//
void test_vst3q_u16(uint16_t *a, uint16x8x3_t b) {
  vst3q_u16(a, b);
}

// CHECK-LABEL: define dso_local void @test_vst3q_u32(
// CHECK-SAME: ptr noundef [[A:%.*]], [3 x <4 x i32>] alignstack(16) [[B_COERCE:%.*]]) #[[ATTR0]] {
// CHECK-NEXT:  entry:
// CHECK-NEXT:    call void @llvm.donothing()
// CHECK-NEXT:    [[B:%.*]] = alloca [[STRUCT_UINT32X4X3_T:%.*]], align 16
// CHECK-NEXT:    [[TMP0:%.*]] = ptrtoint ptr [[B]] to i64
// CHECK-NEXT:    [[TMP1:%.*]] = xor i64 [[TMP0]], 193514046488576
// CHECK-NEXT:    [[TMP2:%.*]] = inttoptr i64 [[TMP1]] to ptr
// CHECK-NEXT:    call void @llvm.memset.p0.i64(ptr align 16 [[TMP2]], i8 0, i64 48, i1 false)
// CHECK-NEXT:    [[__S1:%.*]] = alloca [[STRUCT_UINT32X4X3_T]], align 16
// CHECK-NEXT:    [[TMP3:%.*]] = ptrtoint ptr [[__S1]] to i64
// CHECK-NEXT:    [[TMP4:%.*]] = xor i64 [[TMP3]], 193514046488576
// CHECK-NEXT:    [[TMP5:%.*]] = inttoptr i64 [[TMP4]] to ptr
// CHECK-NEXT:    call void @llvm.memset.p0.i64(ptr align 16 [[TMP5]], i8 0, i64 48, i1 false)
// CHECK-NEXT:    [[COERCE_DIVE:%.*]] = getelementptr inbounds [[STRUCT_UINT32X4X3_T]], ptr [[B]], i32 0, i32 0
// CHECK-NEXT:    [[TMP6:%.*]] = ptrtoint ptr [[COERCE_DIVE]] to i64
// CHECK-NEXT:    [[TMP7:%.*]] = xor i64 [[TMP6]], 193514046488576
// CHECK-NEXT:    [[TMP8:%.*]] = inttoptr i64 [[TMP7]] to ptr
// CHECK-NEXT:    store [3 x <4 x i32>] zeroinitializer, ptr [[TMP8]], align 16
// CHECK-NEXT:    store [3 x <4 x i32>] [[B_COERCE]], ptr [[COERCE_DIVE]], align 16
// CHECK-NEXT:    [[TMP9:%.*]] = call ptr @__msan_memcpy(ptr [[__S1]], ptr [[B]], i64 48)
// CHECK-NEXT:    [[VAL:%.*]] = getelementptr inbounds [[STRUCT_UINT32X4X3_T]], ptr [[__S1]], i32 0, i32 0
// CHECK-NEXT:    [[ARRAYIDX:%.*]] = getelementptr inbounds [3 x <4 x i32>], ptr [[VAL]], i64 0, i64 0
// CHECK-NEXT:    [[TMP10:%.*]] = load <4 x i32>, ptr [[ARRAYIDX]], align 16
// CHECK-NEXT:    [[TMP11:%.*]] = bitcast <4 x i32> [[TMP10]] to <16 x i8>
// CHECK-NEXT:    [[VAL1:%.*]] = getelementptr inbounds [[STRUCT_UINT32X4X3_T]], ptr [[__S1]], i32 0, i32 0
// CHECK-NEXT:    [[ARRAYIDX2:%.*]] = getelementptr inbounds [3 x <4 x i32>], ptr [[VAL1]], i64 0, i64 1
// CHECK-NEXT:    [[TMP12:%.*]] = load <4 x i32>, ptr [[ARRAYIDX2]], align 16
// CHECK-NEXT:    [[TMP13:%.*]] = bitcast <4 x i32> [[TMP12]] to <16 x i8>
// CHECK-NEXT:    [[VAL3:%.*]] = getelementptr inbounds [[STRUCT_UINT32X4X3_T]], ptr [[__S1]], i32 0, i32 0
// CHECK-NEXT:    [[ARRAYIDX4:%.*]] = getelementptr inbounds [3 x <4 x i32>], ptr [[VAL3]], i64 0, i64 2
// CHECK-NEXT:    [[TMP14:%.*]] = load <4 x i32>, ptr [[ARRAYIDX4]], align 16
// CHECK-NEXT:    [[TMP15:%.*]] = bitcast <4 x i32> [[TMP14]] to <16 x i8>
// CHECK-NEXT:    [[TMP16:%.*]] = bitcast <16 x i8> [[TMP11]] to <4 x i32>
// CHECK-NEXT:    [[TMP17:%.*]] = bitcast <16 x i8> [[TMP13]] to <4 x i32>
// CHECK-NEXT:    [[TMP18:%.*]] = bitcast <16 x i8> [[TMP15]] to <4 x i32>
// CHECK-NEXT:    [[TMP19:%.*]] = ptrtoint ptr [[A]] to i64
// CHECK-NEXT:    [[TMP20:%.*]] = xor i64 [[TMP19]], 193514046488576
// CHECK-NEXT:    [[TMP21:%.*]] = inttoptr i64 [[TMP20]] to ptr
// CHECK-NEXT:    store <12 x i32> zeroinitializer, ptr [[TMP21]], align 1
// CHECK-NEXT:    call void @llvm.aarch64.neon.st3.v4i32.p0(<4 x i32> [[TMP16]], <4 x i32> [[TMP17]], <4 x i32> [[TMP18]], ptr [[A]])
// CHECK-NEXT:    ret void
//
void test_vst3q_u32(uint32_t *a, uint32x4x3_t b) {
  vst3q_u32(a, b);
}

// CHECK-LABEL: define dso_local void @test_vst3q_u64(
// CHECK-SAME: ptr noundef [[A:%.*]], [3 x <2 x i64>] alignstack(16) [[B_COERCE:%.*]]) #[[ATTR0]] {
// CHECK-NEXT:  entry:
// CHECK-NEXT:    call void @llvm.donothing()
// CHECK-NEXT:    [[B:%.*]] = alloca [[STRUCT_UINT64X2X3_T:%.*]], align 16
// CHECK-NEXT:    [[TMP0:%.*]] = ptrtoint ptr [[B]] to i64
// CHECK-NEXT:    [[TMP1:%.*]] = xor i64 [[TMP0]], 193514046488576
// CHECK-NEXT:    [[TMP2:%.*]] = inttoptr i64 [[TMP1]] to ptr
// CHECK-NEXT:    call void @llvm.memset.p0.i64(ptr align 16 [[TMP2]], i8 0, i64 48, i1 false)
// CHECK-NEXT:    [[__S1:%.*]] = alloca [[STRUCT_UINT64X2X3_T]], align 16
// CHECK-NEXT:    [[TMP3:%.*]] = ptrtoint ptr [[__S1]] to i64
// CHECK-NEXT:    [[TMP4:%.*]] = xor i64 [[TMP3]], 193514046488576
// CHECK-NEXT:    [[TMP5:%.*]] = inttoptr i64 [[TMP4]] to ptr
// CHECK-NEXT:    call void @llvm.memset.p0.i64(ptr align 16 [[TMP5]], i8 0, i64 48, i1 false)
// CHECK-NEXT:    [[COERCE_DIVE:%.*]] = getelementptr inbounds [[STRUCT_UINT64X2X3_T]], ptr [[B]], i32 0, i32 0
// CHECK-NEXT:    [[TMP6:%.*]] = ptrtoint ptr [[COERCE_DIVE]] to i64
// CHECK-NEXT:    [[TMP7:%.*]] = xor i64 [[TMP6]], 193514046488576
// CHECK-NEXT:    [[TMP8:%.*]] = inttoptr i64 [[TMP7]] to ptr
// CHECK-NEXT:    store [3 x <2 x i64>] zeroinitializer, ptr [[TMP8]], align 16
// CHECK-NEXT:    store [3 x <2 x i64>] [[B_COERCE]], ptr [[COERCE_DIVE]], align 16
// CHECK-NEXT:    [[TMP9:%.*]] = call ptr @__msan_memcpy(ptr [[__S1]], ptr [[B]], i64 48)
// CHECK-NEXT:    [[VAL:%.*]] = getelementptr inbounds [[STRUCT_UINT64X2X3_T]], ptr [[__S1]], i32 0, i32 0
// CHECK-NEXT:    [[ARRAYIDX:%.*]] = getelementptr inbounds [3 x <2 x i64>], ptr [[VAL]], i64 0, i64 0
// CHECK-NEXT:    [[TMP10:%.*]] = load <2 x i64>, ptr [[ARRAYIDX]], align 16
// CHECK-NEXT:    [[TMP11:%.*]] = bitcast <2 x i64> [[TMP10]] to <16 x i8>
// CHECK-NEXT:    [[VAL1:%.*]] = getelementptr inbounds [[STRUCT_UINT64X2X3_T]], ptr [[__S1]], i32 0, i32 0
// CHECK-NEXT:    [[ARRAYIDX2:%.*]] = getelementptr inbounds [3 x <2 x i64>], ptr [[VAL1]], i64 0, i64 1
// CHECK-NEXT:    [[TMP12:%.*]] = load <2 x i64>, ptr [[ARRAYIDX2]], align 16
// CHECK-NEXT:    [[TMP13:%.*]] = bitcast <2 x i64> [[TMP12]] to <16 x i8>
// CHECK-NEXT:    [[VAL3:%.*]] = getelementptr inbounds [[STRUCT_UINT64X2X3_T]], ptr [[__S1]], i32 0, i32 0
// CHECK-NEXT:    [[ARRAYIDX4:%.*]] = getelementptr inbounds [3 x <2 x i64>], ptr [[VAL3]], i64 0, i64 2
// CHECK-NEXT:    [[TMP14:%.*]] = load <2 x i64>, ptr [[ARRAYIDX4]], align 16
// CHECK-NEXT:    [[TMP15:%.*]] = bitcast <2 x i64> [[TMP14]] to <16 x i8>
// CHECK-NEXT:    [[TMP16:%.*]] = bitcast <16 x i8> [[TMP11]] to <2 x i64>
// CHECK-NEXT:    [[TMP17:%.*]] = bitcast <16 x i8> [[TMP13]] to <2 x i64>
// CHECK-NEXT:    [[TMP18:%.*]] = bitcast <16 x i8> [[TMP15]] to <2 x i64>
// CHECK-NEXT:    [[TMP19:%.*]] = ptrtoint ptr [[A]] to i64
// CHECK-NEXT:    [[TMP20:%.*]] = xor i64 [[TMP19]], 193514046488576
// CHECK-NEXT:    [[TMP21:%.*]] = inttoptr i64 [[TMP20]] to ptr
// CHECK-NEXT:    store <6 x i64> zeroinitializer, ptr [[TMP21]], align 1
// CHECK-NEXT:    call void @llvm.aarch64.neon.st3.v2i64.p0(<2 x i64> [[TMP16]], <2 x i64> [[TMP17]], <2 x i64> [[TMP18]], ptr [[A]])
// CHECK-NEXT:    ret void
//
void test_vst3q_u64(uint64_t *a, uint64x2x3_t b) {
  vst3q_u64(a, b);
}

// CHECK-LABEL: define dso_local void @test_vst3q_s8(
// CHECK-SAME: ptr noundef [[A:%.*]], [3 x <16 x i8>] alignstack(16) [[B_COERCE:%.*]]) #[[ATTR0]] {
// CHECK-NEXT:  entry:
// CHECK-NEXT:    call void @llvm.donothing()
// CHECK-NEXT:    [[B:%.*]] = alloca [[STRUCT_INT8X16X3_T:%.*]], align 16
// CHECK-NEXT:    [[TMP0:%.*]] = ptrtoint ptr [[B]] to i64
// CHECK-NEXT:    [[TMP1:%.*]] = xor i64 [[TMP0]], 193514046488576
// CHECK-NEXT:    [[TMP2:%.*]] = inttoptr i64 [[TMP1]] to ptr
// CHECK-NEXT:    call void @llvm.memset.p0.i64(ptr align 16 [[TMP2]], i8 0, i64 48, i1 false)
// CHECK-NEXT:    [[__S1:%.*]] = alloca [[STRUCT_INT8X16X3_T]], align 16
// CHECK-NEXT:    [[TMP3:%.*]] = ptrtoint ptr [[__S1]] to i64
// CHECK-NEXT:    [[TMP4:%.*]] = xor i64 [[TMP3]], 193514046488576
// CHECK-NEXT:    [[TMP5:%.*]] = inttoptr i64 [[TMP4]] to ptr
// CHECK-NEXT:    call void @llvm.memset.p0.i64(ptr align 16 [[TMP5]], i8 0, i64 48, i1 false)
// CHECK-NEXT:    [[COERCE_DIVE:%.*]] = getelementptr inbounds [[STRUCT_INT8X16X3_T]], ptr [[B]], i32 0, i32 0
// CHECK-NEXT:    [[TMP6:%.*]] = ptrtoint ptr [[COERCE_DIVE]] to i64
// CHECK-NEXT:    [[TMP7:%.*]] = xor i64 [[TMP6]], 193514046488576
// CHECK-NEXT:    [[TMP8:%.*]] = inttoptr i64 [[TMP7]] to ptr
// CHECK-NEXT:    store [3 x <16 x i8>] zeroinitializer, ptr [[TMP8]], align 16
// CHECK-NEXT:    store [3 x <16 x i8>] [[B_COERCE]], ptr [[COERCE_DIVE]], align 16
// CHECK-NEXT:    [[TMP9:%.*]] = call ptr @__msan_memcpy(ptr [[__S1]], ptr [[B]], i64 48)
// CHECK-NEXT:    [[VAL:%.*]] = getelementptr inbounds [[STRUCT_INT8X16X3_T]], ptr [[__S1]], i32 0, i32 0
// CHECK-NEXT:    [[ARRAYIDX:%.*]] = getelementptr inbounds [3 x <16 x i8>], ptr [[VAL]], i64 0, i64 0
// CHECK-NEXT:    [[TMP10:%.*]] = load <16 x i8>, ptr [[ARRAYIDX]], align 16
// CHECK-NEXT:    [[VAL1:%.*]] = getelementptr inbounds [[STRUCT_INT8X16X3_T]], ptr [[__S1]], i32 0, i32 0
// CHECK-NEXT:    [[ARRAYIDX2:%.*]] = getelementptr inbounds [3 x <16 x i8>], ptr [[VAL1]], i64 0, i64 1
// CHECK-NEXT:    [[TMP11:%.*]] = load <16 x i8>, ptr [[ARRAYIDX2]], align 16
// CHECK-NEXT:    [[VAL3:%.*]] = getelementptr inbounds [[STRUCT_INT8X16X3_T]], ptr [[__S1]], i32 0, i32 0
// CHECK-NEXT:    [[ARRAYIDX4:%.*]] = getelementptr inbounds [3 x <16 x i8>], ptr [[VAL3]], i64 0, i64 2
// CHECK-NEXT:    [[TMP12:%.*]] = load <16 x i8>, ptr [[ARRAYIDX4]], align 16
// CHECK-NEXT:    [[TMP13:%.*]] = ptrtoint ptr [[A]] to i64
// CHECK-NEXT:    [[TMP14:%.*]] = xor i64 [[TMP13]], 193514046488576
// CHECK-NEXT:    [[TMP15:%.*]] = inttoptr i64 [[TMP14]] to ptr
// CHECK-NEXT:    store <48 x i8> zeroinitializer, ptr [[TMP15]], align 1
// CHECK-NEXT:    call void @llvm.aarch64.neon.st3.v16i8.p0(<16 x i8> [[TMP10]], <16 x i8> [[TMP11]], <16 x i8> [[TMP12]], ptr [[A]])
// CHECK-NEXT:    ret void
//
void test_vst3q_s8(int8_t *a, int8x16x3_t b) {
  vst3q_s8(a, b);
}

// CHECK-LABEL: define dso_local void @test_vst3q_s16(
// CHECK-SAME: ptr noundef [[A:%.*]], [3 x <8 x i16>] alignstack(16) [[B_COERCE:%.*]]) #[[ATTR0]] {
// CHECK-NEXT:  entry:
// CHECK-NEXT:    call void @llvm.donothing()
// CHECK-NEXT:    [[B:%.*]] = alloca [[STRUCT_INT16X8X3_T:%.*]], align 16
// CHECK-NEXT:    [[TMP0:%.*]] = ptrtoint ptr [[B]] to i64
// CHECK-NEXT:    [[TMP1:%.*]] = xor i64 [[TMP0]], 193514046488576
// CHECK-NEXT:    [[TMP2:%.*]] = inttoptr i64 [[TMP1]] to ptr
// CHECK-NEXT:    call void @llvm.memset.p0.i64(ptr align 16 [[TMP2]], i8 0, i64 48, i1 false)
// CHECK-NEXT:    [[__S1:%.*]] = alloca [[STRUCT_INT16X8X3_T]], align 16
// CHECK-NEXT:    [[TMP3:%.*]] = ptrtoint ptr [[__S1]] to i64
// CHECK-NEXT:    [[TMP4:%.*]] = xor i64 [[TMP3]], 193514046488576
// CHECK-NEXT:    [[TMP5:%.*]] = inttoptr i64 [[TMP4]] to ptr
// CHECK-NEXT:    call void @llvm.memset.p0.i64(ptr align 16 [[TMP5]], i8 0, i64 48, i1 false)
// CHECK-NEXT:    [[COERCE_DIVE:%.*]] = getelementptr inbounds [[STRUCT_INT16X8X3_T]], ptr [[B]], i32 0, i32 0
// CHECK-NEXT:    [[TMP6:%.*]] = ptrtoint ptr [[COERCE_DIVE]] to i64
// CHECK-NEXT:    [[TMP7:%.*]] = xor i64 [[TMP6]], 193514046488576
// CHECK-NEXT:    [[TMP8:%.*]] = inttoptr i64 [[TMP7]] to ptr
// CHECK-NEXT:    store [3 x <8 x i16>] zeroinitializer, ptr [[TMP8]], align 16
// CHECK-NEXT:    store [3 x <8 x i16>] [[B_COERCE]], ptr [[COERCE_DIVE]], align 16
// CHECK-NEXT:    [[TMP9:%.*]] = call ptr @__msan_memcpy(ptr [[__S1]], ptr [[B]], i64 48)
// CHECK-NEXT:    [[VAL:%.*]] = getelementptr inbounds [[STRUCT_INT16X8X3_T]], ptr [[__S1]], i32 0, i32 0
// CHECK-NEXT:    [[ARRAYIDX:%.*]] = getelementptr inbounds [3 x <8 x i16>], ptr [[VAL]], i64 0, i64 0
// CHECK-NEXT:    [[TMP10:%.*]] = load <8 x i16>, ptr [[ARRAYIDX]], align 16
// CHECK-NEXT:    [[TMP11:%.*]] = bitcast <8 x i16> [[TMP10]] to <16 x i8>
// CHECK-NEXT:    [[VAL1:%.*]] = getelementptr inbounds [[STRUCT_INT16X8X3_T]], ptr [[__S1]], i32 0, i32 0
// CHECK-NEXT:    [[ARRAYIDX2:%.*]] = getelementptr inbounds [3 x <8 x i16>], ptr [[VAL1]], i64 0, i64 1
// CHECK-NEXT:    [[TMP12:%.*]] = load <8 x i16>, ptr [[ARRAYIDX2]], align 16
// CHECK-NEXT:    [[TMP13:%.*]] = bitcast <8 x i16> [[TMP12]] to <16 x i8>
// CHECK-NEXT:    [[VAL3:%.*]] = getelementptr inbounds [[STRUCT_INT16X8X3_T]], ptr [[__S1]], i32 0, i32 0
// CHECK-NEXT:    [[ARRAYIDX4:%.*]] = getelementptr inbounds [3 x <8 x i16>], ptr [[VAL3]], i64 0, i64 2
// CHECK-NEXT:    [[TMP14:%.*]] = load <8 x i16>, ptr [[ARRAYIDX4]], align 16
// CHECK-NEXT:    [[TMP15:%.*]] = bitcast <8 x i16> [[TMP14]] to <16 x i8>
// CHECK-NEXT:    [[TMP16:%.*]] = bitcast <16 x i8> [[TMP11]] to <8 x i16>
// CHECK-NEXT:    [[TMP17:%.*]] = bitcast <16 x i8> [[TMP13]] to <8 x i16>
// CHECK-NEXT:    [[TMP18:%.*]] = bitcast <16 x i8> [[TMP15]] to <8 x i16>
// CHECK-NEXT:    [[TMP19:%.*]] = ptrtoint ptr [[A]] to i64
// CHECK-NEXT:    [[TMP20:%.*]] = xor i64 [[TMP19]], 193514046488576
// CHECK-NEXT:    [[TMP21:%.*]] = inttoptr i64 [[TMP20]] to ptr
// CHECK-NEXT:    store <24 x i16> zeroinitializer, ptr [[TMP21]], align 1
// CHECK-NEXT:    call void @llvm.aarch64.neon.st3.v8i16.p0(<8 x i16> [[TMP16]], <8 x i16> [[TMP17]], <8 x i16> [[TMP18]], ptr [[A]])
// CHECK-NEXT:    ret void
//
void test_vst3q_s16(int16_t *a, int16x8x3_t b) {
  vst3q_s16(a, b);
}

// CHECK-LABEL: define dso_local void @test_vst3q_s32(
// CHECK-SAME: ptr noundef [[A:%.*]], [3 x <4 x i32>] alignstack(16) [[B_COERCE:%.*]]) #[[ATTR0]] {
// CHECK-NEXT:  entry:
// CHECK-NEXT:    call void @llvm.donothing()
// CHECK-NEXT:    [[B:%.*]] = alloca [[STRUCT_INT32X4X3_T:%.*]], align 16
// CHECK-NEXT:    [[TMP0:%.*]] = ptrtoint ptr [[B]] to i64
// CHECK-NEXT:    [[TMP1:%.*]] = xor i64 [[TMP0]], 193514046488576
// CHECK-NEXT:    [[TMP2:%.*]] = inttoptr i64 [[TMP1]] to ptr
// CHECK-NEXT:    call void @llvm.memset.p0.i64(ptr align 16 [[TMP2]], i8 0, i64 48, i1 false)
// CHECK-NEXT:    [[__S1:%.*]] = alloca [[STRUCT_INT32X4X3_T]], align 16
// CHECK-NEXT:    [[TMP3:%.*]] = ptrtoint ptr [[__S1]] to i64
// CHECK-NEXT:    [[TMP4:%.*]] = xor i64 [[TMP3]], 193514046488576
// CHECK-NEXT:    [[TMP5:%.*]] = inttoptr i64 [[TMP4]] to ptr
// CHECK-NEXT:    call void @llvm.memset.p0.i64(ptr align 16 [[TMP5]], i8 0, i64 48, i1 false)
// CHECK-NEXT:    [[COERCE_DIVE:%.*]] = getelementptr inbounds [[STRUCT_INT32X4X3_T]], ptr [[B]], i32 0, i32 0
// CHECK-NEXT:    [[TMP6:%.*]] = ptrtoint ptr [[COERCE_DIVE]] to i64
// CHECK-NEXT:    [[TMP7:%.*]] = xor i64 [[TMP6]], 193514046488576
// CHECK-NEXT:    [[TMP8:%.*]] = inttoptr i64 [[TMP7]] to ptr
// CHECK-NEXT:    store [3 x <4 x i32>] zeroinitializer, ptr [[TMP8]], align 16
// CHECK-NEXT:    store [3 x <4 x i32>] [[B_COERCE]], ptr [[COERCE_DIVE]], align 16
// CHECK-NEXT:    [[TMP9:%.*]] = call ptr @__msan_memcpy(ptr [[__S1]], ptr [[B]], i64 48)
// CHECK-NEXT:    [[VAL:%.*]] = getelementptr inbounds [[STRUCT_INT32X4X3_T]], ptr [[__S1]], i32 0, i32 0
// CHECK-NEXT:    [[ARRAYIDX:%.*]] = getelementptr inbounds [3 x <4 x i32>], ptr [[VAL]], i64 0, i64 0
// CHECK-NEXT:    [[TMP10:%.*]] = load <4 x i32>, ptr [[ARRAYIDX]], align 16
// CHECK-NEXT:    [[TMP11:%.*]] = bitcast <4 x i32> [[TMP10]] to <16 x i8>
// CHECK-NEXT:    [[VAL1:%.*]] = getelementptr inbounds [[STRUCT_INT32X4X3_T]], ptr [[__S1]], i32 0, i32 0
// CHECK-NEXT:    [[ARRAYIDX2:%.*]] = getelementptr inbounds [3 x <4 x i32>], ptr [[VAL1]], i64 0, i64 1
// CHECK-NEXT:    [[TMP12:%.*]] = load <4 x i32>, ptr [[ARRAYIDX2]], align 16
// CHECK-NEXT:    [[TMP13:%.*]] = bitcast <4 x i32> [[TMP12]] to <16 x i8>
// CHECK-NEXT:    [[VAL3:%.*]] = getelementptr inbounds [[STRUCT_INT32X4X3_T]], ptr [[__S1]], i32 0, i32 0
// CHECK-NEXT:    [[ARRAYIDX4:%.*]] = getelementptr inbounds [3 x <4 x i32>], ptr [[VAL3]], i64 0, i64 2
// CHECK-NEXT:    [[TMP14:%.*]] = load <4 x i32>, ptr [[ARRAYIDX4]], align 16
// CHECK-NEXT:    [[TMP15:%.*]] = bitcast <4 x i32> [[TMP14]] to <16 x i8>
// CHECK-NEXT:    [[TMP16:%.*]] = bitcast <16 x i8> [[TMP11]] to <4 x i32>
// CHECK-NEXT:    [[TMP17:%.*]] = bitcast <16 x i8> [[TMP13]] to <4 x i32>
// CHECK-NEXT:    [[TMP18:%.*]] = bitcast <16 x i8> [[TMP15]] to <4 x i32>
// CHECK-NEXT:    [[TMP19:%.*]] = ptrtoint ptr [[A]] to i64
// CHECK-NEXT:    [[TMP20:%.*]] = xor i64 [[TMP19]], 193514046488576
// CHECK-NEXT:    [[TMP21:%.*]] = inttoptr i64 [[TMP20]] to ptr
// CHECK-NEXT:    store <12 x i32> zeroinitializer, ptr [[TMP21]], align 1
// CHECK-NEXT:    call void @llvm.aarch64.neon.st3.v4i32.p0(<4 x i32> [[TMP16]], <4 x i32> [[TMP17]], <4 x i32> [[TMP18]], ptr [[A]])
// CHECK-NEXT:    ret void
//
void test_vst3q_s32(int32_t *a, int32x4x3_t b) {
  vst3q_s32(a, b);
}

// CHECK-LABEL: define dso_local void @test_vst3q_s64(
// CHECK-SAME: ptr noundef [[A:%.*]], [3 x <2 x i64>] alignstack(16) [[B_COERCE:%.*]]) #[[ATTR0]] {
// CHECK-NEXT:  entry:
// CHECK-NEXT:    call void @llvm.donothing()
// CHECK-NEXT:    [[B:%.*]] = alloca [[STRUCT_INT64X2X3_T:%.*]], align 16
// CHECK-NEXT:    [[TMP0:%.*]] = ptrtoint ptr [[B]] to i64
// CHECK-NEXT:    [[TMP1:%.*]] = xor i64 [[TMP0]], 193514046488576
// CHECK-NEXT:    [[TMP2:%.*]] = inttoptr i64 [[TMP1]] to ptr
// CHECK-NEXT:    call void @llvm.memset.p0.i64(ptr align 16 [[TMP2]], i8 0, i64 48, i1 false)
// CHECK-NEXT:    [[__S1:%.*]] = alloca [[STRUCT_INT64X2X3_T]], align 16
// CHECK-NEXT:    [[TMP3:%.*]] = ptrtoint ptr [[__S1]] to i64
// CHECK-NEXT:    [[TMP4:%.*]] = xor i64 [[TMP3]], 193514046488576
// CHECK-NEXT:    [[TMP5:%.*]] = inttoptr i64 [[TMP4]] to ptr
// CHECK-NEXT:    call void @llvm.memset.p0.i64(ptr align 16 [[TMP5]], i8 0, i64 48, i1 false)
// CHECK-NEXT:    [[COERCE_DIVE:%.*]] = getelementptr inbounds [[STRUCT_INT64X2X3_T]], ptr [[B]], i32 0, i32 0
// CHECK-NEXT:    [[TMP6:%.*]] = ptrtoint ptr [[COERCE_DIVE]] to i64
// CHECK-NEXT:    [[TMP7:%.*]] = xor i64 [[TMP6]], 193514046488576
// CHECK-NEXT:    [[TMP8:%.*]] = inttoptr i64 [[TMP7]] to ptr
// CHECK-NEXT:    store [3 x <2 x i64>] zeroinitializer, ptr [[TMP8]], align 16
// CHECK-NEXT:    store [3 x <2 x i64>] [[B_COERCE]], ptr [[COERCE_DIVE]], align 16
// CHECK-NEXT:    [[TMP9:%.*]] = call ptr @__msan_memcpy(ptr [[__S1]], ptr [[B]], i64 48)
// CHECK-NEXT:    [[VAL:%.*]] = getelementptr inbounds [[STRUCT_INT64X2X3_T]], ptr [[__S1]], i32 0, i32 0
// CHECK-NEXT:    [[ARRAYIDX:%.*]] = getelementptr inbounds [3 x <2 x i64>], ptr [[VAL]], i64 0, i64 0
// CHECK-NEXT:    [[TMP10:%.*]] = load <2 x i64>, ptr [[ARRAYIDX]], align 16
// CHECK-NEXT:    [[TMP11:%.*]] = bitcast <2 x i64> [[TMP10]] to <16 x i8>
// CHECK-NEXT:    [[VAL1:%.*]] = getelementptr inbounds [[STRUCT_INT64X2X3_T]], ptr [[__S1]], i32 0, i32 0
// CHECK-NEXT:    [[ARRAYIDX2:%.*]] = getelementptr inbounds [3 x <2 x i64>], ptr [[VAL1]], i64 0, i64 1
// CHECK-NEXT:    [[TMP12:%.*]] = load <2 x i64>, ptr [[ARRAYIDX2]], align 16
// CHECK-NEXT:    [[TMP13:%.*]] = bitcast <2 x i64> [[TMP12]] to <16 x i8>
// CHECK-NEXT:    [[VAL3:%.*]] = getelementptr inbounds [[STRUCT_INT64X2X3_T]], ptr [[__S1]], i32 0, i32 0
// CHECK-NEXT:    [[ARRAYIDX4:%.*]] = getelementptr inbounds [3 x <2 x i64>], ptr [[VAL3]], i64 0, i64 2
// CHECK-NEXT:    [[TMP14:%.*]] = load <2 x i64>, ptr [[ARRAYIDX4]], align 16
// CHECK-NEXT:    [[TMP15:%.*]] = bitcast <2 x i64> [[TMP14]] to <16 x i8>
// CHECK-NEXT:    [[TMP16:%.*]] = bitcast <16 x i8> [[TMP11]] to <2 x i64>
// CHECK-NEXT:    [[TMP17:%.*]] = bitcast <16 x i8> [[TMP13]] to <2 x i64>
// CHECK-NEXT:    [[TMP18:%.*]] = bitcast <16 x i8> [[TMP15]] to <2 x i64>
// CHECK-NEXT:    [[TMP19:%.*]] = ptrtoint ptr [[A]] to i64
// CHECK-NEXT:    [[TMP20:%.*]] = xor i64 [[TMP19]], 193514046488576
// CHECK-NEXT:    [[TMP21:%.*]] = inttoptr i64 [[TMP20]] to ptr
// CHECK-NEXT:    store <6 x i64> zeroinitializer, ptr [[TMP21]], align 1
// CHECK-NEXT:    call void @llvm.aarch64.neon.st3.v2i64.p0(<2 x i64> [[TMP16]], <2 x i64> [[TMP17]], <2 x i64> [[TMP18]], ptr [[A]])
// CHECK-NEXT:    ret void
//
void test_vst3q_s64(int64_t *a, int64x2x3_t b) {
  vst3q_s64(a, b);
}

// CHECK-LABEL: define dso_local void @test_vst3q_f16(
// CHECK-SAME: ptr noundef [[A:%.*]], [3 x <8 x half>] alignstack(16) [[B_COERCE:%.*]]) #[[ATTR0]] {
// CHECK-NEXT:  entry:
// CHECK-NEXT:    call void @llvm.donothing()
// CHECK-NEXT:    [[B:%.*]] = alloca [[STRUCT_FLOAT16X8X3_T:%.*]], align 16
// CHECK-NEXT:    [[TMP0:%.*]] = ptrtoint ptr [[B]] to i64
// CHECK-NEXT:    [[TMP1:%.*]] = xor i64 [[TMP0]], 193514046488576
// CHECK-NEXT:    [[TMP2:%.*]] = inttoptr i64 [[TMP1]] to ptr
// CHECK-NEXT:    call void @llvm.memset.p0.i64(ptr align 16 [[TMP2]], i8 0, i64 48, i1 false)
// CHECK-NEXT:    [[__S1:%.*]] = alloca [[STRUCT_FLOAT16X8X3_T]], align 16
// CHECK-NEXT:    [[TMP3:%.*]] = ptrtoint ptr [[__S1]] to i64
// CHECK-NEXT:    [[TMP4:%.*]] = xor i64 [[TMP3]], 193514046488576
// CHECK-NEXT:    [[TMP5:%.*]] = inttoptr i64 [[TMP4]] to ptr
// CHECK-NEXT:    call void @llvm.memset.p0.i64(ptr align 16 [[TMP5]], i8 0, i64 48, i1 false)
// CHECK-NEXT:    [[COERCE_DIVE:%.*]] = getelementptr inbounds [[STRUCT_FLOAT16X8X3_T]], ptr [[B]], i32 0, i32 0
// CHECK-NEXT:    [[TMP6:%.*]] = ptrtoint ptr [[COERCE_DIVE]] to i64
// CHECK-NEXT:    [[TMP7:%.*]] = xor i64 [[TMP6]], 193514046488576
// CHECK-NEXT:    [[TMP8:%.*]] = inttoptr i64 [[TMP7]] to ptr
// CHECK-NEXT:    store [3 x <8 x i16>] zeroinitializer, ptr [[TMP8]], align 16
// CHECK-NEXT:    store [3 x <8 x half>] [[B_COERCE]], ptr [[COERCE_DIVE]], align 16
// CHECK-NEXT:    [[TMP9:%.*]] = call ptr @__msan_memcpy(ptr [[__S1]], ptr [[B]], i64 48)
// CHECK-NEXT:    [[VAL:%.*]] = getelementptr inbounds [[STRUCT_FLOAT16X8X3_T]], ptr [[__S1]], i32 0, i32 0
// CHECK-NEXT:    [[ARRAYIDX:%.*]] = getelementptr inbounds [3 x <8 x half>], ptr [[VAL]], i64 0, i64 0
// CHECK-NEXT:    [[TMP10:%.*]] = load <8 x half>, ptr [[ARRAYIDX]], align 16
// CHECK-NEXT:    [[TMP11:%.*]] = bitcast <8 x half> [[TMP10]] to <16 x i8>
// CHECK-NEXT:    [[VAL1:%.*]] = getelementptr inbounds [[STRUCT_FLOAT16X8X3_T]], ptr [[__S1]], i32 0, i32 0
// CHECK-NEXT:    [[ARRAYIDX2:%.*]] = getelementptr inbounds [3 x <8 x half>], ptr [[VAL1]], i64 0, i64 1
// CHECK-NEXT:    [[TMP12:%.*]] = load <8 x half>, ptr [[ARRAYIDX2]], align 16
// CHECK-NEXT:    [[TMP13:%.*]] = bitcast <8 x half> [[TMP12]] to <16 x i8>
// CHECK-NEXT:    [[VAL3:%.*]] = getelementptr inbounds [[STRUCT_FLOAT16X8X3_T]], ptr [[__S1]], i32 0, i32 0
// CHECK-NEXT:    [[ARRAYIDX4:%.*]] = getelementptr inbounds [3 x <8 x half>], ptr [[VAL3]], i64 0, i64 2
// CHECK-NEXT:    [[TMP14:%.*]] = load <8 x half>, ptr [[ARRAYIDX4]], align 16
// CHECK-NEXT:    [[TMP15:%.*]] = bitcast <8 x half> [[TMP14]] to <16 x i8>
// CHECK-NEXT:    [[TMP16:%.*]] = bitcast <16 x i8> [[TMP11]] to <8 x half>
// CHECK-NEXT:    [[TMP17:%.*]] = bitcast <16 x i8> [[TMP13]] to <8 x half>
// CHECK-NEXT:    [[TMP18:%.*]] = bitcast <16 x i8> [[TMP15]] to <8 x half>
// CHECK-NEXT:    [[TMP19:%.*]] = ptrtoint ptr [[A]] to i64
// CHECK-NEXT:    [[TMP20:%.*]] = xor i64 [[TMP19]], 193514046488576
// CHECK-NEXT:    [[TMP21:%.*]] = inttoptr i64 [[TMP20]] to ptr
// CHECK-NEXT:    store <24 x i16> zeroinitializer, ptr [[TMP21]], align 1
// CHECK-NEXT:    call void @llvm.aarch64.neon.st3.v8f16.p0(<8 x half> [[TMP16]], <8 x half> [[TMP17]], <8 x half> [[TMP18]], ptr [[A]])
// CHECK-NEXT:    ret void
//
void test_vst3q_f16(float16_t *a, float16x8x3_t b) {
  vst3q_f16(a, b);
}

// CHECK-LABEL: define dso_local void @test_vst3q_f32(
// CHECK-SAME: ptr noundef [[A:%.*]], [3 x <4 x float>] alignstack(16) [[B_COERCE:%.*]]) #[[ATTR0]] {
// CHECK-NEXT:  entry:
// CHECK-NEXT:    call void @llvm.donothing()
// CHECK-NEXT:    [[B:%.*]] = alloca [[STRUCT_FLOAT32X4X3_T:%.*]], align 16
// CHECK-NEXT:    [[TMP0:%.*]] = ptrtoint ptr [[B]] to i64
// CHECK-NEXT:    [[TMP1:%.*]] = xor i64 [[TMP0]], 193514046488576
// CHECK-NEXT:    [[TMP2:%.*]] = inttoptr i64 [[TMP1]] to ptr
// CHECK-NEXT:    call void @llvm.memset.p0.i64(ptr align 16 [[TMP2]], i8 0, i64 48, i1 false)
// CHECK-NEXT:    [[__S1:%.*]] = alloca [[STRUCT_FLOAT32X4X3_T]], align 16
// CHECK-NEXT:    [[TMP3:%.*]] = ptrtoint ptr [[__S1]] to i64
// CHECK-NEXT:    [[TMP4:%.*]] = xor i64 [[TMP3]], 193514046488576
// CHECK-NEXT:    [[TMP5:%.*]] = inttoptr i64 [[TMP4]] to ptr
// CHECK-NEXT:    call void @llvm.memset.p0.i64(ptr align 16 [[TMP5]], i8 0, i64 48, i1 false)
// CHECK-NEXT:    [[COERCE_DIVE:%.*]] = getelementptr inbounds [[STRUCT_FLOAT32X4X3_T]], ptr [[B]], i32 0, i32 0
// CHECK-NEXT:    [[TMP6:%.*]] = ptrtoint ptr [[COERCE_DIVE]] to i64
// CHECK-NEXT:    [[TMP7:%.*]] = xor i64 [[TMP6]], 193514046488576
// CHECK-NEXT:    [[TMP8:%.*]] = inttoptr i64 [[TMP7]] to ptr
// CHECK-NEXT:    store [3 x <4 x i32>] zeroinitializer, ptr [[TMP8]], align 16
// CHECK-NEXT:    store [3 x <4 x float>] [[B_COERCE]], ptr [[COERCE_DIVE]], align 16
// CHECK-NEXT:    [[TMP9:%.*]] = call ptr @__msan_memcpy(ptr [[__S1]], ptr [[B]], i64 48)
// CHECK-NEXT:    [[VAL:%.*]] = getelementptr inbounds [[STRUCT_FLOAT32X4X3_T]], ptr [[__S1]], i32 0, i32 0
// CHECK-NEXT:    [[ARRAYIDX:%.*]] = getelementptr inbounds [3 x <4 x float>], ptr [[VAL]], i64 0, i64 0
// CHECK-NEXT:    [[TMP10:%.*]] = load <4 x float>, ptr [[ARRAYIDX]], align 16
// CHECK-NEXT:    [[TMP11:%.*]] = bitcast <4 x float> [[TMP10]] to <16 x i8>
// CHECK-NEXT:    [[VAL1:%.*]] = getelementptr inbounds [[STRUCT_FLOAT32X4X3_T]], ptr [[__S1]], i32 0, i32 0
// CHECK-NEXT:    [[ARRAYIDX2:%.*]] = getelementptr inbounds [3 x <4 x float>], ptr [[VAL1]], i64 0, i64 1
// CHECK-NEXT:    [[TMP12:%.*]] = load <4 x float>, ptr [[ARRAYIDX2]], align 16
// CHECK-NEXT:    [[TMP13:%.*]] = bitcast <4 x float> [[TMP12]] to <16 x i8>
// CHECK-NEXT:    [[VAL3:%.*]] = getelementptr inbounds [[STRUCT_FLOAT32X4X3_T]], ptr [[__S1]], i32 0, i32 0
// CHECK-NEXT:    [[ARRAYIDX4:%.*]] = getelementptr inbounds [3 x <4 x float>], ptr [[VAL3]], i64 0, i64 2
// CHECK-NEXT:    [[TMP14:%.*]] = load <4 x float>, ptr [[ARRAYIDX4]], align 16
// CHECK-NEXT:    [[TMP15:%.*]] = bitcast <4 x float> [[TMP14]] to <16 x i8>
// CHECK-NEXT:    [[TMP16:%.*]] = bitcast <16 x i8> [[TMP11]] to <4 x float>
// CHECK-NEXT:    [[TMP17:%.*]] = bitcast <16 x i8> [[TMP13]] to <4 x float>
// CHECK-NEXT:    [[TMP18:%.*]] = bitcast <16 x i8> [[TMP15]] to <4 x float>
// CHECK-NEXT:    [[TMP19:%.*]] = ptrtoint ptr [[A]] to i64
// CHECK-NEXT:    [[TMP20:%.*]] = xor i64 [[TMP19]], 193514046488576
// CHECK-NEXT:    [[TMP21:%.*]] = inttoptr i64 [[TMP20]] to ptr
// CHECK-NEXT:    store <12 x i32> zeroinitializer, ptr [[TMP21]], align 1
// CHECK-NEXT:    call void @llvm.aarch64.neon.st3.v4f32.p0(<4 x float> [[TMP16]], <4 x float> [[TMP17]], <4 x float> [[TMP18]], ptr [[A]])
// CHECK-NEXT:    ret void
//
void test_vst3q_f32(float32_t *a, float32x4x3_t b) {
  vst3q_f32(a, b);
}

// CHECK-LABEL: define dso_local void @test_vst3q_f64(
// CHECK-SAME: ptr noundef [[A:%.*]], [3 x <2 x double>] alignstack(16) [[B_COERCE:%.*]]) #[[ATTR0]] {
// CHECK-NEXT:  entry:
// CHECK-NEXT:    call void @llvm.donothing()
// CHECK-NEXT:    [[B:%.*]] = alloca [[STRUCT_FLOAT64X2X3_T:%.*]], align 16
// CHECK-NEXT:    [[TMP0:%.*]] = ptrtoint ptr [[B]] to i64
// CHECK-NEXT:    [[TMP1:%.*]] = xor i64 [[TMP0]], 193514046488576
// CHECK-NEXT:    [[TMP2:%.*]] = inttoptr i64 [[TMP1]] to ptr
// CHECK-NEXT:    call void @llvm.memset.p0.i64(ptr align 16 [[TMP2]], i8 0, i64 48, i1 false)
// CHECK-NEXT:    [[__S1:%.*]] = alloca [[STRUCT_FLOAT64X2X3_T]], align 16
// CHECK-NEXT:    [[TMP3:%.*]] = ptrtoint ptr [[__S1]] to i64
// CHECK-NEXT:    [[TMP4:%.*]] = xor i64 [[TMP3]], 193514046488576
// CHECK-NEXT:    [[TMP5:%.*]] = inttoptr i64 [[TMP4]] to ptr
// CHECK-NEXT:    call void @llvm.memset.p0.i64(ptr align 16 [[TMP5]], i8 0, i64 48, i1 false)
// CHECK-NEXT:    [[COERCE_DIVE:%.*]] = getelementptr inbounds [[STRUCT_FLOAT64X2X3_T]], ptr [[B]], i32 0, i32 0
// CHECK-NEXT:    [[TMP6:%.*]] = ptrtoint ptr [[COERCE_DIVE]] to i64
// CHECK-NEXT:    [[TMP7:%.*]] = xor i64 [[TMP6]], 193514046488576
// CHECK-NEXT:    [[TMP8:%.*]] = inttoptr i64 [[TMP7]] to ptr
// CHECK-NEXT:    store [3 x <2 x i64>] zeroinitializer, ptr [[TMP8]], align 16
// CHECK-NEXT:    store [3 x <2 x double>] [[B_COERCE]], ptr [[COERCE_DIVE]], align 16
// CHECK-NEXT:    [[TMP9:%.*]] = call ptr @__msan_memcpy(ptr [[__S1]], ptr [[B]], i64 48)
// CHECK-NEXT:    [[VAL:%.*]] = getelementptr inbounds [[STRUCT_FLOAT64X2X3_T]], ptr [[__S1]], i32 0, i32 0
// CHECK-NEXT:    [[ARRAYIDX:%.*]] = getelementptr inbounds [3 x <2 x double>], ptr [[VAL]], i64 0, i64 0
// CHECK-NEXT:    [[TMP10:%.*]] = load <2 x double>, ptr [[ARRAYIDX]], align 16
// CHECK-NEXT:    [[TMP11:%.*]] = bitcast <2 x double> [[TMP10]] to <16 x i8>
// CHECK-NEXT:    [[VAL1:%.*]] = getelementptr inbounds [[STRUCT_FLOAT64X2X3_T]], ptr [[__S1]], i32 0, i32 0
// CHECK-NEXT:    [[ARRAYIDX2:%.*]] = getelementptr inbounds [3 x <2 x double>], ptr [[VAL1]], i64 0, i64 1
// CHECK-NEXT:    [[TMP12:%.*]] = load <2 x double>, ptr [[ARRAYIDX2]], align 16
// CHECK-NEXT:    [[TMP13:%.*]] = bitcast <2 x double> [[TMP12]] to <16 x i8>
// CHECK-NEXT:    [[VAL3:%.*]] = getelementptr inbounds [[STRUCT_FLOAT64X2X3_T]], ptr [[__S1]], i32 0, i32 0
// CHECK-NEXT:    [[ARRAYIDX4:%.*]] = getelementptr inbounds [3 x <2 x double>], ptr [[VAL3]], i64 0, i64 2
// CHECK-NEXT:    [[TMP14:%.*]] = load <2 x double>, ptr [[ARRAYIDX4]], align 16
// CHECK-NEXT:    [[TMP15:%.*]] = bitcast <2 x double> [[TMP14]] to <16 x i8>
// CHECK-NEXT:    [[TMP16:%.*]] = bitcast <16 x i8> [[TMP11]] to <2 x double>
// CHECK-NEXT:    [[TMP17:%.*]] = bitcast <16 x i8> [[TMP13]] to <2 x double>
// CHECK-NEXT:    [[TMP18:%.*]] = bitcast <16 x i8> [[TMP15]] to <2 x double>
// CHECK-NEXT:    [[TMP19:%.*]] = ptrtoint ptr [[A]] to i64
// CHECK-NEXT:    [[TMP20:%.*]] = xor i64 [[TMP19]], 193514046488576
// CHECK-NEXT:    [[TMP21:%.*]] = inttoptr i64 [[TMP20]] to ptr
// CHECK-NEXT:    store <6 x i64> zeroinitializer, ptr [[TMP21]], align 1
// CHECK-NEXT:    call void @llvm.aarch64.neon.st3.v2f64.p0(<2 x double> [[TMP16]], <2 x double> [[TMP17]], <2 x double> [[TMP18]], ptr [[A]])
// CHECK-NEXT:    ret void
//
void test_vst3q_f64(float64_t *a, float64x2x3_t b) {
  vst3q_f64(a, b);
}

// CHECK-LABEL: define dso_local void @test_vst3q_p8(
// CHECK-SAME: ptr noundef [[A:%.*]], [3 x <16 x i8>] alignstack(16) [[B_COERCE:%.*]]) #[[ATTR0]] {
// CHECK-NEXT:  entry:
// CHECK-NEXT:    call void @llvm.donothing()
// CHECK-NEXT:    [[B:%.*]] = alloca [[STRUCT_POLY8X16X3_T:%.*]], align 16
// CHECK-NEXT:    [[TMP0:%.*]] = ptrtoint ptr [[B]] to i64
// CHECK-NEXT:    [[TMP1:%.*]] = xor i64 [[TMP0]], 193514046488576
// CHECK-NEXT:    [[TMP2:%.*]] = inttoptr i64 [[TMP1]] to ptr
// CHECK-NEXT:    call void @llvm.memset.p0.i64(ptr align 16 [[TMP2]], i8 0, i64 48, i1 false)
// CHECK-NEXT:    [[__S1:%.*]] = alloca [[STRUCT_POLY8X16X3_T]], align 16
// CHECK-NEXT:    [[TMP3:%.*]] = ptrtoint ptr [[__S1]] to i64
// CHECK-NEXT:    [[TMP4:%.*]] = xor i64 [[TMP3]], 193514046488576
// CHECK-NEXT:    [[TMP5:%.*]] = inttoptr i64 [[TMP4]] to ptr
// CHECK-NEXT:    call void @llvm.memset.p0.i64(ptr align 16 [[TMP5]], i8 0, i64 48, i1 false)
// CHECK-NEXT:    [[COERCE_DIVE:%.*]] = getelementptr inbounds [[STRUCT_POLY8X16X3_T]], ptr [[B]], i32 0, i32 0
// CHECK-NEXT:    [[TMP6:%.*]] = ptrtoint ptr [[COERCE_DIVE]] to i64
// CHECK-NEXT:    [[TMP7:%.*]] = xor i64 [[TMP6]], 193514046488576
// CHECK-NEXT:    [[TMP8:%.*]] = inttoptr i64 [[TMP7]] to ptr
// CHECK-NEXT:    store [3 x <16 x i8>] zeroinitializer, ptr [[TMP8]], align 16
// CHECK-NEXT:    store [3 x <16 x i8>] [[B_COERCE]], ptr [[COERCE_DIVE]], align 16
// CHECK-NEXT:    [[TMP9:%.*]] = call ptr @__msan_memcpy(ptr [[__S1]], ptr [[B]], i64 48)
// CHECK-NEXT:    [[VAL:%.*]] = getelementptr inbounds [[STRUCT_POLY8X16X3_T]], ptr [[__S1]], i32 0, i32 0
// CHECK-NEXT:    [[ARRAYIDX:%.*]] = getelementptr inbounds [3 x <16 x i8>], ptr [[VAL]], i64 0, i64 0
// CHECK-NEXT:    [[TMP10:%.*]] = load <16 x i8>, ptr [[ARRAYIDX]], align 16
// CHECK-NEXT:    [[VAL1:%.*]] = getelementptr inbounds [[STRUCT_POLY8X16X3_T]], ptr [[__S1]], i32 0, i32 0
// CHECK-NEXT:    [[ARRAYIDX2:%.*]] = getelementptr inbounds [3 x <16 x i8>], ptr [[VAL1]], i64 0, i64 1
// CHECK-NEXT:    [[TMP11:%.*]] = load <16 x i8>, ptr [[ARRAYIDX2]], align 16
// CHECK-NEXT:    [[VAL3:%.*]] = getelementptr inbounds [[STRUCT_POLY8X16X3_T]], ptr [[__S1]], i32 0, i32 0
// CHECK-NEXT:    [[ARRAYIDX4:%.*]] = getelementptr inbounds [3 x <16 x i8>], ptr [[VAL3]], i64 0, i64 2
// CHECK-NEXT:    [[TMP12:%.*]] = load <16 x i8>, ptr [[ARRAYIDX4]], align 16
// CHECK-NEXT:    [[TMP13:%.*]] = ptrtoint ptr [[A]] to i64
// CHECK-NEXT:    [[TMP14:%.*]] = xor i64 [[TMP13]], 193514046488576
// CHECK-NEXT:    [[TMP15:%.*]] = inttoptr i64 [[TMP14]] to ptr
// CHECK-NEXT:    store <48 x i8> zeroinitializer, ptr [[TMP15]], align 1
// CHECK-NEXT:    call void @llvm.aarch64.neon.st3.v16i8.p0(<16 x i8> [[TMP10]], <16 x i8> [[TMP11]], <16 x i8> [[TMP12]], ptr [[A]])
// CHECK-NEXT:    ret void
//
void test_vst3q_p8(poly8_t *a, poly8x16x3_t b) {
  vst3q_p8(a, b);
}

// CHECK-LABEL: define dso_local void @test_vst3q_p16(
// CHECK-SAME: ptr noundef [[A:%.*]], [3 x <8 x i16>] alignstack(16) [[B_COERCE:%.*]]) #[[ATTR0]] {
// CHECK-NEXT:  entry:
// CHECK-NEXT:    call void @llvm.donothing()
// CHECK-NEXT:    [[B:%.*]] = alloca [[STRUCT_POLY16X8X3_T:%.*]], align 16
// CHECK-NEXT:    [[TMP0:%.*]] = ptrtoint ptr [[B]] to i64
// CHECK-NEXT:    [[TMP1:%.*]] = xor i64 [[TMP0]], 193514046488576
// CHECK-NEXT:    [[TMP2:%.*]] = inttoptr i64 [[TMP1]] to ptr
// CHECK-NEXT:    call void @llvm.memset.p0.i64(ptr align 16 [[TMP2]], i8 0, i64 48, i1 false)
// CHECK-NEXT:    [[__S1:%.*]] = alloca [[STRUCT_POLY16X8X3_T]], align 16
// CHECK-NEXT:    [[TMP3:%.*]] = ptrtoint ptr [[__S1]] to i64
// CHECK-NEXT:    [[TMP4:%.*]] = xor i64 [[TMP3]], 193514046488576
// CHECK-NEXT:    [[TMP5:%.*]] = inttoptr i64 [[TMP4]] to ptr
// CHECK-NEXT:    call void @llvm.memset.p0.i64(ptr align 16 [[TMP5]], i8 0, i64 48, i1 false)
// CHECK-NEXT:    [[COERCE_DIVE:%.*]] = getelementptr inbounds [[STRUCT_POLY16X8X3_T]], ptr [[B]], i32 0, i32 0
// CHECK-NEXT:    [[TMP6:%.*]] = ptrtoint ptr [[COERCE_DIVE]] to i64
// CHECK-NEXT:    [[TMP7:%.*]] = xor i64 [[TMP6]], 193514046488576
// CHECK-NEXT:    [[TMP8:%.*]] = inttoptr i64 [[TMP7]] to ptr
// CHECK-NEXT:    store [3 x <8 x i16>] zeroinitializer, ptr [[TMP8]], align 16
// CHECK-NEXT:    store [3 x <8 x i16>] [[B_COERCE]], ptr [[COERCE_DIVE]], align 16
// CHECK-NEXT:    [[TMP9:%.*]] = call ptr @__msan_memcpy(ptr [[__S1]], ptr [[B]], i64 48)
// CHECK-NEXT:    [[VAL:%.*]] = getelementptr inbounds [[STRUCT_POLY16X8X3_T]], ptr [[__S1]], i32 0, i32 0
// CHECK-NEXT:    [[ARRAYIDX:%.*]] = getelementptr inbounds [3 x <8 x i16>], ptr [[VAL]], i64 0, i64 0
// CHECK-NEXT:    [[TMP10:%.*]] = load <8 x i16>, ptr [[ARRAYIDX]], align 16
// CHECK-NEXT:    [[TMP11:%.*]] = bitcast <8 x i16> [[TMP10]] to <16 x i8>
// CHECK-NEXT:    [[VAL1:%.*]] = getelementptr inbounds [[STRUCT_POLY16X8X3_T]], ptr [[__S1]], i32 0, i32 0
// CHECK-NEXT:    [[ARRAYIDX2:%.*]] = getelementptr inbounds [3 x <8 x i16>], ptr [[VAL1]], i64 0, i64 1
// CHECK-NEXT:    [[TMP12:%.*]] = load <8 x i16>, ptr [[ARRAYIDX2]], align 16
// CHECK-NEXT:    [[TMP13:%.*]] = bitcast <8 x i16> [[TMP12]] to <16 x i8>
// CHECK-NEXT:    [[VAL3:%.*]] = getelementptr inbounds [[STRUCT_POLY16X8X3_T]], ptr [[__S1]], i32 0, i32 0
// CHECK-NEXT:    [[ARRAYIDX4:%.*]] = getelementptr inbounds [3 x <8 x i16>], ptr [[VAL3]], i64 0, i64 2
// CHECK-NEXT:    [[TMP14:%.*]] = load <8 x i16>, ptr [[ARRAYIDX4]], align 16
// CHECK-NEXT:    [[TMP15:%.*]] = bitcast <8 x i16> [[TMP14]] to <16 x i8>
// CHECK-NEXT:    [[TMP16:%.*]] = bitcast <16 x i8> [[TMP11]] to <8 x i16>
// CHECK-NEXT:    [[TMP17:%.*]] = bitcast <16 x i8> [[TMP13]] to <8 x i16>
// CHECK-NEXT:    [[TMP18:%.*]] = bitcast <16 x i8> [[TMP15]] to <8 x i16>
// CHECK-NEXT:    [[TMP19:%.*]] = ptrtoint ptr [[A]] to i64
// CHECK-NEXT:    [[TMP20:%.*]] = xor i64 [[TMP19]], 193514046488576
// CHECK-NEXT:    [[TMP21:%.*]] = inttoptr i64 [[TMP20]] to ptr
// CHECK-NEXT:    store <24 x i16> zeroinitializer, ptr [[TMP21]], align 1
// CHECK-NEXT:    call void @llvm.aarch64.neon.st3.v8i16.p0(<8 x i16> [[TMP16]], <8 x i16> [[TMP17]], <8 x i16> [[TMP18]], ptr [[A]])
// CHECK-NEXT:    ret void
//
void test_vst3q_p16(poly16_t *a, poly16x8x3_t b) {
  vst3q_p16(a, b);
}

// CHECK-LABEL: define dso_local void @test_vst3_u8(
// CHECK-SAME: ptr noundef [[A:%.*]], [3 x <8 x i8>] alignstack(8) [[B_COERCE:%.*]]) #[[ATTR0]] {
// CHECK-NEXT:  entry:
// CHECK-NEXT:    call void @llvm.donothing()
// CHECK-NEXT:    [[B:%.*]] = alloca [[STRUCT_UINT8X8X3_T:%.*]], align 8
// CHECK-NEXT:    [[TMP0:%.*]] = ptrtoint ptr [[B]] to i64
// CHECK-NEXT:    [[TMP1:%.*]] = xor i64 [[TMP0]], 193514046488576
// CHECK-NEXT:    [[TMP2:%.*]] = inttoptr i64 [[TMP1]] to ptr
// CHECK-NEXT:    call void @llvm.memset.p0.i64(ptr align 8 [[TMP2]], i8 0, i64 24, i1 false)
// CHECK-NEXT:    [[__S1:%.*]] = alloca [[STRUCT_UINT8X8X3_T]], align 8
// CHECK-NEXT:    [[TMP3:%.*]] = ptrtoint ptr [[__S1]] to i64
// CHECK-NEXT:    [[TMP4:%.*]] = xor i64 [[TMP3]], 193514046488576
// CHECK-NEXT:    [[TMP5:%.*]] = inttoptr i64 [[TMP4]] to ptr
// CHECK-NEXT:    call void @llvm.memset.p0.i64(ptr align 8 [[TMP5]], i8 0, i64 24, i1 false)
// CHECK-NEXT:    [[COERCE_DIVE:%.*]] = getelementptr inbounds [[STRUCT_UINT8X8X3_T]], ptr [[B]], i32 0, i32 0
// CHECK-NEXT:    [[TMP6:%.*]] = ptrtoint ptr [[COERCE_DIVE]] to i64
// CHECK-NEXT:    [[TMP7:%.*]] = xor i64 [[TMP6]], 193514046488576
// CHECK-NEXT:    [[TMP8:%.*]] = inttoptr i64 [[TMP7]] to ptr
// CHECK-NEXT:    store [3 x <8 x i8>] zeroinitializer, ptr [[TMP8]], align 8
// CHECK-NEXT:    store [3 x <8 x i8>] [[B_COERCE]], ptr [[COERCE_DIVE]], align 8
// CHECK-NEXT:    [[TMP9:%.*]] = call ptr @__msan_memcpy(ptr [[__S1]], ptr [[B]], i64 24)
// CHECK-NEXT:    [[VAL:%.*]] = getelementptr inbounds [[STRUCT_UINT8X8X3_T]], ptr [[__S1]], i32 0, i32 0
// CHECK-NEXT:    [[ARRAYIDX:%.*]] = getelementptr inbounds [3 x <8 x i8>], ptr [[VAL]], i64 0, i64 0
// CHECK-NEXT:    [[TMP10:%.*]] = load <8 x i8>, ptr [[ARRAYIDX]], align 8
// CHECK-NEXT:    [[VAL1:%.*]] = getelementptr inbounds [[STRUCT_UINT8X8X3_T]], ptr [[__S1]], i32 0, i32 0
// CHECK-NEXT:    [[ARRAYIDX2:%.*]] = getelementptr inbounds [3 x <8 x i8>], ptr [[VAL1]], i64 0, i64 1
// CHECK-NEXT:    [[TMP11:%.*]] = load <8 x i8>, ptr [[ARRAYIDX2]], align 8
// CHECK-NEXT:    [[VAL3:%.*]] = getelementptr inbounds [[STRUCT_UINT8X8X3_T]], ptr [[__S1]], i32 0, i32 0
// CHECK-NEXT:    [[ARRAYIDX4:%.*]] = getelementptr inbounds [3 x <8 x i8>], ptr [[VAL3]], i64 0, i64 2
// CHECK-NEXT:    [[TMP12:%.*]] = load <8 x i8>, ptr [[ARRAYIDX4]], align 8
// CHECK-NEXT:    [[TMP13:%.*]] = ptrtoint ptr [[A]] to i64
// CHECK-NEXT:    [[TMP14:%.*]] = xor i64 [[TMP13]], 193514046488576
// CHECK-NEXT:    [[TMP15:%.*]] = inttoptr i64 [[TMP14]] to ptr
// CHECK-NEXT:    store <24 x i8> zeroinitializer, ptr [[TMP15]], align 1
// CHECK-NEXT:    call void @llvm.aarch64.neon.st3.v8i8.p0(<8 x i8> [[TMP10]], <8 x i8> [[TMP11]], <8 x i8> [[TMP12]], ptr [[A]])
// CHECK-NEXT:    ret void
//
void test_vst3_u8(uint8_t *a, uint8x8x3_t b) {
  vst3_u8(a, b);
}

// CHECK-LABEL: define dso_local void @test_vst3_u16(
// CHECK-SAME: ptr noundef [[A:%.*]], [3 x <4 x i16>] alignstack(8) [[B_COERCE:%.*]]) #[[ATTR0]] {
// CHECK-NEXT:  entry:
// CHECK-NEXT:    call void @llvm.donothing()
// CHECK-NEXT:    [[B:%.*]] = alloca [[STRUCT_UINT16X4X3_T:%.*]], align 8
// CHECK-NEXT:    [[TMP0:%.*]] = ptrtoint ptr [[B]] to i64
// CHECK-NEXT:    [[TMP1:%.*]] = xor i64 [[TMP0]], 193514046488576
// CHECK-NEXT:    [[TMP2:%.*]] = inttoptr i64 [[TMP1]] to ptr
// CHECK-NEXT:    call void @llvm.memset.p0.i64(ptr align 8 [[TMP2]], i8 0, i64 24, i1 false)
// CHECK-NEXT:    [[__S1:%.*]] = alloca [[STRUCT_UINT16X4X3_T]], align 8
// CHECK-NEXT:    [[TMP3:%.*]] = ptrtoint ptr [[__S1]] to i64
// CHECK-NEXT:    [[TMP4:%.*]] = xor i64 [[TMP3]], 193514046488576
// CHECK-NEXT:    [[TMP5:%.*]] = inttoptr i64 [[TMP4]] to ptr
// CHECK-NEXT:    call void @llvm.memset.p0.i64(ptr align 8 [[TMP5]], i8 0, i64 24, i1 false)
// CHECK-NEXT:    [[COERCE_DIVE:%.*]] = getelementptr inbounds [[STRUCT_UINT16X4X3_T]], ptr [[B]], i32 0, i32 0
// CHECK-NEXT:    [[TMP6:%.*]] = ptrtoint ptr [[COERCE_DIVE]] to i64
// CHECK-NEXT:    [[TMP7:%.*]] = xor i64 [[TMP6]], 193514046488576
// CHECK-NEXT:    [[TMP8:%.*]] = inttoptr i64 [[TMP7]] to ptr
// CHECK-NEXT:    store [3 x <4 x i16>] zeroinitializer, ptr [[TMP8]], align 8
// CHECK-NEXT:    store [3 x <4 x i16>] [[B_COERCE]], ptr [[COERCE_DIVE]], align 8
// CHECK-NEXT:    [[TMP9:%.*]] = call ptr @__msan_memcpy(ptr [[__S1]], ptr [[B]], i64 24)
// CHECK-NEXT:    [[VAL:%.*]] = getelementptr inbounds [[STRUCT_UINT16X4X3_T]], ptr [[__S1]], i32 0, i32 0
// CHECK-NEXT:    [[ARRAYIDX:%.*]] = getelementptr inbounds [3 x <4 x i16>], ptr [[VAL]], i64 0, i64 0
// CHECK-NEXT:    [[TMP10:%.*]] = load <4 x i16>, ptr [[ARRAYIDX]], align 8
// CHECK-NEXT:    [[TMP11:%.*]] = bitcast <4 x i16> [[TMP10]] to <8 x i8>
// CHECK-NEXT:    [[VAL1:%.*]] = getelementptr inbounds [[STRUCT_UINT16X4X3_T]], ptr [[__S1]], i32 0, i32 0
// CHECK-NEXT:    [[ARRAYIDX2:%.*]] = getelementptr inbounds [3 x <4 x i16>], ptr [[VAL1]], i64 0, i64 1
// CHECK-NEXT:    [[TMP12:%.*]] = load <4 x i16>, ptr [[ARRAYIDX2]], align 8
// CHECK-NEXT:    [[TMP13:%.*]] = bitcast <4 x i16> [[TMP12]] to <8 x i8>
// CHECK-NEXT:    [[VAL3:%.*]] = getelementptr inbounds [[STRUCT_UINT16X4X3_T]], ptr [[__S1]], i32 0, i32 0
// CHECK-NEXT:    [[ARRAYIDX4:%.*]] = getelementptr inbounds [3 x <4 x i16>], ptr [[VAL3]], i64 0, i64 2
// CHECK-NEXT:    [[TMP14:%.*]] = load <4 x i16>, ptr [[ARRAYIDX4]], align 8
// CHECK-NEXT:    [[TMP15:%.*]] = bitcast <4 x i16> [[TMP14]] to <8 x i8>
// CHECK-NEXT:    [[TMP16:%.*]] = bitcast <8 x i8> [[TMP11]] to <4 x i16>
// CHECK-NEXT:    [[TMP17:%.*]] = bitcast <8 x i8> [[TMP13]] to <4 x i16>
// CHECK-NEXT:    [[TMP18:%.*]] = bitcast <8 x i8> [[TMP15]] to <4 x i16>
// CHECK-NEXT:    [[TMP19:%.*]] = ptrtoint ptr [[A]] to i64
// CHECK-NEXT:    [[TMP20:%.*]] = xor i64 [[TMP19]], 193514046488576
// CHECK-NEXT:    [[TMP21:%.*]] = inttoptr i64 [[TMP20]] to ptr
// CHECK-NEXT:    store <12 x i16> zeroinitializer, ptr [[TMP21]], align 1
// CHECK-NEXT:    call void @llvm.aarch64.neon.st3.v4i16.p0(<4 x i16> [[TMP16]], <4 x i16> [[TMP17]], <4 x i16> [[TMP18]], ptr [[A]])
// CHECK-NEXT:    ret void
//
void test_vst3_u16(uint16_t *a, uint16x4x3_t b) {
  vst3_u16(a, b);
}

// CHECK-LABEL: define dso_local void @test_vst3_u32(
// CHECK-SAME: ptr noundef [[A:%.*]], [3 x <2 x i32>] alignstack(8) [[B_COERCE:%.*]]) #[[ATTR0]] {
// CHECK-NEXT:  entry:
// CHECK-NEXT:    call void @llvm.donothing()
// CHECK-NEXT:    [[B:%.*]] = alloca [[STRUCT_UINT32X2X3_T:%.*]], align 8
// CHECK-NEXT:    [[TMP0:%.*]] = ptrtoint ptr [[B]] to i64
// CHECK-NEXT:    [[TMP1:%.*]] = xor i64 [[TMP0]], 193514046488576
// CHECK-NEXT:    [[TMP2:%.*]] = inttoptr i64 [[TMP1]] to ptr
// CHECK-NEXT:    call void @llvm.memset.p0.i64(ptr align 8 [[TMP2]], i8 0, i64 24, i1 false)
// CHECK-NEXT:    [[__S1:%.*]] = alloca [[STRUCT_UINT32X2X3_T]], align 8
// CHECK-NEXT:    [[TMP3:%.*]] = ptrtoint ptr [[__S1]] to i64
// CHECK-NEXT:    [[TMP4:%.*]] = xor i64 [[TMP3]], 193514046488576
// CHECK-NEXT:    [[TMP5:%.*]] = inttoptr i64 [[TMP4]] to ptr
// CHECK-NEXT:    call void @llvm.memset.p0.i64(ptr align 8 [[TMP5]], i8 0, i64 24, i1 false)
// CHECK-NEXT:    [[COERCE_DIVE:%.*]] = getelementptr inbounds [[STRUCT_UINT32X2X3_T]], ptr [[B]], i32 0, i32 0
// CHECK-NEXT:    [[TMP6:%.*]] = ptrtoint ptr [[COERCE_DIVE]] to i64
// CHECK-NEXT:    [[TMP7:%.*]] = xor i64 [[TMP6]], 193514046488576
// CHECK-NEXT:    [[TMP8:%.*]] = inttoptr i64 [[TMP7]] to ptr
// CHECK-NEXT:    store [3 x <2 x i32>] zeroinitializer, ptr [[TMP8]], align 8
// CHECK-NEXT:    store [3 x <2 x i32>] [[B_COERCE]], ptr [[COERCE_DIVE]], align 8
// CHECK-NEXT:    [[TMP9:%.*]] = call ptr @__msan_memcpy(ptr [[__S1]], ptr [[B]], i64 24)
// CHECK-NEXT:    [[VAL:%.*]] = getelementptr inbounds [[STRUCT_UINT32X2X3_T]], ptr [[__S1]], i32 0, i32 0
// CHECK-NEXT:    [[ARRAYIDX:%.*]] = getelementptr inbounds [3 x <2 x i32>], ptr [[VAL]], i64 0, i64 0
// CHECK-NEXT:    [[TMP10:%.*]] = load <2 x i32>, ptr [[ARRAYIDX]], align 8
// CHECK-NEXT:    [[TMP11:%.*]] = bitcast <2 x i32> [[TMP10]] to <8 x i8>
// CHECK-NEXT:    [[VAL1:%.*]] = getelementptr inbounds [[STRUCT_UINT32X2X3_T]], ptr [[__S1]], i32 0, i32 0
// CHECK-NEXT:    [[ARRAYIDX2:%.*]] = getelementptr inbounds [3 x <2 x i32>], ptr [[VAL1]], i64 0, i64 1
// CHECK-NEXT:    [[TMP12:%.*]] = load <2 x i32>, ptr [[ARRAYIDX2]], align 8
// CHECK-NEXT:    [[TMP13:%.*]] = bitcast <2 x i32> [[TMP12]] to <8 x i8>
// CHECK-NEXT:    [[VAL3:%.*]] = getelementptr inbounds [[STRUCT_UINT32X2X3_T]], ptr [[__S1]], i32 0, i32 0
// CHECK-NEXT:    [[ARRAYIDX4:%.*]] = getelementptr inbounds [3 x <2 x i32>], ptr [[VAL3]], i64 0, i64 2
// CHECK-NEXT:    [[TMP14:%.*]] = load <2 x i32>, ptr [[ARRAYIDX4]], align 8
// CHECK-NEXT:    [[TMP15:%.*]] = bitcast <2 x i32> [[TMP14]] to <8 x i8>
// CHECK-NEXT:    [[TMP16:%.*]] = bitcast <8 x i8> [[TMP11]] to <2 x i32>
// CHECK-NEXT:    [[TMP17:%.*]] = bitcast <8 x i8> [[TMP13]] to <2 x i32>
// CHECK-NEXT:    [[TMP18:%.*]] = bitcast <8 x i8> [[TMP15]] to <2 x i32>
// CHECK-NEXT:    [[TMP19:%.*]] = ptrtoint ptr [[A]] to i64
// CHECK-NEXT:    [[TMP20:%.*]] = xor i64 [[TMP19]], 193514046488576
// CHECK-NEXT:    [[TMP21:%.*]] = inttoptr i64 [[TMP20]] to ptr
// CHECK-NEXT:    store <6 x i32> zeroinitializer, ptr [[TMP21]], align 1
// CHECK-NEXT:    call void @llvm.aarch64.neon.st3.v2i32.p0(<2 x i32> [[TMP16]], <2 x i32> [[TMP17]], <2 x i32> [[TMP18]], ptr [[A]])
// CHECK-NEXT:    ret void
//
void test_vst3_u32(uint32_t *a, uint32x2x3_t b) {
  vst3_u32(a, b);
}

// CHECK-LABEL: define dso_local void @test_vst3_u64(
// CHECK-SAME: ptr noundef [[A:%.*]], [3 x <1 x i64>] alignstack(8) [[B_COERCE:%.*]]) #[[ATTR0]] {
// CHECK-NEXT:  entry:
// CHECK-NEXT:    call void @llvm.donothing()
// CHECK-NEXT:    [[B:%.*]] = alloca [[STRUCT_UINT64X1X3_T:%.*]], align 8
// CHECK-NEXT:    [[TMP0:%.*]] = ptrtoint ptr [[B]] to i64
// CHECK-NEXT:    [[TMP1:%.*]] = xor i64 [[TMP0]], 193514046488576
// CHECK-NEXT:    [[TMP2:%.*]] = inttoptr i64 [[TMP1]] to ptr
// CHECK-NEXT:    call void @llvm.memset.p0.i64(ptr align 8 [[TMP2]], i8 0, i64 24, i1 false)
// CHECK-NEXT:    [[__S1:%.*]] = alloca [[STRUCT_UINT64X1X3_T]], align 8
// CHECK-NEXT:    [[TMP3:%.*]] = ptrtoint ptr [[__S1]] to i64
// CHECK-NEXT:    [[TMP4:%.*]] = xor i64 [[TMP3]], 193514046488576
// CHECK-NEXT:    [[TMP5:%.*]] = inttoptr i64 [[TMP4]] to ptr
// CHECK-NEXT:    call void @llvm.memset.p0.i64(ptr align 8 [[TMP5]], i8 0, i64 24, i1 false)
// CHECK-NEXT:    [[COERCE_DIVE:%.*]] = getelementptr inbounds [[STRUCT_UINT64X1X3_T]], ptr [[B]], i32 0, i32 0
// CHECK-NEXT:    [[TMP6:%.*]] = ptrtoint ptr [[COERCE_DIVE]] to i64
// CHECK-NEXT:    [[TMP7:%.*]] = xor i64 [[TMP6]], 193514046488576
// CHECK-NEXT:    [[TMP8:%.*]] = inttoptr i64 [[TMP7]] to ptr
// CHECK-NEXT:    store [3 x <1 x i64>] zeroinitializer, ptr [[TMP8]], align 8
// CHECK-NEXT:    store [3 x <1 x i64>] [[B_COERCE]], ptr [[COERCE_DIVE]], align 8
// CHECK-NEXT:    [[TMP9:%.*]] = call ptr @__msan_memcpy(ptr [[__S1]], ptr [[B]], i64 24)
// CHECK-NEXT:    [[VAL:%.*]] = getelementptr inbounds [[STRUCT_UINT64X1X3_T]], ptr [[__S1]], i32 0, i32 0
// CHECK-NEXT:    [[ARRAYIDX:%.*]] = getelementptr inbounds [3 x <1 x i64>], ptr [[VAL]], i64 0, i64 0
// CHECK-NEXT:    [[TMP10:%.*]] = load <1 x i64>, ptr [[ARRAYIDX]], align 8
// CHECK-NEXT:    [[TMP11:%.*]] = bitcast <1 x i64> [[TMP10]] to <8 x i8>
// CHECK-NEXT:    [[VAL1:%.*]] = getelementptr inbounds [[STRUCT_UINT64X1X3_T]], ptr [[__S1]], i32 0, i32 0
// CHECK-NEXT:    [[ARRAYIDX2:%.*]] = getelementptr inbounds [3 x <1 x i64>], ptr [[VAL1]], i64 0, i64 1
// CHECK-NEXT:    [[TMP12:%.*]] = load <1 x i64>, ptr [[ARRAYIDX2]], align 8
// CHECK-NEXT:    [[TMP13:%.*]] = bitcast <1 x i64> [[TMP12]] to <8 x i8>
// CHECK-NEXT:    [[VAL3:%.*]] = getelementptr inbounds [[STRUCT_UINT64X1X3_T]], ptr [[__S1]], i32 0, i32 0
// CHECK-NEXT:    [[ARRAYIDX4:%.*]] = getelementptr inbounds [3 x <1 x i64>], ptr [[VAL3]], i64 0, i64 2
// CHECK-NEXT:    [[TMP14:%.*]] = load <1 x i64>, ptr [[ARRAYIDX4]], align 8
// CHECK-NEXT:    [[TMP15:%.*]] = bitcast <1 x i64> [[TMP14]] to <8 x i8>
// CHECK-NEXT:    [[TMP16:%.*]] = bitcast <8 x i8> [[TMP11]] to <1 x i64>
// CHECK-NEXT:    [[TMP17:%.*]] = bitcast <8 x i8> [[TMP13]] to <1 x i64>
// CHECK-NEXT:    [[TMP18:%.*]] = bitcast <8 x i8> [[TMP15]] to <1 x i64>
// CHECK-NEXT:    [[TMP19:%.*]] = ptrtoint ptr [[A]] to i64
// CHECK-NEXT:    [[TMP20:%.*]] = xor i64 [[TMP19]], 193514046488576
// CHECK-NEXT:    [[TMP21:%.*]] = inttoptr i64 [[TMP20]] to ptr
// CHECK-NEXT:    store <3 x i64> zeroinitializer, ptr [[TMP21]], align 1
// CHECK-NEXT:    call void @llvm.aarch64.neon.st3.v1i64.p0(<1 x i64> [[TMP16]], <1 x i64> [[TMP17]], <1 x i64> [[TMP18]], ptr [[A]])
// CHECK-NEXT:    ret void
//
void test_vst3_u64(uint64_t *a, uint64x1x3_t b) {
  vst3_u64(a, b);
}

// CHECK-LABEL: define dso_local void @test_vst3_s8(
// CHECK-SAME: ptr noundef [[A:%.*]], [3 x <8 x i8>] alignstack(8) [[B_COERCE:%.*]]) #[[ATTR0]] {
// CHECK-NEXT:  entry:
// CHECK-NEXT:    call void @llvm.donothing()
// CHECK-NEXT:    [[B:%.*]] = alloca [[STRUCT_INT8X8X3_T:%.*]], align 8
// CHECK-NEXT:    [[TMP0:%.*]] = ptrtoint ptr [[B]] to i64
// CHECK-NEXT:    [[TMP1:%.*]] = xor i64 [[TMP0]], 193514046488576
// CHECK-NEXT:    [[TMP2:%.*]] = inttoptr i64 [[TMP1]] to ptr
// CHECK-NEXT:    call void @llvm.memset.p0.i64(ptr align 8 [[TMP2]], i8 0, i64 24, i1 false)
// CHECK-NEXT:    [[__S1:%.*]] = alloca [[STRUCT_INT8X8X3_T]], align 8
// CHECK-NEXT:    [[TMP3:%.*]] = ptrtoint ptr [[__S1]] to i64
// CHECK-NEXT:    [[TMP4:%.*]] = xor i64 [[TMP3]], 193514046488576
// CHECK-NEXT:    [[TMP5:%.*]] = inttoptr i64 [[TMP4]] to ptr
// CHECK-NEXT:    call void @llvm.memset.p0.i64(ptr align 8 [[TMP5]], i8 0, i64 24, i1 false)
// CHECK-NEXT:    [[COERCE_DIVE:%.*]] = getelementptr inbounds [[STRUCT_INT8X8X3_T]], ptr [[B]], i32 0, i32 0
// CHECK-NEXT:    [[TMP6:%.*]] = ptrtoint ptr [[COERCE_DIVE]] to i64
// CHECK-NEXT:    [[TMP7:%.*]] = xor i64 [[TMP6]], 193514046488576
// CHECK-NEXT:    [[TMP8:%.*]] = inttoptr i64 [[TMP7]] to ptr
// CHECK-NEXT:    store [3 x <8 x i8>] zeroinitializer, ptr [[TMP8]], align 8
// CHECK-NEXT:    store [3 x <8 x i8>] [[B_COERCE]], ptr [[COERCE_DIVE]], align 8
// CHECK-NEXT:    [[TMP9:%.*]] = call ptr @__msan_memcpy(ptr [[__S1]], ptr [[B]], i64 24)
// CHECK-NEXT:    [[VAL:%.*]] = getelementptr inbounds [[STRUCT_INT8X8X3_T]], ptr [[__S1]], i32 0, i32 0
// CHECK-NEXT:    [[ARRAYIDX:%.*]] = getelementptr inbounds [3 x <8 x i8>], ptr [[VAL]], i64 0, i64 0
// CHECK-NEXT:    [[TMP10:%.*]] = load <8 x i8>, ptr [[ARRAYIDX]], align 8
// CHECK-NEXT:    [[VAL1:%.*]] = getelementptr inbounds [[STRUCT_INT8X8X3_T]], ptr [[__S1]], i32 0, i32 0
// CHECK-NEXT:    [[ARRAYIDX2:%.*]] = getelementptr inbounds [3 x <8 x i8>], ptr [[VAL1]], i64 0, i64 1
// CHECK-NEXT:    [[TMP11:%.*]] = load <8 x i8>, ptr [[ARRAYIDX2]], align 8
// CHECK-NEXT:    [[VAL3:%.*]] = getelementptr inbounds [[STRUCT_INT8X8X3_T]], ptr [[__S1]], i32 0, i32 0
// CHECK-NEXT:    [[ARRAYIDX4:%.*]] = getelementptr inbounds [3 x <8 x i8>], ptr [[VAL3]], i64 0, i64 2
// CHECK-NEXT:    [[TMP12:%.*]] = load <8 x i8>, ptr [[ARRAYIDX4]], align 8
// CHECK-NEXT:    [[TMP13:%.*]] = ptrtoint ptr [[A]] to i64
// CHECK-NEXT:    [[TMP14:%.*]] = xor i64 [[TMP13]], 193514046488576
// CHECK-NEXT:    [[TMP15:%.*]] = inttoptr i64 [[TMP14]] to ptr
// CHECK-NEXT:    store <24 x i8> zeroinitializer, ptr [[TMP15]], align 1
// CHECK-NEXT:    call void @llvm.aarch64.neon.st3.v8i8.p0(<8 x i8> [[TMP10]], <8 x i8> [[TMP11]], <8 x i8> [[TMP12]], ptr [[A]])
// CHECK-NEXT:    ret void
//
void test_vst3_s8(int8_t *a, int8x8x3_t b) {
  vst3_s8(a, b);
}

// CHECK-LABEL: define dso_local void @test_vst3_s16(
// CHECK-SAME: ptr noundef [[A:%.*]], [3 x <4 x i16>] alignstack(8) [[B_COERCE:%.*]]) #[[ATTR0]] {
// CHECK-NEXT:  entry:
// CHECK-NEXT:    call void @llvm.donothing()
// CHECK-NEXT:    [[B:%.*]] = alloca [[STRUCT_INT16X4X3_T:%.*]], align 8
// CHECK-NEXT:    [[TMP0:%.*]] = ptrtoint ptr [[B]] to i64
// CHECK-NEXT:    [[TMP1:%.*]] = xor i64 [[TMP0]], 193514046488576
// CHECK-NEXT:    [[TMP2:%.*]] = inttoptr i64 [[TMP1]] to ptr
// CHECK-NEXT:    call void @llvm.memset.p0.i64(ptr align 8 [[TMP2]], i8 0, i64 24, i1 false)
// CHECK-NEXT:    [[__S1:%.*]] = alloca [[STRUCT_INT16X4X3_T]], align 8
// CHECK-NEXT:    [[TMP3:%.*]] = ptrtoint ptr [[__S1]] to i64
// CHECK-NEXT:    [[TMP4:%.*]] = xor i64 [[TMP3]], 193514046488576
// CHECK-NEXT:    [[TMP5:%.*]] = inttoptr i64 [[TMP4]] to ptr
// CHECK-NEXT:    call void @llvm.memset.p0.i64(ptr align 8 [[TMP5]], i8 0, i64 24, i1 false)
// CHECK-NEXT:    [[COERCE_DIVE:%.*]] = getelementptr inbounds [[STRUCT_INT16X4X3_T]], ptr [[B]], i32 0, i32 0
// CHECK-NEXT:    [[TMP6:%.*]] = ptrtoint ptr [[COERCE_DIVE]] to i64
// CHECK-NEXT:    [[TMP7:%.*]] = xor i64 [[TMP6]], 193514046488576
// CHECK-NEXT:    [[TMP8:%.*]] = inttoptr i64 [[TMP7]] to ptr
// CHECK-NEXT:    store [3 x <4 x i16>] zeroinitializer, ptr [[TMP8]], align 8
// CHECK-NEXT:    store [3 x <4 x i16>] [[B_COERCE]], ptr [[COERCE_DIVE]], align 8
// CHECK-NEXT:    [[TMP9:%.*]] = call ptr @__msan_memcpy(ptr [[__S1]], ptr [[B]], i64 24)
// CHECK-NEXT:    [[VAL:%.*]] = getelementptr inbounds [[STRUCT_INT16X4X3_T]], ptr [[__S1]], i32 0, i32 0
// CHECK-NEXT:    [[ARRAYIDX:%.*]] = getelementptr inbounds [3 x <4 x i16>], ptr [[VAL]], i64 0, i64 0
// CHECK-NEXT:    [[TMP10:%.*]] = load <4 x i16>, ptr [[ARRAYIDX]], align 8
// CHECK-NEXT:    [[TMP11:%.*]] = bitcast <4 x i16> [[TMP10]] to <8 x i8>
// CHECK-NEXT:    [[VAL1:%.*]] = getelementptr inbounds [[STRUCT_INT16X4X3_T]], ptr [[__S1]], i32 0, i32 0
// CHECK-NEXT:    [[ARRAYIDX2:%.*]] = getelementptr inbounds [3 x <4 x i16>], ptr [[VAL1]], i64 0, i64 1
// CHECK-NEXT:    [[TMP12:%.*]] = load <4 x i16>, ptr [[ARRAYIDX2]], align 8
// CHECK-NEXT:    [[TMP13:%.*]] = bitcast <4 x i16> [[TMP12]] to <8 x i8>
// CHECK-NEXT:    [[VAL3:%.*]] = getelementptr inbounds [[STRUCT_INT16X4X3_T]], ptr [[__S1]], i32 0, i32 0
// CHECK-NEXT:    [[ARRAYIDX4:%.*]] = getelementptr inbounds [3 x <4 x i16>], ptr [[VAL3]], i64 0, i64 2
// CHECK-NEXT:    [[TMP14:%.*]] = load <4 x i16>, ptr [[ARRAYIDX4]], align 8
// CHECK-NEXT:    [[TMP15:%.*]] = bitcast <4 x i16> [[TMP14]] to <8 x i8>
// CHECK-NEXT:    [[TMP16:%.*]] = bitcast <8 x i8> [[TMP11]] to <4 x i16>
// CHECK-NEXT:    [[TMP17:%.*]] = bitcast <8 x i8> [[TMP13]] to <4 x i16>
// CHECK-NEXT:    [[TMP18:%.*]] = bitcast <8 x i8> [[TMP15]] to <4 x i16>
// CHECK-NEXT:    [[TMP19:%.*]] = ptrtoint ptr [[A]] to i64
// CHECK-NEXT:    [[TMP20:%.*]] = xor i64 [[TMP19]], 193514046488576
// CHECK-NEXT:    [[TMP21:%.*]] = inttoptr i64 [[TMP20]] to ptr
// CHECK-NEXT:    store <12 x i16> zeroinitializer, ptr [[TMP21]], align 1
// CHECK-NEXT:    call void @llvm.aarch64.neon.st3.v4i16.p0(<4 x i16> [[TMP16]], <4 x i16> [[TMP17]], <4 x i16> [[TMP18]], ptr [[A]])
// CHECK-NEXT:    ret void
//
void test_vst3_s16(int16_t *a, int16x4x3_t b) {
  vst3_s16(a, b);
}

// CHECK-LABEL: define dso_local void @test_vst3_s32(
// CHECK-SAME: ptr noundef [[A:%.*]], [3 x <2 x i32>] alignstack(8) [[B_COERCE:%.*]]) #[[ATTR0]] {
// CHECK-NEXT:  entry:
// CHECK-NEXT:    call void @llvm.donothing()
// CHECK-NEXT:    [[B:%.*]] = alloca [[STRUCT_INT32X2X3_T:%.*]], align 8
// CHECK-NEXT:    [[TMP0:%.*]] = ptrtoint ptr [[B]] to i64
// CHECK-NEXT:    [[TMP1:%.*]] = xor i64 [[TMP0]], 193514046488576
// CHECK-NEXT:    [[TMP2:%.*]] = inttoptr i64 [[TMP1]] to ptr
// CHECK-NEXT:    call void @llvm.memset.p0.i64(ptr align 8 [[TMP2]], i8 0, i64 24, i1 false)
// CHECK-NEXT:    [[__S1:%.*]] = alloca [[STRUCT_INT32X2X3_T]], align 8
// CHECK-NEXT:    [[TMP3:%.*]] = ptrtoint ptr [[__S1]] to i64
// CHECK-NEXT:    [[TMP4:%.*]] = xor i64 [[TMP3]], 193514046488576
// CHECK-NEXT:    [[TMP5:%.*]] = inttoptr i64 [[TMP4]] to ptr
// CHECK-NEXT:    call void @llvm.memset.p0.i64(ptr align 8 [[TMP5]], i8 0, i64 24, i1 false)
// CHECK-NEXT:    [[COERCE_DIVE:%.*]] = getelementptr inbounds [[STRUCT_INT32X2X3_T]], ptr [[B]], i32 0, i32 0
// CHECK-NEXT:    [[TMP6:%.*]] = ptrtoint ptr [[COERCE_DIVE]] to i64
// CHECK-NEXT:    [[TMP7:%.*]] = xor i64 [[TMP6]], 193514046488576
// CHECK-NEXT:    [[TMP8:%.*]] = inttoptr i64 [[TMP7]] to ptr
// CHECK-NEXT:    store [3 x <2 x i32>] zeroinitializer, ptr [[TMP8]], align 8
// CHECK-NEXT:    store [3 x <2 x i32>] [[B_COERCE]], ptr [[COERCE_DIVE]], align 8
// CHECK-NEXT:    [[TMP9:%.*]] = call ptr @__msan_memcpy(ptr [[__S1]], ptr [[B]], i64 24)
// CHECK-NEXT:    [[VAL:%.*]] = getelementptr inbounds [[STRUCT_INT32X2X3_T]], ptr [[__S1]], i32 0, i32 0
// CHECK-NEXT:    [[ARRAYIDX:%.*]] = getelementptr inbounds [3 x <2 x i32>], ptr [[VAL]], i64 0, i64 0
// CHECK-NEXT:    [[TMP10:%.*]] = load <2 x i32>, ptr [[ARRAYIDX]], align 8
// CHECK-NEXT:    [[TMP11:%.*]] = bitcast <2 x i32> [[TMP10]] to <8 x i8>
// CHECK-NEXT:    [[VAL1:%.*]] = getelementptr inbounds [[STRUCT_INT32X2X3_T]], ptr [[__S1]], i32 0, i32 0
// CHECK-NEXT:    [[ARRAYIDX2:%.*]] = getelementptr inbounds [3 x <2 x i32>], ptr [[VAL1]], i64 0, i64 1
// CHECK-NEXT:    [[TMP12:%.*]] = load <2 x i32>, ptr [[ARRAYIDX2]], align 8
// CHECK-NEXT:    [[TMP13:%.*]] = bitcast <2 x i32> [[TMP12]] to <8 x i8>
// CHECK-NEXT:    [[VAL3:%.*]] = getelementptr inbounds [[STRUCT_INT32X2X3_T]], ptr [[__S1]], i32 0, i32 0
// CHECK-NEXT:    [[ARRAYIDX4:%.*]] = getelementptr inbounds [3 x <2 x i32>], ptr [[VAL3]], i64 0, i64 2
// CHECK-NEXT:    [[TMP14:%.*]] = load <2 x i32>, ptr [[ARRAYIDX4]], align 8
// CHECK-NEXT:    [[TMP15:%.*]] = bitcast <2 x i32> [[TMP14]] to <8 x i8>
// CHECK-NEXT:    [[TMP16:%.*]] = bitcast <8 x i8> [[TMP11]] to <2 x i32>
// CHECK-NEXT:    [[TMP17:%.*]] = bitcast <8 x i8> [[TMP13]] to <2 x i32>
// CHECK-NEXT:    [[TMP18:%.*]] = bitcast <8 x i8> [[TMP15]] to <2 x i32>
// CHECK-NEXT:    [[TMP19:%.*]] = ptrtoint ptr [[A]] to i64
// CHECK-NEXT:    [[TMP20:%.*]] = xor i64 [[TMP19]], 193514046488576
// CHECK-NEXT:    [[TMP21:%.*]] = inttoptr i64 [[TMP20]] to ptr
// CHECK-NEXT:    store <6 x i32> zeroinitializer, ptr [[TMP21]], align 1
// CHECK-NEXT:    call void @llvm.aarch64.neon.st3.v2i32.p0(<2 x i32> [[TMP16]], <2 x i32> [[TMP17]], <2 x i32> [[TMP18]], ptr [[A]])
// CHECK-NEXT:    ret void
//
void test_vst3_s32(int32_t *a, int32x2x3_t b) {
  vst3_s32(a, b);
}

// CHECK-LABEL: define dso_local void @test_vst3_s64(
// CHECK-SAME: ptr noundef [[A:%.*]], [3 x <1 x i64>] alignstack(8) [[B_COERCE:%.*]]) #[[ATTR0]] {
// CHECK-NEXT:  entry:
// CHECK-NEXT:    call void @llvm.donothing()
// CHECK-NEXT:    [[B:%.*]] = alloca [[STRUCT_INT64X1X3_T:%.*]], align 8
// CHECK-NEXT:    [[TMP0:%.*]] = ptrtoint ptr [[B]] to i64
// CHECK-NEXT:    [[TMP1:%.*]] = xor i64 [[TMP0]], 193514046488576
// CHECK-NEXT:    [[TMP2:%.*]] = inttoptr i64 [[TMP1]] to ptr
// CHECK-NEXT:    call void @llvm.memset.p0.i64(ptr align 8 [[TMP2]], i8 0, i64 24, i1 false)
// CHECK-NEXT:    [[__S1:%.*]] = alloca [[STRUCT_INT64X1X3_T]], align 8
// CHECK-NEXT:    [[TMP3:%.*]] = ptrtoint ptr [[__S1]] to i64
// CHECK-NEXT:    [[TMP4:%.*]] = xor i64 [[TMP3]], 193514046488576
// CHECK-NEXT:    [[TMP5:%.*]] = inttoptr i64 [[TMP4]] to ptr
// CHECK-NEXT:    call void @llvm.memset.p0.i64(ptr align 8 [[TMP5]], i8 0, i64 24, i1 false)
// CHECK-NEXT:    [[COERCE_DIVE:%.*]] = getelementptr inbounds [[STRUCT_INT64X1X3_T]], ptr [[B]], i32 0, i32 0
// CHECK-NEXT:    [[TMP6:%.*]] = ptrtoint ptr [[COERCE_DIVE]] to i64
// CHECK-NEXT:    [[TMP7:%.*]] = xor i64 [[TMP6]], 193514046488576
// CHECK-NEXT:    [[TMP8:%.*]] = inttoptr i64 [[TMP7]] to ptr
// CHECK-NEXT:    store [3 x <1 x i64>] zeroinitializer, ptr [[TMP8]], align 8
// CHECK-NEXT:    store [3 x <1 x i64>] [[B_COERCE]], ptr [[COERCE_DIVE]], align 8
// CHECK-NEXT:    [[TMP9:%.*]] = call ptr @__msan_memcpy(ptr [[__S1]], ptr [[B]], i64 24)
// CHECK-NEXT:    [[VAL:%.*]] = getelementptr inbounds [[STRUCT_INT64X1X3_T]], ptr [[__S1]], i32 0, i32 0
// CHECK-NEXT:    [[ARRAYIDX:%.*]] = getelementptr inbounds [3 x <1 x i64>], ptr [[VAL]], i64 0, i64 0
// CHECK-NEXT:    [[TMP10:%.*]] = load <1 x i64>, ptr [[ARRAYIDX]], align 8
// CHECK-NEXT:    [[TMP11:%.*]] = bitcast <1 x i64> [[TMP10]] to <8 x i8>
// CHECK-NEXT:    [[VAL1:%.*]] = getelementptr inbounds [[STRUCT_INT64X1X3_T]], ptr [[__S1]], i32 0, i32 0
// CHECK-NEXT:    [[ARRAYIDX2:%.*]] = getelementptr inbounds [3 x <1 x i64>], ptr [[VAL1]], i64 0, i64 1
// CHECK-NEXT:    [[TMP12:%.*]] = load <1 x i64>, ptr [[ARRAYIDX2]], align 8
// CHECK-NEXT:    [[TMP13:%.*]] = bitcast <1 x i64> [[TMP12]] to <8 x i8>
// CHECK-NEXT:    [[VAL3:%.*]] = getelementptr inbounds [[STRUCT_INT64X1X3_T]], ptr [[__S1]], i32 0, i32 0
// CHECK-NEXT:    [[ARRAYIDX4:%.*]] = getelementptr inbounds [3 x <1 x i64>], ptr [[VAL3]], i64 0, i64 2
// CHECK-NEXT:    [[TMP14:%.*]] = load <1 x i64>, ptr [[ARRAYIDX4]], align 8
// CHECK-NEXT:    [[TMP15:%.*]] = bitcast <1 x i64> [[TMP14]] to <8 x i8>
// CHECK-NEXT:    [[TMP16:%.*]] = bitcast <8 x i8> [[TMP11]] to <1 x i64>
// CHECK-NEXT:    [[TMP17:%.*]] = bitcast <8 x i8> [[TMP13]] to <1 x i64>
// CHECK-NEXT:    [[TMP18:%.*]] = bitcast <8 x i8> [[TMP15]] to <1 x i64>
// CHECK-NEXT:    [[TMP19:%.*]] = ptrtoint ptr [[A]] to i64
// CHECK-NEXT:    [[TMP20:%.*]] = xor i64 [[TMP19]], 193514046488576
// CHECK-NEXT:    [[TMP21:%.*]] = inttoptr i64 [[TMP20]] to ptr
// CHECK-NEXT:    store <3 x i64> zeroinitializer, ptr [[TMP21]], align 1
// CHECK-NEXT:    call void @llvm.aarch64.neon.st3.v1i64.p0(<1 x i64> [[TMP16]], <1 x i64> [[TMP17]], <1 x i64> [[TMP18]], ptr [[A]])
// CHECK-NEXT:    ret void
//
void test_vst3_s64(int64_t *a, int64x1x3_t b) {
  vst3_s64(a, b);
}

// CHECK-LABEL: define dso_local void @test_vst3_f16(
// CHECK-SAME: ptr noundef [[A:%.*]], [3 x <4 x half>] alignstack(8) [[B_COERCE:%.*]]) #[[ATTR0]] {
// CHECK-NEXT:  entry:
// CHECK-NEXT:    call void @llvm.donothing()
// CHECK-NEXT:    [[B:%.*]] = alloca [[STRUCT_FLOAT16X4X3_T:%.*]], align 8
// CHECK-NEXT:    [[TMP0:%.*]] = ptrtoint ptr [[B]] to i64
// CHECK-NEXT:    [[TMP1:%.*]] = xor i64 [[TMP0]], 193514046488576
// CHECK-NEXT:    [[TMP2:%.*]] = inttoptr i64 [[TMP1]] to ptr
// CHECK-NEXT:    call void @llvm.memset.p0.i64(ptr align 8 [[TMP2]], i8 0, i64 24, i1 false)
// CHECK-NEXT:    [[__S1:%.*]] = alloca [[STRUCT_FLOAT16X4X3_T]], align 8
// CHECK-NEXT:    [[TMP3:%.*]] = ptrtoint ptr [[__S1]] to i64
// CHECK-NEXT:    [[TMP4:%.*]] = xor i64 [[TMP3]], 193514046488576
// CHECK-NEXT:    [[TMP5:%.*]] = inttoptr i64 [[TMP4]] to ptr
// CHECK-NEXT:    call void @llvm.memset.p0.i64(ptr align 8 [[TMP5]], i8 0, i64 24, i1 false)
// CHECK-NEXT:    [[COERCE_DIVE:%.*]] = getelementptr inbounds [[STRUCT_FLOAT16X4X3_T]], ptr [[B]], i32 0, i32 0
// CHECK-NEXT:    [[TMP6:%.*]] = ptrtoint ptr [[COERCE_DIVE]] to i64
// CHECK-NEXT:    [[TMP7:%.*]] = xor i64 [[TMP6]], 193514046488576
// CHECK-NEXT:    [[TMP8:%.*]] = inttoptr i64 [[TMP7]] to ptr
// CHECK-NEXT:    store [3 x <4 x i16>] zeroinitializer, ptr [[TMP8]], align 8
// CHECK-NEXT:    store [3 x <4 x half>] [[B_COERCE]], ptr [[COERCE_DIVE]], align 8
// CHECK-NEXT:    [[TMP9:%.*]] = call ptr @__msan_memcpy(ptr [[__S1]], ptr [[B]], i64 24)
// CHECK-NEXT:    [[VAL:%.*]] = getelementptr inbounds [[STRUCT_FLOAT16X4X3_T]], ptr [[__S1]], i32 0, i32 0
// CHECK-NEXT:    [[ARRAYIDX:%.*]] = getelementptr inbounds [3 x <4 x half>], ptr [[VAL]], i64 0, i64 0
// CHECK-NEXT:    [[TMP10:%.*]] = load <4 x half>, ptr [[ARRAYIDX]], align 8
// CHECK-NEXT:    [[TMP11:%.*]] = bitcast <4 x half> [[TMP10]] to <8 x i8>
// CHECK-NEXT:    [[VAL1:%.*]] = getelementptr inbounds [[STRUCT_FLOAT16X4X3_T]], ptr [[__S1]], i32 0, i32 0
// CHECK-NEXT:    [[ARRAYIDX2:%.*]] = getelementptr inbounds [3 x <4 x half>], ptr [[VAL1]], i64 0, i64 1
// CHECK-NEXT:    [[TMP12:%.*]] = load <4 x half>, ptr [[ARRAYIDX2]], align 8
// CHECK-NEXT:    [[TMP13:%.*]] = bitcast <4 x half> [[TMP12]] to <8 x i8>
// CHECK-NEXT:    [[VAL3:%.*]] = getelementptr inbounds [[STRUCT_FLOAT16X4X3_T]], ptr [[__S1]], i32 0, i32 0
// CHECK-NEXT:    [[ARRAYIDX4:%.*]] = getelementptr inbounds [3 x <4 x half>], ptr [[VAL3]], i64 0, i64 2
// CHECK-NEXT:    [[TMP14:%.*]] = load <4 x half>, ptr [[ARRAYIDX4]], align 8
// CHECK-NEXT:    [[TMP15:%.*]] = bitcast <4 x half> [[TMP14]] to <8 x i8>
// CHECK-NEXT:    [[TMP16:%.*]] = bitcast <8 x i8> [[TMP11]] to <4 x half>
// CHECK-NEXT:    [[TMP17:%.*]] = bitcast <8 x i8> [[TMP13]] to <4 x half>
// CHECK-NEXT:    [[TMP18:%.*]] = bitcast <8 x i8> [[TMP15]] to <4 x half>
// CHECK-NEXT:    [[TMP19:%.*]] = ptrtoint ptr [[A]] to i64
// CHECK-NEXT:    [[TMP20:%.*]] = xor i64 [[TMP19]], 193514046488576
// CHECK-NEXT:    [[TMP21:%.*]] = inttoptr i64 [[TMP20]] to ptr
// CHECK-NEXT:    store <12 x i16> zeroinitializer, ptr [[TMP21]], align 1
// CHECK-NEXT:    call void @llvm.aarch64.neon.st3.v4f16.p0(<4 x half> [[TMP16]], <4 x half> [[TMP17]], <4 x half> [[TMP18]], ptr [[A]])
// CHECK-NEXT:    ret void
//
void test_vst3_f16(float16_t *a, float16x4x3_t b) {
  vst3_f16(a, b);
}

// CHECK-LABEL: define dso_local void @test_vst3_f32(
// CHECK-SAME: ptr noundef [[A:%.*]], [3 x <2 x float>] alignstack(8) [[B_COERCE:%.*]]) #[[ATTR0]] {
// CHECK-NEXT:  entry:
// CHECK-NEXT:    call void @llvm.donothing()
// CHECK-NEXT:    [[B:%.*]] = alloca [[STRUCT_FLOAT32X2X3_T:%.*]], align 8
// CHECK-NEXT:    [[TMP0:%.*]] = ptrtoint ptr [[B]] to i64
// CHECK-NEXT:    [[TMP1:%.*]] = xor i64 [[TMP0]], 193514046488576
// CHECK-NEXT:    [[TMP2:%.*]] = inttoptr i64 [[TMP1]] to ptr
// CHECK-NEXT:    call void @llvm.memset.p0.i64(ptr align 8 [[TMP2]], i8 0, i64 24, i1 false)
// CHECK-NEXT:    [[__S1:%.*]] = alloca [[STRUCT_FLOAT32X2X3_T]], align 8
// CHECK-NEXT:    [[TMP3:%.*]] = ptrtoint ptr [[__S1]] to i64
// CHECK-NEXT:    [[TMP4:%.*]] = xor i64 [[TMP3]], 193514046488576
// CHECK-NEXT:    [[TMP5:%.*]] = inttoptr i64 [[TMP4]] to ptr
// CHECK-NEXT:    call void @llvm.memset.p0.i64(ptr align 8 [[TMP5]], i8 0, i64 24, i1 false)
// CHECK-NEXT:    [[COERCE_DIVE:%.*]] = getelementptr inbounds [[STRUCT_FLOAT32X2X3_T]], ptr [[B]], i32 0, i32 0
// CHECK-NEXT:    [[TMP6:%.*]] = ptrtoint ptr [[COERCE_DIVE]] to i64
// CHECK-NEXT:    [[TMP7:%.*]] = xor i64 [[TMP6]], 193514046488576
// CHECK-NEXT:    [[TMP8:%.*]] = inttoptr i64 [[TMP7]] to ptr
// CHECK-NEXT:    store [3 x <2 x i32>] zeroinitializer, ptr [[TMP8]], align 8
// CHECK-NEXT:    store [3 x <2 x float>] [[B_COERCE]], ptr [[COERCE_DIVE]], align 8
// CHECK-NEXT:    [[TMP9:%.*]] = call ptr @__msan_memcpy(ptr [[__S1]], ptr [[B]], i64 24)
// CHECK-NEXT:    [[VAL:%.*]] = getelementptr inbounds [[STRUCT_FLOAT32X2X3_T]], ptr [[__S1]], i32 0, i32 0
// CHECK-NEXT:    [[ARRAYIDX:%.*]] = getelementptr inbounds [3 x <2 x float>], ptr [[VAL]], i64 0, i64 0
// CHECK-NEXT:    [[TMP10:%.*]] = load <2 x float>, ptr [[ARRAYIDX]], align 8
// CHECK-NEXT:    [[TMP11:%.*]] = bitcast <2 x float> [[TMP10]] to <8 x i8>
// CHECK-NEXT:    [[VAL1:%.*]] = getelementptr inbounds [[STRUCT_FLOAT32X2X3_T]], ptr [[__S1]], i32 0, i32 0
// CHECK-NEXT:    [[ARRAYIDX2:%.*]] = getelementptr inbounds [3 x <2 x float>], ptr [[VAL1]], i64 0, i64 1
// CHECK-NEXT:    [[TMP12:%.*]] = load <2 x float>, ptr [[ARRAYIDX2]], align 8
// CHECK-NEXT:    [[TMP13:%.*]] = bitcast <2 x float> [[TMP12]] to <8 x i8>
// CHECK-NEXT:    [[VAL3:%.*]] = getelementptr inbounds [[STRUCT_FLOAT32X2X3_T]], ptr [[__S1]], i32 0, i32 0
// CHECK-NEXT:    [[ARRAYIDX4:%.*]] = getelementptr inbounds [3 x <2 x float>], ptr [[VAL3]], i64 0, i64 2
// CHECK-NEXT:    [[TMP14:%.*]] = load <2 x float>, ptr [[ARRAYIDX4]], align 8
// CHECK-NEXT:    [[TMP15:%.*]] = bitcast <2 x float> [[TMP14]] to <8 x i8>
// CHECK-NEXT:    [[TMP16:%.*]] = bitcast <8 x i8> [[TMP11]] to <2 x float>
// CHECK-NEXT:    [[TMP17:%.*]] = bitcast <8 x i8> [[TMP13]] to <2 x float>
// CHECK-NEXT:    [[TMP18:%.*]] = bitcast <8 x i8> [[TMP15]] to <2 x float>
// CHECK-NEXT:    [[TMP19:%.*]] = ptrtoint ptr [[A]] to i64
// CHECK-NEXT:    [[TMP20:%.*]] = xor i64 [[TMP19]], 193514046488576
// CHECK-NEXT:    [[TMP21:%.*]] = inttoptr i64 [[TMP20]] to ptr
// CHECK-NEXT:    store <6 x i32> zeroinitializer, ptr [[TMP21]], align 1
// CHECK-NEXT:    call void @llvm.aarch64.neon.st3.v2f32.p0(<2 x float> [[TMP16]], <2 x float> [[TMP17]], <2 x float> [[TMP18]], ptr [[A]])
// CHECK-NEXT:    ret void
//
void test_vst3_f32(float32_t *a, float32x2x3_t b) {
  vst3_f32(a, b);
}

// CHECK-LABEL: define dso_local void @test_vst3_f64(
// CHECK-SAME: ptr noundef [[A:%.*]], [3 x <1 x double>] alignstack(8) [[B_COERCE:%.*]]) #[[ATTR0]] {
// CHECK-NEXT:  entry:
// CHECK-NEXT:    call void @llvm.donothing()
// CHECK-NEXT:    [[B:%.*]] = alloca [[STRUCT_FLOAT64X1X3_T:%.*]], align 8
// CHECK-NEXT:    [[TMP0:%.*]] = ptrtoint ptr [[B]] to i64
// CHECK-NEXT:    [[TMP1:%.*]] = xor i64 [[TMP0]], 193514046488576
// CHECK-NEXT:    [[TMP2:%.*]] = inttoptr i64 [[TMP1]] to ptr
// CHECK-NEXT:    call void @llvm.memset.p0.i64(ptr align 8 [[TMP2]], i8 0, i64 24, i1 false)
// CHECK-NEXT:    [[__S1:%.*]] = alloca [[STRUCT_FLOAT64X1X3_T]], align 8
// CHECK-NEXT:    [[TMP3:%.*]] = ptrtoint ptr [[__S1]] to i64
// CHECK-NEXT:    [[TMP4:%.*]] = xor i64 [[TMP3]], 193514046488576
// CHECK-NEXT:    [[TMP5:%.*]] = inttoptr i64 [[TMP4]] to ptr
// CHECK-NEXT:    call void @llvm.memset.p0.i64(ptr align 8 [[TMP5]], i8 0, i64 24, i1 false)
// CHECK-NEXT:    [[COERCE_DIVE:%.*]] = getelementptr inbounds [[STRUCT_FLOAT64X1X3_T]], ptr [[B]], i32 0, i32 0
// CHECK-NEXT:    [[TMP6:%.*]] = ptrtoint ptr [[COERCE_DIVE]] to i64
// CHECK-NEXT:    [[TMP7:%.*]] = xor i64 [[TMP6]], 193514046488576
// CHECK-NEXT:    [[TMP8:%.*]] = inttoptr i64 [[TMP7]] to ptr
// CHECK-NEXT:    store [3 x <1 x i64>] zeroinitializer, ptr [[TMP8]], align 8
// CHECK-NEXT:    store [3 x <1 x double>] [[B_COERCE]], ptr [[COERCE_DIVE]], align 8
// CHECK-NEXT:    [[TMP9:%.*]] = call ptr @__msan_memcpy(ptr [[__S1]], ptr [[B]], i64 24)
// CHECK-NEXT:    [[VAL:%.*]] = getelementptr inbounds [[STRUCT_FLOAT64X1X3_T]], ptr [[__S1]], i32 0, i32 0
// CHECK-NEXT:    [[ARRAYIDX:%.*]] = getelementptr inbounds [3 x <1 x double>], ptr [[VAL]], i64 0, i64 0
// CHECK-NEXT:    [[TMP10:%.*]] = load <1 x double>, ptr [[ARRAYIDX]], align 8
// CHECK-NEXT:    [[TMP11:%.*]] = bitcast <1 x double> [[TMP10]] to <8 x i8>
// CHECK-NEXT:    [[VAL1:%.*]] = getelementptr inbounds [[STRUCT_FLOAT64X1X3_T]], ptr [[__S1]], i32 0, i32 0
// CHECK-NEXT:    [[ARRAYIDX2:%.*]] = getelementptr inbounds [3 x <1 x double>], ptr [[VAL1]], i64 0, i64 1
// CHECK-NEXT:    [[TMP12:%.*]] = load <1 x double>, ptr [[ARRAYIDX2]], align 8
// CHECK-NEXT:    [[TMP13:%.*]] = bitcast <1 x double> [[TMP12]] to <8 x i8>
// CHECK-NEXT:    [[VAL3:%.*]] = getelementptr inbounds [[STRUCT_FLOAT64X1X3_T]], ptr [[__S1]], i32 0, i32 0
// CHECK-NEXT:    [[ARRAYIDX4:%.*]] = getelementptr inbounds [3 x <1 x double>], ptr [[VAL3]], i64 0, i64 2
// CHECK-NEXT:    [[TMP14:%.*]] = load <1 x double>, ptr [[ARRAYIDX4]], align 8
// CHECK-NEXT:    [[TMP15:%.*]] = bitcast <1 x double> [[TMP14]] to <8 x i8>
// CHECK-NEXT:    [[TMP16:%.*]] = bitcast <8 x i8> [[TMP11]] to <1 x double>
// CHECK-NEXT:    [[TMP17:%.*]] = bitcast <8 x i8> [[TMP13]] to <1 x double>
// CHECK-NEXT:    [[TMP18:%.*]] = bitcast <8 x i8> [[TMP15]] to <1 x double>
// CHECK-NEXT:    [[TMP19:%.*]] = ptrtoint ptr [[A]] to i64
// CHECK-NEXT:    [[TMP20:%.*]] = xor i64 [[TMP19]], 193514046488576
// CHECK-NEXT:    [[TMP21:%.*]] = inttoptr i64 [[TMP20]] to ptr
// CHECK-NEXT:    store <3 x i64> zeroinitializer, ptr [[TMP21]], align 1
// CHECK-NEXT:    call void @llvm.aarch64.neon.st3.v1f64.p0(<1 x double> [[TMP16]], <1 x double> [[TMP17]], <1 x double> [[TMP18]], ptr [[A]])
// CHECK-NEXT:    ret void
//
void test_vst3_f64(float64_t *a, float64x1x3_t b) {
  vst3_f64(a, b);
}

// CHECK-LABEL: define dso_local void @test_vst3_p8(
// CHECK-SAME: ptr noundef [[A:%.*]], [3 x <8 x i8>] alignstack(8) [[B_COERCE:%.*]]) #[[ATTR0]] {
// CHECK-NEXT:  entry:
// CHECK-NEXT:    call void @llvm.donothing()
// CHECK-NEXT:    [[B:%.*]] = alloca [[STRUCT_POLY8X8X3_T:%.*]], align 8
// CHECK-NEXT:    [[TMP0:%.*]] = ptrtoint ptr [[B]] to i64
// CHECK-NEXT:    [[TMP1:%.*]] = xor i64 [[TMP0]], 193514046488576
// CHECK-NEXT:    [[TMP2:%.*]] = inttoptr i64 [[TMP1]] to ptr
// CHECK-NEXT:    call void @llvm.memset.p0.i64(ptr align 8 [[TMP2]], i8 0, i64 24, i1 false)
// CHECK-NEXT:    [[__S1:%.*]] = alloca [[STRUCT_POLY8X8X3_T]], align 8
// CHECK-NEXT:    [[TMP3:%.*]] = ptrtoint ptr [[__S1]] to i64
// CHECK-NEXT:    [[TMP4:%.*]] = xor i64 [[TMP3]], 193514046488576
// CHECK-NEXT:    [[TMP5:%.*]] = inttoptr i64 [[TMP4]] to ptr
// CHECK-NEXT:    call void @llvm.memset.p0.i64(ptr align 8 [[TMP5]], i8 0, i64 24, i1 false)
// CHECK-NEXT:    [[COERCE_DIVE:%.*]] = getelementptr inbounds [[STRUCT_POLY8X8X3_T]], ptr [[B]], i32 0, i32 0
// CHECK-NEXT:    [[TMP6:%.*]] = ptrtoint ptr [[COERCE_DIVE]] to i64
// CHECK-NEXT:    [[TMP7:%.*]] = xor i64 [[TMP6]], 193514046488576
// CHECK-NEXT:    [[TMP8:%.*]] = inttoptr i64 [[TMP7]] to ptr
// CHECK-NEXT:    store [3 x <8 x i8>] zeroinitializer, ptr [[TMP8]], align 8
// CHECK-NEXT:    store [3 x <8 x i8>] [[B_COERCE]], ptr [[COERCE_DIVE]], align 8
// CHECK-NEXT:    [[TMP9:%.*]] = call ptr @__msan_memcpy(ptr [[__S1]], ptr [[B]], i64 24)
// CHECK-NEXT:    [[VAL:%.*]] = getelementptr inbounds [[STRUCT_POLY8X8X3_T]], ptr [[__S1]], i32 0, i32 0
// CHECK-NEXT:    [[ARRAYIDX:%.*]] = getelementptr inbounds [3 x <8 x i8>], ptr [[VAL]], i64 0, i64 0
// CHECK-NEXT:    [[TMP10:%.*]] = load <8 x i8>, ptr [[ARRAYIDX]], align 8
// CHECK-NEXT:    [[VAL1:%.*]] = getelementptr inbounds [[STRUCT_POLY8X8X3_T]], ptr [[__S1]], i32 0, i32 0
// CHECK-NEXT:    [[ARRAYIDX2:%.*]] = getelementptr inbounds [3 x <8 x i8>], ptr [[VAL1]], i64 0, i64 1
// CHECK-NEXT:    [[TMP11:%.*]] = load <8 x i8>, ptr [[ARRAYIDX2]], align 8
// CHECK-NEXT:    [[VAL3:%.*]] = getelementptr inbounds [[STRUCT_POLY8X8X3_T]], ptr [[__S1]], i32 0, i32 0
// CHECK-NEXT:    [[ARRAYIDX4:%.*]] = getelementptr inbounds [3 x <8 x i8>], ptr [[VAL3]], i64 0, i64 2
// CHECK-NEXT:    [[TMP12:%.*]] = load <8 x i8>, ptr [[ARRAYIDX4]], align 8
// CHECK-NEXT:    [[TMP13:%.*]] = ptrtoint ptr [[A]] to i64
// CHECK-NEXT:    [[TMP14:%.*]] = xor i64 [[TMP13]], 193514046488576
// CHECK-NEXT:    [[TMP15:%.*]] = inttoptr i64 [[TMP14]] to ptr
// CHECK-NEXT:    store <24 x i8> zeroinitializer, ptr [[TMP15]], align 1
// CHECK-NEXT:    call void @llvm.aarch64.neon.st3.v8i8.p0(<8 x i8> [[TMP10]], <8 x i8> [[TMP11]], <8 x i8> [[TMP12]], ptr [[A]])
// CHECK-NEXT:    ret void
//
void test_vst3_p8(poly8_t *a, poly8x8x3_t b) {
  vst3_p8(a, b);
}

// CHECK-LABEL: define dso_local void @test_vst3_p16(
// CHECK-SAME: ptr noundef [[A:%.*]], [3 x <4 x i16>] alignstack(8) [[B_COERCE:%.*]]) #[[ATTR0]] {
// CHECK-NEXT:  entry:
// CHECK-NEXT:    call void @llvm.donothing()
// CHECK-NEXT:    [[B:%.*]] = alloca [[STRUCT_POLY16X4X3_T:%.*]], align 8
// CHECK-NEXT:    [[TMP0:%.*]] = ptrtoint ptr [[B]] to i64
// CHECK-NEXT:    [[TMP1:%.*]] = xor i64 [[TMP0]], 193514046488576
// CHECK-NEXT:    [[TMP2:%.*]] = inttoptr i64 [[TMP1]] to ptr
// CHECK-NEXT:    call void @llvm.memset.p0.i64(ptr align 8 [[TMP2]], i8 0, i64 24, i1 false)
// CHECK-NEXT:    [[__S1:%.*]] = alloca [[STRUCT_POLY16X4X3_T]], align 8
// CHECK-NEXT:    [[TMP3:%.*]] = ptrtoint ptr [[__S1]] to i64
// CHECK-NEXT:    [[TMP4:%.*]] = xor i64 [[TMP3]], 193514046488576
// CHECK-NEXT:    [[TMP5:%.*]] = inttoptr i64 [[TMP4]] to ptr
// CHECK-NEXT:    call void @llvm.memset.p0.i64(ptr align 8 [[TMP5]], i8 0, i64 24, i1 false)
// CHECK-NEXT:    [[COERCE_DIVE:%.*]] = getelementptr inbounds [[STRUCT_POLY16X4X3_T]], ptr [[B]], i32 0, i32 0
// CHECK-NEXT:    [[TMP6:%.*]] = ptrtoint ptr [[COERCE_DIVE]] to i64
// CHECK-NEXT:    [[TMP7:%.*]] = xor i64 [[TMP6]], 193514046488576
// CHECK-NEXT:    [[TMP8:%.*]] = inttoptr i64 [[TMP7]] to ptr
// CHECK-NEXT:    store [3 x <4 x i16>] zeroinitializer, ptr [[TMP8]], align 8
// CHECK-NEXT:    store [3 x <4 x i16>] [[B_COERCE]], ptr [[COERCE_DIVE]], align 8
// CHECK-NEXT:    [[TMP9:%.*]] = call ptr @__msan_memcpy(ptr [[__S1]], ptr [[B]], i64 24)
// CHECK-NEXT:    [[VAL:%.*]] = getelementptr inbounds [[STRUCT_POLY16X4X3_T]], ptr [[__S1]], i32 0, i32 0
// CHECK-NEXT:    [[ARRAYIDX:%.*]] = getelementptr inbounds [3 x <4 x i16>], ptr [[VAL]], i64 0, i64 0
// CHECK-NEXT:    [[TMP10:%.*]] = load <4 x i16>, ptr [[ARRAYIDX]], align 8
// CHECK-NEXT:    [[TMP11:%.*]] = bitcast <4 x i16> [[TMP10]] to <8 x i8>
// CHECK-NEXT:    [[VAL1:%.*]] = getelementptr inbounds [[STRUCT_POLY16X4X3_T]], ptr [[__S1]], i32 0, i32 0
// CHECK-NEXT:    [[ARRAYIDX2:%.*]] = getelementptr inbounds [3 x <4 x i16>], ptr [[VAL1]], i64 0, i64 1
// CHECK-NEXT:    [[TMP12:%.*]] = load <4 x i16>, ptr [[ARRAYIDX2]], align 8
// CHECK-NEXT:    [[TMP13:%.*]] = bitcast <4 x i16> [[TMP12]] to <8 x i8>
// CHECK-NEXT:    [[VAL3:%.*]] = getelementptr inbounds [[STRUCT_POLY16X4X3_T]], ptr [[__S1]], i32 0, i32 0
// CHECK-NEXT:    [[ARRAYIDX4:%.*]] = getelementptr inbounds [3 x <4 x i16>], ptr [[VAL3]], i64 0, i64 2
// CHECK-NEXT:    [[TMP14:%.*]] = load <4 x i16>, ptr [[ARRAYIDX4]], align 8
// CHECK-NEXT:    [[TMP15:%.*]] = bitcast <4 x i16> [[TMP14]] to <8 x i8>
// CHECK-NEXT:    [[TMP16:%.*]] = bitcast <8 x i8> [[TMP11]] to <4 x i16>
// CHECK-NEXT:    [[TMP17:%.*]] = bitcast <8 x i8> [[TMP13]] to <4 x i16>
// CHECK-NEXT:    [[TMP18:%.*]] = bitcast <8 x i8> [[TMP15]] to <4 x i16>
// CHECK-NEXT:    [[TMP19:%.*]] = ptrtoint ptr [[A]] to i64
// CHECK-NEXT:    [[TMP20:%.*]] = xor i64 [[TMP19]], 193514046488576
// CHECK-NEXT:    [[TMP21:%.*]] = inttoptr i64 [[TMP20]] to ptr
// CHECK-NEXT:    store <12 x i16> zeroinitializer, ptr [[TMP21]], align 1
// CHECK-NEXT:    call void @llvm.aarch64.neon.st3.v4i16.p0(<4 x i16> [[TMP16]], <4 x i16> [[TMP17]], <4 x i16> [[TMP18]], ptr [[A]])
// CHECK-NEXT:    ret void
//
void test_vst3_p16(poly16_t *a, poly16x4x3_t b) {
  vst3_p16(a, b);
}

// CHECK-LABEL: define dso_local void @test_vst4q_u8(
// CHECK-SAME: ptr noundef [[A:%.*]], [4 x <16 x i8>] alignstack(16) [[B_COERCE:%.*]]) #[[ATTR0]] {
// CHECK-NEXT:  entry:
// CHECK-NEXT:    call void @llvm.donothing()
// CHECK-NEXT:    [[B:%.*]] = alloca [[STRUCT_UINT8X16X4_T:%.*]], align 16
// CHECK-NEXT:    [[TMP0:%.*]] = ptrtoint ptr [[B]] to i64
// CHECK-NEXT:    [[TMP1:%.*]] = xor i64 [[TMP0]], 193514046488576
// CHECK-NEXT:    [[TMP2:%.*]] = inttoptr i64 [[TMP1]] to ptr
// CHECK-NEXT:    call void @llvm.memset.p0.i64(ptr align 16 [[TMP2]], i8 0, i64 64, i1 false)
// CHECK-NEXT:    [[__S1:%.*]] = alloca [[STRUCT_UINT8X16X4_T]], align 16
// CHECK-NEXT:    [[TMP3:%.*]] = ptrtoint ptr [[__S1]] to i64
// CHECK-NEXT:    [[TMP4:%.*]] = xor i64 [[TMP3]], 193514046488576
// CHECK-NEXT:    [[TMP5:%.*]] = inttoptr i64 [[TMP4]] to ptr
// CHECK-NEXT:    call void @llvm.memset.p0.i64(ptr align 16 [[TMP5]], i8 0, i64 64, i1 false)
// CHECK-NEXT:    [[COERCE_DIVE:%.*]] = getelementptr inbounds [[STRUCT_UINT8X16X4_T]], ptr [[B]], i32 0, i32 0
// CHECK-NEXT:    [[TMP6:%.*]] = ptrtoint ptr [[COERCE_DIVE]] to i64
// CHECK-NEXT:    [[TMP7:%.*]] = xor i64 [[TMP6]], 193514046488576
// CHECK-NEXT:    [[TMP8:%.*]] = inttoptr i64 [[TMP7]] to ptr
// CHECK-NEXT:    store [4 x <16 x i8>] zeroinitializer, ptr [[TMP8]], align 16
// CHECK-NEXT:    store [4 x <16 x i8>] [[B_COERCE]], ptr [[COERCE_DIVE]], align 16
// CHECK-NEXT:    [[TMP9:%.*]] = call ptr @__msan_memcpy(ptr [[__S1]], ptr [[B]], i64 64)
// CHECK-NEXT:    [[VAL:%.*]] = getelementptr inbounds [[STRUCT_UINT8X16X4_T]], ptr [[__S1]], i32 0, i32 0
// CHECK-NEXT:    [[ARRAYIDX:%.*]] = getelementptr inbounds [4 x <16 x i8>], ptr [[VAL]], i64 0, i64 0
// CHECK-NEXT:    [[TMP10:%.*]] = load <16 x i8>, ptr [[ARRAYIDX]], align 16
// CHECK-NEXT:    [[VAL1:%.*]] = getelementptr inbounds [[STRUCT_UINT8X16X4_T]], ptr [[__S1]], i32 0, i32 0
// CHECK-NEXT:    [[ARRAYIDX2:%.*]] = getelementptr inbounds [4 x <16 x i8>], ptr [[VAL1]], i64 0, i64 1
// CHECK-NEXT:    [[TMP11:%.*]] = load <16 x i8>, ptr [[ARRAYIDX2]], align 16
// CHECK-NEXT:    [[VAL3:%.*]] = getelementptr inbounds [[STRUCT_UINT8X16X4_T]], ptr [[__S1]], i32 0, i32 0
// CHECK-NEXT:    [[ARRAYIDX4:%.*]] = getelementptr inbounds [4 x <16 x i8>], ptr [[VAL3]], i64 0, i64 2
// CHECK-NEXT:    [[TMP12:%.*]] = load <16 x i8>, ptr [[ARRAYIDX4]], align 16
// CHECK-NEXT:    [[VAL5:%.*]] = getelementptr inbounds [[STRUCT_UINT8X16X4_T]], ptr [[__S1]], i32 0, i32 0
// CHECK-NEXT:    [[ARRAYIDX6:%.*]] = getelementptr inbounds [4 x <16 x i8>], ptr [[VAL5]], i64 0, i64 3
// CHECK-NEXT:    [[TMP13:%.*]] = load <16 x i8>, ptr [[ARRAYIDX6]], align 16
// CHECK-NEXT:    [[TMP14:%.*]] = ptrtoint ptr [[A]] to i64
// CHECK-NEXT:    [[TMP15:%.*]] = xor i64 [[TMP14]], 193514046488576
// CHECK-NEXT:    [[TMP16:%.*]] = inttoptr i64 [[TMP15]] to ptr
// CHECK-NEXT:    store <64 x i8> zeroinitializer, ptr [[TMP16]], align 1
// CHECK-NEXT:    call void @llvm.aarch64.neon.st4.v16i8.p0(<16 x i8> [[TMP10]], <16 x i8> [[TMP11]], <16 x i8> [[TMP12]], <16 x i8> [[TMP13]], ptr [[A]])
// CHECK-NEXT:    ret void
//
void test_vst4q_u8(uint8_t *a, uint8x16x4_t b) {
  vst4q_u8(a, b);
}

// CHECK-LABEL: define dso_local void @test_vst4q_u16(
// CHECK-SAME: ptr noundef [[A:%.*]], [4 x <8 x i16>] alignstack(16) [[B_COERCE:%.*]]) #[[ATTR0]] {
// CHECK-NEXT:  entry:
// CHECK-NEXT:    call void @llvm.donothing()
// CHECK-NEXT:    [[B:%.*]] = alloca [[STRUCT_UINT16X8X4_T:%.*]], align 16
// CHECK-NEXT:    [[TMP0:%.*]] = ptrtoint ptr [[B]] to i64
// CHECK-NEXT:    [[TMP1:%.*]] = xor i64 [[TMP0]], 193514046488576
// CHECK-NEXT:    [[TMP2:%.*]] = inttoptr i64 [[TMP1]] to ptr
// CHECK-NEXT:    call void @llvm.memset.p0.i64(ptr align 16 [[TMP2]], i8 0, i64 64, i1 false)
// CHECK-NEXT:    [[__S1:%.*]] = alloca [[STRUCT_UINT16X8X4_T]], align 16
// CHECK-NEXT:    [[TMP3:%.*]] = ptrtoint ptr [[__S1]] to i64
// CHECK-NEXT:    [[TMP4:%.*]] = xor i64 [[TMP3]], 193514046488576
// CHECK-NEXT:    [[TMP5:%.*]] = inttoptr i64 [[TMP4]] to ptr
// CHECK-NEXT:    call void @llvm.memset.p0.i64(ptr align 16 [[TMP5]], i8 0, i64 64, i1 false)
// CHECK-NEXT:    [[COERCE_DIVE:%.*]] = getelementptr inbounds [[STRUCT_UINT16X8X4_T]], ptr [[B]], i32 0, i32 0
// CHECK-NEXT:    [[TMP6:%.*]] = ptrtoint ptr [[COERCE_DIVE]] to i64
// CHECK-NEXT:    [[TMP7:%.*]] = xor i64 [[TMP6]], 193514046488576
// CHECK-NEXT:    [[TMP8:%.*]] = inttoptr i64 [[TMP7]] to ptr
// CHECK-NEXT:    store [4 x <8 x i16>] zeroinitializer, ptr [[TMP8]], align 16
// CHECK-NEXT:    store [4 x <8 x i16>] [[B_COERCE]], ptr [[COERCE_DIVE]], align 16
// CHECK-NEXT:    [[TMP9:%.*]] = call ptr @__msan_memcpy(ptr [[__S1]], ptr [[B]], i64 64)
// CHECK-NEXT:    [[VAL:%.*]] = getelementptr inbounds [[STRUCT_UINT16X8X4_T]], ptr [[__S1]], i32 0, i32 0
// CHECK-NEXT:    [[ARRAYIDX:%.*]] = getelementptr inbounds [4 x <8 x i16>], ptr [[VAL]], i64 0, i64 0
// CHECK-NEXT:    [[TMP10:%.*]] = load <8 x i16>, ptr [[ARRAYIDX]], align 16
// CHECK-NEXT:    [[TMP11:%.*]] = bitcast <8 x i16> [[TMP10]] to <16 x i8>
// CHECK-NEXT:    [[VAL1:%.*]] = getelementptr inbounds [[STRUCT_UINT16X8X4_T]], ptr [[__S1]], i32 0, i32 0
// CHECK-NEXT:    [[ARRAYIDX2:%.*]] = getelementptr inbounds [4 x <8 x i16>], ptr [[VAL1]], i64 0, i64 1
// CHECK-NEXT:    [[TMP12:%.*]] = load <8 x i16>, ptr [[ARRAYIDX2]], align 16
// CHECK-NEXT:    [[TMP13:%.*]] = bitcast <8 x i16> [[TMP12]] to <16 x i8>
// CHECK-NEXT:    [[VAL3:%.*]] = getelementptr inbounds [[STRUCT_UINT16X8X4_T]], ptr [[__S1]], i32 0, i32 0
// CHECK-NEXT:    [[ARRAYIDX4:%.*]] = getelementptr inbounds [4 x <8 x i16>], ptr [[VAL3]], i64 0, i64 2
// CHECK-NEXT:    [[TMP14:%.*]] = load <8 x i16>, ptr [[ARRAYIDX4]], align 16
// CHECK-NEXT:    [[TMP15:%.*]] = bitcast <8 x i16> [[TMP14]] to <16 x i8>
// CHECK-NEXT:    [[VAL5:%.*]] = getelementptr inbounds [[STRUCT_UINT16X8X4_T]], ptr [[__S1]], i32 0, i32 0
// CHECK-NEXT:    [[ARRAYIDX6:%.*]] = getelementptr inbounds [4 x <8 x i16>], ptr [[VAL5]], i64 0, i64 3
// CHECK-NEXT:    [[TMP16:%.*]] = load <8 x i16>, ptr [[ARRAYIDX6]], align 16
// CHECK-NEXT:    [[TMP17:%.*]] = bitcast <8 x i16> [[TMP16]] to <16 x i8>
// CHECK-NEXT:    [[TMP18:%.*]] = bitcast <16 x i8> [[TMP11]] to <8 x i16>
// CHECK-NEXT:    [[TMP19:%.*]] = bitcast <16 x i8> [[TMP13]] to <8 x i16>
// CHECK-NEXT:    [[TMP20:%.*]] = bitcast <16 x i8> [[TMP15]] to <8 x i16>
// CHECK-NEXT:    [[TMP21:%.*]] = bitcast <16 x i8> [[TMP17]] to <8 x i16>
// CHECK-NEXT:    [[TMP22:%.*]] = ptrtoint ptr [[A]] to i64
// CHECK-NEXT:    [[TMP23:%.*]] = xor i64 [[TMP22]], 193514046488576
// CHECK-NEXT:    [[TMP24:%.*]] = inttoptr i64 [[TMP23]] to ptr
// CHECK-NEXT:    store <32 x i16> zeroinitializer, ptr [[TMP24]], align 1
// CHECK-NEXT:    call void @llvm.aarch64.neon.st4.v8i16.p0(<8 x i16> [[TMP18]], <8 x i16> [[TMP19]], <8 x i16> [[TMP20]], <8 x i16> [[TMP21]], ptr [[A]])
// CHECK-NEXT:    ret void
//
void test_vst4q_u16(uint16_t *a, uint16x8x4_t b) {
  vst4q_u16(a, b);
}

// CHECK-LABEL: define dso_local void @test_vst4q_u32(
// CHECK-SAME: ptr noundef [[A:%.*]], [4 x <4 x i32>] alignstack(16) [[B_COERCE:%.*]]) #[[ATTR0]] {
// CHECK-NEXT:  entry:
// CHECK-NEXT:    call void @llvm.donothing()
// CHECK-NEXT:    [[B:%.*]] = alloca [[STRUCT_UINT32X4X4_T:%.*]], align 16
// CHECK-NEXT:    [[TMP0:%.*]] = ptrtoint ptr [[B]] to i64
// CHECK-NEXT:    [[TMP1:%.*]] = xor i64 [[TMP0]], 193514046488576
// CHECK-NEXT:    [[TMP2:%.*]] = inttoptr i64 [[TMP1]] to ptr
// CHECK-NEXT:    call void @llvm.memset.p0.i64(ptr align 16 [[TMP2]], i8 0, i64 64, i1 false)
// CHECK-NEXT:    [[__S1:%.*]] = alloca [[STRUCT_UINT32X4X4_T]], align 16
// CHECK-NEXT:    [[TMP3:%.*]] = ptrtoint ptr [[__S1]] to i64
// CHECK-NEXT:    [[TMP4:%.*]] = xor i64 [[TMP3]], 193514046488576
// CHECK-NEXT:    [[TMP5:%.*]] = inttoptr i64 [[TMP4]] to ptr
// CHECK-NEXT:    call void @llvm.memset.p0.i64(ptr align 16 [[TMP5]], i8 0, i64 64, i1 false)
// CHECK-NEXT:    [[COERCE_DIVE:%.*]] = getelementptr inbounds [[STRUCT_UINT32X4X4_T]], ptr [[B]], i32 0, i32 0
// CHECK-NEXT:    [[TMP6:%.*]] = ptrtoint ptr [[COERCE_DIVE]] to i64
// CHECK-NEXT:    [[TMP7:%.*]] = xor i64 [[TMP6]], 193514046488576
// CHECK-NEXT:    [[TMP8:%.*]] = inttoptr i64 [[TMP7]] to ptr
// CHECK-NEXT:    store [4 x <4 x i32>] zeroinitializer, ptr [[TMP8]], align 16
// CHECK-NEXT:    store [4 x <4 x i32>] [[B_COERCE]], ptr [[COERCE_DIVE]], align 16
// CHECK-NEXT:    [[TMP9:%.*]] = call ptr @__msan_memcpy(ptr [[__S1]], ptr [[B]], i64 64)
// CHECK-NEXT:    [[VAL:%.*]] = getelementptr inbounds [[STRUCT_UINT32X4X4_T]], ptr [[__S1]], i32 0, i32 0
// CHECK-NEXT:    [[ARRAYIDX:%.*]] = getelementptr inbounds [4 x <4 x i32>], ptr [[VAL]], i64 0, i64 0
// CHECK-NEXT:    [[TMP10:%.*]] = load <4 x i32>, ptr [[ARRAYIDX]], align 16
// CHECK-NEXT:    [[TMP11:%.*]] = bitcast <4 x i32> [[TMP10]] to <16 x i8>
// CHECK-NEXT:    [[VAL1:%.*]] = getelementptr inbounds [[STRUCT_UINT32X4X4_T]], ptr [[__S1]], i32 0, i32 0
// CHECK-NEXT:    [[ARRAYIDX2:%.*]] = getelementptr inbounds [4 x <4 x i32>], ptr [[VAL1]], i64 0, i64 1
// CHECK-NEXT:    [[TMP12:%.*]] = load <4 x i32>, ptr [[ARRAYIDX2]], align 16
// CHECK-NEXT:    [[TMP13:%.*]] = bitcast <4 x i32> [[TMP12]] to <16 x i8>
// CHECK-NEXT:    [[VAL3:%.*]] = getelementptr inbounds [[STRUCT_UINT32X4X4_T]], ptr [[__S1]], i32 0, i32 0
// CHECK-NEXT:    [[ARRAYIDX4:%.*]] = getelementptr inbounds [4 x <4 x i32>], ptr [[VAL3]], i64 0, i64 2
// CHECK-NEXT:    [[TMP14:%.*]] = load <4 x i32>, ptr [[ARRAYIDX4]], align 16
// CHECK-NEXT:    [[TMP15:%.*]] = bitcast <4 x i32> [[TMP14]] to <16 x i8>
// CHECK-NEXT:    [[VAL5:%.*]] = getelementptr inbounds [[STRUCT_UINT32X4X4_T]], ptr [[__S1]], i32 0, i32 0
// CHECK-NEXT:    [[ARRAYIDX6:%.*]] = getelementptr inbounds [4 x <4 x i32>], ptr [[VAL5]], i64 0, i64 3
// CHECK-NEXT:    [[TMP16:%.*]] = load <4 x i32>, ptr [[ARRAYIDX6]], align 16
// CHECK-NEXT:    [[TMP17:%.*]] = bitcast <4 x i32> [[TMP16]] to <16 x i8>
// CHECK-NEXT:    [[TMP18:%.*]] = bitcast <16 x i8> [[TMP11]] to <4 x i32>
// CHECK-NEXT:    [[TMP19:%.*]] = bitcast <16 x i8> [[TMP13]] to <4 x i32>
// CHECK-NEXT:    [[TMP20:%.*]] = bitcast <16 x i8> [[TMP15]] to <4 x i32>
// CHECK-NEXT:    [[TMP21:%.*]] = bitcast <16 x i8> [[TMP17]] to <4 x i32>
// CHECK-NEXT:    [[TMP22:%.*]] = ptrtoint ptr [[A]] to i64
// CHECK-NEXT:    [[TMP23:%.*]] = xor i64 [[TMP22]], 193514046488576
// CHECK-NEXT:    [[TMP24:%.*]] = inttoptr i64 [[TMP23]] to ptr
// CHECK-NEXT:    store <16 x i32> zeroinitializer, ptr [[TMP24]], align 1
// CHECK-NEXT:    call void @llvm.aarch64.neon.st4.v4i32.p0(<4 x i32> [[TMP18]], <4 x i32> [[TMP19]], <4 x i32> [[TMP20]], <4 x i32> [[TMP21]], ptr [[A]])
// CHECK-NEXT:    ret void
//
void test_vst4q_u32(uint32_t *a, uint32x4x4_t b) {
  vst4q_u32(a, b);
}

// CHECK-LABEL: define dso_local void @test_vst4q_u64(
// CHECK-SAME: ptr noundef [[A:%.*]], [4 x <2 x i64>] alignstack(16) [[B_COERCE:%.*]]) #[[ATTR0]] {
// CHECK-NEXT:  entry:
// CHECK-NEXT:    call void @llvm.donothing()
// CHECK-NEXT:    [[B:%.*]] = alloca [[STRUCT_UINT64X2X4_T:%.*]], align 16
// CHECK-NEXT:    [[TMP0:%.*]] = ptrtoint ptr [[B]] to i64
// CHECK-NEXT:    [[TMP1:%.*]] = xor i64 [[TMP0]], 193514046488576
// CHECK-NEXT:    [[TMP2:%.*]] = inttoptr i64 [[TMP1]] to ptr
// CHECK-NEXT:    call void @llvm.memset.p0.i64(ptr align 16 [[TMP2]], i8 0, i64 64, i1 false)
// CHECK-NEXT:    [[__S1:%.*]] = alloca [[STRUCT_UINT64X2X4_T]], align 16
// CHECK-NEXT:    [[TMP3:%.*]] = ptrtoint ptr [[__S1]] to i64
// CHECK-NEXT:    [[TMP4:%.*]] = xor i64 [[TMP3]], 193514046488576
// CHECK-NEXT:    [[TMP5:%.*]] = inttoptr i64 [[TMP4]] to ptr
// CHECK-NEXT:    call void @llvm.memset.p0.i64(ptr align 16 [[TMP5]], i8 0, i64 64, i1 false)
// CHECK-NEXT:    [[COERCE_DIVE:%.*]] = getelementptr inbounds [[STRUCT_UINT64X2X4_T]], ptr [[B]], i32 0, i32 0
// CHECK-NEXT:    [[TMP6:%.*]] = ptrtoint ptr [[COERCE_DIVE]] to i64
// CHECK-NEXT:    [[TMP7:%.*]] = xor i64 [[TMP6]], 193514046488576
// CHECK-NEXT:    [[TMP8:%.*]] = inttoptr i64 [[TMP7]] to ptr
// CHECK-NEXT:    store [4 x <2 x i64>] zeroinitializer, ptr [[TMP8]], align 16
// CHECK-NEXT:    store [4 x <2 x i64>] [[B_COERCE]], ptr [[COERCE_DIVE]], align 16
// CHECK-NEXT:    [[TMP9:%.*]] = call ptr @__msan_memcpy(ptr [[__S1]], ptr [[B]], i64 64)
// CHECK-NEXT:    [[VAL:%.*]] = getelementptr inbounds [[STRUCT_UINT64X2X4_T]], ptr [[__S1]], i32 0, i32 0
// CHECK-NEXT:    [[ARRAYIDX:%.*]] = getelementptr inbounds [4 x <2 x i64>], ptr [[VAL]], i64 0, i64 0
// CHECK-NEXT:    [[TMP10:%.*]] = load <2 x i64>, ptr [[ARRAYIDX]], align 16
// CHECK-NEXT:    [[TMP11:%.*]] = bitcast <2 x i64> [[TMP10]] to <16 x i8>
// CHECK-NEXT:    [[VAL1:%.*]] = getelementptr inbounds [[STRUCT_UINT64X2X4_T]], ptr [[__S1]], i32 0, i32 0
// CHECK-NEXT:    [[ARRAYIDX2:%.*]] = getelementptr inbounds [4 x <2 x i64>], ptr [[VAL1]], i64 0, i64 1
// CHECK-NEXT:    [[TMP12:%.*]] = load <2 x i64>, ptr [[ARRAYIDX2]], align 16
// CHECK-NEXT:    [[TMP13:%.*]] = bitcast <2 x i64> [[TMP12]] to <16 x i8>
// CHECK-NEXT:    [[VAL3:%.*]] = getelementptr inbounds [[STRUCT_UINT64X2X4_T]], ptr [[__S1]], i32 0, i32 0
// CHECK-NEXT:    [[ARRAYIDX4:%.*]] = getelementptr inbounds [4 x <2 x i64>], ptr [[VAL3]], i64 0, i64 2
// CHECK-NEXT:    [[TMP14:%.*]] = load <2 x i64>, ptr [[ARRAYIDX4]], align 16
// CHECK-NEXT:    [[TMP15:%.*]] = bitcast <2 x i64> [[TMP14]] to <16 x i8>
// CHECK-NEXT:    [[VAL5:%.*]] = getelementptr inbounds [[STRUCT_UINT64X2X4_T]], ptr [[__S1]], i32 0, i32 0
// CHECK-NEXT:    [[ARRAYIDX6:%.*]] = getelementptr inbounds [4 x <2 x i64>], ptr [[VAL5]], i64 0, i64 3
// CHECK-NEXT:    [[TMP16:%.*]] = load <2 x i64>, ptr [[ARRAYIDX6]], align 16
// CHECK-NEXT:    [[TMP17:%.*]] = bitcast <2 x i64> [[TMP16]] to <16 x i8>
// CHECK-NEXT:    [[TMP18:%.*]] = bitcast <16 x i8> [[TMP11]] to <2 x i64>
// CHECK-NEXT:    [[TMP19:%.*]] = bitcast <16 x i8> [[TMP13]] to <2 x i64>
// CHECK-NEXT:    [[TMP20:%.*]] = bitcast <16 x i8> [[TMP15]] to <2 x i64>
// CHECK-NEXT:    [[TMP21:%.*]] = bitcast <16 x i8> [[TMP17]] to <2 x i64>
// CHECK-NEXT:    [[TMP22:%.*]] = ptrtoint ptr [[A]] to i64
// CHECK-NEXT:    [[TMP23:%.*]] = xor i64 [[TMP22]], 193514046488576
// CHECK-NEXT:    [[TMP24:%.*]] = inttoptr i64 [[TMP23]] to ptr
// CHECK-NEXT:    store <8 x i64> zeroinitializer, ptr [[TMP24]], align 1
// CHECK-NEXT:    call void @llvm.aarch64.neon.st4.v2i64.p0(<2 x i64> [[TMP18]], <2 x i64> [[TMP19]], <2 x i64> [[TMP20]], <2 x i64> [[TMP21]], ptr [[A]])
// CHECK-NEXT:    ret void
//
void test_vst4q_u64(uint64_t *a, uint64x2x4_t b) {
  vst4q_u64(a, b);
}

// CHECK-LABEL: define dso_local void @test_vst4q_s8(
// CHECK-SAME: ptr noundef [[A:%.*]], [4 x <16 x i8>] alignstack(16) [[B_COERCE:%.*]]) #[[ATTR0]] {
// CHECK-NEXT:  entry:
// CHECK-NEXT:    call void @llvm.donothing()
// CHECK-NEXT:    [[B:%.*]] = alloca [[STRUCT_INT8X16X4_T:%.*]], align 16
// CHECK-NEXT:    [[TMP0:%.*]] = ptrtoint ptr [[B]] to i64
// CHECK-NEXT:    [[TMP1:%.*]] = xor i64 [[TMP0]], 193514046488576
// CHECK-NEXT:    [[TMP2:%.*]] = inttoptr i64 [[TMP1]] to ptr
// CHECK-NEXT:    call void @llvm.memset.p0.i64(ptr align 16 [[TMP2]], i8 0, i64 64, i1 false)
// CHECK-NEXT:    [[__S1:%.*]] = alloca [[STRUCT_INT8X16X4_T]], align 16
// CHECK-NEXT:    [[TMP3:%.*]] = ptrtoint ptr [[__S1]] to i64
// CHECK-NEXT:    [[TMP4:%.*]] = xor i64 [[TMP3]], 193514046488576
// CHECK-NEXT:    [[TMP5:%.*]] = inttoptr i64 [[TMP4]] to ptr
// CHECK-NEXT:    call void @llvm.memset.p0.i64(ptr align 16 [[TMP5]], i8 0, i64 64, i1 false)
// CHECK-NEXT:    [[COERCE_DIVE:%.*]] = getelementptr inbounds [[STRUCT_INT8X16X4_T]], ptr [[B]], i32 0, i32 0
// CHECK-NEXT:    [[TMP6:%.*]] = ptrtoint ptr [[COERCE_DIVE]] to i64
// CHECK-NEXT:    [[TMP7:%.*]] = xor i64 [[TMP6]], 193514046488576
// CHECK-NEXT:    [[TMP8:%.*]] = inttoptr i64 [[TMP7]] to ptr
// CHECK-NEXT:    store [4 x <16 x i8>] zeroinitializer, ptr [[TMP8]], align 16
// CHECK-NEXT:    store [4 x <16 x i8>] [[B_COERCE]], ptr [[COERCE_DIVE]], align 16
// CHECK-NEXT:    [[TMP9:%.*]] = call ptr @__msan_memcpy(ptr [[__S1]], ptr [[B]], i64 64)
// CHECK-NEXT:    [[VAL:%.*]] = getelementptr inbounds [[STRUCT_INT8X16X4_T]], ptr [[__S1]], i32 0, i32 0
// CHECK-NEXT:    [[ARRAYIDX:%.*]] = getelementptr inbounds [4 x <16 x i8>], ptr [[VAL]], i64 0, i64 0
// CHECK-NEXT:    [[TMP10:%.*]] = load <16 x i8>, ptr [[ARRAYIDX]], align 16
// CHECK-NEXT:    [[VAL1:%.*]] = getelementptr inbounds [[STRUCT_INT8X16X4_T]], ptr [[__S1]], i32 0, i32 0
// CHECK-NEXT:    [[ARRAYIDX2:%.*]] = getelementptr inbounds [4 x <16 x i8>], ptr [[VAL1]], i64 0, i64 1
// CHECK-NEXT:    [[TMP11:%.*]] = load <16 x i8>, ptr [[ARRAYIDX2]], align 16
// CHECK-NEXT:    [[VAL3:%.*]] = getelementptr inbounds [[STRUCT_INT8X16X4_T]], ptr [[__S1]], i32 0, i32 0
// CHECK-NEXT:    [[ARRAYIDX4:%.*]] = getelementptr inbounds [4 x <16 x i8>], ptr [[VAL3]], i64 0, i64 2
// CHECK-NEXT:    [[TMP12:%.*]] = load <16 x i8>, ptr [[ARRAYIDX4]], align 16
// CHECK-NEXT:    [[VAL5:%.*]] = getelementptr inbounds [[STRUCT_INT8X16X4_T]], ptr [[__S1]], i32 0, i32 0
// CHECK-NEXT:    [[ARRAYIDX6:%.*]] = getelementptr inbounds [4 x <16 x i8>], ptr [[VAL5]], i64 0, i64 3
// CHECK-NEXT:    [[TMP13:%.*]] = load <16 x i8>, ptr [[ARRAYIDX6]], align 16
// CHECK-NEXT:    [[TMP14:%.*]] = ptrtoint ptr [[A]] to i64
// CHECK-NEXT:    [[TMP15:%.*]] = xor i64 [[TMP14]], 193514046488576
// CHECK-NEXT:    [[TMP16:%.*]] = inttoptr i64 [[TMP15]] to ptr
// CHECK-NEXT:    store <64 x i8> zeroinitializer, ptr [[TMP16]], align 1
// CHECK-NEXT:    call void @llvm.aarch64.neon.st4.v16i8.p0(<16 x i8> [[TMP10]], <16 x i8> [[TMP11]], <16 x i8> [[TMP12]], <16 x i8> [[TMP13]], ptr [[A]])
// CHECK-NEXT:    ret void
//
void test_vst4q_s8(int8_t *a, int8x16x4_t b) {
  vst4q_s8(a, b);
}

// CHECK-LABEL: define dso_local void @test_vst4q_s16(
// CHECK-SAME: ptr noundef [[A:%.*]], [4 x <8 x i16>] alignstack(16) [[B_COERCE:%.*]]) #[[ATTR0]] {
// CHECK-NEXT:  entry:
// CHECK-NEXT:    call void @llvm.donothing()
// CHECK-NEXT:    [[B:%.*]] = alloca [[STRUCT_INT16X8X4_T:%.*]], align 16
// CHECK-NEXT:    [[TMP0:%.*]] = ptrtoint ptr [[B]] to i64
// CHECK-NEXT:    [[TMP1:%.*]] = xor i64 [[TMP0]], 193514046488576
// CHECK-NEXT:    [[TMP2:%.*]] = inttoptr i64 [[TMP1]] to ptr
// CHECK-NEXT:    call void @llvm.memset.p0.i64(ptr align 16 [[TMP2]], i8 0, i64 64, i1 false)
// CHECK-NEXT:    [[__S1:%.*]] = alloca [[STRUCT_INT16X8X4_T]], align 16
// CHECK-NEXT:    [[TMP3:%.*]] = ptrtoint ptr [[__S1]] to i64
// CHECK-NEXT:    [[TMP4:%.*]] = xor i64 [[TMP3]], 193514046488576
// CHECK-NEXT:    [[TMP5:%.*]] = inttoptr i64 [[TMP4]] to ptr
// CHECK-NEXT:    call void @llvm.memset.p0.i64(ptr align 16 [[TMP5]], i8 0, i64 64, i1 false)
// CHECK-NEXT:    [[COERCE_DIVE:%.*]] = getelementptr inbounds [[STRUCT_INT16X8X4_T]], ptr [[B]], i32 0, i32 0
// CHECK-NEXT:    [[TMP6:%.*]] = ptrtoint ptr [[COERCE_DIVE]] to i64
// CHECK-NEXT:    [[TMP7:%.*]] = xor i64 [[TMP6]], 193514046488576
// CHECK-NEXT:    [[TMP8:%.*]] = inttoptr i64 [[TMP7]] to ptr
// CHECK-NEXT:    store [4 x <8 x i16>] zeroinitializer, ptr [[TMP8]], align 16
// CHECK-NEXT:    store [4 x <8 x i16>] [[B_COERCE]], ptr [[COERCE_DIVE]], align 16
// CHECK-NEXT:    [[TMP9:%.*]] = call ptr @__msan_memcpy(ptr [[__S1]], ptr [[B]], i64 64)
// CHECK-NEXT:    [[VAL:%.*]] = getelementptr inbounds [[STRUCT_INT16X8X4_T]], ptr [[__S1]], i32 0, i32 0
// CHECK-NEXT:    [[ARRAYIDX:%.*]] = getelementptr inbounds [4 x <8 x i16>], ptr [[VAL]], i64 0, i64 0
// CHECK-NEXT:    [[TMP10:%.*]] = load <8 x i16>, ptr [[ARRAYIDX]], align 16
// CHECK-NEXT:    [[TMP11:%.*]] = bitcast <8 x i16> [[TMP10]] to <16 x i8>
// CHECK-NEXT:    [[VAL1:%.*]] = getelementptr inbounds [[STRUCT_INT16X8X4_T]], ptr [[__S1]], i32 0, i32 0
// CHECK-NEXT:    [[ARRAYIDX2:%.*]] = getelementptr inbounds [4 x <8 x i16>], ptr [[VAL1]], i64 0, i64 1
// CHECK-NEXT:    [[TMP12:%.*]] = load <8 x i16>, ptr [[ARRAYIDX2]], align 16
// CHECK-NEXT:    [[TMP13:%.*]] = bitcast <8 x i16> [[TMP12]] to <16 x i8>
// CHECK-NEXT:    [[VAL3:%.*]] = getelementptr inbounds [[STRUCT_INT16X8X4_T]], ptr [[__S1]], i32 0, i32 0
// CHECK-NEXT:    [[ARRAYIDX4:%.*]] = getelementptr inbounds [4 x <8 x i16>], ptr [[VAL3]], i64 0, i64 2
// CHECK-NEXT:    [[TMP14:%.*]] = load <8 x i16>, ptr [[ARRAYIDX4]], align 16
// CHECK-NEXT:    [[TMP15:%.*]] = bitcast <8 x i16> [[TMP14]] to <16 x i8>
// CHECK-NEXT:    [[VAL5:%.*]] = getelementptr inbounds [[STRUCT_INT16X8X4_T]], ptr [[__S1]], i32 0, i32 0
// CHECK-NEXT:    [[ARRAYIDX6:%.*]] = getelementptr inbounds [4 x <8 x i16>], ptr [[VAL5]], i64 0, i64 3
// CHECK-NEXT:    [[TMP16:%.*]] = load <8 x i16>, ptr [[ARRAYIDX6]], align 16
// CHECK-NEXT:    [[TMP17:%.*]] = bitcast <8 x i16> [[TMP16]] to <16 x i8>
// CHECK-NEXT:    [[TMP18:%.*]] = bitcast <16 x i8> [[TMP11]] to <8 x i16>
// CHECK-NEXT:    [[TMP19:%.*]] = bitcast <16 x i8> [[TMP13]] to <8 x i16>
// CHECK-NEXT:    [[TMP20:%.*]] = bitcast <16 x i8> [[TMP15]] to <8 x i16>
// CHECK-NEXT:    [[TMP21:%.*]] = bitcast <16 x i8> [[TMP17]] to <8 x i16>
// CHECK-NEXT:    [[TMP22:%.*]] = ptrtoint ptr [[A]] to i64
// CHECK-NEXT:    [[TMP23:%.*]] = xor i64 [[TMP22]], 193514046488576
// CHECK-NEXT:    [[TMP24:%.*]] = inttoptr i64 [[TMP23]] to ptr
// CHECK-NEXT:    store <32 x i16> zeroinitializer, ptr [[TMP24]], align 1
// CHECK-NEXT:    call void @llvm.aarch64.neon.st4.v8i16.p0(<8 x i16> [[TMP18]], <8 x i16> [[TMP19]], <8 x i16> [[TMP20]], <8 x i16> [[TMP21]], ptr [[A]])
// CHECK-NEXT:    ret void
//
void test_vst4q_s16(int16_t *a, int16x8x4_t b) {
  vst4q_s16(a, b);
}

// CHECK-LABEL: define dso_local void @test_vst4q_s32(
// CHECK-SAME: ptr noundef [[A:%.*]], [4 x <4 x i32>] alignstack(16) [[B_COERCE:%.*]]) #[[ATTR0]] {
// CHECK-NEXT:  entry:
// CHECK-NEXT:    call void @llvm.donothing()
// CHECK-NEXT:    [[B:%.*]] = alloca [[STRUCT_INT32X4X4_T:%.*]], align 16
// CHECK-NEXT:    [[TMP0:%.*]] = ptrtoint ptr [[B]] to i64
// CHECK-NEXT:    [[TMP1:%.*]] = xor i64 [[TMP0]], 193514046488576
// CHECK-NEXT:    [[TMP2:%.*]] = inttoptr i64 [[TMP1]] to ptr
// CHECK-NEXT:    call void @llvm.memset.p0.i64(ptr align 16 [[TMP2]], i8 0, i64 64, i1 false)
// CHECK-NEXT:    [[__S1:%.*]] = alloca [[STRUCT_INT32X4X4_T]], align 16
// CHECK-NEXT:    [[TMP3:%.*]] = ptrtoint ptr [[__S1]] to i64
// CHECK-NEXT:    [[TMP4:%.*]] = xor i64 [[TMP3]], 193514046488576
// CHECK-NEXT:    [[TMP5:%.*]] = inttoptr i64 [[TMP4]] to ptr
// CHECK-NEXT:    call void @llvm.memset.p0.i64(ptr align 16 [[TMP5]], i8 0, i64 64, i1 false)
// CHECK-NEXT:    [[COERCE_DIVE:%.*]] = getelementptr inbounds [[STRUCT_INT32X4X4_T]], ptr [[B]], i32 0, i32 0
// CHECK-NEXT:    [[TMP6:%.*]] = ptrtoint ptr [[COERCE_DIVE]] to i64
// CHECK-NEXT:    [[TMP7:%.*]] = xor i64 [[TMP6]], 193514046488576
// CHECK-NEXT:    [[TMP8:%.*]] = inttoptr i64 [[TMP7]] to ptr
// CHECK-NEXT:    store [4 x <4 x i32>] zeroinitializer, ptr [[TMP8]], align 16
// CHECK-NEXT:    store [4 x <4 x i32>] [[B_COERCE]], ptr [[COERCE_DIVE]], align 16
// CHECK-NEXT:    [[TMP9:%.*]] = call ptr @__msan_memcpy(ptr [[__S1]], ptr [[B]], i64 64)
// CHECK-NEXT:    [[VAL:%.*]] = getelementptr inbounds [[STRUCT_INT32X4X4_T]], ptr [[__S1]], i32 0, i32 0
// CHECK-NEXT:    [[ARRAYIDX:%.*]] = getelementptr inbounds [4 x <4 x i32>], ptr [[VAL]], i64 0, i64 0
// CHECK-NEXT:    [[TMP10:%.*]] = load <4 x i32>, ptr [[ARRAYIDX]], align 16
// CHECK-NEXT:    [[TMP11:%.*]] = bitcast <4 x i32> [[TMP10]] to <16 x i8>
// CHECK-NEXT:    [[VAL1:%.*]] = getelementptr inbounds [[STRUCT_INT32X4X4_T]], ptr [[__S1]], i32 0, i32 0
// CHECK-NEXT:    [[ARRAYIDX2:%.*]] = getelementptr inbounds [4 x <4 x i32>], ptr [[VAL1]], i64 0, i64 1
// CHECK-NEXT:    [[TMP12:%.*]] = load <4 x i32>, ptr [[ARRAYIDX2]], align 16
// CHECK-NEXT:    [[TMP13:%.*]] = bitcast <4 x i32> [[TMP12]] to <16 x i8>
// CHECK-NEXT:    [[VAL3:%.*]] = getelementptr inbounds [[STRUCT_INT32X4X4_T]], ptr [[__S1]], i32 0, i32 0
// CHECK-NEXT:    [[ARRAYIDX4:%.*]] = getelementptr inbounds [4 x <4 x i32>], ptr [[VAL3]], i64 0, i64 2
// CHECK-NEXT:    [[TMP14:%.*]] = load <4 x i32>, ptr [[ARRAYIDX4]], align 16
// CHECK-NEXT:    [[TMP15:%.*]] = bitcast <4 x i32> [[TMP14]] to <16 x i8>
// CHECK-NEXT:    [[VAL5:%.*]] = getelementptr inbounds [[STRUCT_INT32X4X4_T]], ptr [[__S1]], i32 0, i32 0
// CHECK-NEXT:    [[ARRAYIDX6:%.*]] = getelementptr inbounds [4 x <4 x i32>], ptr [[VAL5]], i64 0, i64 3
// CHECK-NEXT:    [[TMP16:%.*]] = load <4 x i32>, ptr [[ARRAYIDX6]], align 16
// CHECK-NEXT:    [[TMP17:%.*]] = bitcast <4 x i32> [[TMP16]] to <16 x i8>
// CHECK-NEXT:    [[TMP18:%.*]] = bitcast <16 x i8> [[TMP11]] to <4 x i32>
// CHECK-NEXT:    [[TMP19:%.*]] = bitcast <16 x i8> [[TMP13]] to <4 x i32>
// CHECK-NEXT:    [[TMP20:%.*]] = bitcast <16 x i8> [[TMP15]] to <4 x i32>
// CHECK-NEXT:    [[TMP21:%.*]] = bitcast <16 x i8> [[TMP17]] to <4 x i32>
// CHECK-NEXT:    [[TMP22:%.*]] = ptrtoint ptr [[A]] to i64
// CHECK-NEXT:    [[TMP23:%.*]] = xor i64 [[TMP22]], 193514046488576
// CHECK-NEXT:    [[TMP24:%.*]] = inttoptr i64 [[TMP23]] to ptr
// CHECK-NEXT:    store <16 x i32> zeroinitializer, ptr [[TMP24]], align 1
// CHECK-NEXT:    call void @llvm.aarch64.neon.st4.v4i32.p0(<4 x i32> [[TMP18]], <4 x i32> [[TMP19]], <4 x i32> [[TMP20]], <4 x i32> [[TMP21]], ptr [[A]])
// CHECK-NEXT:    ret void
//
void test_vst4q_s32(int32_t *a, int32x4x4_t b) {
  vst4q_s32(a, b);
}

// CHECK-LABEL: define dso_local void @test_vst4q_s64(
// CHECK-SAME: ptr noundef [[A:%.*]], [4 x <2 x i64>] alignstack(16) [[B_COERCE:%.*]]) #[[ATTR0]] {
// CHECK-NEXT:  entry:
// CHECK-NEXT:    call void @llvm.donothing()
// CHECK-NEXT:    [[B:%.*]] = alloca [[STRUCT_INT64X2X4_T:%.*]], align 16
// CHECK-NEXT:    [[TMP0:%.*]] = ptrtoint ptr [[B]] to i64
// CHECK-NEXT:    [[TMP1:%.*]] = xor i64 [[TMP0]], 193514046488576
// CHECK-NEXT:    [[TMP2:%.*]] = inttoptr i64 [[TMP1]] to ptr
// CHECK-NEXT:    call void @llvm.memset.p0.i64(ptr align 16 [[TMP2]], i8 0, i64 64, i1 false)
// CHECK-NEXT:    [[__S1:%.*]] = alloca [[STRUCT_INT64X2X4_T]], align 16
// CHECK-NEXT:    [[TMP3:%.*]] = ptrtoint ptr [[__S1]] to i64
// CHECK-NEXT:    [[TMP4:%.*]] = xor i64 [[TMP3]], 193514046488576
// CHECK-NEXT:    [[TMP5:%.*]] = inttoptr i64 [[TMP4]] to ptr
// CHECK-NEXT:    call void @llvm.memset.p0.i64(ptr align 16 [[TMP5]], i8 0, i64 64, i1 false)
// CHECK-NEXT:    [[COERCE_DIVE:%.*]] = getelementptr inbounds [[STRUCT_INT64X2X4_T]], ptr [[B]], i32 0, i32 0
// CHECK-NEXT:    [[TMP6:%.*]] = ptrtoint ptr [[COERCE_DIVE]] to i64
// CHECK-NEXT:    [[TMP7:%.*]] = xor i64 [[TMP6]], 193514046488576
// CHECK-NEXT:    [[TMP8:%.*]] = inttoptr i64 [[TMP7]] to ptr
// CHECK-NEXT:    store [4 x <2 x i64>] zeroinitializer, ptr [[TMP8]], align 16
// CHECK-NEXT:    store [4 x <2 x i64>] [[B_COERCE]], ptr [[COERCE_DIVE]], align 16
// CHECK-NEXT:    [[TMP9:%.*]] = call ptr @__msan_memcpy(ptr [[__S1]], ptr [[B]], i64 64)
// CHECK-NEXT:    [[VAL:%.*]] = getelementptr inbounds [[STRUCT_INT64X2X4_T]], ptr [[__S1]], i32 0, i32 0
// CHECK-NEXT:    [[ARRAYIDX:%.*]] = getelementptr inbounds [4 x <2 x i64>], ptr [[VAL]], i64 0, i64 0
// CHECK-NEXT:    [[TMP10:%.*]] = load <2 x i64>, ptr [[ARRAYIDX]], align 16
// CHECK-NEXT:    [[TMP11:%.*]] = bitcast <2 x i64> [[TMP10]] to <16 x i8>
// CHECK-NEXT:    [[VAL1:%.*]] = getelementptr inbounds [[STRUCT_INT64X2X4_T]], ptr [[__S1]], i32 0, i32 0
// CHECK-NEXT:    [[ARRAYIDX2:%.*]] = getelementptr inbounds [4 x <2 x i64>], ptr [[VAL1]], i64 0, i64 1
// CHECK-NEXT:    [[TMP12:%.*]] = load <2 x i64>, ptr [[ARRAYIDX2]], align 16
// CHECK-NEXT:    [[TMP13:%.*]] = bitcast <2 x i64> [[TMP12]] to <16 x i8>
// CHECK-NEXT:    [[VAL3:%.*]] = getelementptr inbounds [[STRUCT_INT64X2X4_T]], ptr [[__S1]], i32 0, i32 0
// CHECK-NEXT:    [[ARRAYIDX4:%.*]] = getelementptr inbounds [4 x <2 x i64>], ptr [[VAL3]], i64 0, i64 2
// CHECK-NEXT:    [[TMP14:%.*]] = load <2 x i64>, ptr [[ARRAYIDX4]], align 16
// CHECK-NEXT:    [[TMP15:%.*]] = bitcast <2 x i64> [[TMP14]] to <16 x i8>
// CHECK-NEXT:    [[VAL5:%.*]] = getelementptr inbounds [[STRUCT_INT64X2X4_T]], ptr [[__S1]], i32 0, i32 0
// CHECK-NEXT:    [[ARRAYIDX6:%.*]] = getelementptr inbounds [4 x <2 x i64>], ptr [[VAL5]], i64 0, i64 3
// CHECK-NEXT:    [[TMP16:%.*]] = load <2 x i64>, ptr [[ARRAYIDX6]], align 16
// CHECK-NEXT:    [[TMP17:%.*]] = bitcast <2 x i64> [[TMP16]] to <16 x i8>
// CHECK-NEXT:    [[TMP18:%.*]] = bitcast <16 x i8> [[TMP11]] to <2 x i64>
// CHECK-NEXT:    [[TMP19:%.*]] = bitcast <16 x i8> [[TMP13]] to <2 x i64>
// CHECK-NEXT:    [[TMP20:%.*]] = bitcast <16 x i8> [[TMP15]] to <2 x i64>
// CHECK-NEXT:    [[TMP21:%.*]] = bitcast <16 x i8> [[TMP17]] to <2 x i64>
// CHECK-NEXT:    [[TMP22:%.*]] = ptrtoint ptr [[A]] to i64
// CHECK-NEXT:    [[TMP23:%.*]] = xor i64 [[TMP22]], 193514046488576
// CHECK-NEXT:    [[TMP24:%.*]] = inttoptr i64 [[TMP23]] to ptr
// CHECK-NEXT:    store <8 x i64> zeroinitializer, ptr [[TMP24]], align 1
// CHECK-NEXT:    call void @llvm.aarch64.neon.st4.v2i64.p0(<2 x i64> [[TMP18]], <2 x i64> [[TMP19]], <2 x i64> [[TMP20]], <2 x i64> [[TMP21]], ptr [[A]])
// CHECK-NEXT:    ret void
//
void test_vst4q_s64(int64_t *a, int64x2x4_t b) {
  vst4q_s64(a, b);
}

// CHECK-LABEL: define dso_local void @test_vst4q_f16(
// CHECK-SAME: ptr noundef [[A:%.*]], [4 x <8 x half>] alignstack(16) [[B_COERCE:%.*]]) #[[ATTR0]] {
// CHECK-NEXT:  entry:
// CHECK-NEXT:    call void @llvm.donothing()
// CHECK-NEXT:    [[B:%.*]] = alloca [[STRUCT_FLOAT16X8X4_T:%.*]], align 16
// CHECK-NEXT:    [[TMP0:%.*]] = ptrtoint ptr [[B]] to i64
// CHECK-NEXT:    [[TMP1:%.*]] = xor i64 [[TMP0]], 193514046488576
// CHECK-NEXT:    [[TMP2:%.*]] = inttoptr i64 [[TMP1]] to ptr
// CHECK-NEXT:    call void @llvm.memset.p0.i64(ptr align 16 [[TMP2]], i8 0, i64 64, i1 false)
// CHECK-NEXT:    [[__S1:%.*]] = alloca [[STRUCT_FLOAT16X8X4_T]], align 16
// CHECK-NEXT:    [[TMP3:%.*]] = ptrtoint ptr [[__S1]] to i64
// CHECK-NEXT:    [[TMP4:%.*]] = xor i64 [[TMP3]], 193514046488576
// CHECK-NEXT:    [[TMP5:%.*]] = inttoptr i64 [[TMP4]] to ptr
// CHECK-NEXT:    call void @llvm.memset.p0.i64(ptr align 16 [[TMP5]], i8 0, i64 64, i1 false)
// CHECK-NEXT:    [[COERCE_DIVE:%.*]] = getelementptr inbounds [[STRUCT_FLOAT16X8X4_T]], ptr [[B]], i32 0, i32 0
// CHECK-NEXT:    [[TMP6:%.*]] = ptrtoint ptr [[COERCE_DIVE]] to i64
// CHECK-NEXT:    [[TMP7:%.*]] = xor i64 [[TMP6]], 193514046488576
// CHECK-NEXT:    [[TMP8:%.*]] = inttoptr i64 [[TMP7]] to ptr
// CHECK-NEXT:    store [4 x <8 x i16>] zeroinitializer, ptr [[TMP8]], align 16
// CHECK-NEXT:    store [4 x <8 x half>] [[B_COERCE]], ptr [[COERCE_DIVE]], align 16
// CHECK-NEXT:    [[TMP9:%.*]] = call ptr @__msan_memcpy(ptr [[__S1]], ptr [[B]], i64 64)
// CHECK-NEXT:    [[VAL:%.*]] = getelementptr inbounds [[STRUCT_FLOAT16X8X4_T]], ptr [[__S1]], i32 0, i32 0
// CHECK-NEXT:    [[ARRAYIDX:%.*]] = getelementptr inbounds [4 x <8 x half>], ptr [[VAL]], i64 0, i64 0
// CHECK-NEXT:    [[TMP10:%.*]] = load <8 x half>, ptr [[ARRAYIDX]], align 16
// CHECK-NEXT:    [[TMP11:%.*]] = bitcast <8 x half> [[TMP10]] to <16 x i8>
// CHECK-NEXT:    [[VAL1:%.*]] = getelementptr inbounds [[STRUCT_FLOAT16X8X4_T]], ptr [[__S1]], i32 0, i32 0
// CHECK-NEXT:    [[ARRAYIDX2:%.*]] = getelementptr inbounds [4 x <8 x half>], ptr [[VAL1]], i64 0, i64 1
// CHECK-NEXT:    [[TMP12:%.*]] = load <8 x half>, ptr [[ARRAYIDX2]], align 16
// CHECK-NEXT:    [[TMP13:%.*]] = bitcast <8 x half> [[TMP12]] to <16 x i8>
// CHECK-NEXT:    [[VAL3:%.*]] = getelementptr inbounds [[STRUCT_FLOAT16X8X4_T]], ptr [[__S1]], i32 0, i32 0
// CHECK-NEXT:    [[ARRAYIDX4:%.*]] = getelementptr inbounds [4 x <8 x half>], ptr [[VAL3]], i64 0, i64 2
// CHECK-NEXT:    [[TMP14:%.*]] = load <8 x half>, ptr [[ARRAYIDX4]], align 16
// CHECK-NEXT:    [[TMP15:%.*]] = bitcast <8 x half> [[TMP14]] to <16 x i8>
// CHECK-NEXT:    [[VAL5:%.*]] = getelementptr inbounds [[STRUCT_FLOAT16X8X4_T]], ptr [[__S1]], i32 0, i32 0
// CHECK-NEXT:    [[ARRAYIDX6:%.*]] = getelementptr inbounds [4 x <8 x half>], ptr [[VAL5]], i64 0, i64 3
// CHECK-NEXT:    [[TMP16:%.*]] = load <8 x half>, ptr [[ARRAYIDX6]], align 16
// CHECK-NEXT:    [[TMP17:%.*]] = bitcast <8 x half> [[TMP16]] to <16 x i8>
// CHECK-NEXT:    [[TMP18:%.*]] = bitcast <16 x i8> [[TMP11]] to <8 x half>
// CHECK-NEXT:    [[TMP19:%.*]] = bitcast <16 x i8> [[TMP13]] to <8 x half>
// CHECK-NEXT:    [[TMP20:%.*]] = bitcast <16 x i8> [[TMP15]] to <8 x half>
// CHECK-NEXT:    [[TMP21:%.*]] = bitcast <16 x i8> [[TMP17]] to <8 x half>
// CHECK-NEXT:    [[TMP22:%.*]] = ptrtoint ptr [[A]] to i64
// CHECK-NEXT:    [[TMP23:%.*]] = xor i64 [[TMP22]], 193514046488576
// CHECK-NEXT:    [[TMP24:%.*]] = inttoptr i64 [[TMP23]] to ptr
// CHECK-NEXT:    store <32 x i16> zeroinitializer, ptr [[TMP24]], align 1
// CHECK-NEXT:    call void @llvm.aarch64.neon.st4.v8f16.p0(<8 x half> [[TMP18]], <8 x half> [[TMP19]], <8 x half> [[TMP20]], <8 x half> [[TMP21]], ptr [[A]])
// CHECK-NEXT:    ret void
//
void test_vst4q_f16(float16_t *a, float16x8x4_t b) {
  vst4q_f16(a, b);
}

// CHECK-LABEL: define dso_local void @test_vst4q_f32(
// CHECK-SAME: ptr noundef [[A:%.*]], [4 x <4 x float>] alignstack(16) [[B_COERCE:%.*]]) #[[ATTR0]] {
// CHECK-NEXT:  entry:
// CHECK-NEXT:    call void @llvm.donothing()
// CHECK-NEXT:    [[B:%.*]] = alloca [[STRUCT_FLOAT32X4X4_T:%.*]], align 16
// CHECK-NEXT:    [[TMP0:%.*]] = ptrtoint ptr [[B]] to i64
// CHECK-NEXT:    [[TMP1:%.*]] = xor i64 [[TMP0]], 193514046488576
// CHECK-NEXT:    [[TMP2:%.*]] = inttoptr i64 [[TMP1]] to ptr
// CHECK-NEXT:    call void @llvm.memset.p0.i64(ptr align 16 [[TMP2]], i8 0, i64 64, i1 false)
// CHECK-NEXT:    [[__S1:%.*]] = alloca [[STRUCT_FLOAT32X4X4_T]], align 16
// CHECK-NEXT:    [[TMP3:%.*]] = ptrtoint ptr [[__S1]] to i64
// CHECK-NEXT:    [[TMP4:%.*]] = xor i64 [[TMP3]], 193514046488576
// CHECK-NEXT:    [[TMP5:%.*]] = inttoptr i64 [[TMP4]] to ptr
// CHECK-NEXT:    call void @llvm.memset.p0.i64(ptr align 16 [[TMP5]], i8 0, i64 64, i1 false)
// CHECK-NEXT:    [[COERCE_DIVE:%.*]] = getelementptr inbounds [[STRUCT_FLOAT32X4X4_T]], ptr [[B]], i32 0, i32 0
// CHECK-NEXT:    [[TMP6:%.*]] = ptrtoint ptr [[COERCE_DIVE]] to i64
// CHECK-NEXT:    [[TMP7:%.*]] = xor i64 [[TMP6]], 193514046488576
// CHECK-NEXT:    [[TMP8:%.*]] = inttoptr i64 [[TMP7]] to ptr
// CHECK-NEXT:    store [4 x <4 x i32>] zeroinitializer, ptr [[TMP8]], align 16
// CHECK-NEXT:    store [4 x <4 x float>] [[B_COERCE]], ptr [[COERCE_DIVE]], align 16
// CHECK-NEXT:    [[TMP9:%.*]] = call ptr @__msan_memcpy(ptr [[__S1]], ptr [[B]], i64 64)
// CHECK-NEXT:    [[VAL:%.*]] = getelementptr inbounds [[STRUCT_FLOAT32X4X4_T]], ptr [[__S1]], i32 0, i32 0
// CHECK-NEXT:    [[ARRAYIDX:%.*]] = getelementptr inbounds [4 x <4 x float>], ptr [[VAL]], i64 0, i64 0
// CHECK-NEXT:    [[TMP10:%.*]] = load <4 x float>, ptr [[ARRAYIDX]], align 16
// CHECK-NEXT:    [[TMP11:%.*]] = bitcast <4 x float> [[TMP10]] to <16 x i8>
// CHECK-NEXT:    [[VAL1:%.*]] = getelementptr inbounds [[STRUCT_FLOAT32X4X4_T]], ptr [[__S1]], i32 0, i32 0
// CHECK-NEXT:    [[ARRAYIDX2:%.*]] = getelementptr inbounds [4 x <4 x float>], ptr [[VAL1]], i64 0, i64 1
// CHECK-NEXT:    [[TMP12:%.*]] = load <4 x float>, ptr [[ARRAYIDX2]], align 16
// CHECK-NEXT:    [[TMP13:%.*]] = bitcast <4 x float> [[TMP12]] to <16 x i8>
// CHECK-NEXT:    [[VAL3:%.*]] = getelementptr inbounds [[STRUCT_FLOAT32X4X4_T]], ptr [[__S1]], i32 0, i32 0
// CHECK-NEXT:    [[ARRAYIDX4:%.*]] = getelementptr inbounds [4 x <4 x float>], ptr [[VAL3]], i64 0, i64 2
// CHECK-NEXT:    [[TMP14:%.*]] = load <4 x float>, ptr [[ARRAYIDX4]], align 16
// CHECK-NEXT:    [[TMP15:%.*]] = bitcast <4 x float> [[TMP14]] to <16 x i8>
// CHECK-NEXT:    [[VAL5:%.*]] = getelementptr inbounds [[STRUCT_FLOAT32X4X4_T]], ptr [[__S1]], i32 0, i32 0
// CHECK-NEXT:    [[ARRAYIDX6:%.*]] = getelementptr inbounds [4 x <4 x float>], ptr [[VAL5]], i64 0, i64 3
// CHECK-NEXT:    [[TMP16:%.*]] = load <4 x float>, ptr [[ARRAYIDX6]], align 16
// CHECK-NEXT:    [[TMP17:%.*]] = bitcast <4 x float> [[TMP16]] to <16 x i8>
// CHECK-NEXT:    [[TMP18:%.*]] = bitcast <16 x i8> [[TMP11]] to <4 x float>
// CHECK-NEXT:    [[TMP19:%.*]] = bitcast <16 x i8> [[TMP13]] to <4 x float>
// CHECK-NEXT:    [[TMP20:%.*]] = bitcast <16 x i8> [[TMP15]] to <4 x float>
// CHECK-NEXT:    [[TMP21:%.*]] = bitcast <16 x i8> [[TMP17]] to <4 x float>
// CHECK-NEXT:    [[TMP22:%.*]] = ptrtoint ptr [[A]] to i64
// CHECK-NEXT:    [[TMP23:%.*]] = xor i64 [[TMP22]], 193514046488576
// CHECK-NEXT:    [[TMP24:%.*]] = inttoptr i64 [[TMP23]] to ptr
// CHECK-NEXT:    store <16 x i32> zeroinitializer, ptr [[TMP24]], align 1
// CHECK-NEXT:    call void @llvm.aarch64.neon.st4.v4f32.p0(<4 x float> [[TMP18]], <4 x float> [[TMP19]], <4 x float> [[TMP20]], <4 x float> [[TMP21]], ptr [[A]])
// CHECK-NEXT:    ret void
//
void test_vst4q_f32(float32_t *a, float32x4x4_t b) {
  vst4q_f32(a, b);
}

// CHECK-LABEL: define dso_local void @test_vst4q_f64(
// CHECK-SAME: ptr noundef [[A:%.*]], [4 x <2 x double>] alignstack(16) [[B_COERCE:%.*]]) #[[ATTR0]] {
// CHECK-NEXT:  entry:
// CHECK-NEXT:    call void @llvm.donothing()
// CHECK-NEXT:    [[B:%.*]] = alloca [[STRUCT_FLOAT64X2X4_T:%.*]], align 16
// CHECK-NEXT:    [[TMP0:%.*]] = ptrtoint ptr [[B]] to i64
// CHECK-NEXT:    [[TMP1:%.*]] = xor i64 [[TMP0]], 193514046488576
// CHECK-NEXT:    [[TMP2:%.*]] = inttoptr i64 [[TMP1]] to ptr
// CHECK-NEXT:    call void @llvm.memset.p0.i64(ptr align 16 [[TMP2]], i8 0, i64 64, i1 false)
// CHECK-NEXT:    [[__S1:%.*]] = alloca [[STRUCT_FLOAT64X2X4_T]], align 16
// CHECK-NEXT:    [[TMP3:%.*]] = ptrtoint ptr [[__S1]] to i64
// CHECK-NEXT:    [[TMP4:%.*]] = xor i64 [[TMP3]], 193514046488576
// CHECK-NEXT:    [[TMP5:%.*]] = inttoptr i64 [[TMP4]] to ptr
// CHECK-NEXT:    call void @llvm.memset.p0.i64(ptr align 16 [[TMP5]], i8 0, i64 64, i1 false)
// CHECK-NEXT:    [[COERCE_DIVE:%.*]] = getelementptr inbounds [[STRUCT_FLOAT64X2X4_T]], ptr [[B]], i32 0, i32 0
// CHECK-NEXT:    [[TMP6:%.*]] = ptrtoint ptr [[COERCE_DIVE]] to i64
// CHECK-NEXT:    [[TMP7:%.*]] = xor i64 [[TMP6]], 193514046488576
// CHECK-NEXT:    [[TMP8:%.*]] = inttoptr i64 [[TMP7]] to ptr
// CHECK-NEXT:    store [4 x <2 x i64>] zeroinitializer, ptr [[TMP8]], align 16
// CHECK-NEXT:    store [4 x <2 x double>] [[B_COERCE]], ptr [[COERCE_DIVE]], align 16
// CHECK-NEXT:    [[TMP9:%.*]] = call ptr @__msan_memcpy(ptr [[__S1]], ptr [[B]], i64 64)
// CHECK-NEXT:    [[VAL:%.*]] = getelementptr inbounds [[STRUCT_FLOAT64X2X4_T]], ptr [[__S1]], i32 0, i32 0
// CHECK-NEXT:    [[ARRAYIDX:%.*]] = getelementptr inbounds [4 x <2 x double>], ptr [[VAL]], i64 0, i64 0
// CHECK-NEXT:    [[TMP10:%.*]] = load <2 x double>, ptr [[ARRAYIDX]], align 16
// CHECK-NEXT:    [[TMP11:%.*]] = bitcast <2 x double> [[TMP10]] to <16 x i8>
// CHECK-NEXT:    [[VAL1:%.*]] = getelementptr inbounds [[STRUCT_FLOAT64X2X4_T]], ptr [[__S1]], i32 0, i32 0
// CHECK-NEXT:    [[ARRAYIDX2:%.*]] = getelementptr inbounds [4 x <2 x double>], ptr [[VAL1]], i64 0, i64 1
// CHECK-NEXT:    [[TMP12:%.*]] = load <2 x double>, ptr [[ARRAYIDX2]], align 16
// CHECK-NEXT:    [[TMP13:%.*]] = bitcast <2 x double> [[TMP12]] to <16 x i8>
// CHECK-NEXT:    [[VAL3:%.*]] = getelementptr inbounds [[STRUCT_FLOAT64X2X4_T]], ptr [[__S1]], i32 0, i32 0
// CHECK-NEXT:    [[ARRAYIDX4:%.*]] = getelementptr inbounds [4 x <2 x double>], ptr [[VAL3]], i64 0, i64 2
// CHECK-NEXT:    [[TMP14:%.*]] = load <2 x double>, ptr [[ARRAYIDX4]], align 16
// CHECK-NEXT:    [[TMP15:%.*]] = bitcast <2 x double> [[TMP14]] to <16 x i8>
// CHECK-NEXT:    [[VAL5:%.*]] = getelementptr inbounds [[STRUCT_FLOAT64X2X4_T]], ptr [[__S1]], i32 0, i32 0
// CHECK-NEXT:    [[ARRAYIDX6:%.*]] = getelementptr inbounds [4 x <2 x double>], ptr [[VAL5]], i64 0, i64 3
// CHECK-NEXT:    [[TMP16:%.*]] = load <2 x double>, ptr [[ARRAYIDX6]], align 16
// CHECK-NEXT:    [[TMP17:%.*]] = bitcast <2 x double> [[TMP16]] to <16 x i8>
// CHECK-NEXT:    [[TMP18:%.*]] = bitcast <16 x i8> [[TMP11]] to <2 x double>
// CHECK-NEXT:    [[TMP19:%.*]] = bitcast <16 x i8> [[TMP13]] to <2 x double>
// CHECK-NEXT:    [[TMP20:%.*]] = bitcast <16 x i8> [[TMP15]] to <2 x double>
// CHECK-NEXT:    [[TMP21:%.*]] = bitcast <16 x i8> [[TMP17]] to <2 x double>
// CHECK-NEXT:    [[TMP22:%.*]] = ptrtoint ptr [[A]] to i64
// CHECK-NEXT:    [[TMP23:%.*]] = xor i64 [[TMP22]], 193514046488576
// CHECK-NEXT:    [[TMP24:%.*]] = inttoptr i64 [[TMP23]] to ptr
// CHECK-NEXT:    store <8 x i64> zeroinitializer, ptr [[TMP24]], align 1
// CHECK-NEXT:    call void @llvm.aarch64.neon.st4.v2f64.p0(<2 x double> [[TMP18]], <2 x double> [[TMP19]], <2 x double> [[TMP20]], <2 x double> [[TMP21]], ptr [[A]])
// CHECK-NEXT:    ret void
//
void test_vst4q_f64(float64_t *a, float64x2x4_t b) {
  vst4q_f64(a, b);
}

// CHECK-LABEL: define dso_local void @test_vst4q_p8(
// CHECK-SAME: ptr noundef [[A:%.*]], [4 x <16 x i8>] alignstack(16) [[B_COERCE:%.*]]) #[[ATTR0]] {
// CHECK-NEXT:  entry:
// CHECK-NEXT:    call void @llvm.donothing()
// CHECK-NEXT:    [[B:%.*]] = alloca [[STRUCT_POLY8X16X4_T:%.*]], align 16
// CHECK-NEXT:    [[TMP0:%.*]] = ptrtoint ptr [[B]] to i64
// CHECK-NEXT:    [[TMP1:%.*]] = xor i64 [[TMP0]], 193514046488576
// CHECK-NEXT:    [[TMP2:%.*]] = inttoptr i64 [[TMP1]] to ptr
// CHECK-NEXT:    call void @llvm.memset.p0.i64(ptr align 16 [[TMP2]], i8 0, i64 64, i1 false)
// CHECK-NEXT:    [[__S1:%.*]] = alloca [[STRUCT_POLY8X16X4_T]], align 16
// CHECK-NEXT:    [[TMP3:%.*]] = ptrtoint ptr [[__S1]] to i64
// CHECK-NEXT:    [[TMP4:%.*]] = xor i64 [[TMP3]], 193514046488576
// CHECK-NEXT:    [[TMP5:%.*]] = inttoptr i64 [[TMP4]] to ptr
// CHECK-NEXT:    call void @llvm.memset.p0.i64(ptr align 16 [[TMP5]], i8 0, i64 64, i1 false)
// CHECK-NEXT:    [[COERCE_DIVE:%.*]] = getelementptr inbounds [[STRUCT_POLY8X16X4_T]], ptr [[B]], i32 0, i32 0
// CHECK-NEXT:    [[TMP6:%.*]] = ptrtoint ptr [[COERCE_DIVE]] to i64
// CHECK-NEXT:    [[TMP7:%.*]] = xor i64 [[TMP6]], 193514046488576
// CHECK-NEXT:    [[TMP8:%.*]] = inttoptr i64 [[TMP7]] to ptr
// CHECK-NEXT:    store [4 x <16 x i8>] zeroinitializer, ptr [[TMP8]], align 16
// CHECK-NEXT:    store [4 x <16 x i8>] [[B_COERCE]], ptr [[COERCE_DIVE]], align 16
// CHECK-NEXT:    [[TMP9:%.*]] = call ptr @__msan_memcpy(ptr [[__S1]], ptr [[B]], i64 64)
// CHECK-NEXT:    [[VAL:%.*]] = getelementptr inbounds [[STRUCT_POLY8X16X4_T]], ptr [[__S1]], i32 0, i32 0
// CHECK-NEXT:    [[ARRAYIDX:%.*]] = getelementptr inbounds [4 x <16 x i8>], ptr [[VAL]], i64 0, i64 0
// CHECK-NEXT:    [[TMP10:%.*]] = load <16 x i8>, ptr [[ARRAYIDX]], align 16
// CHECK-NEXT:    [[VAL1:%.*]] = getelementptr inbounds [[STRUCT_POLY8X16X4_T]], ptr [[__S1]], i32 0, i32 0
// CHECK-NEXT:    [[ARRAYIDX2:%.*]] = getelementptr inbounds [4 x <16 x i8>], ptr [[VAL1]], i64 0, i64 1
// CHECK-NEXT:    [[TMP11:%.*]] = load <16 x i8>, ptr [[ARRAYIDX2]], align 16
// CHECK-NEXT:    [[VAL3:%.*]] = getelementptr inbounds [[STRUCT_POLY8X16X4_T]], ptr [[__S1]], i32 0, i32 0
// CHECK-NEXT:    [[ARRAYIDX4:%.*]] = getelementptr inbounds [4 x <16 x i8>], ptr [[VAL3]], i64 0, i64 2
// CHECK-NEXT:    [[TMP12:%.*]] = load <16 x i8>, ptr [[ARRAYIDX4]], align 16
// CHECK-NEXT:    [[VAL5:%.*]] = getelementptr inbounds [[STRUCT_POLY8X16X4_T]], ptr [[__S1]], i32 0, i32 0
// CHECK-NEXT:    [[ARRAYIDX6:%.*]] = getelementptr inbounds [4 x <16 x i8>], ptr [[VAL5]], i64 0, i64 3
// CHECK-NEXT:    [[TMP13:%.*]] = load <16 x i8>, ptr [[ARRAYIDX6]], align 16
// CHECK-NEXT:    [[TMP14:%.*]] = ptrtoint ptr [[A]] to i64
// CHECK-NEXT:    [[TMP15:%.*]] = xor i64 [[TMP14]], 193514046488576
// CHECK-NEXT:    [[TMP16:%.*]] = inttoptr i64 [[TMP15]] to ptr
// CHECK-NEXT:    store <64 x i8> zeroinitializer, ptr [[TMP16]], align 1
// CHECK-NEXT:    call void @llvm.aarch64.neon.st4.v16i8.p0(<16 x i8> [[TMP10]], <16 x i8> [[TMP11]], <16 x i8> [[TMP12]], <16 x i8> [[TMP13]], ptr [[A]])
// CHECK-NEXT:    ret void
//
void test_vst4q_p8(poly8_t *a, poly8x16x4_t b) {
  vst4q_p8(a, b);
}

// CHECK-LABEL: define dso_local void @test_vst4q_p16(
// CHECK-SAME: ptr noundef [[A:%.*]], [4 x <8 x i16>] alignstack(16) [[B_COERCE:%.*]]) #[[ATTR0]] {
// CHECK-NEXT:  entry:
// CHECK-NEXT:    call void @llvm.donothing()
// CHECK-NEXT:    [[B:%.*]] = alloca [[STRUCT_POLY16X8X4_T:%.*]], align 16
// CHECK-NEXT:    [[TMP0:%.*]] = ptrtoint ptr [[B]] to i64
// CHECK-NEXT:    [[TMP1:%.*]] = xor i64 [[TMP0]], 193514046488576
// CHECK-NEXT:    [[TMP2:%.*]] = inttoptr i64 [[TMP1]] to ptr
// CHECK-NEXT:    call void @llvm.memset.p0.i64(ptr align 16 [[TMP2]], i8 0, i64 64, i1 false)
// CHECK-NEXT:    [[__S1:%.*]] = alloca [[STRUCT_POLY16X8X4_T]], align 16
// CHECK-NEXT:    [[TMP3:%.*]] = ptrtoint ptr [[__S1]] to i64
// CHECK-NEXT:    [[TMP4:%.*]] = xor i64 [[TMP3]], 193514046488576
// CHECK-NEXT:    [[TMP5:%.*]] = inttoptr i64 [[TMP4]] to ptr
// CHECK-NEXT:    call void @llvm.memset.p0.i64(ptr align 16 [[TMP5]], i8 0, i64 64, i1 false)
// CHECK-NEXT:    [[COERCE_DIVE:%.*]] = getelementptr inbounds [[STRUCT_POLY16X8X4_T]], ptr [[B]], i32 0, i32 0
// CHECK-NEXT:    [[TMP6:%.*]] = ptrtoint ptr [[COERCE_DIVE]] to i64
// CHECK-NEXT:    [[TMP7:%.*]] = xor i64 [[TMP6]], 193514046488576
// CHECK-NEXT:    [[TMP8:%.*]] = inttoptr i64 [[TMP7]] to ptr
// CHECK-NEXT:    store [4 x <8 x i16>] zeroinitializer, ptr [[TMP8]], align 16
// CHECK-NEXT:    store [4 x <8 x i16>] [[B_COERCE]], ptr [[COERCE_DIVE]], align 16
// CHECK-NEXT:    [[TMP9:%.*]] = call ptr @__msan_memcpy(ptr [[__S1]], ptr [[B]], i64 64)
// CHECK-NEXT:    [[VAL:%.*]] = getelementptr inbounds [[STRUCT_POLY16X8X4_T]], ptr [[__S1]], i32 0, i32 0
// CHECK-NEXT:    [[ARRAYIDX:%.*]] = getelementptr inbounds [4 x <8 x i16>], ptr [[VAL]], i64 0, i64 0
// CHECK-NEXT:    [[TMP10:%.*]] = load <8 x i16>, ptr [[ARRAYIDX]], align 16
// CHECK-NEXT:    [[TMP11:%.*]] = bitcast <8 x i16> [[TMP10]] to <16 x i8>
// CHECK-NEXT:    [[VAL1:%.*]] = getelementptr inbounds [[STRUCT_POLY16X8X4_T]], ptr [[__S1]], i32 0, i32 0
// CHECK-NEXT:    [[ARRAYIDX2:%.*]] = getelementptr inbounds [4 x <8 x i16>], ptr [[VAL1]], i64 0, i64 1
// CHECK-NEXT:    [[TMP12:%.*]] = load <8 x i16>, ptr [[ARRAYIDX2]], align 16
// CHECK-NEXT:    [[TMP13:%.*]] = bitcast <8 x i16> [[TMP12]] to <16 x i8>
// CHECK-NEXT:    [[VAL3:%.*]] = getelementptr inbounds [[STRUCT_POLY16X8X4_T]], ptr [[__S1]], i32 0, i32 0
// CHECK-NEXT:    [[ARRAYIDX4:%.*]] = getelementptr inbounds [4 x <8 x i16>], ptr [[VAL3]], i64 0, i64 2
// CHECK-NEXT:    [[TMP14:%.*]] = load <8 x i16>, ptr [[ARRAYIDX4]], align 16
// CHECK-NEXT:    [[TMP15:%.*]] = bitcast <8 x i16> [[TMP14]] to <16 x i8>
// CHECK-NEXT:    [[VAL5:%.*]] = getelementptr inbounds [[STRUCT_POLY16X8X4_T]], ptr [[__S1]], i32 0, i32 0
// CHECK-NEXT:    [[ARRAYIDX6:%.*]] = getelementptr inbounds [4 x <8 x i16>], ptr [[VAL5]], i64 0, i64 3
// CHECK-NEXT:    [[TMP16:%.*]] = load <8 x i16>, ptr [[ARRAYIDX6]], align 16
// CHECK-NEXT:    [[TMP17:%.*]] = bitcast <8 x i16> [[TMP16]] to <16 x i8>
// CHECK-NEXT:    [[TMP18:%.*]] = bitcast <16 x i8> [[TMP11]] to <8 x i16>
// CHECK-NEXT:    [[TMP19:%.*]] = bitcast <16 x i8> [[TMP13]] to <8 x i16>
// CHECK-NEXT:    [[TMP20:%.*]] = bitcast <16 x i8> [[TMP15]] to <8 x i16>
// CHECK-NEXT:    [[TMP21:%.*]] = bitcast <16 x i8> [[TMP17]] to <8 x i16>
// CHECK-NEXT:    [[TMP22:%.*]] = ptrtoint ptr [[A]] to i64
// CHECK-NEXT:    [[TMP23:%.*]] = xor i64 [[TMP22]], 193514046488576
// CHECK-NEXT:    [[TMP24:%.*]] = inttoptr i64 [[TMP23]] to ptr
// CHECK-NEXT:    store <32 x i16> zeroinitializer, ptr [[TMP24]], align 1
// CHECK-NEXT:    call void @llvm.aarch64.neon.st4.v8i16.p0(<8 x i16> [[TMP18]], <8 x i16> [[TMP19]], <8 x i16> [[TMP20]], <8 x i16> [[TMP21]], ptr [[A]])
// CHECK-NEXT:    ret void
//
void test_vst4q_p16(poly16_t *a, poly16x8x4_t b) {
  vst4q_p16(a, b);
}

// CHECK-LABEL: define dso_local void @test_vst4_u8(
// CHECK-SAME: ptr noundef [[A:%.*]], [4 x <8 x i8>] alignstack(8) [[B_COERCE:%.*]]) #[[ATTR0]] {
// CHECK-NEXT:  entry:
// CHECK-NEXT:    call void @llvm.donothing()
// CHECK-NEXT:    [[B:%.*]] = alloca [[STRUCT_UINT8X8X4_T:%.*]], align 8
// CHECK-NEXT:    [[TMP0:%.*]] = ptrtoint ptr [[B]] to i64
// CHECK-NEXT:    [[TMP1:%.*]] = xor i64 [[TMP0]], 193514046488576
// CHECK-NEXT:    [[TMP2:%.*]] = inttoptr i64 [[TMP1]] to ptr
// CHECK-NEXT:    call void @llvm.memset.p0.i64(ptr align 8 [[TMP2]], i8 0, i64 32, i1 false)
// CHECK-NEXT:    [[__S1:%.*]] = alloca [[STRUCT_UINT8X8X4_T]], align 8
// CHECK-NEXT:    [[TMP3:%.*]] = ptrtoint ptr [[__S1]] to i64
// CHECK-NEXT:    [[TMP4:%.*]] = xor i64 [[TMP3]], 193514046488576
// CHECK-NEXT:    [[TMP5:%.*]] = inttoptr i64 [[TMP4]] to ptr
// CHECK-NEXT:    call void @llvm.memset.p0.i64(ptr align 8 [[TMP5]], i8 0, i64 32, i1 false)
// CHECK-NEXT:    [[COERCE_DIVE:%.*]] = getelementptr inbounds [[STRUCT_UINT8X8X4_T]], ptr [[B]], i32 0, i32 0
// CHECK-NEXT:    [[TMP6:%.*]] = ptrtoint ptr [[COERCE_DIVE]] to i64
// CHECK-NEXT:    [[TMP7:%.*]] = xor i64 [[TMP6]], 193514046488576
// CHECK-NEXT:    [[TMP8:%.*]] = inttoptr i64 [[TMP7]] to ptr
// CHECK-NEXT:    store [4 x <8 x i8>] zeroinitializer, ptr [[TMP8]], align 8
// CHECK-NEXT:    store [4 x <8 x i8>] [[B_COERCE]], ptr [[COERCE_DIVE]], align 8
// CHECK-NEXT:    [[TMP9:%.*]] = call ptr @__msan_memcpy(ptr [[__S1]], ptr [[B]], i64 32)
// CHECK-NEXT:    [[VAL:%.*]] = getelementptr inbounds [[STRUCT_UINT8X8X4_T]], ptr [[__S1]], i32 0, i32 0
// CHECK-NEXT:    [[ARRAYIDX:%.*]] = getelementptr inbounds [4 x <8 x i8>], ptr [[VAL]], i64 0, i64 0
// CHECK-NEXT:    [[TMP10:%.*]] = load <8 x i8>, ptr [[ARRAYIDX]], align 8
// CHECK-NEXT:    [[VAL1:%.*]] = getelementptr inbounds [[STRUCT_UINT8X8X4_T]], ptr [[__S1]], i32 0, i32 0
// CHECK-NEXT:    [[ARRAYIDX2:%.*]] = getelementptr inbounds [4 x <8 x i8>], ptr [[VAL1]], i64 0, i64 1
// CHECK-NEXT:    [[TMP11:%.*]] = load <8 x i8>, ptr [[ARRAYIDX2]], align 8
// CHECK-NEXT:    [[VAL3:%.*]] = getelementptr inbounds [[STRUCT_UINT8X8X4_T]], ptr [[__S1]], i32 0, i32 0
// CHECK-NEXT:    [[ARRAYIDX4:%.*]] = getelementptr inbounds [4 x <8 x i8>], ptr [[VAL3]], i64 0, i64 2
// CHECK-NEXT:    [[TMP12:%.*]] = load <8 x i8>, ptr [[ARRAYIDX4]], align 8
// CHECK-NEXT:    [[VAL5:%.*]] = getelementptr inbounds [[STRUCT_UINT8X8X4_T]], ptr [[__S1]], i32 0, i32 0
// CHECK-NEXT:    [[ARRAYIDX6:%.*]] = getelementptr inbounds [4 x <8 x i8>], ptr [[VAL5]], i64 0, i64 3
// CHECK-NEXT:    [[TMP13:%.*]] = load <8 x i8>, ptr [[ARRAYIDX6]], align 8
// CHECK-NEXT:    [[TMP14:%.*]] = ptrtoint ptr [[A]] to i64
// CHECK-NEXT:    [[TMP15:%.*]] = xor i64 [[TMP14]], 193514046488576
// CHECK-NEXT:    [[TMP16:%.*]] = inttoptr i64 [[TMP15]] to ptr
// CHECK-NEXT:    store <32 x i8> zeroinitializer, ptr [[TMP16]], align 1
// CHECK-NEXT:    call void @llvm.aarch64.neon.st4.v8i8.p0(<8 x i8> [[TMP10]], <8 x i8> [[TMP11]], <8 x i8> [[TMP12]], <8 x i8> [[TMP13]], ptr [[A]])
// CHECK-NEXT:    ret void
//
void test_vst4_u8(uint8_t *a, uint8x8x4_t b) {
  vst4_u8(a, b);
}

// CHECK-LABEL: define dso_local void @test_vst4_u16(
// CHECK-SAME: ptr noundef [[A:%.*]], [4 x <4 x i16>] alignstack(8) [[B_COERCE:%.*]]) #[[ATTR0]] {
// CHECK-NEXT:  entry:
// CHECK-NEXT:    call void @llvm.donothing()
// CHECK-NEXT:    [[B:%.*]] = alloca [[STRUCT_UINT16X4X4_T:%.*]], align 8
// CHECK-NEXT:    [[TMP0:%.*]] = ptrtoint ptr [[B]] to i64
// CHECK-NEXT:    [[TMP1:%.*]] = xor i64 [[TMP0]], 193514046488576
// CHECK-NEXT:    [[TMP2:%.*]] = inttoptr i64 [[TMP1]] to ptr
// CHECK-NEXT:    call void @llvm.memset.p0.i64(ptr align 8 [[TMP2]], i8 0, i64 32, i1 false)
// CHECK-NEXT:    [[__S1:%.*]] = alloca [[STRUCT_UINT16X4X4_T]], align 8
// CHECK-NEXT:    [[TMP3:%.*]] = ptrtoint ptr [[__S1]] to i64
// CHECK-NEXT:    [[TMP4:%.*]] = xor i64 [[TMP3]], 193514046488576
// CHECK-NEXT:    [[TMP5:%.*]] = inttoptr i64 [[TMP4]] to ptr
// CHECK-NEXT:    call void @llvm.memset.p0.i64(ptr align 8 [[TMP5]], i8 0, i64 32, i1 false)
// CHECK-NEXT:    [[COERCE_DIVE:%.*]] = getelementptr inbounds [[STRUCT_UINT16X4X4_T]], ptr [[B]], i32 0, i32 0
// CHECK-NEXT:    [[TMP6:%.*]] = ptrtoint ptr [[COERCE_DIVE]] to i64
// CHECK-NEXT:    [[TMP7:%.*]] = xor i64 [[TMP6]], 193514046488576
// CHECK-NEXT:    [[TMP8:%.*]] = inttoptr i64 [[TMP7]] to ptr
// CHECK-NEXT:    store [4 x <4 x i16>] zeroinitializer, ptr [[TMP8]], align 8
// CHECK-NEXT:    store [4 x <4 x i16>] [[B_COERCE]], ptr [[COERCE_DIVE]], align 8
// CHECK-NEXT:    [[TMP9:%.*]] = call ptr @__msan_memcpy(ptr [[__S1]], ptr [[B]], i64 32)
// CHECK-NEXT:    [[VAL:%.*]] = getelementptr inbounds [[STRUCT_UINT16X4X4_T]], ptr [[__S1]], i32 0, i32 0
// CHECK-NEXT:    [[ARRAYIDX:%.*]] = getelementptr inbounds [4 x <4 x i16>], ptr [[VAL]], i64 0, i64 0
// CHECK-NEXT:    [[TMP10:%.*]] = load <4 x i16>, ptr [[ARRAYIDX]], align 8
// CHECK-NEXT:    [[TMP11:%.*]] = bitcast <4 x i16> [[TMP10]] to <8 x i8>
// CHECK-NEXT:    [[VAL1:%.*]] = getelementptr inbounds [[STRUCT_UINT16X4X4_T]], ptr [[__S1]], i32 0, i32 0
// CHECK-NEXT:    [[ARRAYIDX2:%.*]] = getelementptr inbounds [4 x <4 x i16>], ptr [[VAL1]], i64 0, i64 1
// CHECK-NEXT:    [[TMP12:%.*]] = load <4 x i16>, ptr [[ARRAYIDX2]], align 8
// CHECK-NEXT:    [[TMP13:%.*]] = bitcast <4 x i16> [[TMP12]] to <8 x i8>
// CHECK-NEXT:    [[VAL3:%.*]] = getelementptr inbounds [[STRUCT_UINT16X4X4_T]], ptr [[__S1]], i32 0, i32 0
// CHECK-NEXT:    [[ARRAYIDX4:%.*]] = getelementptr inbounds [4 x <4 x i16>], ptr [[VAL3]], i64 0, i64 2
// CHECK-NEXT:    [[TMP14:%.*]] = load <4 x i16>, ptr [[ARRAYIDX4]], align 8
// CHECK-NEXT:    [[TMP15:%.*]] = bitcast <4 x i16> [[TMP14]] to <8 x i8>
// CHECK-NEXT:    [[VAL5:%.*]] = getelementptr inbounds [[STRUCT_UINT16X4X4_T]], ptr [[__S1]], i32 0, i32 0
// CHECK-NEXT:    [[ARRAYIDX6:%.*]] = getelementptr inbounds [4 x <4 x i16>], ptr [[VAL5]], i64 0, i64 3
// CHECK-NEXT:    [[TMP16:%.*]] = load <4 x i16>, ptr [[ARRAYIDX6]], align 8
// CHECK-NEXT:    [[TMP17:%.*]] = bitcast <4 x i16> [[TMP16]] to <8 x i8>
// CHECK-NEXT:    [[TMP18:%.*]] = bitcast <8 x i8> [[TMP11]] to <4 x i16>
// CHECK-NEXT:    [[TMP19:%.*]] = bitcast <8 x i8> [[TMP13]] to <4 x i16>
// CHECK-NEXT:    [[TMP20:%.*]] = bitcast <8 x i8> [[TMP15]] to <4 x i16>
// CHECK-NEXT:    [[TMP21:%.*]] = bitcast <8 x i8> [[TMP17]] to <4 x i16>
// CHECK-NEXT:    [[TMP22:%.*]] = ptrtoint ptr [[A]] to i64
// CHECK-NEXT:    [[TMP23:%.*]] = xor i64 [[TMP22]], 193514046488576
// CHECK-NEXT:    [[TMP24:%.*]] = inttoptr i64 [[TMP23]] to ptr
// CHECK-NEXT:    store <16 x i16> zeroinitializer, ptr [[TMP24]], align 1
// CHECK-NEXT:    call void @llvm.aarch64.neon.st4.v4i16.p0(<4 x i16> [[TMP18]], <4 x i16> [[TMP19]], <4 x i16> [[TMP20]], <4 x i16> [[TMP21]], ptr [[A]])
// CHECK-NEXT:    ret void
//
void test_vst4_u16(uint16_t *a, uint16x4x4_t b) {
  vst4_u16(a, b);
}

// CHECK-LABEL: define dso_local void @test_vst4_u32(
// CHECK-SAME: ptr noundef [[A:%.*]], [4 x <2 x i32>] alignstack(8) [[B_COERCE:%.*]]) #[[ATTR0]] {
// CHECK-NEXT:  entry:
// CHECK-NEXT:    call void @llvm.donothing()
// CHECK-NEXT:    [[B:%.*]] = alloca [[STRUCT_UINT32X2X4_T:%.*]], align 8
// CHECK-NEXT:    [[TMP0:%.*]] = ptrtoint ptr [[B]] to i64
// CHECK-NEXT:    [[TMP1:%.*]] = xor i64 [[TMP0]], 193514046488576
// CHECK-NEXT:    [[TMP2:%.*]] = inttoptr i64 [[TMP1]] to ptr
// CHECK-NEXT:    call void @llvm.memset.p0.i64(ptr align 8 [[TMP2]], i8 0, i64 32, i1 false)
// CHECK-NEXT:    [[__S1:%.*]] = alloca [[STRUCT_UINT32X2X4_T]], align 8
// CHECK-NEXT:    [[TMP3:%.*]] = ptrtoint ptr [[__S1]] to i64
// CHECK-NEXT:    [[TMP4:%.*]] = xor i64 [[TMP3]], 193514046488576
// CHECK-NEXT:    [[TMP5:%.*]] = inttoptr i64 [[TMP4]] to ptr
// CHECK-NEXT:    call void @llvm.memset.p0.i64(ptr align 8 [[TMP5]], i8 0, i64 32, i1 false)
// CHECK-NEXT:    [[COERCE_DIVE:%.*]] = getelementptr inbounds [[STRUCT_UINT32X2X4_T]], ptr [[B]], i32 0, i32 0
// CHECK-NEXT:    [[TMP6:%.*]] = ptrtoint ptr [[COERCE_DIVE]] to i64
// CHECK-NEXT:    [[TMP7:%.*]] = xor i64 [[TMP6]], 193514046488576
// CHECK-NEXT:    [[TMP8:%.*]] = inttoptr i64 [[TMP7]] to ptr
// CHECK-NEXT:    store [4 x <2 x i32>] zeroinitializer, ptr [[TMP8]], align 8
// CHECK-NEXT:    store [4 x <2 x i32>] [[B_COERCE]], ptr [[COERCE_DIVE]], align 8
// CHECK-NEXT:    [[TMP9:%.*]] = call ptr @__msan_memcpy(ptr [[__S1]], ptr [[B]], i64 32)
// CHECK-NEXT:    [[VAL:%.*]] = getelementptr inbounds [[STRUCT_UINT32X2X4_T]], ptr [[__S1]], i32 0, i32 0
// CHECK-NEXT:    [[ARRAYIDX:%.*]] = getelementptr inbounds [4 x <2 x i32>], ptr [[VAL]], i64 0, i64 0
// CHECK-NEXT:    [[TMP10:%.*]] = load <2 x i32>, ptr [[ARRAYIDX]], align 8
// CHECK-NEXT:    [[TMP11:%.*]] = bitcast <2 x i32> [[TMP10]] to <8 x i8>
// CHECK-NEXT:    [[VAL1:%.*]] = getelementptr inbounds [[STRUCT_UINT32X2X4_T]], ptr [[__S1]], i32 0, i32 0
// CHECK-NEXT:    [[ARRAYIDX2:%.*]] = getelementptr inbounds [4 x <2 x i32>], ptr [[VAL1]], i64 0, i64 1
// CHECK-NEXT:    [[TMP12:%.*]] = load <2 x i32>, ptr [[ARRAYIDX2]], align 8
// CHECK-NEXT:    [[TMP13:%.*]] = bitcast <2 x i32> [[TMP12]] to <8 x i8>
// CHECK-NEXT:    [[VAL3:%.*]] = getelementptr inbounds [[STRUCT_UINT32X2X4_T]], ptr [[__S1]], i32 0, i32 0
// CHECK-NEXT:    [[ARRAYIDX4:%.*]] = getelementptr inbounds [4 x <2 x i32>], ptr [[VAL3]], i64 0, i64 2
// CHECK-NEXT:    [[TMP14:%.*]] = load <2 x i32>, ptr [[ARRAYIDX4]], align 8
// CHECK-NEXT:    [[TMP15:%.*]] = bitcast <2 x i32> [[TMP14]] to <8 x i8>
// CHECK-NEXT:    [[VAL5:%.*]] = getelementptr inbounds [[STRUCT_UINT32X2X4_T]], ptr [[__S1]], i32 0, i32 0
// CHECK-NEXT:    [[ARRAYIDX6:%.*]] = getelementptr inbounds [4 x <2 x i32>], ptr [[VAL5]], i64 0, i64 3
// CHECK-NEXT:    [[TMP16:%.*]] = load <2 x i32>, ptr [[ARRAYIDX6]], align 8
// CHECK-NEXT:    [[TMP17:%.*]] = bitcast <2 x i32> [[TMP16]] to <8 x i8>
// CHECK-NEXT:    [[TMP18:%.*]] = bitcast <8 x i8> [[TMP11]] to <2 x i32>
// CHECK-NEXT:    [[TMP19:%.*]] = bitcast <8 x i8> [[TMP13]] to <2 x i32>
// CHECK-NEXT:    [[TMP20:%.*]] = bitcast <8 x i8> [[TMP15]] to <2 x i32>
// CHECK-NEXT:    [[TMP21:%.*]] = bitcast <8 x i8> [[TMP17]] to <2 x i32>
// CHECK-NEXT:    [[TMP22:%.*]] = ptrtoint ptr [[A]] to i64
// CHECK-NEXT:    [[TMP23:%.*]] = xor i64 [[TMP22]], 193514046488576
// CHECK-NEXT:    [[TMP24:%.*]] = inttoptr i64 [[TMP23]] to ptr
// CHECK-NEXT:    store <8 x i32> zeroinitializer, ptr [[TMP24]], align 1
// CHECK-NEXT:    call void @llvm.aarch64.neon.st4.v2i32.p0(<2 x i32> [[TMP18]], <2 x i32> [[TMP19]], <2 x i32> [[TMP20]], <2 x i32> [[TMP21]], ptr [[A]])
// CHECK-NEXT:    ret void
//
void test_vst4_u32(uint32_t *a, uint32x2x4_t b) {
  vst4_u32(a, b);
}

// CHECK-LABEL: define dso_local void @test_vst4_u64(
// CHECK-SAME: ptr noundef [[A:%.*]], [4 x <1 x i64>] alignstack(8) [[B_COERCE:%.*]]) #[[ATTR0]] {
// CHECK-NEXT:  entry:
// CHECK-NEXT:    call void @llvm.donothing()
// CHECK-NEXT:    [[B:%.*]] = alloca [[STRUCT_UINT64X1X4_T:%.*]], align 8
// CHECK-NEXT:    [[TMP0:%.*]] = ptrtoint ptr [[B]] to i64
// CHECK-NEXT:    [[TMP1:%.*]] = xor i64 [[TMP0]], 193514046488576
// CHECK-NEXT:    [[TMP2:%.*]] = inttoptr i64 [[TMP1]] to ptr
// CHECK-NEXT:    call void @llvm.memset.p0.i64(ptr align 8 [[TMP2]], i8 0, i64 32, i1 false)
// CHECK-NEXT:    [[__S1:%.*]] = alloca [[STRUCT_UINT64X1X4_T]], align 8
// CHECK-NEXT:    [[TMP3:%.*]] = ptrtoint ptr [[__S1]] to i64
// CHECK-NEXT:    [[TMP4:%.*]] = xor i64 [[TMP3]], 193514046488576
// CHECK-NEXT:    [[TMP5:%.*]] = inttoptr i64 [[TMP4]] to ptr
// CHECK-NEXT:    call void @llvm.memset.p0.i64(ptr align 8 [[TMP5]], i8 0, i64 32, i1 false)
// CHECK-NEXT:    [[COERCE_DIVE:%.*]] = getelementptr inbounds [[STRUCT_UINT64X1X4_T]], ptr [[B]], i32 0, i32 0
// CHECK-NEXT:    [[TMP6:%.*]] = ptrtoint ptr [[COERCE_DIVE]] to i64
// CHECK-NEXT:    [[TMP7:%.*]] = xor i64 [[TMP6]], 193514046488576
// CHECK-NEXT:    [[TMP8:%.*]] = inttoptr i64 [[TMP7]] to ptr
// CHECK-NEXT:    store [4 x <1 x i64>] zeroinitializer, ptr [[TMP8]], align 8
// CHECK-NEXT:    store [4 x <1 x i64>] [[B_COERCE]], ptr [[COERCE_DIVE]], align 8
// CHECK-NEXT:    [[TMP9:%.*]] = call ptr @__msan_memcpy(ptr [[__S1]], ptr [[B]], i64 32)
// CHECK-NEXT:    [[VAL:%.*]] = getelementptr inbounds [[STRUCT_UINT64X1X4_T]], ptr [[__S1]], i32 0, i32 0
// CHECK-NEXT:    [[ARRAYIDX:%.*]] = getelementptr inbounds [4 x <1 x i64>], ptr [[VAL]], i64 0, i64 0
// CHECK-NEXT:    [[TMP10:%.*]] = load <1 x i64>, ptr [[ARRAYIDX]], align 8
// CHECK-NEXT:    [[TMP11:%.*]] = bitcast <1 x i64> [[TMP10]] to <8 x i8>
// CHECK-NEXT:    [[VAL1:%.*]] = getelementptr inbounds [[STRUCT_UINT64X1X4_T]], ptr [[__S1]], i32 0, i32 0
// CHECK-NEXT:    [[ARRAYIDX2:%.*]] = getelementptr inbounds [4 x <1 x i64>], ptr [[VAL1]], i64 0, i64 1
// CHECK-NEXT:    [[TMP12:%.*]] = load <1 x i64>, ptr [[ARRAYIDX2]], align 8
// CHECK-NEXT:    [[TMP13:%.*]] = bitcast <1 x i64> [[TMP12]] to <8 x i8>
// CHECK-NEXT:    [[VAL3:%.*]] = getelementptr inbounds [[STRUCT_UINT64X1X4_T]], ptr [[__S1]], i32 0, i32 0
// CHECK-NEXT:    [[ARRAYIDX4:%.*]] = getelementptr inbounds [4 x <1 x i64>], ptr [[VAL3]], i64 0, i64 2
// CHECK-NEXT:    [[TMP14:%.*]] = load <1 x i64>, ptr [[ARRAYIDX4]], align 8
// CHECK-NEXT:    [[TMP15:%.*]] = bitcast <1 x i64> [[TMP14]] to <8 x i8>
// CHECK-NEXT:    [[VAL5:%.*]] = getelementptr inbounds [[STRUCT_UINT64X1X4_T]], ptr [[__S1]], i32 0, i32 0
// CHECK-NEXT:    [[ARRAYIDX6:%.*]] = getelementptr inbounds [4 x <1 x i64>], ptr [[VAL5]], i64 0, i64 3
// CHECK-NEXT:    [[TMP16:%.*]] = load <1 x i64>, ptr [[ARRAYIDX6]], align 8
// CHECK-NEXT:    [[TMP17:%.*]] = bitcast <1 x i64> [[TMP16]] to <8 x i8>
// CHECK-NEXT:    [[TMP18:%.*]] = bitcast <8 x i8> [[TMP11]] to <1 x i64>
// CHECK-NEXT:    [[TMP19:%.*]] = bitcast <8 x i8> [[TMP13]] to <1 x i64>
// CHECK-NEXT:    [[TMP20:%.*]] = bitcast <8 x i8> [[TMP15]] to <1 x i64>
// CHECK-NEXT:    [[TMP21:%.*]] = bitcast <8 x i8> [[TMP17]] to <1 x i64>
// CHECK-NEXT:    [[TMP22:%.*]] = ptrtoint ptr [[A]] to i64
// CHECK-NEXT:    [[TMP23:%.*]] = xor i64 [[TMP22]], 193514046488576
// CHECK-NEXT:    [[TMP24:%.*]] = inttoptr i64 [[TMP23]] to ptr
// CHECK-NEXT:    store <4 x i64> zeroinitializer, ptr [[TMP24]], align 1
// CHECK-NEXT:    call void @llvm.aarch64.neon.st4.v1i64.p0(<1 x i64> [[TMP18]], <1 x i64> [[TMP19]], <1 x i64> [[TMP20]], <1 x i64> [[TMP21]], ptr [[A]])
// CHECK-NEXT:    ret void
//
void test_vst4_u64(uint64_t *a, uint64x1x4_t b) {
  vst4_u64(a, b);
}

// CHECK-LABEL: define dso_local void @test_vst4_s8(
// CHECK-SAME: ptr noundef [[A:%.*]], [4 x <8 x i8>] alignstack(8) [[B_COERCE:%.*]]) #[[ATTR0]] {
// CHECK-NEXT:  entry:
// CHECK-NEXT:    call void @llvm.donothing()
// CHECK-NEXT:    [[B:%.*]] = alloca [[STRUCT_INT8X8X4_T:%.*]], align 8
// CHECK-NEXT:    [[TMP0:%.*]] = ptrtoint ptr [[B]] to i64
// CHECK-NEXT:    [[TMP1:%.*]] = xor i64 [[TMP0]], 193514046488576
// CHECK-NEXT:    [[TMP2:%.*]] = inttoptr i64 [[TMP1]] to ptr
// CHECK-NEXT:    call void @llvm.memset.p0.i64(ptr align 8 [[TMP2]], i8 0, i64 32, i1 false)
// CHECK-NEXT:    [[__S1:%.*]] = alloca [[STRUCT_INT8X8X4_T]], align 8
// CHECK-NEXT:    [[TMP3:%.*]] = ptrtoint ptr [[__S1]] to i64
// CHECK-NEXT:    [[TMP4:%.*]] = xor i64 [[TMP3]], 193514046488576
// CHECK-NEXT:    [[TMP5:%.*]] = inttoptr i64 [[TMP4]] to ptr
// CHECK-NEXT:    call void @llvm.memset.p0.i64(ptr align 8 [[TMP5]], i8 0, i64 32, i1 false)
// CHECK-NEXT:    [[COERCE_DIVE:%.*]] = getelementptr inbounds [[STRUCT_INT8X8X4_T]], ptr [[B]], i32 0, i32 0
// CHECK-NEXT:    [[TMP6:%.*]] = ptrtoint ptr [[COERCE_DIVE]] to i64
// CHECK-NEXT:    [[TMP7:%.*]] = xor i64 [[TMP6]], 193514046488576
// CHECK-NEXT:    [[TMP8:%.*]] = inttoptr i64 [[TMP7]] to ptr
// CHECK-NEXT:    store [4 x <8 x i8>] zeroinitializer, ptr [[TMP8]], align 8
// CHECK-NEXT:    store [4 x <8 x i8>] [[B_COERCE]], ptr [[COERCE_DIVE]], align 8
// CHECK-NEXT:    [[TMP9:%.*]] = call ptr @__msan_memcpy(ptr [[__S1]], ptr [[B]], i64 32)
// CHECK-NEXT:    [[VAL:%.*]] = getelementptr inbounds [[STRUCT_INT8X8X4_T]], ptr [[__S1]], i32 0, i32 0
// CHECK-NEXT:    [[ARRAYIDX:%.*]] = getelementptr inbounds [4 x <8 x i8>], ptr [[VAL]], i64 0, i64 0
// CHECK-NEXT:    [[TMP10:%.*]] = load <8 x i8>, ptr [[ARRAYIDX]], align 8
// CHECK-NEXT:    [[VAL1:%.*]] = getelementptr inbounds [[STRUCT_INT8X8X4_T]], ptr [[__S1]], i32 0, i32 0
// CHECK-NEXT:    [[ARRAYIDX2:%.*]] = getelementptr inbounds [4 x <8 x i8>], ptr [[VAL1]], i64 0, i64 1
// CHECK-NEXT:    [[TMP11:%.*]] = load <8 x i8>, ptr [[ARRAYIDX2]], align 8
// CHECK-NEXT:    [[VAL3:%.*]] = getelementptr inbounds [[STRUCT_INT8X8X4_T]], ptr [[__S1]], i32 0, i32 0
// CHECK-NEXT:    [[ARRAYIDX4:%.*]] = getelementptr inbounds [4 x <8 x i8>], ptr [[VAL3]], i64 0, i64 2
// CHECK-NEXT:    [[TMP12:%.*]] = load <8 x i8>, ptr [[ARRAYIDX4]], align 8
// CHECK-NEXT:    [[VAL5:%.*]] = getelementptr inbounds [[STRUCT_INT8X8X4_T]], ptr [[__S1]], i32 0, i32 0
// CHECK-NEXT:    [[ARRAYIDX6:%.*]] = getelementptr inbounds [4 x <8 x i8>], ptr [[VAL5]], i64 0, i64 3
// CHECK-NEXT:    [[TMP13:%.*]] = load <8 x i8>, ptr [[ARRAYIDX6]], align 8
// CHECK-NEXT:    [[TMP14:%.*]] = ptrtoint ptr [[A]] to i64
// CHECK-NEXT:    [[TMP15:%.*]] = xor i64 [[TMP14]], 193514046488576
// CHECK-NEXT:    [[TMP16:%.*]] = inttoptr i64 [[TMP15]] to ptr
// CHECK-NEXT:    store <32 x i8> zeroinitializer, ptr [[TMP16]], align 1
// CHECK-NEXT:    call void @llvm.aarch64.neon.st4.v8i8.p0(<8 x i8> [[TMP10]], <8 x i8> [[TMP11]], <8 x i8> [[TMP12]], <8 x i8> [[TMP13]], ptr [[A]])
// CHECK-NEXT:    ret void
//
void test_vst4_s8(int8_t *a, int8x8x4_t b) {
  vst4_s8(a, b);
}

// CHECK-LABEL: define dso_local void @test_vst4_s16(
// CHECK-SAME: ptr noundef [[A:%.*]], [4 x <4 x i16>] alignstack(8) [[B_COERCE:%.*]]) #[[ATTR0]] {
// CHECK-NEXT:  entry:
// CHECK-NEXT:    call void @llvm.donothing()
// CHECK-NEXT:    [[B:%.*]] = alloca [[STRUCT_INT16X4X4_T:%.*]], align 8
// CHECK-NEXT:    [[TMP0:%.*]] = ptrtoint ptr [[B]] to i64
// CHECK-NEXT:    [[TMP1:%.*]] = xor i64 [[TMP0]], 193514046488576
// CHECK-NEXT:    [[TMP2:%.*]] = inttoptr i64 [[TMP1]] to ptr
// CHECK-NEXT:    call void @llvm.memset.p0.i64(ptr align 8 [[TMP2]], i8 0, i64 32, i1 false)
// CHECK-NEXT:    [[__S1:%.*]] = alloca [[STRUCT_INT16X4X4_T]], align 8
// CHECK-NEXT:    [[TMP3:%.*]] = ptrtoint ptr [[__S1]] to i64
// CHECK-NEXT:    [[TMP4:%.*]] = xor i64 [[TMP3]], 193514046488576
// CHECK-NEXT:    [[TMP5:%.*]] = inttoptr i64 [[TMP4]] to ptr
// CHECK-NEXT:    call void @llvm.memset.p0.i64(ptr align 8 [[TMP5]], i8 0, i64 32, i1 false)
// CHECK-NEXT:    [[COERCE_DIVE:%.*]] = getelementptr inbounds [[STRUCT_INT16X4X4_T]], ptr [[B]], i32 0, i32 0
// CHECK-NEXT:    [[TMP6:%.*]] = ptrtoint ptr [[COERCE_DIVE]] to i64
// CHECK-NEXT:    [[TMP7:%.*]] = xor i64 [[TMP6]], 193514046488576
// CHECK-NEXT:    [[TMP8:%.*]] = inttoptr i64 [[TMP7]] to ptr
// CHECK-NEXT:    store [4 x <4 x i16>] zeroinitializer, ptr [[TMP8]], align 8
// CHECK-NEXT:    store [4 x <4 x i16>] [[B_COERCE]], ptr [[COERCE_DIVE]], align 8
// CHECK-NEXT:    [[TMP9:%.*]] = call ptr @__msan_memcpy(ptr [[__S1]], ptr [[B]], i64 32)
// CHECK-NEXT:    [[VAL:%.*]] = getelementptr inbounds [[STRUCT_INT16X4X4_T]], ptr [[__S1]], i32 0, i32 0
// CHECK-NEXT:    [[ARRAYIDX:%.*]] = getelementptr inbounds [4 x <4 x i16>], ptr [[VAL]], i64 0, i64 0
// CHECK-NEXT:    [[TMP10:%.*]] = load <4 x i16>, ptr [[ARRAYIDX]], align 8
// CHECK-NEXT:    [[TMP11:%.*]] = bitcast <4 x i16> [[TMP10]] to <8 x i8>
// CHECK-NEXT:    [[VAL1:%.*]] = getelementptr inbounds [[STRUCT_INT16X4X4_T]], ptr [[__S1]], i32 0, i32 0
// CHECK-NEXT:    [[ARRAYIDX2:%.*]] = getelementptr inbounds [4 x <4 x i16>], ptr [[VAL1]], i64 0, i64 1
// CHECK-NEXT:    [[TMP12:%.*]] = load <4 x i16>, ptr [[ARRAYIDX2]], align 8
// CHECK-NEXT:    [[TMP13:%.*]] = bitcast <4 x i16> [[TMP12]] to <8 x i8>
// CHECK-NEXT:    [[VAL3:%.*]] = getelementptr inbounds [[STRUCT_INT16X4X4_T]], ptr [[__S1]], i32 0, i32 0
// CHECK-NEXT:    [[ARRAYIDX4:%.*]] = getelementptr inbounds [4 x <4 x i16>], ptr [[VAL3]], i64 0, i64 2
// CHECK-NEXT:    [[TMP14:%.*]] = load <4 x i16>, ptr [[ARRAYIDX4]], align 8
// CHECK-NEXT:    [[TMP15:%.*]] = bitcast <4 x i16> [[TMP14]] to <8 x i8>
// CHECK-NEXT:    [[VAL5:%.*]] = getelementptr inbounds [[STRUCT_INT16X4X4_T]], ptr [[__S1]], i32 0, i32 0
// CHECK-NEXT:    [[ARRAYIDX6:%.*]] = getelementptr inbounds [4 x <4 x i16>], ptr [[VAL5]], i64 0, i64 3
// CHECK-NEXT:    [[TMP16:%.*]] = load <4 x i16>, ptr [[ARRAYIDX6]], align 8
// CHECK-NEXT:    [[TMP17:%.*]] = bitcast <4 x i16> [[TMP16]] to <8 x i8>
// CHECK-NEXT:    [[TMP18:%.*]] = bitcast <8 x i8> [[TMP11]] to <4 x i16>
// CHECK-NEXT:    [[TMP19:%.*]] = bitcast <8 x i8> [[TMP13]] to <4 x i16>
// CHECK-NEXT:    [[TMP20:%.*]] = bitcast <8 x i8> [[TMP15]] to <4 x i16>
// CHECK-NEXT:    [[TMP21:%.*]] = bitcast <8 x i8> [[TMP17]] to <4 x i16>
// CHECK-NEXT:    [[TMP22:%.*]] = ptrtoint ptr [[A]] to i64
// CHECK-NEXT:    [[TMP23:%.*]] = xor i64 [[TMP22]], 193514046488576
// CHECK-NEXT:    [[TMP24:%.*]] = inttoptr i64 [[TMP23]] to ptr
// CHECK-NEXT:    store <16 x i16> zeroinitializer, ptr [[TMP24]], align 1
// CHECK-NEXT:    call void @llvm.aarch64.neon.st4.v4i16.p0(<4 x i16> [[TMP18]], <4 x i16> [[TMP19]], <4 x i16> [[TMP20]], <4 x i16> [[TMP21]], ptr [[A]])
// CHECK-NEXT:    ret void
//
void test_vst4_s16(int16_t *a, int16x4x4_t b) {
  vst4_s16(a, b);
}

// CHECK-LABEL: define dso_local void @test_vst4_s32(
// CHECK-SAME: ptr noundef [[A:%.*]], [4 x <2 x i32>] alignstack(8) [[B_COERCE:%.*]]) #[[ATTR0]] {
// CHECK-NEXT:  entry:
// CHECK-NEXT:    call void @llvm.donothing()
// CHECK-NEXT:    [[B:%.*]] = alloca [[STRUCT_INT32X2X4_T:%.*]], align 8
// CHECK-NEXT:    [[TMP0:%.*]] = ptrtoint ptr [[B]] to i64
// CHECK-NEXT:    [[TMP1:%.*]] = xor i64 [[TMP0]], 193514046488576
// CHECK-NEXT:    [[TMP2:%.*]] = inttoptr i64 [[TMP1]] to ptr
// CHECK-NEXT:    call void @llvm.memset.p0.i64(ptr align 8 [[TMP2]], i8 0, i64 32, i1 false)
// CHECK-NEXT:    [[__S1:%.*]] = alloca [[STRUCT_INT32X2X4_T]], align 8
// CHECK-NEXT:    [[TMP3:%.*]] = ptrtoint ptr [[__S1]] to i64
// CHECK-NEXT:    [[TMP4:%.*]] = xor i64 [[TMP3]], 193514046488576
// CHECK-NEXT:    [[TMP5:%.*]] = inttoptr i64 [[TMP4]] to ptr
// CHECK-NEXT:    call void @llvm.memset.p0.i64(ptr align 8 [[TMP5]], i8 0, i64 32, i1 false)
// CHECK-NEXT:    [[COERCE_DIVE:%.*]] = getelementptr inbounds [[STRUCT_INT32X2X4_T]], ptr [[B]], i32 0, i32 0
// CHECK-NEXT:    [[TMP6:%.*]] = ptrtoint ptr [[COERCE_DIVE]] to i64
// CHECK-NEXT:    [[TMP7:%.*]] = xor i64 [[TMP6]], 193514046488576
// CHECK-NEXT:    [[TMP8:%.*]] = inttoptr i64 [[TMP7]] to ptr
// CHECK-NEXT:    store [4 x <2 x i32>] zeroinitializer, ptr [[TMP8]], align 8
// CHECK-NEXT:    store [4 x <2 x i32>] [[B_COERCE]], ptr [[COERCE_DIVE]], align 8
// CHECK-NEXT:    [[TMP9:%.*]] = call ptr @__msan_memcpy(ptr [[__S1]], ptr [[B]], i64 32)
// CHECK-NEXT:    [[VAL:%.*]] = getelementptr inbounds [[STRUCT_INT32X2X4_T]], ptr [[__S1]], i32 0, i32 0
// CHECK-NEXT:    [[ARRAYIDX:%.*]] = getelementptr inbounds [4 x <2 x i32>], ptr [[VAL]], i64 0, i64 0
// CHECK-NEXT:    [[TMP10:%.*]] = load <2 x i32>, ptr [[ARRAYIDX]], align 8
// CHECK-NEXT:    [[TMP11:%.*]] = bitcast <2 x i32> [[TMP10]] to <8 x i8>
// CHECK-NEXT:    [[VAL1:%.*]] = getelementptr inbounds [[STRUCT_INT32X2X4_T]], ptr [[__S1]], i32 0, i32 0
// CHECK-NEXT:    [[ARRAYIDX2:%.*]] = getelementptr inbounds [4 x <2 x i32>], ptr [[VAL1]], i64 0, i64 1
// CHECK-NEXT:    [[TMP12:%.*]] = load <2 x i32>, ptr [[ARRAYIDX2]], align 8
// CHECK-NEXT:    [[TMP13:%.*]] = bitcast <2 x i32> [[TMP12]] to <8 x i8>
// CHECK-NEXT:    [[VAL3:%.*]] = getelementptr inbounds [[STRUCT_INT32X2X4_T]], ptr [[__S1]], i32 0, i32 0
// CHECK-NEXT:    [[ARRAYIDX4:%.*]] = getelementptr inbounds [4 x <2 x i32>], ptr [[VAL3]], i64 0, i64 2
// CHECK-NEXT:    [[TMP14:%.*]] = load <2 x i32>, ptr [[ARRAYIDX4]], align 8
// CHECK-NEXT:    [[TMP15:%.*]] = bitcast <2 x i32> [[TMP14]] to <8 x i8>
// CHECK-NEXT:    [[VAL5:%.*]] = getelementptr inbounds [[STRUCT_INT32X2X4_T]], ptr [[__S1]], i32 0, i32 0
// CHECK-NEXT:    [[ARRAYIDX6:%.*]] = getelementptr inbounds [4 x <2 x i32>], ptr [[VAL5]], i64 0, i64 3
// CHECK-NEXT:    [[TMP16:%.*]] = load <2 x i32>, ptr [[ARRAYIDX6]], align 8
// CHECK-NEXT:    [[TMP17:%.*]] = bitcast <2 x i32> [[TMP16]] to <8 x i8>
// CHECK-NEXT:    [[TMP18:%.*]] = bitcast <8 x i8> [[TMP11]] to <2 x i32>
// CHECK-NEXT:    [[TMP19:%.*]] = bitcast <8 x i8> [[TMP13]] to <2 x i32>
// CHECK-NEXT:    [[TMP20:%.*]] = bitcast <8 x i8> [[TMP15]] to <2 x i32>
// CHECK-NEXT:    [[TMP21:%.*]] = bitcast <8 x i8> [[TMP17]] to <2 x i32>
// CHECK-NEXT:    [[TMP22:%.*]] = ptrtoint ptr [[A]] to i64
// CHECK-NEXT:    [[TMP23:%.*]] = xor i64 [[TMP22]], 193514046488576
// CHECK-NEXT:    [[TMP24:%.*]] = inttoptr i64 [[TMP23]] to ptr
// CHECK-NEXT:    store <8 x i32> zeroinitializer, ptr [[TMP24]], align 1
// CHECK-NEXT:    call void @llvm.aarch64.neon.st4.v2i32.p0(<2 x i32> [[TMP18]], <2 x i32> [[TMP19]], <2 x i32> [[TMP20]], <2 x i32> [[TMP21]], ptr [[A]])
// CHECK-NEXT:    ret void
//
void test_vst4_s32(int32_t *a, int32x2x4_t b) {
  vst4_s32(a, b);
}

// CHECK-LABEL: define dso_local void @test_vst4_s64(
// CHECK-SAME: ptr noundef [[A:%.*]], [4 x <1 x i64>] alignstack(8) [[B_COERCE:%.*]]) #[[ATTR0]] {
// CHECK-NEXT:  entry:
// CHECK-NEXT:    call void @llvm.donothing()
// CHECK-NEXT:    [[B:%.*]] = alloca [[STRUCT_INT64X1X4_T:%.*]], align 8
// CHECK-NEXT:    [[TMP0:%.*]] = ptrtoint ptr [[B]] to i64
// CHECK-NEXT:    [[TMP1:%.*]] = xor i64 [[TMP0]], 193514046488576
// CHECK-NEXT:    [[TMP2:%.*]] = inttoptr i64 [[TMP1]] to ptr
// CHECK-NEXT:    call void @llvm.memset.p0.i64(ptr align 8 [[TMP2]], i8 0, i64 32, i1 false)
// CHECK-NEXT:    [[__S1:%.*]] = alloca [[STRUCT_INT64X1X4_T]], align 8
// CHECK-NEXT:    [[TMP3:%.*]] = ptrtoint ptr [[__S1]] to i64
// CHECK-NEXT:    [[TMP4:%.*]] = xor i64 [[TMP3]], 193514046488576
// CHECK-NEXT:    [[TMP5:%.*]] = inttoptr i64 [[TMP4]] to ptr
// CHECK-NEXT:    call void @llvm.memset.p0.i64(ptr align 8 [[TMP5]], i8 0, i64 32, i1 false)
// CHECK-NEXT:    [[COERCE_DIVE:%.*]] = getelementptr inbounds [[STRUCT_INT64X1X4_T]], ptr [[B]], i32 0, i32 0
// CHECK-NEXT:    [[TMP6:%.*]] = ptrtoint ptr [[COERCE_DIVE]] to i64
// CHECK-NEXT:    [[TMP7:%.*]] = xor i64 [[TMP6]], 193514046488576
// CHECK-NEXT:    [[TMP8:%.*]] = inttoptr i64 [[TMP7]] to ptr
// CHECK-NEXT:    store [4 x <1 x i64>] zeroinitializer, ptr [[TMP8]], align 8
// CHECK-NEXT:    store [4 x <1 x i64>] [[B_COERCE]], ptr [[COERCE_DIVE]], align 8
// CHECK-NEXT:    [[TMP9:%.*]] = call ptr @__msan_memcpy(ptr [[__S1]], ptr [[B]], i64 32)
// CHECK-NEXT:    [[VAL:%.*]] = getelementptr inbounds [[STRUCT_INT64X1X4_T]], ptr [[__S1]], i32 0, i32 0
// CHECK-NEXT:    [[ARRAYIDX:%.*]] = getelementptr inbounds [4 x <1 x i64>], ptr [[VAL]], i64 0, i64 0
// CHECK-NEXT:    [[TMP10:%.*]] = load <1 x i64>, ptr [[ARRAYIDX]], align 8
// CHECK-NEXT:    [[TMP11:%.*]] = bitcast <1 x i64> [[TMP10]] to <8 x i8>
// CHECK-NEXT:    [[VAL1:%.*]] = getelementptr inbounds [[STRUCT_INT64X1X4_T]], ptr [[__S1]], i32 0, i32 0
// CHECK-NEXT:    [[ARRAYIDX2:%.*]] = getelementptr inbounds [4 x <1 x i64>], ptr [[VAL1]], i64 0, i64 1
// CHECK-NEXT:    [[TMP12:%.*]] = load <1 x i64>, ptr [[ARRAYIDX2]], align 8
// CHECK-NEXT:    [[TMP13:%.*]] = bitcast <1 x i64> [[TMP12]] to <8 x i8>
// CHECK-NEXT:    [[VAL3:%.*]] = getelementptr inbounds [[STRUCT_INT64X1X4_T]], ptr [[__S1]], i32 0, i32 0
// CHECK-NEXT:    [[ARRAYIDX4:%.*]] = getelementptr inbounds [4 x <1 x i64>], ptr [[VAL3]], i64 0, i64 2
// CHECK-NEXT:    [[TMP14:%.*]] = load <1 x i64>, ptr [[ARRAYIDX4]], align 8
// CHECK-NEXT:    [[TMP15:%.*]] = bitcast <1 x i64> [[TMP14]] to <8 x i8>
// CHECK-NEXT:    [[VAL5:%.*]] = getelementptr inbounds [[STRUCT_INT64X1X4_T]], ptr [[__S1]], i32 0, i32 0
// CHECK-NEXT:    [[ARRAYIDX6:%.*]] = getelementptr inbounds [4 x <1 x i64>], ptr [[VAL5]], i64 0, i64 3
// CHECK-NEXT:    [[TMP16:%.*]] = load <1 x i64>, ptr [[ARRAYIDX6]], align 8
// CHECK-NEXT:    [[TMP17:%.*]] = bitcast <1 x i64> [[TMP16]] to <8 x i8>
// CHECK-NEXT:    [[TMP18:%.*]] = bitcast <8 x i8> [[TMP11]] to <1 x i64>
// CHECK-NEXT:    [[TMP19:%.*]] = bitcast <8 x i8> [[TMP13]] to <1 x i64>
// CHECK-NEXT:    [[TMP20:%.*]] = bitcast <8 x i8> [[TMP15]] to <1 x i64>
// CHECK-NEXT:    [[TMP21:%.*]] = bitcast <8 x i8> [[TMP17]] to <1 x i64>
// CHECK-NEXT:    [[TMP22:%.*]] = ptrtoint ptr [[A]] to i64
// CHECK-NEXT:    [[TMP23:%.*]] = xor i64 [[TMP22]], 193514046488576
// CHECK-NEXT:    [[TMP24:%.*]] = inttoptr i64 [[TMP23]] to ptr
// CHECK-NEXT:    store <4 x i64> zeroinitializer, ptr [[TMP24]], align 1
// CHECK-NEXT:    call void @llvm.aarch64.neon.st4.v1i64.p0(<1 x i64> [[TMP18]], <1 x i64> [[TMP19]], <1 x i64> [[TMP20]], <1 x i64> [[TMP21]], ptr [[A]])
// CHECK-NEXT:    ret void
//
void test_vst4_s64(int64_t *a, int64x1x4_t b) {
  vst4_s64(a, b);
}

// CHECK-LABEL: define dso_local void @test_vst4_f16(
// CHECK-SAME: ptr noundef [[A:%.*]], [4 x <4 x half>] alignstack(8) [[B_COERCE:%.*]]) #[[ATTR0]] {
// CHECK-NEXT:  entry:
// CHECK-NEXT:    call void @llvm.donothing()
// CHECK-NEXT:    [[B:%.*]] = alloca [[STRUCT_FLOAT16X4X4_T:%.*]], align 8
// CHECK-NEXT:    [[TMP0:%.*]] = ptrtoint ptr [[B]] to i64
// CHECK-NEXT:    [[TMP1:%.*]] = xor i64 [[TMP0]], 193514046488576
// CHECK-NEXT:    [[TMP2:%.*]] = inttoptr i64 [[TMP1]] to ptr
// CHECK-NEXT:    call void @llvm.memset.p0.i64(ptr align 8 [[TMP2]], i8 0, i64 32, i1 false)
// CHECK-NEXT:    [[__S1:%.*]] = alloca [[STRUCT_FLOAT16X4X4_T]], align 8
// CHECK-NEXT:    [[TMP3:%.*]] = ptrtoint ptr [[__S1]] to i64
// CHECK-NEXT:    [[TMP4:%.*]] = xor i64 [[TMP3]], 193514046488576
// CHECK-NEXT:    [[TMP5:%.*]] = inttoptr i64 [[TMP4]] to ptr
// CHECK-NEXT:    call void @llvm.memset.p0.i64(ptr align 8 [[TMP5]], i8 0, i64 32, i1 false)
// CHECK-NEXT:    [[COERCE_DIVE:%.*]] = getelementptr inbounds [[STRUCT_FLOAT16X4X4_T]], ptr [[B]], i32 0, i32 0
// CHECK-NEXT:    [[TMP6:%.*]] = ptrtoint ptr [[COERCE_DIVE]] to i64
// CHECK-NEXT:    [[TMP7:%.*]] = xor i64 [[TMP6]], 193514046488576
// CHECK-NEXT:    [[TMP8:%.*]] = inttoptr i64 [[TMP7]] to ptr
// CHECK-NEXT:    store [4 x <4 x i16>] zeroinitializer, ptr [[TMP8]], align 8
// CHECK-NEXT:    store [4 x <4 x half>] [[B_COERCE]], ptr [[COERCE_DIVE]], align 8
// CHECK-NEXT:    [[TMP9:%.*]] = call ptr @__msan_memcpy(ptr [[__S1]], ptr [[B]], i64 32)
// CHECK-NEXT:    [[VAL:%.*]] = getelementptr inbounds [[STRUCT_FLOAT16X4X4_T]], ptr [[__S1]], i32 0, i32 0
// CHECK-NEXT:    [[ARRAYIDX:%.*]] = getelementptr inbounds [4 x <4 x half>], ptr [[VAL]], i64 0, i64 0
// CHECK-NEXT:    [[TMP10:%.*]] = load <4 x half>, ptr [[ARRAYIDX]], align 8
// CHECK-NEXT:    [[TMP11:%.*]] = bitcast <4 x half> [[TMP10]] to <8 x i8>
// CHECK-NEXT:    [[VAL1:%.*]] = getelementptr inbounds [[STRUCT_FLOAT16X4X4_T]], ptr [[__S1]], i32 0, i32 0
// CHECK-NEXT:    [[ARRAYIDX2:%.*]] = getelementptr inbounds [4 x <4 x half>], ptr [[VAL1]], i64 0, i64 1
// CHECK-NEXT:    [[TMP12:%.*]] = load <4 x half>, ptr [[ARRAYIDX2]], align 8
// CHECK-NEXT:    [[TMP13:%.*]] = bitcast <4 x half> [[TMP12]] to <8 x i8>
// CHECK-NEXT:    [[VAL3:%.*]] = getelementptr inbounds [[STRUCT_FLOAT16X4X4_T]], ptr [[__S1]], i32 0, i32 0
// CHECK-NEXT:    [[ARRAYIDX4:%.*]] = getelementptr inbounds [4 x <4 x half>], ptr [[VAL3]], i64 0, i64 2
// CHECK-NEXT:    [[TMP14:%.*]] = load <4 x half>, ptr [[ARRAYIDX4]], align 8
// CHECK-NEXT:    [[TMP15:%.*]] = bitcast <4 x half> [[TMP14]] to <8 x i8>
// CHECK-NEXT:    [[VAL5:%.*]] = getelementptr inbounds [[STRUCT_FLOAT16X4X4_T]], ptr [[__S1]], i32 0, i32 0
// CHECK-NEXT:    [[ARRAYIDX6:%.*]] = getelementptr inbounds [4 x <4 x half>], ptr [[VAL5]], i64 0, i64 3
// CHECK-NEXT:    [[TMP16:%.*]] = load <4 x half>, ptr [[ARRAYIDX6]], align 8
// CHECK-NEXT:    [[TMP17:%.*]] = bitcast <4 x half> [[TMP16]] to <8 x i8>
// CHECK-NEXT:    [[TMP18:%.*]] = bitcast <8 x i8> [[TMP11]] to <4 x half>
// CHECK-NEXT:    [[TMP19:%.*]] = bitcast <8 x i8> [[TMP13]] to <4 x half>
// CHECK-NEXT:    [[TMP20:%.*]] = bitcast <8 x i8> [[TMP15]] to <4 x half>
// CHECK-NEXT:    [[TMP21:%.*]] = bitcast <8 x i8> [[TMP17]] to <4 x half>
// CHECK-NEXT:    [[TMP22:%.*]] = ptrtoint ptr [[A]] to i64
// CHECK-NEXT:    [[TMP23:%.*]] = xor i64 [[TMP22]], 193514046488576
// CHECK-NEXT:    [[TMP24:%.*]] = inttoptr i64 [[TMP23]] to ptr
// CHECK-NEXT:    store <16 x i16> zeroinitializer, ptr [[TMP24]], align 1
// CHECK-NEXT:    call void @llvm.aarch64.neon.st4.v4f16.p0(<4 x half> [[TMP18]], <4 x half> [[TMP19]], <4 x half> [[TMP20]], <4 x half> [[TMP21]], ptr [[A]])
// CHECK-NEXT:    ret void
//
void test_vst4_f16(float16_t *a, float16x4x4_t b) {
  vst4_f16(a, b);
}

// CHECK-LABEL: define dso_local void @test_vst4_f32(
// CHECK-SAME: ptr noundef [[A:%.*]], [4 x <2 x float>] alignstack(8) [[B_COERCE:%.*]]) #[[ATTR0]] {
// CHECK-NEXT:  entry:
// CHECK-NEXT:    call void @llvm.donothing()
// CHECK-NEXT:    [[B:%.*]] = alloca [[STRUCT_FLOAT32X2X4_T:%.*]], align 8
// CHECK-NEXT:    [[TMP0:%.*]] = ptrtoint ptr [[B]] to i64
// CHECK-NEXT:    [[TMP1:%.*]] = xor i64 [[TMP0]], 193514046488576
// CHECK-NEXT:    [[TMP2:%.*]] = inttoptr i64 [[TMP1]] to ptr
// CHECK-NEXT:    call void @llvm.memset.p0.i64(ptr align 8 [[TMP2]], i8 0, i64 32, i1 false)
// CHECK-NEXT:    [[__S1:%.*]] = alloca [[STRUCT_FLOAT32X2X4_T]], align 8
// CHECK-NEXT:    [[TMP3:%.*]] = ptrtoint ptr [[__S1]] to i64
// CHECK-NEXT:    [[TMP4:%.*]] = xor i64 [[TMP3]], 193514046488576
// CHECK-NEXT:    [[TMP5:%.*]] = inttoptr i64 [[TMP4]] to ptr
// CHECK-NEXT:    call void @llvm.memset.p0.i64(ptr align 8 [[TMP5]], i8 0, i64 32, i1 false)
// CHECK-NEXT:    [[COERCE_DIVE:%.*]] = getelementptr inbounds [[STRUCT_FLOAT32X2X4_T]], ptr [[B]], i32 0, i32 0
// CHECK-NEXT:    [[TMP6:%.*]] = ptrtoint ptr [[COERCE_DIVE]] to i64
// CHECK-NEXT:    [[TMP7:%.*]] = xor i64 [[TMP6]], 193514046488576
// CHECK-NEXT:    [[TMP8:%.*]] = inttoptr i64 [[TMP7]] to ptr
// CHECK-NEXT:    store [4 x <2 x i32>] zeroinitializer, ptr [[TMP8]], align 8
// CHECK-NEXT:    store [4 x <2 x float>] [[B_COERCE]], ptr [[COERCE_DIVE]], align 8
// CHECK-NEXT:    [[TMP9:%.*]] = call ptr @__msan_memcpy(ptr [[__S1]], ptr [[B]], i64 32)
// CHECK-NEXT:    [[VAL:%.*]] = getelementptr inbounds [[STRUCT_FLOAT32X2X4_T]], ptr [[__S1]], i32 0, i32 0
// CHECK-NEXT:    [[ARRAYIDX:%.*]] = getelementptr inbounds [4 x <2 x float>], ptr [[VAL]], i64 0, i64 0
// CHECK-NEXT:    [[TMP10:%.*]] = load <2 x float>, ptr [[ARRAYIDX]], align 8
// CHECK-NEXT:    [[TMP11:%.*]] = bitcast <2 x float> [[TMP10]] to <8 x i8>
// CHECK-NEXT:    [[VAL1:%.*]] = getelementptr inbounds [[STRUCT_FLOAT32X2X4_T]], ptr [[__S1]], i32 0, i32 0
// CHECK-NEXT:    [[ARRAYIDX2:%.*]] = getelementptr inbounds [4 x <2 x float>], ptr [[VAL1]], i64 0, i64 1
// CHECK-NEXT:    [[TMP12:%.*]] = load <2 x float>, ptr [[ARRAYIDX2]], align 8
// CHECK-NEXT:    [[TMP13:%.*]] = bitcast <2 x float> [[TMP12]] to <8 x i8>
// CHECK-NEXT:    [[VAL3:%.*]] = getelementptr inbounds [[STRUCT_FLOAT32X2X4_T]], ptr [[__S1]], i32 0, i32 0
// CHECK-NEXT:    [[ARRAYIDX4:%.*]] = getelementptr inbounds [4 x <2 x float>], ptr [[VAL3]], i64 0, i64 2
// CHECK-NEXT:    [[TMP14:%.*]] = load <2 x float>, ptr [[ARRAYIDX4]], align 8
// CHECK-NEXT:    [[TMP15:%.*]] = bitcast <2 x float> [[TMP14]] to <8 x i8>
// CHECK-NEXT:    [[VAL5:%.*]] = getelementptr inbounds [[STRUCT_FLOAT32X2X4_T]], ptr [[__S1]], i32 0, i32 0
// CHECK-NEXT:    [[ARRAYIDX6:%.*]] = getelementptr inbounds [4 x <2 x float>], ptr [[VAL5]], i64 0, i64 3
// CHECK-NEXT:    [[TMP16:%.*]] = load <2 x float>, ptr [[ARRAYIDX6]], align 8
// CHECK-NEXT:    [[TMP17:%.*]] = bitcast <2 x float> [[TMP16]] to <8 x i8>
// CHECK-NEXT:    [[TMP18:%.*]] = bitcast <8 x i8> [[TMP11]] to <2 x float>
// CHECK-NEXT:    [[TMP19:%.*]] = bitcast <8 x i8> [[TMP13]] to <2 x float>
// CHECK-NEXT:    [[TMP20:%.*]] = bitcast <8 x i8> [[TMP15]] to <2 x float>
// CHECK-NEXT:    [[TMP21:%.*]] = bitcast <8 x i8> [[TMP17]] to <2 x float>
// CHECK-NEXT:    [[TMP22:%.*]] = ptrtoint ptr [[A]] to i64
// CHECK-NEXT:    [[TMP23:%.*]] = xor i64 [[TMP22]], 193514046488576
// CHECK-NEXT:    [[TMP24:%.*]] = inttoptr i64 [[TMP23]] to ptr
// CHECK-NEXT:    store <8 x i32> zeroinitializer, ptr [[TMP24]], align 1
// CHECK-NEXT:    call void @llvm.aarch64.neon.st4.v2f32.p0(<2 x float> [[TMP18]], <2 x float> [[TMP19]], <2 x float> [[TMP20]], <2 x float> [[TMP21]], ptr [[A]])
// CHECK-NEXT:    ret void
//
void test_vst4_f32(float32_t *a, float32x2x4_t b) {
  vst4_f32(a, b);
}

// CHECK-LABEL: define dso_local void @test_vst4_f64(
// CHECK-SAME: ptr noundef [[A:%.*]], [4 x <1 x double>] alignstack(8) [[B_COERCE:%.*]]) #[[ATTR0]] {
// CHECK-NEXT:  entry:
// CHECK-NEXT:    call void @llvm.donothing()
// CHECK-NEXT:    [[B:%.*]] = alloca [[STRUCT_FLOAT64X1X4_T:%.*]], align 8
// CHECK-NEXT:    [[TMP0:%.*]] = ptrtoint ptr [[B]] to i64
// CHECK-NEXT:    [[TMP1:%.*]] = xor i64 [[TMP0]], 193514046488576
// CHECK-NEXT:    [[TMP2:%.*]] = inttoptr i64 [[TMP1]] to ptr
// CHECK-NEXT:    call void @llvm.memset.p0.i64(ptr align 8 [[TMP2]], i8 0, i64 32, i1 false)
// CHECK-NEXT:    [[__S1:%.*]] = alloca [[STRUCT_FLOAT64X1X4_T]], align 8
// CHECK-NEXT:    [[TMP3:%.*]] = ptrtoint ptr [[__S1]] to i64
// CHECK-NEXT:    [[TMP4:%.*]] = xor i64 [[TMP3]], 193514046488576
// CHECK-NEXT:    [[TMP5:%.*]] = inttoptr i64 [[TMP4]] to ptr
// CHECK-NEXT:    call void @llvm.memset.p0.i64(ptr align 8 [[TMP5]], i8 0, i64 32, i1 false)
// CHECK-NEXT:    [[COERCE_DIVE:%.*]] = getelementptr inbounds [[STRUCT_FLOAT64X1X4_T]], ptr [[B]], i32 0, i32 0
// CHECK-NEXT:    [[TMP6:%.*]] = ptrtoint ptr [[COERCE_DIVE]] to i64
// CHECK-NEXT:    [[TMP7:%.*]] = xor i64 [[TMP6]], 193514046488576
// CHECK-NEXT:    [[TMP8:%.*]] = inttoptr i64 [[TMP7]] to ptr
// CHECK-NEXT:    store [4 x <1 x i64>] zeroinitializer, ptr [[TMP8]], align 8
// CHECK-NEXT:    store [4 x <1 x double>] [[B_COERCE]], ptr [[COERCE_DIVE]], align 8
// CHECK-NEXT:    [[TMP9:%.*]] = call ptr @__msan_memcpy(ptr [[__S1]], ptr [[B]], i64 32)
// CHECK-NEXT:    [[VAL:%.*]] = getelementptr inbounds [[STRUCT_FLOAT64X1X4_T]], ptr [[__S1]], i32 0, i32 0
// CHECK-NEXT:    [[ARRAYIDX:%.*]] = getelementptr inbounds [4 x <1 x double>], ptr [[VAL]], i64 0, i64 0
// CHECK-NEXT:    [[TMP10:%.*]] = load <1 x double>, ptr [[ARRAYIDX]], align 8
// CHECK-NEXT:    [[TMP11:%.*]] = bitcast <1 x double> [[TMP10]] to <8 x i8>
// CHECK-NEXT:    [[VAL1:%.*]] = getelementptr inbounds [[STRUCT_FLOAT64X1X4_T]], ptr [[__S1]], i32 0, i32 0
// CHECK-NEXT:    [[ARRAYIDX2:%.*]] = getelementptr inbounds [4 x <1 x double>], ptr [[VAL1]], i64 0, i64 1
// CHECK-NEXT:    [[TMP12:%.*]] = load <1 x double>, ptr [[ARRAYIDX2]], align 8
// CHECK-NEXT:    [[TMP13:%.*]] = bitcast <1 x double> [[TMP12]] to <8 x i8>
// CHECK-NEXT:    [[VAL3:%.*]] = getelementptr inbounds [[STRUCT_FLOAT64X1X4_T]], ptr [[__S1]], i32 0, i32 0
// CHECK-NEXT:    [[ARRAYIDX4:%.*]] = getelementptr inbounds [4 x <1 x double>], ptr [[VAL3]], i64 0, i64 2
// CHECK-NEXT:    [[TMP14:%.*]] = load <1 x double>, ptr [[ARRAYIDX4]], align 8
// CHECK-NEXT:    [[TMP15:%.*]] = bitcast <1 x double> [[TMP14]] to <8 x i8>
// CHECK-NEXT:    [[VAL5:%.*]] = getelementptr inbounds [[STRUCT_FLOAT64X1X4_T]], ptr [[__S1]], i32 0, i32 0
// CHECK-NEXT:    [[ARRAYIDX6:%.*]] = getelementptr inbounds [4 x <1 x double>], ptr [[VAL5]], i64 0, i64 3
// CHECK-NEXT:    [[TMP16:%.*]] = load <1 x double>, ptr [[ARRAYIDX6]], align 8
// CHECK-NEXT:    [[TMP17:%.*]] = bitcast <1 x double> [[TMP16]] to <8 x i8>
// CHECK-NEXT:    [[TMP18:%.*]] = bitcast <8 x i8> [[TMP11]] to <1 x double>
// CHECK-NEXT:    [[TMP19:%.*]] = bitcast <8 x i8> [[TMP13]] to <1 x double>
// CHECK-NEXT:    [[TMP20:%.*]] = bitcast <8 x i8> [[TMP15]] to <1 x double>
// CHECK-NEXT:    [[TMP21:%.*]] = bitcast <8 x i8> [[TMP17]] to <1 x double>
// CHECK-NEXT:    [[TMP22:%.*]] = ptrtoint ptr [[A]] to i64
// CHECK-NEXT:    [[TMP23:%.*]] = xor i64 [[TMP22]], 193514046488576
// CHECK-NEXT:    [[TMP24:%.*]] = inttoptr i64 [[TMP23]] to ptr
// CHECK-NEXT:    store <4 x i64> zeroinitializer, ptr [[TMP24]], align 1
// CHECK-NEXT:    call void @llvm.aarch64.neon.st4.v1f64.p0(<1 x double> [[TMP18]], <1 x double> [[TMP19]], <1 x double> [[TMP20]], <1 x double> [[TMP21]], ptr [[A]])
// CHECK-NEXT:    ret void
//
void test_vst4_f64(float64_t *a, float64x1x4_t b) {
  vst4_f64(a, b);
}

// CHECK-LABEL: define dso_local void @test_vst4_p8(
// CHECK-SAME: ptr noundef [[A:%.*]], [4 x <8 x i8>] alignstack(8) [[B_COERCE:%.*]]) #[[ATTR0]] {
// CHECK-NEXT:  entry:
// CHECK-NEXT:    call void @llvm.donothing()
// CHECK-NEXT:    [[B:%.*]] = alloca [[STRUCT_POLY8X8X4_T:%.*]], align 8
// CHECK-NEXT:    [[TMP0:%.*]] = ptrtoint ptr [[B]] to i64
// CHECK-NEXT:    [[TMP1:%.*]] = xor i64 [[TMP0]], 193514046488576
// CHECK-NEXT:    [[TMP2:%.*]] = inttoptr i64 [[TMP1]] to ptr
// CHECK-NEXT:    call void @llvm.memset.p0.i64(ptr align 8 [[TMP2]], i8 0, i64 32, i1 false)
// CHECK-NEXT:    [[__S1:%.*]] = alloca [[STRUCT_POLY8X8X4_T]], align 8
// CHECK-NEXT:    [[TMP3:%.*]] = ptrtoint ptr [[__S1]] to i64
// CHECK-NEXT:    [[TMP4:%.*]] = xor i64 [[TMP3]], 193514046488576
// CHECK-NEXT:    [[TMP5:%.*]] = inttoptr i64 [[TMP4]] to ptr
// CHECK-NEXT:    call void @llvm.memset.p0.i64(ptr align 8 [[TMP5]], i8 0, i64 32, i1 false)
// CHECK-NEXT:    [[COERCE_DIVE:%.*]] = getelementptr inbounds [[STRUCT_POLY8X8X4_T]], ptr [[B]], i32 0, i32 0
// CHECK-NEXT:    [[TMP6:%.*]] = ptrtoint ptr [[COERCE_DIVE]] to i64
// CHECK-NEXT:    [[TMP7:%.*]] = xor i64 [[TMP6]], 193514046488576
// CHECK-NEXT:    [[TMP8:%.*]] = inttoptr i64 [[TMP7]] to ptr
// CHECK-NEXT:    store [4 x <8 x i8>] zeroinitializer, ptr [[TMP8]], align 8
// CHECK-NEXT:    store [4 x <8 x i8>] [[B_COERCE]], ptr [[COERCE_DIVE]], align 8
// CHECK-NEXT:    [[TMP9:%.*]] = call ptr @__msan_memcpy(ptr [[__S1]], ptr [[B]], i64 32)
// CHECK-NEXT:    [[VAL:%.*]] = getelementptr inbounds [[STRUCT_POLY8X8X4_T]], ptr [[__S1]], i32 0, i32 0
// CHECK-NEXT:    [[ARRAYIDX:%.*]] = getelementptr inbounds [4 x <8 x i8>], ptr [[VAL]], i64 0, i64 0
// CHECK-NEXT:    [[TMP10:%.*]] = load <8 x i8>, ptr [[ARRAYIDX]], align 8
// CHECK-NEXT:    [[VAL1:%.*]] = getelementptr inbounds [[STRUCT_POLY8X8X4_T]], ptr [[__S1]], i32 0, i32 0
// CHECK-NEXT:    [[ARRAYIDX2:%.*]] = getelementptr inbounds [4 x <8 x i8>], ptr [[VAL1]], i64 0, i64 1
// CHECK-NEXT:    [[TMP11:%.*]] = load <8 x i8>, ptr [[ARRAYIDX2]], align 8
// CHECK-NEXT:    [[VAL3:%.*]] = getelementptr inbounds [[STRUCT_POLY8X8X4_T]], ptr [[__S1]], i32 0, i32 0
// CHECK-NEXT:    [[ARRAYIDX4:%.*]] = getelementptr inbounds [4 x <8 x i8>], ptr [[VAL3]], i64 0, i64 2
// CHECK-NEXT:    [[TMP12:%.*]] = load <8 x i8>, ptr [[ARRAYIDX4]], align 8
// CHECK-NEXT:    [[VAL5:%.*]] = getelementptr inbounds [[STRUCT_POLY8X8X4_T]], ptr [[__S1]], i32 0, i32 0
// CHECK-NEXT:    [[ARRAYIDX6:%.*]] = getelementptr inbounds [4 x <8 x i8>], ptr [[VAL5]], i64 0, i64 3
// CHECK-NEXT:    [[TMP13:%.*]] = load <8 x i8>, ptr [[ARRAYIDX6]], align 8
// CHECK-NEXT:    [[TMP14:%.*]] = ptrtoint ptr [[A]] to i64
// CHECK-NEXT:    [[TMP15:%.*]] = xor i64 [[TMP14]], 193514046488576
// CHECK-NEXT:    [[TMP16:%.*]] = inttoptr i64 [[TMP15]] to ptr
// CHECK-NEXT:    store <32 x i8> zeroinitializer, ptr [[TMP16]], align 1
// CHECK-NEXT:    call void @llvm.aarch64.neon.st4.v8i8.p0(<8 x i8> [[TMP10]], <8 x i8> [[TMP11]], <8 x i8> [[TMP12]], <8 x i8> [[TMP13]], ptr [[A]])
// CHECK-NEXT:    ret void
//
void test_vst4_p8(poly8_t *a, poly8x8x4_t b) {
  vst4_p8(a, b);
}

// CHECK-LABEL: define dso_local void @test_vst4_p16(
// CHECK-SAME: ptr noundef [[A:%.*]], [4 x <4 x i16>] alignstack(8) [[B_COERCE:%.*]]) #[[ATTR0]] {
// CHECK-NEXT:  entry:
// CHECK-NEXT:    call void @llvm.donothing()
// CHECK-NEXT:    [[B:%.*]] = alloca [[STRUCT_POLY16X4X4_T:%.*]], align 8
// CHECK-NEXT:    [[TMP0:%.*]] = ptrtoint ptr [[B]] to i64
// CHECK-NEXT:    [[TMP1:%.*]] = xor i64 [[TMP0]], 193514046488576
// CHECK-NEXT:    [[TMP2:%.*]] = inttoptr i64 [[TMP1]] to ptr
// CHECK-NEXT:    call void @llvm.memset.p0.i64(ptr align 8 [[TMP2]], i8 0, i64 32, i1 false)
// CHECK-NEXT:    [[__S1:%.*]] = alloca [[STRUCT_POLY16X4X4_T]], align 8
// CHECK-NEXT:    [[TMP3:%.*]] = ptrtoint ptr [[__S1]] to i64
// CHECK-NEXT:    [[TMP4:%.*]] = xor i64 [[TMP3]], 193514046488576
// CHECK-NEXT:    [[TMP5:%.*]] = inttoptr i64 [[TMP4]] to ptr
// CHECK-NEXT:    call void @llvm.memset.p0.i64(ptr align 8 [[TMP5]], i8 0, i64 32, i1 false)
// CHECK-NEXT:    [[COERCE_DIVE:%.*]] = getelementptr inbounds [[STRUCT_POLY16X4X4_T]], ptr [[B]], i32 0, i32 0
// CHECK-NEXT:    [[TMP6:%.*]] = ptrtoint ptr [[COERCE_DIVE]] to i64
// CHECK-NEXT:    [[TMP7:%.*]] = xor i64 [[TMP6]], 193514046488576
// CHECK-NEXT:    [[TMP8:%.*]] = inttoptr i64 [[TMP7]] to ptr
// CHECK-NEXT:    store [4 x <4 x i16>] zeroinitializer, ptr [[TMP8]], align 8
// CHECK-NEXT:    store [4 x <4 x i16>] [[B_COERCE]], ptr [[COERCE_DIVE]], align 8
// CHECK-NEXT:    [[TMP9:%.*]] = call ptr @__msan_memcpy(ptr [[__S1]], ptr [[B]], i64 32)
// CHECK-NEXT:    [[VAL:%.*]] = getelementptr inbounds [[STRUCT_POLY16X4X4_T]], ptr [[__S1]], i32 0, i32 0
// CHECK-NEXT:    [[ARRAYIDX:%.*]] = getelementptr inbounds [4 x <4 x i16>], ptr [[VAL]], i64 0, i64 0
// CHECK-NEXT:    [[TMP10:%.*]] = load <4 x i16>, ptr [[ARRAYIDX]], align 8
// CHECK-NEXT:    [[TMP11:%.*]] = bitcast <4 x i16> [[TMP10]] to <8 x i8>
// CHECK-NEXT:    [[VAL1:%.*]] = getelementptr inbounds [[STRUCT_POLY16X4X4_T]], ptr [[__S1]], i32 0, i32 0
// CHECK-NEXT:    [[ARRAYIDX2:%.*]] = getelementptr inbounds [4 x <4 x i16>], ptr [[VAL1]], i64 0, i64 1
// CHECK-NEXT:    [[TMP12:%.*]] = load <4 x i16>, ptr [[ARRAYIDX2]], align 8
// CHECK-NEXT:    [[TMP13:%.*]] = bitcast <4 x i16> [[TMP12]] to <8 x i8>
// CHECK-NEXT:    [[VAL3:%.*]] = getelementptr inbounds [[STRUCT_POLY16X4X4_T]], ptr [[__S1]], i32 0, i32 0
// CHECK-NEXT:    [[ARRAYIDX4:%.*]] = getelementptr inbounds [4 x <4 x i16>], ptr [[VAL3]], i64 0, i64 2
// CHECK-NEXT:    [[TMP14:%.*]] = load <4 x i16>, ptr [[ARRAYIDX4]], align 8
// CHECK-NEXT:    [[TMP15:%.*]] = bitcast <4 x i16> [[TMP14]] to <8 x i8>
// CHECK-NEXT:    [[VAL5:%.*]] = getelementptr inbounds [[STRUCT_POLY16X4X4_T]], ptr [[__S1]], i32 0, i32 0
// CHECK-NEXT:    [[ARRAYIDX6:%.*]] = getelementptr inbounds [4 x <4 x i16>], ptr [[VAL5]], i64 0, i64 3
// CHECK-NEXT:    [[TMP16:%.*]] = load <4 x i16>, ptr [[ARRAYIDX6]], align 8
// CHECK-NEXT:    [[TMP17:%.*]] = bitcast <4 x i16> [[TMP16]] to <8 x i8>
// CHECK-NEXT:    [[TMP18:%.*]] = bitcast <8 x i8> [[TMP11]] to <4 x i16>
// CHECK-NEXT:    [[TMP19:%.*]] = bitcast <8 x i8> [[TMP13]] to <4 x i16>
// CHECK-NEXT:    [[TMP20:%.*]] = bitcast <8 x i8> [[TMP15]] to <4 x i16>
// CHECK-NEXT:    [[TMP21:%.*]] = bitcast <8 x i8> [[TMP17]] to <4 x i16>
// CHECK-NEXT:    [[TMP22:%.*]] = ptrtoint ptr [[A]] to i64
// CHECK-NEXT:    [[TMP23:%.*]] = xor i64 [[TMP22]], 193514046488576
// CHECK-NEXT:    [[TMP24:%.*]] = inttoptr i64 [[TMP23]] to ptr
// CHECK-NEXT:    store <16 x i16> zeroinitializer, ptr [[TMP24]], align 1
// CHECK-NEXT:    call void @llvm.aarch64.neon.st4.v4i16.p0(<4 x i16> [[TMP18]], <4 x i16> [[TMP19]], <4 x i16> [[TMP20]], <4 x i16> [[TMP21]], ptr [[A]])
// CHECK-NEXT:    ret void
//
void test_vst4_p16(poly16_t *a, poly16x4x4_t b) {
  vst4_p16(a, b);
}

// CHECK-LABEL: define dso_local %struct.float64x2x2_t @test_vld1q_f64_x2(
// CHECK-SAME: ptr noundef [[A:%.*]]) #[[ATTR0]] {
// CHECK-NEXT:  entry:
// CHECK-NEXT:    call void @llvm.donothing()
// CHECK-NEXT:    [[RETVAL:%.*]] = alloca [[STRUCT_FLOAT64X2X2_T:%.*]], align 16
// CHECK-NEXT:    [[TMP0:%.*]] = ptrtoint ptr [[RETVAL]] to i64
// CHECK-NEXT:    [[TMP1:%.*]] = xor i64 [[TMP0]], 193514046488576
// CHECK-NEXT:    [[TMP2:%.*]] = inttoptr i64 [[TMP1]] to ptr
// CHECK-NEXT:    call void @llvm.memset.p0.i64(ptr align 16 [[TMP2]], i8 0, i64 32, i1 false)
// CHECK-NEXT:    [[__RET:%.*]] = alloca [[STRUCT_FLOAT64X2X2_T]], align 16
// CHECK-NEXT:    [[TMP3:%.*]] = ptrtoint ptr [[__RET]] to i64
// CHECK-NEXT:    [[TMP4:%.*]] = xor i64 [[TMP3]], 193514046488576
// CHECK-NEXT:    [[TMP5:%.*]] = inttoptr i64 [[TMP4]] to ptr
// CHECK-NEXT:    call void @llvm.memset.p0.i64(ptr align 16 [[TMP5]], i8 0, i64 32, i1 false)
// CHECK-NEXT:    [[VLD1XN:%.*]] = call { <2 x double>, <2 x double> } @llvm.aarch64.neon.ld1x2.v2f64.p0(ptr [[A]])
// CHECK-NEXT:    [[TMP6:%.*]] = ptrtoint ptr [[__RET]] to i64
// CHECK-NEXT:    [[TMP7:%.*]] = xor i64 [[TMP6]], 193514046488576
// CHECK-NEXT:    [[TMP8:%.*]] = inttoptr i64 [[TMP7]] to ptr
// CHECK-NEXT:    store { <2 x i64>, <2 x i64> } zeroinitializer, ptr [[TMP8]], align 16
// CHECK-NEXT:    store { <2 x double>, <2 x double> } [[VLD1XN]], ptr [[__RET]], align 16
// CHECK-NEXT:    [[TMP9:%.*]] = call ptr @__msan_memcpy(ptr [[RETVAL]], ptr [[__RET]], i64 32)
// CHECK-NEXT:    [[TMP10:%.*]] = load [[STRUCT_FLOAT64X2X2_T]], ptr [[RETVAL]], align 16
// CHECK-NEXT:    store { [2 x <2 x i64>] } zeroinitializer, ptr @__msan_retval_tls, align 8
// CHECK-NEXT:    ret [[STRUCT_FLOAT64X2X2_T]] [[TMP10]]
//
float64x2x2_t test_vld1q_f64_x2(float64_t const *a) {
  return vld1q_f64_x2(a);
}

// CHECK-LABEL: define dso_local %struct.poly64x2x2_t @test_vld1q_p64_x2(
// CHECK-SAME: ptr noundef [[A:%.*]]) #[[ATTR0]] {
// CHECK-NEXT:  entry:
// CHECK-NEXT:    call void @llvm.donothing()
// CHECK-NEXT:    [[RETVAL:%.*]] = alloca [[STRUCT_POLY64X2X2_T:%.*]], align 16
// CHECK-NEXT:    [[TMP0:%.*]] = ptrtoint ptr [[RETVAL]] to i64
// CHECK-NEXT:    [[TMP1:%.*]] = xor i64 [[TMP0]], 193514046488576
// CHECK-NEXT:    [[TMP2:%.*]] = inttoptr i64 [[TMP1]] to ptr
// CHECK-NEXT:    call void @llvm.memset.p0.i64(ptr align 16 [[TMP2]], i8 0, i64 32, i1 false)
// CHECK-NEXT:    [[__RET:%.*]] = alloca [[STRUCT_POLY64X2X2_T]], align 16
// CHECK-NEXT:    [[TMP3:%.*]] = ptrtoint ptr [[__RET]] to i64
// CHECK-NEXT:    [[TMP4:%.*]] = xor i64 [[TMP3]], 193514046488576
// CHECK-NEXT:    [[TMP5:%.*]] = inttoptr i64 [[TMP4]] to ptr
// CHECK-NEXT:    call void @llvm.memset.p0.i64(ptr align 16 [[TMP5]], i8 0, i64 32, i1 false)
// CHECK-NEXT:    [[VLD1XN:%.*]] = call { <2 x i64>, <2 x i64> } @llvm.aarch64.neon.ld1x2.v2i64.p0(ptr [[A]])
// CHECK-NEXT:    [[TMP6:%.*]] = ptrtoint ptr [[__RET]] to i64
// CHECK-NEXT:    [[TMP7:%.*]] = xor i64 [[TMP6]], 193514046488576
// CHECK-NEXT:    [[TMP8:%.*]] = inttoptr i64 [[TMP7]] to ptr
// CHECK-NEXT:    store { <2 x i64>, <2 x i64> } zeroinitializer, ptr [[TMP8]], align 16
// CHECK-NEXT:    store { <2 x i64>, <2 x i64> } [[VLD1XN]], ptr [[__RET]], align 16
// CHECK-NEXT:    [[TMP9:%.*]] = call ptr @__msan_memcpy(ptr [[RETVAL]], ptr [[__RET]], i64 32)
// CHECK-NEXT:    [[TMP10:%.*]] = load [[STRUCT_POLY64X2X2_T]], ptr [[RETVAL]], align 16
// CHECK-NEXT:    store { [2 x <2 x i64>] } zeroinitializer, ptr @__msan_retval_tls, align 8
// CHECK-NEXT:    ret [[STRUCT_POLY64X2X2_T]] [[TMP10]]
//
poly64x2x2_t test_vld1q_p64_x2(poly64_t const *a) {
  return vld1q_p64_x2(a);
}

// CHECK-LABEL: define dso_local %struct.float64x1x2_t @test_vld1_f64_x2(
// CHECK-SAME: ptr noundef [[A:%.*]]) #[[ATTR0]] {
// CHECK-NEXT:  entry:
// CHECK-NEXT:    call void @llvm.donothing()
// CHECK-NEXT:    [[RETVAL:%.*]] = alloca [[STRUCT_FLOAT64X1X2_T:%.*]], align 8
// CHECK-NEXT:    [[TMP0:%.*]] = ptrtoint ptr [[RETVAL]] to i64
// CHECK-NEXT:    [[TMP1:%.*]] = xor i64 [[TMP0]], 193514046488576
// CHECK-NEXT:    [[TMP2:%.*]] = inttoptr i64 [[TMP1]] to ptr
// CHECK-NEXT:    call void @llvm.memset.p0.i64(ptr align 8 [[TMP2]], i8 0, i64 16, i1 false)
// CHECK-NEXT:    [[__RET:%.*]] = alloca [[STRUCT_FLOAT64X1X2_T]], align 8
// CHECK-NEXT:    [[TMP3:%.*]] = ptrtoint ptr [[__RET]] to i64
// CHECK-NEXT:    [[TMP4:%.*]] = xor i64 [[TMP3]], 193514046488576
// CHECK-NEXT:    [[TMP5:%.*]] = inttoptr i64 [[TMP4]] to ptr
// CHECK-NEXT:    call void @llvm.memset.p0.i64(ptr align 8 [[TMP5]], i8 0, i64 16, i1 false)
// CHECK-NEXT:    [[VLD1XN:%.*]] = call { <1 x double>, <1 x double> } @llvm.aarch64.neon.ld1x2.v1f64.p0(ptr [[A]])
// CHECK-NEXT:    [[TMP6:%.*]] = ptrtoint ptr [[__RET]] to i64
// CHECK-NEXT:    [[TMP7:%.*]] = xor i64 [[TMP6]], 193514046488576
// CHECK-NEXT:    [[TMP8:%.*]] = inttoptr i64 [[TMP7]] to ptr
// CHECK-NEXT:    store { <1 x i64>, <1 x i64> } zeroinitializer, ptr [[TMP8]], align 8
// CHECK-NEXT:    store { <1 x double>, <1 x double> } [[VLD1XN]], ptr [[__RET]], align 8
// CHECK-NEXT:    [[TMP9:%.*]] = call ptr @__msan_memcpy(ptr [[RETVAL]], ptr [[__RET]], i64 16)
// CHECK-NEXT:    [[TMP10:%.*]] = load [[STRUCT_FLOAT64X1X2_T]], ptr [[RETVAL]], align 8
// CHECK-NEXT:    store { [2 x <1 x i64>] } zeroinitializer, ptr @__msan_retval_tls, align 8
// CHECK-NEXT:    ret [[STRUCT_FLOAT64X1X2_T]] [[TMP10]]
//
float64x1x2_t test_vld1_f64_x2(float64_t const *a) {
  return vld1_f64_x2(a);
}

// CHECK-LABEL: define dso_local %struct.poly64x1x2_t @test_vld1_p64_x2(
// CHECK-SAME: ptr noundef [[A:%.*]]) #[[ATTR0]] {
// CHECK-NEXT:  entry:
// CHECK-NEXT:    call void @llvm.donothing()
// CHECK-NEXT:    [[RETVAL:%.*]] = alloca [[STRUCT_POLY64X1X2_T:%.*]], align 8
// CHECK-NEXT:    [[TMP0:%.*]] = ptrtoint ptr [[RETVAL]] to i64
// CHECK-NEXT:    [[TMP1:%.*]] = xor i64 [[TMP0]], 193514046488576
// CHECK-NEXT:    [[TMP2:%.*]] = inttoptr i64 [[TMP1]] to ptr
// CHECK-NEXT:    call void @llvm.memset.p0.i64(ptr align 8 [[TMP2]], i8 0, i64 16, i1 false)
// CHECK-NEXT:    [[__RET:%.*]] = alloca [[STRUCT_POLY64X1X2_T]], align 8
// CHECK-NEXT:    [[TMP3:%.*]] = ptrtoint ptr [[__RET]] to i64
// CHECK-NEXT:    [[TMP4:%.*]] = xor i64 [[TMP3]], 193514046488576
// CHECK-NEXT:    [[TMP5:%.*]] = inttoptr i64 [[TMP4]] to ptr
// CHECK-NEXT:    call void @llvm.memset.p0.i64(ptr align 8 [[TMP5]], i8 0, i64 16, i1 false)
// CHECK-NEXT:    [[VLD1XN:%.*]] = call { <1 x i64>, <1 x i64> } @llvm.aarch64.neon.ld1x2.v1i64.p0(ptr [[A]])
// CHECK-NEXT:    [[TMP6:%.*]] = ptrtoint ptr [[__RET]] to i64
// CHECK-NEXT:    [[TMP7:%.*]] = xor i64 [[TMP6]], 193514046488576
// CHECK-NEXT:    [[TMP8:%.*]] = inttoptr i64 [[TMP7]] to ptr
// CHECK-NEXT:    store { <1 x i64>, <1 x i64> } zeroinitializer, ptr [[TMP8]], align 8
// CHECK-NEXT:    store { <1 x i64>, <1 x i64> } [[VLD1XN]], ptr [[__RET]], align 8
// CHECK-NEXT:    [[TMP9:%.*]] = call ptr @__msan_memcpy(ptr [[RETVAL]], ptr [[__RET]], i64 16)
// CHECK-NEXT:    [[TMP10:%.*]] = load [[STRUCT_POLY64X1X2_T]], ptr [[RETVAL]], align 8
// CHECK-NEXT:    store { [2 x <1 x i64>] } zeroinitializer, ptr @__msan_retval_tls, align 8
// CHECK-NEXT:    ret [[STRUCT_POLY64X1X2_T]] [[TMP10]]
//
poly64x1x2_t test_vld1_p64_x2(poly64_t const *a) {
  return vld1_p64_x2(a);
}

// CHECK-LABEL: define dso_local %struct.float64x2x3_t @test_vld1q_f64_x3(
// CHECK-SAME: ptr noundef [[A:%.*]]) #[[ATTR0]] {
// CHECK-NEXT:  entry:
// CHECK-NEXT:    call void @llvm.donothing()
// CHECK-NEXT:    [[RETVAL:%.*]] = alloca [[STRUCT_FLOAT64X2X3_T:%.*]], align 16
// CHECK-NEXT:    [[TMP0:%.*]] = ptrtoint ptr [[RETVAL]] to i64
// CHECK-NEXT:    [[TMP1:%.*]] = xor i64 [[TMP0]], 193514046488576
// CHECK-NEXT:    [[TMP2:%.*]] = inttoptr i64 [[TMP1]] to ptr
// CHECK-NEXT:    call void @llvm.memset.p0.i64(ptr align 16 [[TMP2]], i8 0, i64 48, i1 false)
// CHECK-NEXT:    [[__RET:%.*]] = alloca [[STRUCT_FLOAT64X2X3_T]], align 16
// CHECK-NEXT:    [[TMP3:%.*]] = ptrtoint ptr [[__RET]] to i64
// CHECK-NEXT:    [[TMP4:%.*]] = xor i64 [[TMP3]], 193514046488576
// CHECK-NEXT:    [[TMP5:%.*]] = inttoptr i64 [[TMP4]] to ptr
// CHECK-NEXT:    call void @llvm.memset.p0.i64(ptr align 16 [[TMP5]], i8 0, i64 48, i1 false)
// CHECK-NEXT:    [[VLD1XN:%.*]] = call { <2 x double>, <2 x double>, <2 x double> } @llvm.aarch64.neon.ld1x3.v2f64.p0(ptr [[A]])
// CHECK-NEXT:    [[TMP6:%.*]] = ptrtoint ptr [[__RET]] to i64
// CHECK-NEXT:    [[TMP7:%.*]] = xor i64 [[TMP6]], 193514046488576
// CHECK-NEXT:    [[TMP8:%.*]] = inttoptr i64 [[TMP7]] to ptr
// CHECK-NEXT:    store { <2 x i64>, <2 x i64>, <2 x i64> } zeroinitializer, ptr [[TMP8]], align 16
// CHECK-NEXT:    store { <2 x double>, <2 x double>, <2 x double> } [[VLD1XN]], ptr [[__RET]], align 16
// CHECK-NEXT:    [[TMP9:%.*]] = call ptr @__msan_memcpy(ptr [[RETVAL]], ptr [[__RET]], i64 48)
// CHECK-NEXT:    [[TMP10:%.*]] = load [[STRUCT_FLOAT64X2X3_T]], ptr [[RETVAL]], align 16
// CHECK-NEXT:    store { [3 x <2 x i64>] } zeroinitializer, ptr @__msan_retval_tls, align 8
// CHECK-NEXT:    ret [[STRUCT_FLOAT64X2X3_T]] [[TMP10]]
//
float64x2x3_t test_vld1q_f64_x3(float64_t const *a) {
  return vld1q_f64_x3(a);
}

// CHECK-LABEL: define dso_local %struct.poly64x2x3_t @test_vld1q_p64_x3(
// CHECK-SAME: ptr noundef [[A:%.*]]) #[[ATTR0]] {
// CHECK-NEXT:  entry:
// CHECK-NEXT:    call void @llvm.donothing()
// CHECK-NEXT:    [[RETVAL:%.*]] = alloca [[STRUCT_POLY64X2X3_T:%.*]], align 16
// CHECK-NEXT:    [[TMP0:%.*]] = ptrtoint ptr [[RETVAL]] to i64
// CHECK-NEXT:    [[TMP1:%.*]] = xor i64 [[TMP0]], 193514046488576
// CHECK-NEXT:    [[TMP2:%.*]] = inttoptr i64 [[TMP1]] to ptr
// CHECK-NEXT:    call void @llvm.memset.p0.i64(ptr align 16 [[TMP2]], i8 0, i64 48, i1 false)
// CHECK-NEXT:    [[__RET:%.*]] = alloca [[STRUCT_POLY64X2X3_T]], align 16
// CHECK-NEXT:    [[TMP3:%.*]] = ptrtoint ptr [[__RET]] to i64
// CHECK-NEXT:    [[TMP4:%.*]] = xor i64 [[TMP3]], 193514046488576
// CHECK-NEXT:    [[TMP5:%.*]] = inttoptr i64 [[TMP4]] to ptr
// CHECK-NEXT:    call void @llvm.memset.p0.i64(ptr align 16 [[TMP5]], i8 0, i64 48, i1 false)
// CHECK-NEXT:    [[VLD1XN:%.*]] = call { <2 x i64>, <2 x i64>, <2 x i64> } @llvm.aarch64.neon.ld1x3.v2i64.p0(ptr [[A]])
// CHECK-NEXT:    [[TMP6:%.*]] = ptrtoint ptr [[__RET]] to i64
// CHECK-NEXT:    [[TMP7:%.*]] = xor i64 [[TMP6]], 193514046488576
// CHECK-NEXT:    [[TMP8:%.*]] = inttoptr i64 [[TMP7]] to ptr
// CHECK-NEXT:    store { <2 x i64>, <2 x i64>, <2 x i64> } zeroinitializer, ptr [[TMP8]], align 16
// CHECK-NEXT:    store { <2 x i64>, <2 x i64>, <2 x i64> } [[VLD1XN]], ptr [[__RET]], align 16
// CHECK-NEXT:    [[TMP9:%.*]] = call ptr @__msan_memcpy(ptr [[RETVAL]], ptr [[__RET]], i64 48)
// CHECK-NEXT:    [[TMP10:%.*]] = load [[STRUCT_POLY64X2X3_T]], ptr [[RETVAL]], align 16
// CHECK-NEXT:    store { [3 x <2 x i64>] } zeroinitializer, ptr @__msan_retval_tls, align 8
// CHECK-NEXT:    ret [[STRUCT_POLY64X2X3_T]] [[TMP10]]
//
poly64x2x3_t test_vld1q_p64_x3(poly64_t const *a) {
  return vld1q_p64_x3(a);
}

// CHECK-LABEL: define dso_local %struct.float64x1x3_t @test_vld1_f64_x3(
// CHECK-SAME: ptr noundef [[A:%.*]]) #[[ATTR0]] {
// CHECK-NEXT:  entry:
// CHECK-NEXT:    call void @llvm.donothing()
// CHECK-NEXT:    [[RETVAL:%.*]] = alloca [[STRUCT_FLOAT64X1X3_T:%.*]], align 8
// CHECK-NEXT:    [[TMP0:%.*]] = ptrtoint ptr [[RETVAL]] to i64
// CHECK-NEXT:    [[TMP1:%.*]] = xor i64 [[TMP0]], 193514046488576
// CHECK-NEXT:    [[TMP2:%.*]] = inttoptr i64 [[TMP1]] to ptr
// CHECK-NEXT:    call void @llvm.memset.p0.i64(ptr align 8 [[TMP2]], i8 0, i64 24, i1 false)
// CHECK-NEXT:    [[__RET:%.*]] = alloca [[STRUCT_FLOAT64X1X3_T]], align 8
// CHECK-NEXT:    [[TMP3:%.*]] = ptrtoint ptr [[__RET]] to i64
// CHECK-NEXT:    [[TMP4:%.*]] = xor i64 [[TMP3]], 193514046488576
// CHECK-NEXT:    [[TMP5:%.*]] = inttoptr i64 [[TMP4]] to ptr
// CHECK-NEXT:    call void @llvm.memset.p0.i64(ptr align 8 [[TMP5]], i8 0, i64 24, i1 false)
// CHECK-NEXT:    [[VLD1XN:%.*]] = call { <1 x double>, <1 x double>, <1 x double> } @llvm.aarch64.neon.ld1x3.v1f64.p0(ptr [[A]])
// CHECK-NEXT:    [[TMP6:%.*]] = ptrtoint ptr [[__RET]] to i64
// CHECK-NEXT:    [[TMP7:%.*]] = xor i64 [[TMP6]], 193514046488576
// CHECK-NEXT:    [[TMP8:%.*]] = inttoptr i64 [[TMP7]] to ptr
// CHECK-NEXT:    store { <1 x i64>, <1 x i64>, <1 x i64> } zeroinitializer, ptr [[TMP8]], align 8
// CHECK-NEXT:    store { <1 x double>, <1 x double>, <1 x double> } [[VLD1XN]], ptr [[__RET]], align 8
// CHECK-NEXT:    [[TMP9:%.*]] = call ptr @__msan_memcpy(ptr [[RETVAL]], ptr [[__RET]], i64 24)
// CHECK-NEXT:    [[TMP10:%.*]] = load [[STRUCT_FLOAT64X1X3_T]], ptr [[RETVAL]], align 8
// CHECK-NEXT:    store { [3 x <1 x i64>] } zeroinitializer, ptr @__msan_retval_tls, align 8
// CHECK-NEXT:    ret [[STRUCT_FLOAT64X1X3_T]] [[TMP10]]
//
float64x1x3_t test_vld1_f64_x3(float64_t const *a) {
  return vld1_f64_x3(a);
}

// CHECK-LABEL: define dso_local %struct.poly64x1x3_t @test_vld1_p64_x3(
// CHECK-SAME: ptr noundef [[A:%.*]]) #[[ATTR0]] {
// CHECK-NEXT:  entry:
// CHECK-NEXT:    call void @llvm.donothing()
// CHECK-NEXT:    [[RETVAL:%.*]] = alloca [[STRUCT_POLY64X1X3_T:%.*]], align 8
// CHECK-NEXT:    [[TMP0:%.*]] = ptrtoint ptr [[RETVAL]] to i64
// CHECK-NEXT:    [[TMP1:%.*]] = xor i64 [[TMP0]], 193514046488576
// CHECK-NEXT:    [[TMP2:%.*]] = inttoptr i64 [[TMP1]] to ptr
// CHECK-NEXT:    call void @llvm.memset.p0.i64(ptr align 8 [[TMP2]], i8 0, i64 24, i1 false)
// CHECK-NEXT:    [[__RET:%.*]] = alloca [[STRUCT_POLY64X1X3_T]], align 8
// CHECK-NEXT:    [[TMP3:%.*]] = ptrtoint ptr [[__RET]] to i64
// CHECK-NEXT:    [[TMP4:%.*]] = xor i64 [[TMP3]], 193514046488576
// CHECK-NEXT:    [[TMP5:%.*]] = inttoptr i64 [[TMP4]] to ptr
// CHECK-NEXT:    call void @llvm.memset.p0.i64(ptr align 8 [[TMP5]], i8 0, i64 24, i1 false)
// CHECK-NEXT:    [[VLD1XN:%.*]] = call { <1 x i64>, <1 x i64>, <1 x i64> } @llvm.aarch64.neon.ld1x3.v1i64.p0(ptr [[A]])
// CHECK-NEXT:    [[TMP6:%.*]] = ptrtoint ptr [[__RET]] to i64
// CHECK-NEXT:    [[TMP7:%.*]] = xor i64 [[TMP6]], 193514046488576
// CHECK-NEXT:    [[TMP8:%.*]] = inttoptr i64 [[TMP7]] to ptr
// CHECK-NEXT:    store { <1 x i64>, <1 x i64>, <1 x i64> } zeroinitializer, ptr [[TMP8]], align 8
// CHECK-NEXT:    store { <1 x i64>, <1 x i64>, <1 x i64> } [[VLD1XN]], ptr [[__RET]], align 8
// CHECK-NEXT:    [[TMP9:%.*]] = call ptr @__msan_memcpy(ptr [[RETVAL]], ptr [[__RET]], i64 24)
// CHECK-NEXT:    [[TMP10:%.*]] = load [[STRUCT_POLY64X1X3_T]], ptr [[RETVAL]], align 8
// CHECK-NEXT:    store { [3 x <1 x i64>] } zeroinitializer, ptr @__msan_retval_tls, align 8
// CHECK-NEXT:    ret [[STRUCT_POLY64X1X3_T]] [[TMP10]]
//
poly64x1x3_t test_vld1_p64_x3(poly64_t const *a) {
  return vld1_p64_x3(a);
}

// CHECK-LABEL: define dso_local %struct.float64x2x4_t @test_vld1q_f64_x4(
// CHECK-SAME: ptr noundef [[A:%.*]]) #[[ATTR0]] {
// CHECK-NEXT:  entry:
// CHECK-NEXT:    call void @llvm.donothing()
// CHECK-NEXT:    [[RETVAL:%.*]] = alloca [[STRUCT_FLOAT64X2X4_T:%.*]], align 16
// CHECK-NEXT:    [[TMP0:%.*]] = ptrtoint ptr [[RETVAL]] to i64
// CHECK-NEXT:    [[TMP1:%.*]] = xor i64 [[TMP0]], 193514046488576
// CHECK-NEXT:    [[TMP2:%.*]] = inttoptr i64 [[TMP1]] to ptr
// CHECK-NEXT:    call void @llvm.memset.p0.i64(ptr align 16 [[TMP2]], i8 0, i64 64, i1 false)
// CHECK-NEXT:    [[__RET:%.*]] = alloca [[STRUCT_FLOAT64X2X4_T]], align 16
// CHECK-NEXT:    [[TMP3:%.*]] = ptrtoint ptr [[__RET]] to i64
// CHECK-NEXT:    [[TMP4:%.*]] = xor i64 [[TMP3]], 193514046488576
// CHECK-NEXT:    [[TMP5:%.*]] = inttoptr i64 [[TMP4]] to ptr
// CHECK-NEXT:    call void @llvm.memset.p0.i64(ptr align 16 [[TMP5]], i8 0, i64 64, i1 false)
// CHECK-NEXT:    [[VLD1XN:%.*]] = call { <2 x double>, <2 x double>, <2 x double>, <2 x double> } @llvm.aarch64.neon.ld1x4.v2f64.p0(ptr [[A]])
// CHECK-NEXT:    [[TMP6:%.*]] = ptrtoint ptr [[__RET]] to i64
// CHECK-NEXT:    [[TMP7:%.*]] = xor i64 [[TMP6]], 193514046488576
// CHECK-NEXT:    [[TMP8:%.*]] = inttoptr i64 [[TMP7]] to ptr
// CHECK-NEXT:    store { <2 x i64>, <2 x i64>, <2 x i64>, <2 x i64> } zeroinitializer, ptr [[TMP8]], align 16
// CHECK-NEXT:    store { <2 x double>, <2 x double>, <2 x double>, <2 x double> } [[VLD1XN]], ptr [[__RET]], align 16
// CHECK-NEXT:    [[TMP9:%.*]] = call ptr @__msan_memcpy(ptr [[RETVAL]], ptr [[__RET]], i64 64)
// CHECK-NEXT:    [[TMP10:%.*]] = load [[STRUCT_FLOAT64X2X4_T]], ptr [[RETVAL]], align 16
// CHECK-NEXT:    store { [4 x <2 x i64>] } zeroinitializer, ptr @__msan_retval_tls, align 8
// CHECK-NEXT:    ret [[STRUCT_FLOAT64X2X4_T]] [[TMP10]]
//
float64x2x4_t test_vld1q_f64_x4(float64_t const *a) {
  return vld1q_f64_x4(a);
}

// CHECK-LABEL: define dso_local %struct.poly64x2x4_t @test_vld1q_p64_x4(
// CHECK-SAME: ptr noundef [[A:%.*]]) #[[ATTR0]] {
// CHECK-NEXT:  entry:
// CHECK-NEXT:    call void @llvm.donothing()
// CHECK-NEXT:    [[RETVAL:%.*]] = alloca [[STRUCT_POLY64X2X4_T:%.*]], align 16
// CHECK-NEXT:    [[TMP0:%.*]] = ptrtoint ptr [[RETVAL]] to i64
// CHECK-NEXT:    [[TMP1:%.*]] = xor i64 [[TMP0]], 193514046488576
// CHECK-NEXT:    [[TMP2:%.*]] = inttoptr i64 [[TMP1]] to ptr
// CHECK-NEXT:    call void @llvm.memset.p0.i64(ptr align 16 [[TMP2]], i8 0, i64 64, i1 false)
// CHECK-NEXT:    [[__RET:%.*]] = alloca [[STRUCT_POLY64X2X4_T]], align 16
// CHECK-NEXT:    [[TMP3:%.*]] = ptrtoint ptr [[__RET]] to i64
// CHECK-NEXT:    [[TMP4:%.*]] = xor i64 [[TMP3]], 193514046488576
// CHECK-NEXT:    [[TMP5:%.*]] = inttoptr i64 [[TMP4]] to ptr
// CHECK-NEXT:    call void @llvm.memset.p0.i64(ptr align 16 [[TMP5]], i8 0, i64 64, i1 false)
// CHECK-NEXT:    [[VLD1XN:%.*]] = call { <2 x i64>, <2 x i64>, <2 x i64>, <2 x i64> } @llvm.aarch64.neon.ld1x4.v2i64.p0(ptr [[A]])
// CHECK-NEXT:    [[TMP6:%.*]] = ptrtoint ptr [[__RET]] to i64
// CHECK-NEXT:    [[TMP7:%.*]] = xor i64 [[TMP6]], 193514046488576
// CHECK-NEXT:    [[TMP8:%.*]] = inttoptr i64 [[TMP7]] to ptr
// CHECK-NEXT:    store { <2 x i64>, <2 x i64>, <2 x i64>, <2 x i64> } zeroinitializer, ptr [[TMP8]], align 16
// CHECK-NEXT:    store { <2 x i64>, <2 x i64>, <2 x i64>, <2 x i64> } [[VLD1XN]], ptr [[__RET]], align 16
// CHECK-NEXT:    [[TMP9:%.*]] = call ptr @__msan_memcpy(ptr [[RETVAL]], ptr [[__RET]], i64 64)
// CHECK-NEXT:    [[TMP10:%.*]] = load [[STRUCT_POLY64X2X4_T]], ptr [[RETVAL]], align 16
// CHECK-NEXT:    store { [4 x <2 x i64>] } zeroinitializer, ptr @__msan_retval_tls, align 8
// CHECK-NEXT:    ret [[STRUCT_POLY64X2X4_T]] [[TMP10]]
//
poly64x2x4_t test_vld1q_p64_x4(poly64_t const *a) {
  return vld1q_p64_x4(a);
}

// CHECK-LABEL: define dso_local %struct.float64x1x4_t @test_vld1_f64_x4(
// CHECK-SAME: ptr noundef [[A:%.*]]) #[[ATTR0]] {
// CHECK-NEXT:  entry:
// CHECK-NEXT:    call void @llvm.donothing()
// CHECK-NEXT:    [[RETVAL:%.*]] = alloca [[STRUCT_FLOAT64X1X4_T:%.*]], align 8
// CHECK-NEXT:    [[TMP0:%.*]] = ptrtoint ptr [[RETVAL]] to i64
// CHECK-NEXT:    [[TMP1:%.*]] = xor i64 [[TMP0]], 193514046488576
// CHECK-NEXT:    [[TMP2:%.*]] = inttoptr i64 [[TMP1]] to ptr
// CHECK-NEXT:    call void @llvm.memset.p0.i64(ptr align 8 [[TMP2]], i8 0, i64 32, i1 false)
// CHECK-NEXT:    [[__RET:%.*]] = alloca [[STRUCT_FLOAT64X1X4_T]], align 8
// CHECK-NEXT:    [[TMP3:%.*]] = ptrtoint ptr [[__RET]] to i64
// CHECK-NEXT:    [[TMP4:%.*]] = xor i64 [[TMP3]], 193514046488576
// CHECK-NEXT:    [[TMP5:%.*]] = inttoptr i64 [[TMP4]] to ptr
// CHECK-NEXT:    call void @llvm.memset.p0.i64(ptr align 8 [[TMP5]], i8 0, i64 32, i1 false)
// CHECK-NEXT:    [[VLD1XN:%.*]] = call { <1 x double>, <1 x double>, <1 x double>, <1 x double> } @llvm.aarch64.neon.ld1x4.v1f64.p0(ptr [[A]])
// CHECK-NEXT:    [[TMP6:%.*]] = ptrtoint ptr [[__RET]] to i64
// CHECK-NEXT:    [[TMP7:%.*]] = xor i64 [[TMP6]], 193514046488576
// CHECK-NEXT:    [[TMP8:%.*]] = inttoptr i64 [[TMP7]] to ptr
// CHECK-NEXT:    store { <1 x i64>, <1 x i64>, <1 x i64>, <1 x i64> } zeroinitializer, ptr [[TMP8]], align 8
// CHECK-NEXT:    store { <1 x double>, <1 x double>, <1 x double>, <1 x double> } [[VLD1XN]], ptr [[__RET]], align 8
// CHECK-NEXT:    [[TMP9:%.*]] = call ptr @__msan_memcpy(ptr [[RETVAL]], ptr [[__RET]], i64 32)
// CHECK-NEXT:    [[TMP10:%.*]] = load [[STRUCT_FLOAT64X1X4_T]], ptr [[RETVAL]], align 8
// CHECK-NEXT:    store { [4 x <1 x i64>] } zeroinitializer, ptr @__msan_retval_tls, align 8
// CHECK-NEXT:    ret [[STRUCT_FLOAT64X1X4_T]] [[TMP10]]
//
float64x1x4_t test_vld1_f64_x4(float64_t const *a) {
  return vld1_f64_x4(a);
}

// CHECK-LABEL: define dso_local %struct.poly64x1x4_t @test_vld1_p64_x4(
// CHECK-SAME: ptr noundef [[A:%.*]]) #[[ATTR0]] {
// CHECK-NEXT:  entry:
// CHECK-NEXT:    call void @llvm.donothing()
// CHECK-NEXT:    [[RETVAL:%.*]] = alloca [[STRUCT_POLY64X1X4_T:%.*]], align 8
// CHECK-NEXT:    [[TMP0:%.*]] = ptrtoint ptr [[RETVAL]] to i64
// CHECK-NEXT:    [[TMP1:%.*]] = xor i64 [[TMP0]], 193514046488576
// CHECK-NEXT:    [[TMP2:%.*]] = inttoptr i64 [[TMP1]] to ptr
// CHECK-NEXT:    call void @llvm.memset.p0.i64(ptr align 8 [[TMP2]], i8 0, i64 32, i1 false)
// CHECK-NEXT:    [[__RET:%.*]] = alloca [[STRUCT_POLY64X1X4_T]], align 8
// CHECK-NEXT:    [[TMP3:%.*]] = ptrtoint ptr [[__RET]] to i64
// CHECK-NEXT:    [[TMP4:%.*]] = xor i64 [[TMP3]], 193514046488576
// CHECK-NEXT:    [[TMP5:%.*]] = inttoptr i64 [[TMP4]] to ptr
// CHECK-NEXT:    call void @llvm.memset.p0.i64(ptr align 8 [[TMP5]], i8 0, i64 32, i1 false)
// CHECK-NEXT:    [[VLD1XN:%.*]] = call { <1 x i64>, <1 x i64>, <1 x i64>, <1 x i64> } @llvm.aarch64.neon.ld1x4.v1i64.p0(ptr [[A]])
// CHECK-NEXT:    [[TMP6:%.*]] = ptrtoint ptr [[__RET]] to i64
// CHECK-NEXT:    [[TMP7:%.*]] = xor i64 [[TMP6]], 193514046488576
// CHECK-NEXT:    [[TMP8:%.*]] = inttoptr i64 [[TMP7]] to ptr
// CHECK-NEXT:    store { <1 x i64>, <1 x i64>, <1 x i64>, <1 x i64> } zeroinitializer, ptr [[TMP8]], align 8
// CHECK-NEXT:    store { <1 x i64>, <1 x i64>, <1 x i64>, <1 x i64> } [[VLD1XN]], ptr [[__RET]], align 8
// CHECK-NEXT:    [[TMP9:%.*]] = call ptr @__msan_memcpy(ptr [[RETVAL]], ptr [[__RET]], i64 32)
// CHECK-NEXT:    [[TMP10:%.*]] = load [[STRUCT_POLY64X1X4_T]], ptr [[RETVAL]], align 8
// CHECK-NEXT:    store { [4 x <1 x i64>] } zeroinitializer, ptr @__msan_retval_tls, align 8
// CHECK-NEXT:    ret [[STRUCT_POLY64X1X4_T]] [[TMP10]]
//
poly64x1x4_t test_vld1_p64_x4(poly64_t const *a) {
  return vld1_p64_x4(a);
}

// CHECK-LABEL: define dso_local void @test_vst1q_f64_x2(
// CHECK-SAME: ptr noundef [[A:%.*]], [2 x <2 x double>] alignstack(16) [[B_COERCE:%.*]]) #[[ATTR0]] {
// CHECK-NEXT:  entry:
// CHECK-NEXT:    call void @llvm.donothing()
// CHECK-NEXT:    [[B:%.*]] = alloca [[STRUCT_FLOAT64X2X2_T:%.*]], align 16
// CHECK-NEXT:    [[TMP0:%.*]] = ptrtoint ptr [[B]] to i64
// CHECK-NEXT:    [[TMP1:%.*]] = xor i64 [[TMP0]], 193514046488576
// CHECK-NEXT:    [[TMP2:%.*]] = inttoptr i64 [[TMP1]] to ptr
// CHECK-NEXT:    call void @llvm.memset.p0.i64(ptr align 16 [[TMP2]], i8 0, i64 32, i1 false)
// CHECK-NEXT:    [[__S1:%.*]] = alloca [[STRUCT_FLOAT64X2X2_T]], align 16
// CHECK-NEXT:    [[TMP3:%.*]] = ptrtoint ptr [[__S1]] to i64
// CHECK-NEXT:    [[TMP4:%.*]] = xor i64 [[TMP3]], 193514046488576
// CHECK-NEXT:    [[TMP5:%.*]] = inttoptr i64 [[TMP4]] to ptr
// CHECK-NEXT:    call void @llvm.memset.p0.i64(ptr align 16 [[TMP5]], i8 0, i64 32, i1 false)
// CHECK-NEXT:    [[COERCE_DIVE:%.*]] = getelementptr inbounds [[STRUCT_FLOAT64X2X2_T]], ptr [[B]], i32 0, i32 0
// CHECK-NEXT:    [[TMP6:%.*]] = ptrtoint ptr [[COERCE_DIVE]] to i64
// CHECK-NEXT:    [[TMP7:%.*]] = xor i64 [[TMP6]], 193514046488576
// CHECK-NEXT:    [[TMP8:%.*]] = inttoptr i64 [[TMP7]] to ptr
// CHECK-NEXT:    store [2 x <2 x i64>] zeroinitializer, ptr [[TMP8]], align 16
// CHECK-NEXT:    store [2 x <2 x double>] [[B_COERCE]], ptr [[COERCE_DIVE]], align 16
// CHECK-NEXT:    [[TMP9:%.*]] = call ptr @__msan_memcpy(ptr [[__S1]], ptr [[B]], i64 32)
// CHECK-NEXT:    [[VAL:%.*]] = getelementptr inbounds [[STRUCT_FLOAT64X2X2_T]], ptr [[__S1]], i32 0, i32 0
// CHECK-NEXT:    [[ARRAYIDX:%.*]] = getelementptr inbounds [2 x <2 x double>], ptr [[VAL]], i64 0, i64 0
// CHECK-NEXT:    [[TMP10:%.*]] = load <2 x double>, ptr [[ARRAYIDX]], align 16
// CHECK-NEXT:    [[TMP11:%.*]] = bitcast <2 x double> [[TMP10]] to <16 x i8>
// CHECK-NEXT:    [[VAL1:%.*]] = getelementptr inbounds [[STRUCT_FLOAT64X2X2_T]], ptr [[__S1]], i32 0, i32 0
// CHECK-NEXT:    [[ARRAYIDX2:%.*]] = getelementptr inbounds [2 x <2 x double>], ptr [[VAL1]], i64 0, i64 1
// CHECK-NEXT:    [[TMP12:%.*]] = load <2 x double>, ptr [[ARRAYIDX2]], align 16
// CHECK-NEXT:    [[TMP13:%.*]] = bitcast <2 x double> [[TMP12]] to <16 x i8>
// CHECK-NEXT:    [[TMP14:%.*]] = bitcast <16 x i8> [[TMP11]] to <2 x double>
// CHECK-NEXT:    [[TMP15:%.*]] = bitcast <16 x i8> [[TMP13]] to <2 x double>
// CHECK-NEXT:    call void @llvm.aarch64.neon.st1x2.v2f64.p0(<2 x double> [[TMP14]], <2 x double> [[TMP15]], ptr [[A]])
// CHECK-NEXT:    ret void
//
void test_vst1q_f64_x2(float64_t *a, float64x2x2_t b) {
  vst1q_f64_x2(a, b);
}

// CHECK-LABEL: define dso_local void @test_vst1q_p64_x2(
// CHECK-SAME: ptr noundef [[A:%.*]], [2 x <2 x i64>] alignstack(16) [[B_COERCE:%.*]]) #[[ATTR0]] {
// CHECK-NEXT:  entry:
// CHECK-NEXT:    call void @llvm.donothing()
// CHECK-NEXT:    [[B:%.*]] = alloca [[STRUCT_POLY64X2X2_T:%.*]], align 16
// CHECK-NEXT:    [[TMP0:%.*]] = ptrtoint ptr [[B]] to i64
// CHECK-NEXT:    [[TMP1:%.*]] = xor i64 [[TMP0]], 193514046488576
// CHECK-NEXT:    [[TMP2:%.*]] = inttoptr i64 [[TMP1]] to ptr
// CHECK-NEXT:    call void @llvm.memset.p0.i64(ptr align 16 [[TMP2]], i8 0, i64 32, i1 false)
// CHECK-NEXT:    [[__S1:%.*]] = alloca [[STRUCT_POLY64X2X2_T]], align 16
// CHECK-NEXT:    [[TMP3:%.*]] = ptrtoint ptr [[__S1]] to i64
// CHECK-NEXT:    [[TMP4:%.*]] = xor i64 [[TMP3]], 193514046488576
// CHECK-NEXT:    [[TMP5:%.*]] = inttoptr i64 [[TMP4]] to ptr
// CHECK-NEXT:    call void @llvm.memset.p0.i64(ptr align 16 [[TMP5]], i8 0, i64 32, i1 false)
// CHECK-NEXT:    [[COERCE_DIVE:%.*]] = getelementptr inbounds [[STRUCT_POLY64X2X2_T]], ptr [[B]], i32 0, i32 0
// CHECK-NEXT:    [[TMP6:%.*]] = ptrtoint ptr [[COERCE_DIVE]] to i64
// CHECK-NEXT:    [[TMP7:%.*]] = xor i64 [[TMP6]], 193514046488576
// CHECK-NEXT:    [[TMP8:%.*]] = inttoptr i64 [[TMP7]] to ptr
// CHECK-NEXT:    store [2 x <2 x i64>] zeroinitializer, ptr [[TMP8]], align 16
// CHECK-NEXT:    store [2 x <2 x i64>] [[B_COERCE]], ptr [[COERCE_DIVE]], align 16
// CHECK-NEXT:    [[TMP9:%.*]] = call ptr @__msan_memcpy(ptr [[__S1]], ptr [[B]], i64 32)
// CHECK-NEXT:    [[VAL:%.*]] = getelementptr inbounds [[STRUCT_POLY64X2X2_T]], ptr [[__S1]], i32 0, i32 0
// CHECK-NEXT:    [[ARRAYIDX:%.*]] = getelementptr inbounds [2 x <2 x i64>], ptr [[VAL]], i64 0, i64 0
// CHECK-NEXT:    [[TMP10:%.*]] = load <2 x i64>, ptr [[ARRAYIDX]], align 16
// CHECK-NEXT:    [[TMP11:%.*]] = bitcast <2 x i64> [[TMP10]] to <16 x i8>
// CHECK-NEXT:    [[VAL1:%.*]] = getelementptr inbounds [[STRUCT_POLY64X2X2_T]], ptr [[__S1]], i32 0, i32 0
// CHECK-NEXT:    [[ARRAYIDX2:%.*]] = getelementptr inbounds [2 x <2 x i64>], ptr [[VAL1]], i64 0, i64 1
// CHECK-NEXT:    [[TMP12:%.*]] = load <2 x i64>, ptr [[ARRAYIDX2]], align 16
// CHECK-NEXT:    [[TMP13:%.*]] = bitcast <2 x i64> [[TMP12]] to <16 x i8>
// CHECK-NEXT:    [[TMP14:%.*]] = bitcast <16 x i8> [[TMP11]] to <2 x i64>
// CHECK-NEXT:    [[TMP15:%.*]] = bitcast <16 x i8> [[TMP13]] to <2 x i64>
// CHECK-NEXT:    call void @llvm.aarch64.neon.st1x2.v2i64.p0(<2 x i64> [[TMP14]], <2 x i64> [[TMP15]], ptr [[A]])
// CHECK-NEXT:    ret void
//
void test_vst1q_p64_x2(poly64_t *a, poly64x2x2_t b) {
  vst1q_p64_x2(a, b);
}

// CHECK-LABEL: define dso_local void @test_vst1_f64_x2(
// CHECK-SAME: ptr noundef [[A:%.*]], [2 x <1 x double>] alignstack(8) [[B_COERCE:%.*]]) #[[ATTR0]] {
// CHECK-NEXT:  entry:
// CHECK-NEXT:    call void @llvm.donothing()
// CHECK-NEXT:    [[B:%.*]] = alloca [[STRUCT_FLOAT64X1X2_T:%.*]], align 8
// CHECK-NEXT:    [[TMP0:%.*]] = ptrtoint ptr [[B]] to i64
// CHECK-NEXT:    [[TMP1:%.*]] = xor i64 [[TMP0]], 193514046488576
// CHECK-NEXT:    [[TMP2:%.*]] = inttoptr i64 [[TMP1]] to ptr
// CHECK-NEXT:    call void @llvm.memset.p0.i64(ptr align 8 [[TMP2]], i8 0, i64 16, i1 false)
// CHECK-NEXT:    [[__S1:%.*]] = alloca [[STRUCT_FLOAT64X1X2_T]], align 8
// CHECK-NEXT:    [[TMP3:%.*]] = ptrtoint ptr [[__S1]] to i64
// CHECK-NEXT:    [[TMP4:%.*]] = xor i64 [[TMP3]], 193514046488576
// CHECK-NEXT:    [[TMP5:%.*]] = inttoptr i64 [[TMP4]] to ptr
// CHECK-NEXT:    call void @llvm.memset.p0.i64(ptr align 8 [[TMP5]], i8 0, i64 16, i1 false)
// CHECK-NEXT:    [[COERCE_DIVE:%.*]] = getelementptr inbounds [[STRUCT_FLOAT64X1X2_T]], ptr [[B]], i32 0, i32 0
// CHECK-NEXT:    [[TMP6:%.*]] = ptrtoint ptr [[COERCE_DIVE]] to i64
// CHECK-NEXT:    [[TMP7:%.*]] = xor i64 [[TMP6]], 193514046488576
// CHECK-NEXT:    [[TMP8:%.*]] = inttoptr i64 [[TMP7]] to ptr
// CHECK-NEXT:    store [2 x <1 x i64>] zeroinitializer, ptr [[TMP8]], align 8
// CHECK-NEXT:    store [2 x <1 x double>] [[B_COERCE]], ptr [[COERCE_DIVE]], align 8
// CHECK-NEXT:    [[TMP9:%.*]] = call ptr @__msan_memcpy(ptr [[__S1]], ptr [[B]], i64 16)
// CHECK-NEXT:    [[VAL:%.*]] = getelementptr inbounds [[STRUCT_FLOAT64X1X2_T]], ptr [[__S1]], i32 0, i32 0
// CHECK-NEXT:    [[ARRAYIDX:%.*]] = getelementptr inbounds [2 x <1 x double>], ptr [[VAL]], i64 0, i64 0
// CHECK-NEXT:    [[TMP10:%.*]] = load <1 x double>, ptr [[ARRAYIDX]], align 8
// CHECK-NEXT:    [[TMP11:%.*]] = bitcast <1 x double> [[TMP10]] to <8 x i8>
// CHECK-NEXT:    [[VAL1:%.*]] = getelementptr inbounds [[STRUCT_FLOAT64X1X2_T]], ptr [[__S1]], i32 0, i32 0
// CHECK-NEXT:    [[ARRAYIDX2:%.*]] = getelementptr inbounds [2 x <1 x double>], ptr [[VAL1]], i64 0, i64 1
// CHECK-NEXT:    [[TMP12:%.*]] = load <1 x double>, ptr [[ARRAYIDX2]], align 8
// CHECK-NEXT:    [[TMP13:%.*]] = bitcast <1 x double> [[TMP12]] to <8 x i8>
// CHECK-NEXT:    [[TMP14:%.*]] = bitcast <8 x i8> [[TMP11]] to <1 x double>
// CHECK-NEXT:    [[TMP15:%.*]] = bitcast <8 x i8> [[TMP13]] to <1 x double>
// CHECK-NEXT:    call void @llvm.aarch64.neon.st1x2.v1f64.p0(<1 x double> [[TMP14]], <1 x double> [[TMP15]], ptr [[A]])
// CHECK-NEXT:    ret void
//
void test_vst1_f64_x2(float64_t *a, float64x1x2_t b) {
  vst1_f64_x2(a, b);
}

// CHECK-LABEL: define dso_local void @test_vst1_p64_x2(
// CHECK-SAME: ptr noundef [[A:%.*]], [2 x <1 x i64>] alignstack(8) [[B_COERCE:%.*]]) #[[ATTR0]] {
// CHECK-NEXT:  entry:
// CHECK-NEXT:    call void @llvm.donothing()
// CHECK-NEXT:    [[B:%.*]] = alloca [[STRUCT_POLY64X1X2_T:%.*]], align 8
// CHECK-NEXT:    [[TMP0:%.*]] = ptrtoint ptr [[B]] to i64
// CHECK-NEXT:    [[TMP1:%.*]] = xor i64 [[TMP0]], 193514046488576
// CHECK-NEXT:    [[TMP2:%.*]] = inttoptr i64 [[TMP1]] to ptr
// CHECK-NEXT:    call void @llvm.memset.p0.i64(ptr align 8 [[TMP2]], i8 0, i64 16, i1 false)
// CHECK-NEXT:    [[__S1:%.*]] = alloca [[STRUCT_POLY64X1X2_T]], align 8
// CHECK-NEXT:    [[TMP3:%.*]] = ptrtoint ptr [[__S1]] to i64
// CHECK-NEXT:    [[TMP4:%.*]] = xor i64 [[TMP3]], 193514046488576
// CHECK-NEXT:    [[TMP5:%.*]] = inttoptr i64 [[TMP4]] to ptr
// CHECK-NEXT:    call void @llvm.memset.p0.i64(ptr align 8 [[TMP5]], i8 0, i64 16, i1 false)
// CHECK-NEXT:    [[COERCE_DIVE:%.*]] = getelementptr inbounds [[STRUCT_POLY64X1X2_T]], ptr [[B]], i32 0, i32 0
// CHECK-NEXT:    [[TMP6:%.*]] = ptrtoint ptr [[COERCE_DIVE]] to i64
// CHECK-NEXT:    [[TMP7:%.*]] = xor i64 [[TMP6]], 193514046488576
// CHECK-NEXT:    [[TMP8:%.*]] = inttoptr i64 [[TMP7]] to ptr
// CHECK-NEXT:    store [2 x <1 x i64>] zeroinitializer, ptr [[TMP8]], align 8
// CHECK-NEXT:    store [2 x <1 x i64>] [[B_COERCE]], ptr [[COERCE_DIVE]], align 8
// CHECK-NEXT:    [[TMP9:%.*]] = call ptr @__msan_memcpy(ptr [[__S1]], ptr [[B]], i64 16)
// CHECK-NEXT:    [[VAL:%.*]] = getelementptr inbounds [[STRUCT_POLY64X1X2_T]], ptr [[__S1]], i32 0, i32 0
// CHECK-NEXT:    [[ARRAYIDX:%.*]] = getelementptr inbounds [2 x <1 x i64>], ptr [[VAL]], i64 0, i64 0
// CHECK-NEXT:    [[TMP10:%.*]] = load <1 x i64>, ptr [[ARRAYIDX]], align 8
// CHECK-NEXT:    [[TMP11:%.*]] = bitcast <1 x i64> [[TMP10]] to <8 x i8>
// CHECK-NEXT:    [[VAL1:%.*]] = getelementptr inbounds [[STRUCT_POLY64X1X2_T]], ptr [[__S1]], i32 0, i32 0
// CHECK-NEXT:    [[ARRAYIDX2:%.*]] = getelementptr inbounds [2 x <1 x i64>], ptr [[VAL1]], i64 0, i64 1
// CHECK-NEXT:    [[TMP12:%.*]] = load <1 x i64>, ptr [[ARRAYIDX2]], align 8
// CHECK-NEXT:    [[TMP13:%.*]] = bitcast <1 x i64> [[TMP12]] to <8 x i8>
// CHECK-NEXT:    [[TMP14:%.*]] = bitcast <8 x i8> [[TMP11]] to <1 x i64>
// CHECK-NEXT:    [[TMP15:%.*]] = bitcast <8 x i8> [[TMP13]] to <1 x i64>
// CHECK-NEXT:    call void @llvm.aarch64.neon.st1x2.v1i64.p0(<1 x i64> [[TMP14]], <1 x i64> [[TMP15]], ptr [[A]])
// CHECK-NEXT:    ret void
//
void test_vst1_p64_x2(poly64_t *a, poly64x1x2_t b) {
  vst1_p64_x2(a, b);
}

// CHECK-LABEL: define dso_local void @test_vst1q_f64_x3(
// CHECK-SAME: ptr noundef [[A:%.*]], [3 x <2 x double>] alignstack(16) [[B_COERCE:%.*]]) #[[ATTR0]] {
// CHECK-NEXT:  entry:
// CHECK-NEXT:    call void @llvm.donothing()
// CHECK-NEXT:    [[B:%.*]] = alloca [[STRUCT_FLOAT64X2X3_T:%.*]], align 16
// CHECK-NEXT:    [[TMP0:%.*]] = ptrtoint ptr [[B]] to i64
// CHECK-NEXT:    [[TMP1:%.*]] = xor i64 [[TMP0]], 193514046488576
// CHECK-NEXT:    [[TMP2:%.*]] = inttoptr i64 [[TMP1]] to ptr
// CHECK-NEXT:    call void @llvm.memset.p0.i64(ptr align 16 [[TMP2]], i8 0, i64 48, i1 false)
// CHECK-NEXT:    [[__S1:%.*]] = alloca [[STRUCT_FLOAT64X2X3_T]], align 16
// CHECK-NEXT:    [[TMP3:%.*]] = ptrtoint ptr [[__S1]] to i64
// CHECK-NEXT:    [[TMP4:%.*]] = xor i64 [[TMP3]], 193514046488576
// CHECK-NEXT:    [[TMP5:%.*]] = inttoptr i64 [[TMP4]] to ptr
// CHECK-NEXT:    call void @llvm.memset.p0.i64(ptr align 16 [[TMP5]], i8 0, i64 48, i1 false)
// CHECK-NEXT:    [[COERCE_DIVE:%.*]] = getelementptr inbounds [[STRUCT_FLOAT64X2X3_T]], ptr [[B]], i32 0, i32 0
// CHECK-NEXT:    [[TMP6:%.*]] = ptrtoint ptr [[COERCE_DIVE]] to i64
// CHECK-NEXT:    [[TMP7:%.*]] = xor i64 [[TMP6]], 193514046488576
// CHECK-NEXT:    [[TMP8:%.*]] = inttoptr i64 [[TMP7]] to ptr
// CHECK-NEXT:    store [3 x <2 x i64>] zeroinitializer, ptr [[TMP8]], align 16
// CHECK-NEXT:    store [3 x <2 x double>] [[B_COERCE]], ptr [[COERCE_DIVE]], align 16
// CHECK-NEXT:    [[TMP9:%.*]] = call ptr @__msan_memcpy(ptr [[__S1]], ptr [[B]], i64 48)
// CHECK-NEXT:    [[VAL:%.*]] = getelementptr inbounds [[STRUCT_FLOAT64X2X3_T]], ptr [[__S1]], i32 0, i32 0
// CHECK-NEXT:    [[ARRAYIDX:%.*]] = getelementptr inbounds [3 x <2 x double>], ptr [[VAL]], i64 0, i64 0
// CHECK-NEXT:    [[TMP10:%.*]] = load <2 x double>, ptr [[ARRAYIDX]], align 16
// CHECK-NEXT:    [[TMP11:%.*]] = bitcast <2 x double> [[TMP10]] to <16 x i8>
// CHECK-NEXT:    [[VAL1:%.*]] = getelementptr inbounds [[STRUCT_FLOAT64X2X3_T]], ptr [[__S1]], i32 0, i32 0
// CHECK-NEXT:    [[ARRAYIDX2:%.*]] = getelementptr inbounds [3 x <2 x double>], ptr [[VAL1]], i64 0, i64 1
// CHECK-NEXT:    [[TMP12:%.*]] = load <2 x double>, ptr [[ARRAYIDX2]], align 16
// CHECK-NEXT:    [[TMP13:%.*]] = bitcast <2 x double> [[TMP12]] to <16 x i8>
// CHECK-NEXT:    [[VAL3:%.*]] = getelementptr inbounds [[STRUCT_FLOAT64X2X3_T]], ptr [[__S1]], i32 0, i32 0
// CHECK-NEXT:    [[ARRAYIDX4:%.*]] = getelementptr inbounds [3 x <2 x double>], ptr [[VAL3]], i64 0, i64 2
// CHECK-NEXT:    [[TMP14:%.*]] = load <2 x double>, ptr [[ARRAYIDX4]], align 16
// CHECK-NEXT:    [[TMP15:%.*]] = bitcast <2 x double> [[TMP14]] to <16 x i8>
// CHECK-NEXT:    [[TMP16:%.*]] = bitcast <16 x i8> [[TMP11]] to <2 x double>
// CHECK-NEXT:    [[TMP17:%.*]] = bitcast <16 x i8> [[TMP13]] to <2 x double>
// CHECK-NEXT:    [[TMP18:%.*]] = bitcast <16 x i8> [[TMP15]] to <2 x double>
// CHECK-NEXT:    call void @llvm.aarch64.neon.st1x3.v2f64.p0(<2 x double> [[TMP16]], <2 x double> [[TMP17]], <2 x double> [[TMP18]], ptr [[A]])
// CHECK-NEXT:    ret void
//
void test_vst1q_f64_x3(float64_t *a, float64x2x3_t b) {
  vst1q_f64_x3(a, b);
}

// CHECK-LABEL: define dso_local void @test_vst1q_p64_x3(
// CHECK-SAME: ptr noundef [[A:%.*]], [3 x <2 x i64>] alignstack(16) [[B_COERCE:%.*]]) #[[ATTR0]] {
// CHECK-NEXT:  entry:
// CHECK-NEXT:    call void @llvm.donothing()
// CHECK-NEXT:    [[B:%.*]] = alloca [[STRUCT_POLY64X2X3_T:%.*]], align 16
// CHECK-NEXT:    [[TMP0:%.*]] = ptrtoint ptr [[B]] to i64
// CHECK-NEXT:    [[TMP1:%.*]] = xor i64 [[TMP0]], 193514046488576
// CHECK-NEXT:    [[TMP2:%.*]] = inttoptr i64 [[TMP1]] to ptr
// CHECK-NEXT:    call void @llvm.memset.p0.i64(ptr align 16 [[TMP2]], i8 0, i64 48, i1 false)
// CHECK-NEXT:    [[__S1:%.*]] = alloca [[STRUCT_POLY64X2X3_T]], align 16
// CHECK-NEXT:    [[TMP3:%.*]] = ptrtoint ptr [[__S1]] to i64
// CHECK-NEXT:    [[TMP4:%.*]] = xor i64 [[TMP3]], 193514046488576
// CHECK-NEXT:    [[TMP5:%.*]] = inttoptr i64 [[TMP4]] to ptr
// CHECK-NEXT:    call void @llvm.memset.p0.i64(ptr align 16 [[TMP5]], i8 0, i64 48, i1 false)
// CHECK-NEXT:    [[COERCE_DIVE:%.*]] = getelementptr inbounds [[STRUCT_POLY64X2X3_T]], ptr [[B]], i32 0, i32 0
// CHECK-NEXT:    [[TMP6:%.*]] = ptrtoint ptr [[COERCE_DIVE]] to i64
// CHECK-NEXT:    [[TMP7:%.*]] = xor i64 [[TMP6]], 193514046488576
// CHECK-NEXT:    [[TMP8:%.*]] = inttoptr i64 [[TMP7]] to ptr
// CHECK-NEXT:    store [3 x <2 x i64>] zeroinitializer, ptr [[TMP8]], align 16
// CHECK-NEXT:    store [3 x <2 x i64>] [[B_COERCE]], ptr [[COERCE_DIVE]], align 16
// CHECK-NEXT:    [[TMP9:%.*]] = call ptr @__msan_memcpy(ptr [[__S1]], ptr [[B]], i64 48)
// CHECK-NEXT:    [[VAL:%.*]] = getelementptr inbounds [[STRUCT_POLY64X2X3_T]], ptr [[__S1]], i32 0, i32 0
// CHECK-NEXT:    [[ARRAYIDX:%.*]] = getelementptr inbounds [3 x <2 x i64>], ptr [[VAL]], i64 0, i64 0
// CHECK-NEXT:    [[TMP10:%.*]] = load <2 x i64>, ptr [[ARRAYIDX]], align 16
// CHECK-NEXT:    [[TMP11:%.*]] = bitcast <2 x i64> [[TMP10]] to <16 x i8>
// CHECK-NEXT:    [[VAL1:%.*]] = getelementptr inbounds [[STRUCT_POLY64X2X3_T]], ptr [[__S1]], i32 0, i32 0
// CHECK-NEXT:    [[ARRAYIDX2:%.*]] = getelementptr inbounds [3 x <2 x i64>], ptr [[VAL1]], i64 0, i64 1
// CHECK-NEXT:    [[TMP12:%.*]] = load <2 x i64>, ptr [[ARRAYIDX2]], align 16
// CHECK-NEXT:    [[TMP13:%.*]] = bitcast <2 x i64> [[TMP12]] to <16 x i8>
// CHECK-NEXT:    [[VAL3:%.*]] = getelementptr inbounds [[STRUCT_POLY64X2X3_T]], ptr [[__S1]], i32 0, i32 0
// CHECK-NEXT:    [[ARRAYIDX4:%.*]] = getelementptr inbounds [3 x <2 x i64>], ptr [[VAL3]], i64 0, i64 2
// CHECK-NEXT:    [[TMP14:%.*]] = load <2 x i64>, ptr [[ARRAYIDX4]], align 16
// CHECK-NEXT:    [[TMP15:%.*]] = bitcast <2 x i64> [[TMP14]] to <16 x i8>
// CHECK-NEXT:    [[TMP16:%.*]] = bitcast <16 x i8> [[TMP11]] to <2 x i64>
// CHECK-NEXT:    [[TMP17:%.*]] = bitcast <16 x i8> [[TMP13]] to <2 x i64>
// CHECK-NEXT:    [[TMP18:%.*]] = bitcast <16 x i8> [[TMP15]] to <2 x i64>
// CHECK-NEXT:    call void @llvm.aarch64.neon.st1x3.v2i64.p0(<2 x i64> [[TMP16]], <2 x i64> [[TMP17]], <2 x i64> [[TMP18]], ptr [[A]])
// CHECK-NEXT:    ret void
//
void test_vst1q_p64_x3(poly64_t *a, poly64x2x3_t b) {
  vst1q_p64_x3(a, b);
}

// CHECK-LABEL: define dso_local void @test_vst1_f64_x3(
// CHECK-SAME: ptr noundef [[A:%.*]], [3 x <1 x double>] alignstack(8) [[B_COERCE:%.*]]) #[[ATTR0]] {
// CHECK-NEXT:  entry:
// CHECK-NEXT:    call void @llvm.donothing()
// CHECK-NEXT:    [[B:%.*]] = alloca [[STRUCT_FLOAT64X1X3_T:%.*]], align 8
// CHECK-NEXT:    [[TMP0:%.*]] = ptrtoint ptr [[B]] to i64
// CHECK-NEXT:    [[TMP1:%.*]] = xor i64 [[TMP0]], 193514046488576
// CHECK-NEXT:    [[TMP2:%.*]] = inttoptr i64 [[TMP1]] to ptr
// CHECK-NEXT:    call void @llvm.memset.p0.i64(ptr align 8 [[TMP2]], i8 0, i64 24, i1 false)
// CHECK-NEXT:    [[__S1:%.*]] = alloca [[STRUCT_FLOAT64X1X3_T]], align 8
// CHECK-NEXT:    [[TMP3:%.*]] = ptrtoint ptr [[__S1]] to i64
// CHECK-NEXT:    [[TMP4:%.*]] = xor i64 [[TMP3]], 193514046488576
// CHECK-NEXT:    [[TMP5:%.*]] = inttoptr i64 [[TMP4]] to ptr
// CHECK-NEXT:    call void @llvm.memset.p0.i64(ptr align 8 [[TMP5]], i8 0, i64 24, i1 false)
// CHECK-NEXT:    [[COERCE_DIVE:%.*]] = getelementptr inbounds [[STRUCT_FLOAT64X1X3_T]], ptr [[B]], i32 0, i32 0
// CHECK-NEXT:    [[TMP6:%.*]] = ptrtoint ptr [[COERCE_DIVE]] to i64
// CHECK-NEXT:    [[TMP7:%.*]] = xor i64 [[TMP6]], 193514046488576
// CHECK-NEXT:    [[TMP8:%.*]] = inttoptr i64 [[TMP7]] to ptr
// CHECK-NEXT:    store [3 x <1 x i64>] zeroinitializer, ptr [[TMP8]], align 8
// CHECK-NEXT:    store [3 x <1 x double>] [[B_COERCE]], ptr [[COERCE_DIVE]], align 8
// CHECK-NEXT:    [[TMP9:%.*]] = call ptr @__msan_memcpy(ptr [[__S1]], ptr [[B]], i64 24)
// CHECK-NEXT:    [[VAL:%.*]] = getelementptr inbounds [[STRUCT_FLOAT64X1X3_T]], ptr [[__S1]], i32 0, i32 0
// CHECK-NEXT:    [[ARRAYIDX:%.*]] = getelementptr inbounds [3 x <1 x double>], ptr [[VAL]], i64 0, i64 0
// CHECK-NEXT:    [[TMP10:%.*]] = load <1 x double>, ptr [[ARRAYIDX]], align 8
// CHECK-NEXT:    [[TMP11:%.*]] = bitcast <1 x double> [[TMP10]] to <8 x i8>
// CHECK-NEXT:    [[VAL1:%.*]] = getelementptr inbounds [[STRUCT_FLOAT64X1X3_T]], ptr [[__S1]], i32 0, i32 0
// CHECK-NEXT:    [[ARRAYIDX2:%.*]] = getelementptr inbounds [3 x <1 x double>], ptr [[VAL1]], i64 0, i64 1
// CHECK-NEXT:    [[TMP12:%.*]] = load <1 x double>, ptr [[ARRAYIDX2]], align 8
// CHECK-NEXT:    [[TMP13:%.*]] = bitcast <1 x double> [[TMP12]] to <8 x i8>
// CHECK-NEXT:    [[VAL3:%.*]] = getelementptr inbounds [[STRUCT_FLOAT64X1X3_T]], ptr [[__S1]], i32 0, i32 0
// CHECK-NEXT:    [[ARRAYIDX4:%.*]] = getelementptr inbounds [3 x <1 x double>], ptr [[VAL3]], i64 0, i64 2
// CHECK-NEXT:    [[TMP14:%.*]] = load <1 x double>, ptr [[ARRAYIDX4]], align 8
// CHECK-NEXT:    [[TMP15:%.*]] = bitcast <1 x double> [[TMP14]] to <8 x i8>
// CHECK-NEXT:    [[TMP16:%.*]] = bitcast <8 x i8> [[TMP11]] to <1 x double>
// CHECK-NEXT:    [[TMP17:%.*]] = bitcast <8 x i8> [[TMP13]] to <1 x double>
// CHECK-NEXT:    [[TMP18:%.*]] = bitcast <8 x i8> [[TMP15]] to <1 x double>
// CHECK-NEXT:    call void @llvm.aarch64.neon.st1x3.v1f64.p0(<1 x double> [[TMP16]], <1 x double> [[TMP17]], <1 x double> [[TMP18]], ptr [[A]])
// CHECK-NEXT:    ret void
//
void test_vst1_f64_x3(float64_t *a, float64x1x3_t b) {
  vst1_f64_x3(a, b);
}

// CHECK-LABEL: define dso_local void @test_vst1_p64_x3(
// CHECK-SAME: ptr noundef [[A:%.*]], [3 x <1 x i64>] alignstack(8) [[B_COERCE:%.*]]) #[[ATTR0]] {
// CHECK-NEXT:  entry:
// CHECK-NEXT:    call void @llvm.donothing()
// CHECK-NEXT:    [[B:%.*]] = alloca [[STRUCT_POLY64X1X3_T:%.*]], align 8
// CHECK-NEXT:    [[TMP0:%.*]] = ptrtoint ptr [[B]] to i64
// CHECK-NEXT:    [[TMP1:%.*]] = xor i64 [[TMP0]], 193514046488576
// CHECK-NEXT:    [[TMP2:%.*]] = inttoptr i64 [[TMP1]] to ptr
// CHECK-NEXT:    call void @llvm.memset.p0.i64(ptr align 8 [[TMP2]], i8 0, i64 24, i1 false)
// CHECK-NEXT:    [[__S1:%.*]] = alloca [[STRUCT_POLY64X1X3_T]], align 8
// CHECK-NEXT:    [[TMP3:%.*]] = ptrtoint ptr [[__S1]] to i64
// CHECK-NEXT:    [[TMP4:%.*]] = xor i64 [[TMP3]], 193514046488576
// CHECK-NEXT:    [[TMP5:%.*]] = inttoptr i64 [[TMP4]] to ptr
// CHECK-NEXT:    call void @llvm.memset.p0.i64(ptr align 8 [[TMP5]], i8 0, i64 24, i1 false)
// CHECK-NEXT:    [[COERCE_DIVE:%.*]] = getelementptr inbounds [[STRUCT_POLY64X1X3_T]], ptr [[B]], i32 0, i32 0
// CHECK-NEXT:    [[TMP6:%.*]] = ptrtoint ptr [[COERCE_DIVE]] to i64
// CHECK-NEXT:    [[TMP7:%.*]] = xor i64 [[TMP6]], 193514046488576
// CHECK-NEXT:    [[TMP8:%.*]] = inttoptr i64 [[TMP7]] to ptr
// CHECK-NEXT:    store [3 x <1 x i64>] zeroinitializer, ptr [[TMP8]], align 8
// CHECK-NEXT:    store [3 x <1 x i64>] [[B_COERCE]], ptr [[COERCE_DIVE]], align 8
// CHECK-NEXT:    [[TMP9:%.*]] = call ptr @__msan_memcpy(ptr [[__S1]], ptr [[B]], i64 24)
// CHECK-NEXT:    [[VAL:%.*]] = getelementptr inbounds [[STRUCT_POLY64X1X3_T]], ptr [[__S1]], i32 0, i32 0
// CHECK-NEXT:    [[ARRAYIDX:%.*]] = getelementptr inbounds [3 x <1 x i64>], ptr [[VAL]], i64 0, i64 0
// CHECK-NEXT:    [[TMP10:%.*]] = load <1 x i64>, ptr [[ARRAYIDX]], align 8
// CHECK-NEXT:    [[TMP11:%.*]] = bitcast <1 x i64> [[TMP10]] to <8 x i8>
// CHECK-NEXT:    [[VAL1:%.*]] = getelementptr inbounds [[STRUCT_POLY64X1X3_T]], ptr [[__S1]], i32 0, i32 0
// CHECK-NEXT:    [[ARRAYIDX2:%.*]] = getelementptr inbounds [3 x <1 x i64>], ptr [[VAL1]], i64 0, i64 1
// CHECK-NEXT:    [[TMP12:%.*]] = load <1 x i64>, ptr [[ARRAYIDX2]], align 8
// CHECK-NEXT:    [[TMP13:%.*]] = bitcast <1 x i64> [[TMP12]] to <8 x i8>
// CHECK-NEXT:    [[VAL3:%.*]] = getelementptr inbounds [[STRUCT_POLY64X1X3_T]], ptr [[__S1]], i32 0, i32 0
// CHECK-NEXT:    [[ARRAYIDX4:%.*]] = getelementptr inbounds [3 x <1 x i64>], ptr [[VAL3]], i64 0, i64 2
// CHECK-NEXT:    [[TMP14:%.*]] = load <1 x i64>, ptr [[ARRAYIDX4]], align 8
// CHECK-NEXT:    [[TMP15:%.*]] = bitcast <1 x i64> [[TMP14]] to <8 x i8>
// CHECK-NEXT:    [[TMP16:%.*]] = bitcast <8 x i8> [[TMP11]] to <1 x i64>
// CHECK-NEXT:    [[TMP17:%.*]] = bitcast <8 x i8> [[TMP13]] to <1 x i64>
// CHECK-NEXT:    [[TMP18:%.*]] = bitcast <8 x i8> [[TMP15]] to <1 x i64>
// CHECK-NEXT:    call void @llvm.aarch64.neon.st1x3.v1i64.p0(<1 x i64> [[TMP16]], <1 x i64> [[TMP17]], <1 x i64> [[TMP18]], ptr [[A]])
// CHECK-NEXT:    ret void
//
void test_vst1_p64_x3(poly64_t *a, poly64x1x3_t b) {
  vst1_p64_x3(a, b);
}

// CHECK-LABEL: define dso_local void @test_vst1q_f64_x4(
// CHECK-SAME: ptr noundef [[A:%.*]], [4 x <2 x double>] alignstack(16) [[B_COERCE:%.*]]) #[[ATTR0]] {
// CHECK-NEXT:  entry:
// CHECK-NEXT:    call void @llvm.donothing()
// CHECK-NEXT:    [[B:%.*]] = alloca [[STRUCT_FLOAT64X2X4_T:%.*]], align 16
// CHECK-NEXT:    [[TMP0:%.*]] = ptrtoint ptr [[B]] to i64
// CHECK-NEXT:    [[TMP1:%.*]] = xor i64 [[TMP0]], 193514046488576
// CHECK-NEXT:    [[TMP2:%.*]] = inttoptr i64 [[TMP1]] to ptr
// CHECK-NEXT:    call void @llvm.memset.p0.i64(ptr align 16 [[TMP2]], i8 0, i64 64, i1 false)
// CHECK-NEXT:    [[__S1:%.*]] = alloca [[STRUCT_FLOAT64X2X4_T]], align 16
// CHECK-NEXT:    [[TMP3:%.*]] = ptrtoint ptr [[__S1]] to i64
// CHECK-NEXT:    [[TMP4:%.*]] = xor i64 [[TMP3]], 193514046488576
// CHECK-NEXT:    [[TMP5:%.*]] = inttoptr i64 [[TMP4]] to ptr
// CHECK-NEXT:    call void @llvm.memset.p0.i64(ptr align 16 [[TMP5]], i8 0, i64 64, i1 false)
// CHECK-NEXT:    [[COERCE_DIVE:%.*]] = getelementptr inbounds [[STRUCT_FLOAT64X2X4_T]], ptr [[B]], i32 0, i32 0
// CHECK-NEXT:    [[TMP6:%.*]] = ptrtoint ptr [[COERCE_DIVE]] to i64
// CHECK-NEXT:    [[TMP7:%.*]] = xor i64 [[TMP6]], 193514046488576
// CHECK-NEXT:    [[TMP8:%.*]] = inttoptr i64 [[TMP7]] to ptr
// CHECK-NEXT:    store [4 x <2 x i64>] zeroinitializer, ptr [[TMP8]], align 16
// CHECK-NEXT:    store [4 x <2 x double>] [[B_COERCE]], ptr [[COERCE_DIVE]], align 16
// CHECK-NEXT:    [[TMP9:%.*]] = call ptr @__msan_memcpy(ptr [[__S1]], ptr [[B]], i64 64)
// CHECK-NEXT:    [[VAL:%.*]] = getelementptr inbounds [[STRUCT_FLOAT64X2X4_T]], ptr [[__S1]], i32 0, i32 0
// CHECK-NEXT:    [[ARRAYIDX:%.*]] = getelementptr inbounds [4 x <2 x double>], ptr [[VAL]], i64 0, i64 0
// CHECK-NEXT:    [[TMP10:%.*]] = load <2 x double>, ptr [[ARRAYIDX]], align 16
// CHECK-NEXT:    [[TMP11:%.*]] = bitcast <2 x double> [[TMP10]] to <16 x i8>
// CHECK-NEXT:    [[VAL1:%.*]] = getelementptr inbounds [[STRUCT_FLOAT64X2X4_T]], ptr [[__S1]], i32 0, i32 0
// CHECK-NEXT:    [[ARRAYIDX2:%.*]] = getelementptr inbounds [4 x <2 x double>], ptr [[VAL1]], i64 0, i64 1
// CHECK-NEXT:    [[TMP12:%.*]] = load <2 x double>, ptr [[ARRAYIDX2]], align 16
// CHECK-NEXT:    [[TMP13:%.*]] = bitcast <2 x double> [[TMP12]] to <16 x i8>
// CHECK-NEXT:    [[VAL3:%.*]] = getelementptr inbounds [[STRUCT_FLOAT64X2X4_T]], ptr [[__S1]], i32 0, i32 0
// CHECK-NEXT:    [[ARRAYIDX4:%.*]] = getelementptr inbounds [4 x <2 x double>], ptr [[VAL3]], i64 0, i64 2
// CHECK-NEXT:    [[TMP14:%.*]] = load <2 x double>, ptr [[ARRAYIDX4]], align 16
// CHECK-NEXT:    [[TMP15:%.*]] = bitcast <2 x double> [[TMP14]] to <16 x i8>
// CHECK-NEXT:    [[VAL5:%.*]] = getelementptr inbounds [[STRUCT_FLOAT64X2X4_T]], ptr [[__S1]], i32 0, i32 0
// CHECK-NEXT:    [[ARRAYIDX6:%.*]] = getelementptr inbounds [4 x <2 x double>], ptr [[VAL5]], i64 0, i64 3
// CHECK-NEXT:    [[TMP16:%.*]] = load <2 x double>, ptr [[ARRAYIDX6]], align 16
// CHECK-NEXT:    [[TMP17:%.*]] = bitcast <2 x double> [[TMP16]] to <16 x i8>
// CHECK-NEXT:    [[TMP18:%.*]] = bitcast <16 x i8> [[TMP11]] to <2 x double>
// CHECK-NEXT:    [[TMP19:%.*]] = bitcast <16 x i8> [[TMP13]] to <2 x double>
// CHECK-NEXT:    [[TMP20:%.*]] = bitcast <16 x i8> [[TMP15]] to <2 x double>
// CHECK-NEXT:    [[TMP21:%.*]] = bitcast <16 x i8> [[TMP17]] to <2 x double>
// CHECK-NEXT:    call void @llvm.aarch64.neon.st1x4.v2f64.p0(<2 x double> [[TMP18]], <2 x double> [[TMP19]], <2 x double> [[TMP20]], <2 x double> [[TMP21]], ptr [[A]])
// CHECK-NEXT:    ret void
//
void test_vst1q_f64_x4(float64_t *a, float64x2x4_t b) {
  vst1q_f64_x4(a, b);
}

// CHECK-LABEL: define dso_local void @test_vst1q_p64_x4(
// CHECK-SAME: ptr noundef [[A:%.*]], [4 x <2 x i64>] alignstack(16) [[B_COERCE:%.*]]) #[[ATTR0]] {
// CHECK-NEXT:  entry:
// CHECK-NEXT:    call void @llvm.donothing()
// CHECK-NEXT:    [[B:%.*]] = alloca [[STRUCT_POLY64X2X4_T:%.*]], align 16
// CHECK-NEXT:    [[TMP0:%.*]] = ptrtoint ptr [[B]] to i64
// CHECK-NEXT:    [[TMP1:%.*]] = xor i64 [[TMP0]], 193514046488576
// CHECK-NEXT:    [[TMP2:%.*]] = inttoptr i64 [[TMP1]] to ptr
// CHECK-NEXT:    call void @llvm.memset.p0.i64(ptr align 16 [[TMP2]], i8 0, i64 64, i1 false)
// CHECK-NEXT:    [[__S1:%.*]] = alloca [[STRUCT_POLY64X2X4_T]], align 16
// CHECK-NEXT:    [[TMP3:%.*]] = ptrtoint ptr [[__S1]] to i64
// CHECK-NEXT:    [[TMP4:%.*]] = xor i64 [[TMP3]], 193514046488576
// CHECK-NEXT:    [[TMP5:%.*]] = inttoptr i64 [[TMP4]] to ptr
// CHECK-NEXT:    call void @llvm.memset.p0.i64(ptr align 16 [[TMP5]], i8 0, i64 64, i1 false)
// CHECK-NEXT:    [[COERCE_DIVE:%.*]] = getelementptr inbounds [[STRUCT_POLY64X2X4_T]], ptr [[B]], i32 0, i32 0
// CHECK-NEXT:    [[TMP6:%.*]] = ptrtoint ptr [[COERCE_DIVE]] to i64
// CHECK-NEXT:    [[TMP7:%.*]] = xor i64 [[TMP6]], 193514046488576
// CHECK-NEXT:    [[TMP8:%.*]] = inttoptr i64 [[TMP7]] to ptr
// CHECK-NEXT:    store [4 x <2 x i64>] zeroinitializer, ptr [[TMP8]], align 16
// CHECK-NEXT:    store [4 x <2 x i64>] [[B_COERCE]], ptr [[COERCE_DIVE]], align 16
// CHECK-NEXT:    [[TMP9:%.*]] = call ptr @__msan_memcpy(ptr [[__S1]], ptr [[B]], i64 64)
// CHECK-NEXT:    [[VAL:%.*]] = getelementptr inbounds [[STRUCT_POLY64X2X4_T]], ptr [[__S1]], i32 0, i32 0
// CHECK-NEXT:    [[ARRAYIDX:%.*]] = getelementptr inbounds [4 x <2 x i64>], ptr [[VAL]], i64 0, i64 0
// CHECK-NEXT:    [[TMP10:%.*]] = load <2 x i64>, ptr [[ARRAYIDX]], align 16
// CHECK-NEXT:    [[TMP11:%.*]] = bitcast <2 x i64> [[TMP10]] to <16 x i8>
// CHECK-NEXT:    [[VAL1:%.*]] = getelementptr inbounds [[STRUCT_POLY64X2X4_T]], ptr [[__S1]], i32 0, i32 0
// CHECK-NEXT:    [[ARRAYIDX2:%.*]] = getelementptr inbounds [4 x <2 x i64>], ptr [[VAL1]], i64 0, i64 1
// CHECK-NEXT:    [[TMP12:%.*]] = load <2 x i64>, ptr [[ARRAYIDX2]], align 16
// CHECK-NEXT:    [[TMP13:%.*]] = bitcast <2 x i64> [[TMP12]] to <16 x i8>
// CHECK-NEXT:    [[VAL3:%.*]] = getelementptr inbounds [[STRUCT_POLY64X2X4_T]], ptr [[__S1]], i32 0, i32 0
// CHECK-NEXT:    [[ARRAYIDX4:%.*]] = getelementptr inbounds [4 x <2 x i64>], ptr [[VAL3]], i64 0, i64 2
// CHECK-NEXT:    [[TMP14:%.*]] = load <2 x i64>, ptr [[ARRAYIDX4]], align 16
// CHECK-NEXT:    [[TMP15:%.*]] = bitcast <2 x i64> [[TMP14]] to <16 x i8>
// CHECK-NEXT:    [[VAL5:%.*]] = getelementptr inbounds [[STRUCT_POLY64X2X4_T]], ptr [[__S1]], i32 0, i32 0
// CHECK-NEXT:    [[ARRAYIDX6:%.*]] = getelementptr inbounds [4 x <2 x i64>], ptr [[VAL5]], i64 0, i64 3
// CHECK-NEXT:    [[TMP16:%.*]] = load <2 x i64>, ptr [[ARRAYIDX6]], align 16
// CHECK-NEXT:    [[TMP17:%.*]] = bitcast <2 x i64> [[TMP16]] to <16 x i8>
// CHECK-NEXT:    [[TMP18:%.*]] = bitcast <16 x i8> [[TMP11]] to <2 x i64>
// CHECK-NEXT:    [[TMP19:%.*]] = bitcast <16 x i8> [[TMP13]] to <2 x i64>
// CHECK-NEXT:    [[TMP20:%.*]] = bitcast <16 x i8> [[TMP15]] to <2 x i64>
// CHECK-NEXT:    [[TMP21:%.*]] = bitcast <16 x i8> [[TMP17]] to <2 x i64>
// CHECK-NEXT:    call void @llvm.aarch64.neon.st1x4.v2i64.p0(<2 x i64> [[TMP18]], <2 x i64> [[TMP19]], <2 x i64> [[TMP20]], <2 x i64> [[TMP21]], ptr [[A]])
// CHECK-NEXT:    ret void
//
void test_vst1q_p64_x4(poly64_t *a, poly64x2x4_t b) {
  vst1q_p64_x4(a, b);
}

// CHECK-LABEL: define dso_local void @test_vst1_f64_x4(
// CHECK-SAME: ptr noundef [[A:%.*]], [4 x <1 x double>] alignstack(8) [[B_COERCE:%.*]]) #[[ATTR0]] {
// CHECK-NEXT:  entry:
// CHECK-NEXT:    call void @llvm.donothing()
// CHECK-NEXT:    [[B:%.*]] = alloca [[STRUCT_FLOAT64X1X4_T:%.*]], align 8
// CHECK-NEXT:    [[TMP0:%.*]] = ptrtoint ptr [[B]] to i64
// CHECK-NEXT:    [[TMP1:%.*]] = xor i64 [[TMP0]], 193514046488576
// CHECK-NEXT:    [[TMP2:%.*]] = inttoptr i64 [[TMP1]] to ptr
// CHECK-NEXT:    call void @llvm.memset.p0.i64(ptr align 8 [[TMP2]], i8 0, i64 32, i1 false)
// CHECK-NEXT:    [[__S1:%.*]] = alloca [[STRUCT_FLOAT64X1X4_T]], align 8
// CHECK-NEXT:    [[TMP3:%.*]] = ptrtoint ptr [[__S1]] to i64
// CHECK-NEXT:    [[TMP4:%.*]] = xor i64 [[TMP3]], 193514046488576
// CHECK-NEXT:    [[TMP5:%.*]] = inttoptr i64 [[TMP4]] to ptr
// CHECK-NEXT:    call void @llvm.memset.p0.i64(ptr align 8 [[TMP5]], i8 0, i64 32, i1 false)
// CHECK-NEXT:    [[COERCE_DIVE:%.*]] = getelementptr inbounds [[STRUCT_FLOAT64X1X4_T]], ptr [[B]], i32 0, i32 0
// CHECK-NEXT:    [[TMP6:%.*]] = ptrtoint ptr [[COERCE_DIVE]] to i64
// CHECK-NEXT:    [[TMP7:%.*]] = xor i64 [[TMP6]], 193514046488576
// CHECK-NEXT:    [[TMP8:%.*]] = inttoptr i64 [[TMP7]] to ptr
// CHECK-NEXT:    store [4 x <1 x i64>] zeroinitializer, ptr [[TMP8]], align 8
// CHECK-NEXT:    store [4 x <1 x double>] [[B_COERCE]], ptr [[COERCE_DIVE]], align 8
// CHECK-NEXT:    [[TMP9:%.*]] = call ptr @__msan_memcpy(ptr [[__S1]], ptr [[B]], i64 32)
// CHECK-NEXT:    [[VAL:%.*]] = getelementptr inbounds [[STRUCT_FLOAT64X1X4_T]], ptr [[__S1]], i32 0, i32 0
// CHECK-NEXT:    [[ARRAYIDX:%.*]] = getelementptr inbounds [4 x <1 x double>], ptr [[VAL]], i64 0, i64 0
// CHECK-NEXT:    [[TMP10:%.*]] = load <1 x double>, ptr [[ARRAYIDX]], align 8
// CHECK-NEXT:    [[TMP11:%.*]] = bitcast <1 x double> [[TMP10]] to <8 x i8>
// CHECK-NEXT:    [[VAL1:%.*]] = getelementptr inbounds [[STRUCT_FLOAT64X1X4_T]], ptr [[__S1]], i32 0, i32 0
// CHECK-NEXT:    [[ARRAYIDX2:%.*]] = getelementptr inbounds [4 x <1 x double>], ptr [[VAL1]], i64 0, i64 1
// CHECK-NEXT:    [[TMP12:%.*]] = load <1 x double>, ptr [[ARRAYIDX2]], align 8
// CHECK-NEXT:    [[TMP13:%.*]] = bitcast <1 x double> [[TMP12]] to <8 x i8>
// CHECK-NEXT:    [[VAL3:%.*]] = getelementptr inbounds [[STRUCT_FLOAT64X1X4_T]], ptr [[__S1]], i32 0, i32 0
// CHECK-NEXT:    [[ARRAYIDX4:%.*]] = getelementptr inbounds [4 x <1 x double>], ptr [[VAL3]], i64 0, i64 2
// CHECK-NEXT:    [[TMP14:%.*]] = load <1 x double>, ptr [[ARRAYIDX4]], align 8
// CHECK-NEXT:    [[TMP15:%.*]] = bitcast <1 x double> [[TMP14]] to <8 x i8>
// CHECK-NEXT:    [[VAL5:%.*]] = getelementptr inbounds [[STRUCT_FLOAT64X1X4_T]], ptr [[__S1]], i32 0, i32 0
// CHECK-NEXT:    [[ARRAYIDX6:%.*]] = getelementptr inbounds [4 x <1 x double>], ptr [[VAL5]], i64 0, i64 3
// CHECK-NEXT:    [[TMP16:%.*]] = load <1 x double>, ptr [[ARRAYIDX6]], align 8
// CHECK-NEXT:    [[TMP17:%.*]] = bitcast <1 x double> [[TMP16]] to <8 x i8>
// CHECK-NEXT:    [[TMP18:%.*]] = bitcast <8 x i8> [[TMP11]] to <1 x double>
// CHECK-NEXT:    [[TMP19:%.*]] = bitcast <8 x i8> [[TMP13]] to <1 x double>
// CHECK-NEXT:    [[TMP20:%.*]] = bitcast <8 x i8> [[TMP15]] to <1 x double>
// CHECK-NEXT:    [[TMP21:%.*]] = bitcast <8 x i8> [[TMP17]] to <1 x double>
// CHECK-NEXT:    call void @llvm.aarch64.neon.st1x4.v1f64.p0(<1 x double> [[TMP18]], <1 x double> [[TMP19]], <1 x double> [[TMP20]], <1 x double> [[TMP21]], ptr [[A]])
// CHECK-NEXT:    ret void
//
void test_vst1_f64_x4(float64_t *a, float64x1x4_t b) {
  vst1_f64_x4(a, b);
}

// CHECK-LABEL: define dso_local void @test_vst1_p64_x4(
// CHECK-SAME: ptr noundef [[A:%.*]], [4 x <1 x i64>] alignstack(8) [[B_COERCE:%.*]]) #[[ATTR0]] {
// CHECK-NEXT:  entry:
// CHECK-NEXT:    call void @llvm.donothing()
// CHECK-NEXT:    [[B:%.*]] = alloca [[STRUCT_POLY64X1X4_T:%.*]], align 8
// CHECK-NEXT:    [[TMP0:%.*]] = ptrtoint ptr [[B]] to i64
// CHECK-NEXT:    [[TMP1:%.*]] = xor i64 [[TMP0]], 193514046488576
// CHECK-NEXT:    [[TMP2:%.*]] = inttoptr i64 [[TMP1]] to ptr
// CHECK-NEXT:    call void @llvm.memset.p0.i64(ptr align 8 [[TMP2]], i8 0, i64 32, i1 false)
// CHECK-NEXT:    [[__S1:%.*]] = alloca [[STRUCT_POLY64X1X4_T]], align 8
// CHECK-NEXT:    [[TMP3:%.*]] = ptrtoint ptr [[__S1]] to i64
// CHECK-NEXT:    [[TMP4:%.*]] = xor i64 [[TMP3]], 193514046488576
// CHECK-NEXT:    [[TMP5:%.*]] = inttoptr i64 [[TMP4]] to ptr
// CHECK-NEXT:    call void @llvm.memset.p0.i64(ptr align 8 [[TMP5]], i8 0, i64 32, i1 false)
// CHECK-NEXT:    [[COERCE_DIVE:%.*]] = getelementptr inbounds [[STRUCT_POLY64X1X4_T]], ptr [[B]], i32 0, i32 0
// CHECK-NEXT:    [[TMP6:%.*]] = ptrtoint ptr [[COERCE_DIVE]] to i64
// CHECK-NEXT:    [[TMP7:%.*]] = xor i64 [[TMP6]], 193514046488576
// CHECK-NEXT:    [[TMP8:%.*]] = inttoptr i64 [[TMP7]] to ptr
// CHECK-NEXT:    store [4 x <1 x i64>] zeroinitializer, ptr [[TMP8]], align 8
// CHECK-NEXT:    store [4 x <1 x i64>] [[B_COERCE]], ptr [[COERCE_DIVE]], align 8
// CHECK-NEXT:    [[TMP9:%.*]] = call ptr @__msan_memcpy(ptr [[__S1]], ptr [[B]], i64 32)
// CHECK-NEXT:    [[VAL:%.*]] = getelementptr inbounds [[STRUCT_POLY64X1X4_T]], ptr [[__S1]], i32 0, i32 0
// CHECK-NEXT:    [[ARRAYIDX:%.*]] = getelementptr inbounds [4 x <1 x i64>], ptr [[VAL]], i64 0, i64 0
// CHECK-NEXT:    [[TMP10:%.*]] = load <1 x i64>, ptr [[ARRAYIDX]], align 8
// CHECK-NEXT:    [[TMP11:%.*]] = bitcast <1 x i64> [[TMP10]] to <8 x i8>
// CHECK-NEXT:    [[VAL1:%.*]] = getelementptr inbounds [[STRUCT_POLY64X1X4_T]], ptr [[__S1]], i32 0, i32 0
// CHECK-NEXT:    [[ARRAYIDX2:%.*]] = getelementptr inbounds [4 x <1 x i64>], ptr [[VAL1]], i64 0, i64 1
// CHECK-NEXT:    [[TMP12:%.*]] = load <1 x i64>, ptr [[ARRAYIDX2]], align 8
// CHECK-NEXT:    [[TMP13:%.*]] = bitcast <1 x i64> [[TMP12]] to <8 x i8>
// CHECK-NEXT:    [[VAL3:%.*]] = getelementptr inbounds [[STRUCT_POLY64X1X4_T]], ptr [[__S1]], i32 0, i32 0
// CHECK-NEXT:    [[ARRAYIDX4:%.*]] = getelementptr inbounds [4 x <1 x i64>], ptr [[VAL3]], i64 0, i64 2
// CHECK-NEXT:    [[TMP14:%.*]] = load <1 x i64>, ptr [[ARRAYIDX4]], align 8
// CHECK-NEXT:    [[TMP15:%.*]] = bitcast <1 x i64> [[TMP14]] to <8 x i8>
// CHECK-NEXT:    [[VAL5:%.*]] = getelementptr inbounds [[STRUCT_POLY64X1X4_T]], ptr [[__S1]], i32 0, i32 0
// CHECK-NEXT:    [[ARRAYIDX6:%.*]] = getelementptr inbounds [4 x <1 x i64>], ptr [[VAL5]], i64 0, i64 3
// CHECK-NEXT:    [[TMP16:%.*]] = load <1 x i64>, ptr [[ARRAYIDX6]], align 8
// CHECK-NEXT:    [[TMP17:%.*]] = bitcast <1 x i64> [[TMP16]] to <8 x i8>
// CHECK-NEXT:    [[TMP18:%.*]] = bitcast <8 x i8> [[TMP11]] to <1 x i64>
// CHECK-NEXT:    [[TMP19:%.*]] = bitcast <8 x i8> [[TMP13]] to <1 x i64>
// CHECK-NEXT:    [[TMP20:%.*]] = bitcast <8 x i8> [[TMP15]] to <1 x i64>
// CHECK-NEXT:    [[TMP21:%.*]] = bitcast <8 x i8> [[TMP17]] to <1 x i64>
// CHECK-NEXT:    call void @llvm.aarch64.neon.st1x4.v1i64.p0(<1 x i64> [[TMP18]], <1 x i64> [[TMP19]], <1 x i64> [[TMP20]], <1 x i64> [[TMP21]], ptr [[A]])
// CHECK-NEXT:    ret void
//
void test_vst1_p64_x4(poly64_t *a, poly64x1x4_t b) {
  vst1_p64_x4(a, b);
}
