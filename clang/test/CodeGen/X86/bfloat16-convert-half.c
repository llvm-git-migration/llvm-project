// NOTE: Assertions have been autogenerated by utils/update_cc_test_checks.py UTC_ARGS: --version 4
// RUN: %clang_cc1 -triple x86_64-unknown-linux-gnu -target-feature +fullbf16 -S -emit-llvm %s -o - | FileCheck %s
// CHECK-LABEL: define dso_local half @test_convert_from_bf16_to_fp16(
// CHECK-SAME: bfloat noundef [[A:%.*]]) #[[ATTR0:[0-9]+]] {
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[A_ADDR:%.*]] = alloca bfloat, align 2
// CHECK-NEXT:    store bfloat [[A]], ptr [[A_ADDR]], align 2
// CHECK-NEXT:    [[TMP0:%.*]] = load bfloat, ptr [[A_ADDR]], align 2
// CHECK-NEXT:    [[CONV:%.*]] = bitcast bfloat [[TMP0]] to half
// CHECK-NEXT:    ret half [[CONV]]
//
_Float16 test_convert_from_bf16_to_fp16(__bf16 a) {
    return (_Float16)a;
}

// CHECK-LABEL: define dso_local bfloat @test_convert_from_fp16_to_bf16(
// CHECK-SAME: half noundef [[A:%.*]]) #[[ATTR0]] {
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[A_ADDR:%.*]] = alloca half, align 2
// CHECK-NEXT:    store half [[A]], ptr [[A_ADDR]], align 2
// CHECK-NEXT:    [[TMP0:%.*]] = load half, ptr [[A_ADDR]], align 2
// CHECK-NEXT:    [[CONV:%.*]] = bitcast half [[TMP0]] to bfloat
// CHECK-NEXT:    ret bfloat [[CONV]]
//
__bf16 test_convert_from_fp16_to_bf16(_Float16 a) {
    return (__bf16)a;
}

typedef _Float16 _Float162 __attribute__((ext_vector_type(2)));
typedef _Float16 _Float164 __attribute__((ext_vector_type(4)));

typedef __bf16 __bf162 __attribute__((ext_vector_type(2)));
typedef __bf16 __bf164 __attribute__((ext_vector_type(4)));

// CHECK-LABEL: define dso_local i32 @test_cast_from_fp162_to_bf162(
// CHECK-SAME: i32 noundef [[IN_COERCE:%.*]]) #[[ATTR0]] {
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[RETVAL:%.*]] = alloca <2 x bfloat>, align 4
// CHECK-NEXT:    [[IN:%.*]] = alloca <2 x half>, align 4
// CHECK-NEXT:    [[IN_ADDR:%.*]] = alloca <2 x half>, align 4
// CHECK-NEXT:    store i32 [[IN_COERCE]], ptr [[IN]], align 4
// CHECK-NEXT:    [[IN1:%.*]] = load <2 x half>, ptr [[IN]], align 4
// CHECK-NEXT:    store <2 x half> [[IN1]], ptr [[IN_ADDR]], align 4
// CHECK-NEXT:    [[TMP0:%.*]] = load <2 x half>, ptr [[IN_ADDR]], align 4
// CHECK-NEXT:    [[CONV:%.*]] = bitcast <2 x half> [[TMP0]] to <2 x bfloat>
// CHECK-NEXT:    store <2 x bfloat> [[CONV]], ptr [[RETVAL]], align 4
// CHECK-NEXT:    [[TMP1:%.*]] = load i32, ptr [[RETVAL]], align 4
// CHECK-NEXT:    ret i32 [[TMP1]]
//
__bf162 test_cast_from_fp162_to_bf162(_Float162 in) {
  return __builtin_convertvector(in, __bf162);
}

// CHECK-LABEL: define dso_local double @test_cast_from_fp164_to_bf164(
// CHECK-SAME: double noundef [[IN_COERCE:%.*]]) #[[ATTR0]] {
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[RETVAL:%.*]] = alloca <4 x bfloat>, align 8
// CHECK-NEXT:    [[IN:%.*]] = alloca <4 x half>, align 8
// CHECK-NEXT:    [[IN_ADDR:%.*]] = alloca <4 x half>, align 8
// CHECK-NEXT:    store double [[IN_COERCE]], ptr [[IN]], align 8
// CHECK-NEXT:    [[IN1:%.*]] = load <4 x half>, ptr [[IN]], align 8
// CHECK-NEXT:    store <4 x half> [[IN1]], ptr [[IN_ADDR]], align 8
// CHECK-NEXT:    [[TMP0:%.*]] = load <4 x half>, ptr [[IN_ADDR]], align 8
// CHECK-NEXT:    [[CONV:%.*]] = bitcast <4 x half> [[TMP0]] to <4 x bfloat>
// CHECK-NEXT:    store <4 x bfloat> [[CONV]], ptr [[RETVAL]], align 8
// CHECK-NEXT:    [[TMP1:%.*]] = load double, ptr [[RETVAL]], align 8
// CHECK-NEXT:    ret double [[TMP1]]
//
__bf164 test_cast_from_fp164_to_bf164(_Float164 in) {
  return __builtin_convertvector(in, __bf164);
}

// CHECK-LABEL: define dso_local i32 @test_cast_from_bf162_to_fp162(
// CHECK-SAME: i32 noundef [[IN_COERCE:%.*]]) #[[ATTR0]] {
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[RETVAL:%.*]] = alloca <2 x half>, align 4
// CHECK-NEXT:    [[IN:%.*]] = alloca <2 x bfloat>, align 4
// CHECK-NEXT:    [[IN_ADDR:%.*]] = alloca <2 x bfloat>, align 4
// CHECK-NEXT:    store i32 [[IN_COERCE]], ptr [[IN]], align 4
// CHECK-NEXT:    [[IN1:%.*]] = load <2 x bfloat>, ptr [[IN]], align 4
// CHECK-NEXT:    store <2 x bfloat> [[IN1]], ptr [[IN_ADDR]], align 4
// CHECK-NEXT:    [[TMP0:%.*]] = load <2 x bfloat>, ptr [[IN_ADDR]], align 4
// CHECK-NEXT:    [[CONV:%.*]] = bitcast <2 x bfloat> [[TMP0]] to <2 x half>
// CHECK-NEXT:    store <2 x half> [[CONV]], ptr [[RETVAL]], align 4
// CHECK-NEXT:    [[TMP1:%.*]] = load i32, ptr [[RETVAL]], align 4
// CHECK-NEXT:    ret i32 [[TMP1]]
//
_Float162 test_cast_from_bf162_to_fp162(__bf162 in) {
  return __builtin_convertvector(in, _Float162);
}

// CHECK-LABEL: define dso_local double @test_cast_from_bf164_to_fp164(
// CHECK-SAME: double noundef [[IN_COERCE:%.*]]) #[[ATTR0]] {
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[RETVAL:%.*]] = alloca <4 x half>, align 8
// CHECK-NEXT:    [[IN:%.*]] = alloca <4 x bfloat>, align 8
// CHECK-NEXT:    [[IN_ADDR:%.*]] = alloca <4 x bfloat>, align 8
// CHECK-NEXT:    store double [[IN_COERCE]], ptr [[IN]], align 8
// CHECK-NEXT:    [[IN1:%.*]] = load <4 x bfloat>, ptr [[IN]], align 8
// CHECK-NEXT:    store <4 x bfloat> [[IN1]], ptr [[IN_ADDR]], align 8
// CHECK-NEXT:    [[TMP0:%.*]] = load <4 x bfloat>, ptr [[IN_ADDR]], align 8
// CHECK-NEXT:    [[CONV:%.*]] = bitcast <4 x bfloat> [[TMP0]] to <4 x half>
// CHECK-NEXT:    store <4 x half> [[CONV]], ptr [[RETVAL]], align 8
// CHECK-NEXT:    [[TMP1:%.*]] = load double, ptr [[RETVAL]], align 8
// CHECK-NEXT:    ret double [[TMP1]]
//
_Float164 test_cast_from_bf164_to_fp164(__bf164 in) {
  return __builtin_convertvector(in, _Float164);
}
