// NOTE: Assertions have been autogenerated by utils/update_cc_test_checks.py UTC_ARGS: --check-globals all --include-generated-funcs --version 4
// RUN: %clang_cc1 -std=c++11 -triple riscv64-linux-gnu -target-feature +i -target-feature +m -emit-llvm %s -o - | FileCheck %s

__attribute__((target_version("arch=+v"))) int foo1(void) { return 1; }
__attribute__((target_version("default"))) int foo1(void) { return 1; }

__attribute__((target_version("arch=+zbb"))) int foo2(void) { return 2; }
__attribute__((target_version("arch=+m"))) int foo2(void) { return 2; }
__attribute__((target_version("default"))) int foo2(void) { return 2; }

__attribute__((target_version("arch=+zbb,+c"))) int foo3(void) { return 3; }
__attribute__((target_version("arch=+m"))) int foo3(void) { return 3; }
__attribute__((target_version("default"))) int foo3(void) { return 3; }

int bar() { return foo1() + foo2() + foo3(); }
//.
// CHECK: @__riscv_feature_bits = external dso_local global { i32, [1 x i64] }
// CHECK: @_Z4foo1v = weak_odr ifunc i32 (), ptr @_Z4foo1v.resolver
// CHECK: @_Z4foo2v = weak_odr ifunc i32 (), ptr @_Z4foo2v.resolver
// CHECK: @_Z4foo3v = weak_odr ifunc i32 (), ptr @_Z4foo3v.resolver
//.
// CHECK-LABEL: define dso_local noundef signext i32 @_Z4foo1v.default(
// CHECK-SAME: ) #[[ATTR1:[0-9]+]] {
// CHECK-NEXT:  entry:
// CHECK-NEXT:    ret i32 1
//
//
// CHECK-LABEL: define dso_local noundef signext i32 @_Z4foo2v.default(
// CHECK-SAME: ) #[[ATTR1]] {
// CHECK-NEXT:  entry:
// CHECK-NEXT:    ret i32 2
//
//
// CHECK-LABEL: define dso_local noundef signext i32 @_Z4foo3v.default(
// CHECK-SAME: ) #[[ATTR1]] {
// CHECK-NEXT:  entry:
// CHECK-NEXT:    ret i32 3
//
//
// CHECK-LABEL: define dso_local noundef signext i32 @_Z3barv(
// CHECK-SAME: ) #[[ATTR1]] {
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[CALL:%.*]] = call noundef signext i32 @_Z4foo1v()
// CHECK-NEXT:    [[CALL1:%.*]] = call noundef signext i32 @_Z4foo2v()
// CHECK-NEXT:    [[ADD:%.*]] = add nsw i32 [[CALL]], [[CALL1]]
// CHECK-NEXT:    [[CALL2:%.*]] = call noundef signext i32 @_Z4foo3v()
// CHECK-NEXT:    [[ADD3:%.*]] = add nsw i32 [[ADD]], [[CALL2]]
// CHECK-NEXT:    ret i32 [[ADD3]]
//
//
// CHECK-LABEL: define weak_odr ptr @_Z4foo1v.resolver() comdat {
// CHECK-NEXT:  resolver_entry:
// CHECK-NEXT:    call void @__init_riscv_features_bits()
// CHECK-NEXT:    [[TMP0:%.*]] = load i64, ptr @__riscv_feature_bits, align 8
// CHECK-NEXT:    [[TMP1:%.*]] = icmp ult i64 0, [[TMP0]]
// CHECK-NEXT:    br i1 [[TMP1]], label [[RESOVLER_COND:%.*]], label [[RESOLVER_ELSE:%.*]]
// CHECK:       resovler_cond:
// CHECK-NEXT:    [[TMP2:%.*]] = load i64, ptr getelementptr inbounds ({ i32, [1 x i64] }, ptr @__riscv_feature_bits, i32 0, i32 1, i32 0), align 8
// CHECK-NEXT:    [[TMP3:%.*]] = and i64 [[TMP2]], 2097152
// CHECK-NEXT:    [[TMP4:%.*]] = icmp eq i64 [[TMP3]], 2097152
// CHECK-NEXT:    [[TMP5:%.*]] = and i1 true, [[TMP4]]
// CHECK-NEXT:    br i1 [[TMP5]], label [[RESOLVER_RETURN:%.*]], label [[RESOLVER_ELSE]]
// CHECK:       resolver_return:
// CHECK-NEXT:    ret ptr @"_Z4foo1v.arch=+v"
// CHECK:       resolver_else:
// CHECK-NEXT:    ret ptr @_Z4foo1v.default
//
//
// CHECK-LABEL: define weak_odr ptr @_Z4foo2v.resolver() comdat {
// CHECK-NEXT:  resolver_entry:
// CHECK-NEXT:    call void @__init_riscv_features_bits()
// CHECK-NEXT:    [[TMP0:%.*]] = load i64, ptr @__riscv_feature_bits, align 8
// CHECK-NEXT:    [[TMP1:%.*]] = icmp ult i64 0, [[TMP0]]
// CHECK-NEXT:    br i1 [[TMP1]], label [[RESOVLER_COND:%.*]], label [[RESOLVER_ELSE:%.*]]
// CHECK:       resovler_cond:
// CHECK-NEXT:    [[TMP2:%.*]] = load i64, ptr getelementptr inbounds ({ i32, [1 x i64] }, ptr @__riscv_feature_bits, i32 0, i32 1, i32 0), align 8
// CHECK-NEXT:    [[TMP3:%.*]] = and i64 [[TMP2]], 268435456
// CHECK-NEXT:    [[TMP4:%.*]] = icmp eq i64 [[TMP3]], 268435456
// CHECK-NEXT:    [[TMP5:%.*]] = and i1 true, [[TMP4]]
// CHECK-NEXT:    br i1 [[TMP5]], label [[RESOLVER_RETURN:%.*]], label [[RESOLVER_ELSE]]
// CHECK:       resolver_return:
// CHECK-NEXT:    ret ptr @"_Z4foo2v.arch=+zbb"
// CHECK:       resolver_else:
// CHECK-NEXT:    [[TMP6:%.*]] = load i64, ptr @__riscv_feature_bits, align 8
// CHECK-NEXT:    [[TMP7:%.*]] = icmp ult i64 0, [[TMP6]]
// CHECK-NEXT:    br i1 [[TMP7]], label [[RESOVLER_COND1:%.*]], label [[RESOLVER_ELSE3:%.*]]
// CHECK:       resovler_cond1:
// CHECK-NEXT:    [[TMP8:%.*]] = load i64, ptr getelementptr inbounds ({ i32, [1 x i64] }, ptr @__riscv_feature_bits, i32 0, i32 1, i32 0), align 8
// CHECK-NEXT:    [[TMP9:%.*]] = and i64 [[TMP8]], 4096
// CHECK-NEXT:    [[TMP10:%.*]] = icmp eq i64 [[TMP9]], 4096
// CHECK-NEXT:    [[TMP11:%.*]] = and i1 true, [[TMP10]]
// CHECK-NEXT:    br i1 [[TMP11]], label [[RESOLVER_RETURN2:%.*]], label [[RESOLVER_ELSE3]]
// CHECK:       resolver_return2:
// CHECK-NEXT:    ret ptr @"_Z4foo2v.arch=+m"
// CHECK:       resolver_else3:
// CHECK-NEXT:    ret ptr @_Z4foo2v.default
//
//
// CHECK-LABEL: define weak_odr ptr @_Z4foo3v.resolver() comdat {
// CHECK-NEXT:  resolver_entry:
// CHECK-NEXT:    call void @__init_riscv_features_bits()
// CHECK-NEXT:    [[TMP0:%.*]] = load i64, ptr @__riscv_feature_bits, align 8
// CHECK-NEXT:    [[TMP1:%.*]] = icmp ult i64 0, [[TMP0]]
// CHECK-NEXT:    br i1 [[TMP1]], label [[RESOVLER_COND:%.*]], label [[RESOLVER_ELSE:%.*]]
// CHECK:       resovler_cond:
// CHECK-NEXT:    [[TMP2:%.*]] = load i64, ptr getelementptr inbounds ({ i32, [1 x i64] }, ptr @__riscv_feature_bits, i32 0, i32 1, i32 0), align 8
// CHECK-NEXT:    [[TMP3:%.*]] = and i64 [[TMP2]], 12
// CHECK-NEXT:    [[TMP4:%.*]] = icmp eq i64 [[TMP3]], 12
// CHECK-NEXT:    [[TMP5:%.*]] = and i1 true, [[TMP4]]
// CHECK-NEXT:    br i1 [[TMP5]], label [[RESOLVER_RETURN:%.*]], label [[RESOLVER_ELSE]]
// CHECK:       resolver_return:
// CHECK-NEXT:    ret ptr @"_Z4foo3v.arch=+zbb,+c"
// CHECK:       resolver_else:
// CHECK-NEXT:    [[TMP6:%.*]] = load i64, ptr @__riscv_feature_bits, align 8
// CHECK-NEXT:    [[TMP7:%.*]] = icmp ult i64 0, [[TMP6]]
// CHECK-NEXT:    br i1 [[TMP7]], label [[RESOVLER_COND1:%.*]], label [[RESOLVER_ELSE3:%.*]]
// CHECK:       resovler_cond1:
// CHECK-NEXT:    [[TMP8:%.*]] = load i64, ptr getelementptr inbounds ({ i32, [1 x i64] }, ptr @__riscv_feature_bits, i32 0, i32 1, i32 0), align 8
// CHECK-NEXT:    [[TMP9:%.*]] = and i64 [[TMP8]], 4096
// CHECK-NEXT:    [[TMP10:%.*]] = icmp eq i64 [[TMP9]], 4096
// CHECK-NEXT:    [[TMP11:%.*]] = and i1 true, [[TMP10]]
// CHECK-NEXT:    br i1 [[TMP11]], label [[RESOLVER_RETURN2:%.*]], label [[RESOLVER_ELSE3]]
// CHECK:       resolver_return2:
// CHECK-NEXT:    ret ptr @"_Z4foo3v.arch=+m"
// CHECK:       resolver_else3:
// CHECK-NEXT:    ret ptr @_Z4foo3v.default
//
//.
// CHECK: attributes #[[ATTR0:[0-9]+]] = { mustprogress noinline nounwind optnone "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-features"="+64bit,+d,+f,+i,+m,+v,+zicsr,+zmmul,+zve32f,+zve32x,+zve64d,+zve64f,+zve64x,+zvl128b,+zvl32b,+zvl64b" }
// CHECK: attributes #[[ATTR1]] = { mustprogress noinline nounwind optnone "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-features"="+64bit,+i,+m,+zmmul" }
// CHECK: attributes #[[ATTR2:[0-9]+]] = { mustprogress noinline nounwind optnone "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-features"="+64bit,+i,+m,+zbb,+zmmul" }
// CHECK: attributes #[[ATTR3:[0-9]+]] = { mustprogress noinline nounwind optnone "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-features"="+64bit,+c,+i,+m,+zbb,+zmmul" }
//.
// CHECK: [[META0:![0-9]+]] = !{i32 1, !"wchar_size", i32 4}
// CHECK: [[META1:![0-9]+]] = !{i32 1, !"target-abi", !"lp64"}
// CHECK: [[META2:![0-9]+]] = !{i32 6, !"riscv-isa", [[META3:![0-9]+]]}
// CHECK: [[META3]] = !{!"rv64i2p1_m2p0_zmmul1p0"}
// CHECK: [[META4:![0-9]+]] = !{i32 8, !"SmallDataLimit", i32 0}
// CHECK: [[META5:![0-9]+]] = !{!"{{.*}}clang version {{.*}}"}
//.
