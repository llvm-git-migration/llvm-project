// NOTE: Assertions have been autogenerated by utils/update_cc_test_checks.py UTC_ARGS: --function-signature --include-generated-funcs --replace-value-regex "__omp_offloading_[0-9a-z]+_[0-9a-z]+" "reduction_size[.].+[.]" "pl_cond[.].+[.|,]" --prefix-filecheck-ir-name _
// RUN: %clang_cc1 -verify -fopenmp -fopenmp-cuda-mode -x c++ \
// RUN:  -triple powerpc64le-unknown-unknown \
// RUN:  -fopenmp-targets=nvptx64-nvidia-cuda -emit-llvm-bc %s -o \
// RUN:  %t-ppc-host.bc

// RUN: %clang_cc1 -verify -fopenmp -fopenmp-cuda-mode -x c++ \
// RUN:  -triple nvptx64-unknown-unknown -DCUA \
// RUN:  -fopenmp-targets=nvptx64-nvidia-cuda -emit-llvm %s \
// RUN:  -fopenmp-is-target-device -fopenmp-host-ir-file-path %t-ppc-host.bc \
// RUN:  -o - | FileCheck %s --check-prefix CHECK

// RUN: %clang_cc1 -verify -fopenmp -x c++ \
// RUN:   -triple powerpc64le-unknown-unknown -DDIAG\
// RUN:   -fopenmp-targets=powerpc64le-ibm-linux-gnu -emit-llvm \
// RUN:   %s -o - | FileCheck  %s \
// RUN:   --check-prefix=CHECK1

// RUN: %clang_cc1 -verify -fopenmp -x c++ \
// RUN:   -triple i386-unknown-unknown \
// RUN:   -fopenmp-targets=i386-pc-linux-gnu -emit-llvm \
// RUN:   %s -o - | FileCheck  %s \
// RUN:   --check-prefix=CHECK2

// expected-no-diagnostics
int foo() {
  int i;
  int j;
  _Complex float sum = 0;

#pragma omp target teams loop reduction(+:sum) collapse(2) bind(parallel) order(concurrent) lastprivate(j) map(tofrom:sum)

  for(i=0; i<10; i++)
    for(j=0; j<10; j++)
      sum += i;

  return 0;
}
// CHECK-LABEL: define {{[^@]+}}@{{__omp_offloading_[0-9a-z]+_[0-9a-z]+}}__Z3foov_l31
// CHECK-SAME: (ptr noalias noundef [[DYN_PTR:%.*]], i64 noundef [[J:%.*]], ptr noundef nonnull align 4 dereferenceable(8) [[SUM:%.*]]) #[[ATTR0:[0-9]+]] {
// CHECK-NEXT:  entry:
// CHECK-NEXT:         %[[VAL_0:.*]] = alloca ptr, align 8
// CHECK-NEXT:         %[[VAL_1:.*]] = alloca i64, align 8
// CHECK-NEXT:         %[[VAL_2:.*]] = alloca ptr, align 8
// CHECK-NEXT:         %[[VAL_3:.*]] = alloca i64, align 8
// CHECK-NEXT:         %[[VAL_4:.*]] = alloca i32, align 4
// CHECK-NEXT:         %[[VAL_5:.*]] = alloca i32, align 4
// CHECK-NEXT:         store ptr %[[VAL_6:.*]], ptr %[[VAL_0]], align 8
// CHECK-NEXT:         store i64 %[[VAL_7:.*]], ptr %[[VAL_1]], align 8
// CHECK-NEXT:         store ptr %[[VAL_8:.*]], ptr %[[VAL_2]], align 8
// CHECK-NEXT:         %[[VAL_9:.*]] = load ptr, ptr %[[VAL_2]], align 8
// CHECK-NEXT:         %[[VAL_10:.*]] = call i32 @__kmpc_target_init(ptr @{{__omp_offloading_[0-9a-z]+_[0-9a-z]+}}__Z3foov_l31_kernel_environment, ptr %[[VAL_6]])
// CHECK-NEXT:         %[[VAL_11:.*]] = icmp eq i32 %[[VAL_10]], -1
// CHECK-NEXT:         br i1 %[[VAL_11]], label %[[VAL_12:.*]], label %[[VAL_13:.*]]
// CHECK:       user_code.entry:                                  ; preds = %[[VAL_14:.*]]
// CHECK-NEXT:         %[[VAL_15:.*]] = call i32 @__kmpc_global_thread_num(ptr @1)
// CHECK-NEXT:         %[[VAL_16:.*]] = load i32, ptr %[[VAL_1]], align 4
// CHECK-NEXT:         store i32 %[[VAL_16]], ptr %[[VAL_3]], align 4
// CHECK-NEXT:         %[[VAL_17:.*]] = load i64, ptr %[[VAL_3]], align 8
// CHECK-NEXT:         store i32 0, ptr %[[VAL_4]], align 4
// CHECK-NEXT:         store i32 %[[VAL_15]], ptr %[[VAL_5]], align 4
// CHECK-NEXT:         call void @{{__omp_offloading_[0-9a-z]+_[0-9a-z]+}}__Z3foov_l31_omp_outlined(ptr %[[VAL_5]], ptr %[[VAL_4]], i64 %[[VAL_17]], ptr %[[VAL_9]]) #2
// CHECK-NEXT:         call void @__kmpc_target_deinit()
// CHECK-NEXT:         ret void
//
//
// CHECK-LABEL: define {{[^@]+}}@{{__omp_offloading_[0-9a-z]+_[0-9a-z]+}}__Z3foov_l31_omp_outlined
// CHECK-SAME: (ptr noalias noundef [[DOTGLOBAL_TID_:%.*]], ptr noalias noundef [[DOTBOUND_TID_:%.*]], i64 noundef [[J:%.*]], ptr noundef nonnull align 4 dereferenceable(8) [[SUM:%.*]]) #[[ATTR1:[0-9]+]] {
// CHECK-NEXT:  entry:
// CHECK-NEXT:         %[[VAL_18:.*]] = alloca ptr, align 8
// CHECK-NEXT:         %[[VAL_19:.*]] = alloca ptr, align 8
// CHECK-NEXT:         %[[VAL_20:.*]] = alloca i64, align 8
// CHECK-NEXT:         %[[VAL_21:.*]] = alloca ptr, align 8
// CHECK-NEXT:         %[[VAL_22:.*]] = alloca { float, float }, align 4
// CHECK-NEXT:         %[[VAL_23:.*]] = alloca i32, align 4
// CHECK-NEXT:         %[[VAL_24:.*]] = alloca i32, align 4
// CHECK-NEXT:         %[[VAL_25:.*]] = alloca i32, align 4
// CHECK-NEXT:         %[[VAL_26:.*]] = alloca i32, align 4
// CHECK-NEXT:         %[[VAL_27:.*]] = alloca i32, align 4
// CHECK-NEXT:         %[[VAL_28:.*]] = alloca i32, align 4
// CHECK-NEXT:         %[[VAL_29:.*]] = alloca i32, align 4
// CHECK-NEXT:         %[[VAL_30:.*]] = alloca i32, align 4
// CHECK-NEXT:         %[[VAL_31:.*]] = alloca i32, align 4
// CHECK-NEXT:         %[[VAL_32:.*]] = alloca i32, align 4
// CHECK-NEXT:         %[[VAL_33:.*]] = alloca i64, align 8
// CHECK-NEXT:         %[[VAL_34:.*]] = alloca [4 x ptr], align 8
// CHECK-NEXT:         %[[VAL_35:.*]] = alloca [1 x ptr], align 8
// CHECK-NEXT:         store ptr %[[VAL_36:.*]], ptr %[[VAL_18]], align 8
// CHECK-NEXT:         store ptr %[[VAL_37:.*]], ptr %[[VAL_19]], align 8
// CHECK-NEXT:         store i64 %[[VAL_38:.*]], ptr %[[VAL_20]], align 8
// CHECK-NEXT:         store ptr %[[VAL_39:.*]], ptr %[[VAL_21]], align 8
// CHECK-NEXT:         %[[VAL_40:.*]] = load ptr, ptr %[[VAL_21]], align 8
// CHECK-NEXT:         %[[VAL_41:.*]] = getelementptr inbounds { float, float }, ptr %[[VAL_22]], i32 0, i32 0
// CHECK-NEXT:         %[[VAL_42:.*]] = getelementptr inbounds { float, float }, ptr %[[VAL_22]], i32 0, i32 1
// CHECK-NEXT:         store float 0.000000e+00, ptr %[[VAL_41]], align 4
// CHECK-NEXT:         store float 0.000000e+00, ptr %[[VAL_42]], align 4
// CHECK-NEXT:         store i32 0, ptr %[[VAL_26]], align 4
// CHECK-NEXT:         store i32 99, ptr %[[VAL_27]], align 4
// CHECK-NEXT:         store i32 1, ptr %[[VAL_28]], align 4
// CHECK-NEXT:         store i32 0, ptr %[[VAL_29]], align 4
// CHECK-NEXT:         %[[VAL_43:.*]] = call i32 @__kmpc_get_hardware_num_threads_in_block()
// CHECK-NEXT:         %[[VAL_44:.*]] = load ptr, ptr %[[VAL_18]], align 8
// CHECK-NEXT:         %[[VAL_45:.*]] = load i32, ptr %[[VAL_44]], align 4
// CHECK-NEXT:         call void @__kmpc_distribute_static_init_4(ptr @2, i32 %[[VAL_45]], i32 91, ptr %[[VAL_29]], ptr %[[VAL_26]], ptr %[[VAL_27]], ptr %[[VAL_28]], i32 1, i32 %[[VAL_43]])
// CHECK-NEXT:         %[[VAL_46:.*]] = load i32, ptr %[[VAL_27]], align 4
// CHECK-NEXT:         %[[VAL_47:.*]] = icmp sgt i32 %[[VAL_46]], 99
// CHECK-NEXT:         br i1 %[[VAL_47]], label %[[VAL_48:.*]], label %[[VAL_49:.*]]
// CHECK:       cond.true:                                        ; preds = %[[VAL_50:.*]]
// CHECK-NEXT:         br label %[[VAL_51:.*]]
// CHECK:       cond.false:                                       ; preds = %[[VAL_50]]
// CHECK-NEXT:         %[[VAL_52:.*]] = load i32, ptr %[[VAL_27]], align 4
// CHECK-NEXT:         br label %[[VAL_51]]
// CHECK:       cond.end:                                         ; preds = %[[VAL_49]], %[[VAL_48]]
// CHECK-NEXT:         %[[VAL_53:.*]] = phi i32 [ 99, %[[VAL_48]] ], [ %[[VAL_52]], %[[VAL_49]] ]
// CHECK-NEXT:         store i32 %[[VAL_53]], ptr %[[VAL_27]], align 4
// CHECK-NEXT:         %[[VAL_54:.*]] = load i32, ptr %[[VAL_26]], align 4
// CHECK-NEXT:         store i32 %[[VAL_54]], ptr %[[VAL_23]], align 4
// CHECK-NEXT:         br label %[[VAL_55:.*]]
// CHECK:       omp.inner.for.cond:                               ; preds = %[[VAL_56:.*]], %[[VAL_51]]
// CHECK-NEXT:         %[[VAL_57:.*]] = load i32, ptr %[[VAL_23]], align 4
// CHECK-NEXT:         %[[VAL_58:.*]] = icmp slt i32 %[[VAL_57]], 100
// CHECK-NEXT:         br i1 %[[VAL_58]], label %[[VAL_59:.*]], label %[[VAL_60:.*]]
// CHECK:       omp.inner.for.body:                               ; preds = %[[VAL_55]]
// CHECK-NEXT:         %[[VAL_61:.*]] = load i32, ptr %[[VAL_26]], align 4
// CHECK-NEXT:         %[[VAL_62:.*]] = zext i32 %[[VAL_61]] to i64
// CHECK-NEXT:         %[[VAL_63:.*]] = load i32, ptr %[[VAL_27]], align 4
// CHECK-NEXT:         %[[VAL_64:.*]] = zext i32 %[[VAL_63]] to i64
// CHECK-NEXT:         %[[VAL_65:.*]] = load i32, ptr %[[VAL_30]], align 4
// CHECK-NEXT:         store i32 %[[VAL_65]], ptr %[[VAL_33]], align 4
// CHECK-NEXT:         %[[VAL_66:.*]] = load i64, ptr %[[VAL_33]], align 8
// CHECK-NEXT:         %[[VAL_67:.*]] = getelementptr inbounds [4 x ptr], ptr %[[VAL_34]], i64 0, i64 0
// CHECK-NEXT:         %[[VAL_68:.*]] = inttoptr i64 %[[VAL_62]] to ptr
// CHECK-NEXT:         store ptr %[[VAL_68]], ptr %[[VAL_67]], align 8
// CHECK-NEXT:         %[[VAL_69:.*]] = getelementptr inbounds [4 x ptr], ptr %[[VAL_34]], i64 0, i64 1
// CHECK-NEXT:         %[[VAL_70:.*]] = inttoptr i64 %[[VAL_64]] to ptr
// CHECK-NEXT:         store ptr %[[VAL_70]], ptr %[[VAL_69]], align 8
// CHECK-NEXT:         %[[VAL_71:.*]] = getelementptr inbounds [4 x ptr], ptr %[[VAL_34]], i64 0, i64 2
// CHECK-NEXT:         %[[VAL_72:.*]] = inttoptr i64 %[[VAL_66]] to ptr
// CHECK-NEXT:         store ptr %[[VAL_72]], ptr %[[VAL_71]], align 8
// CHECK-NEXT:         %[[VAL_73:.*]] = getelementptr inbounds [4 x ptr], ptr %[[VAL_34]], i64 0, i64 3
// CHECK-NEXT:         store ptr %[[VAL_22]], ptr %[[VAL_73]], align 8
// CHECK-NEXT:         call void @__kmpc_parallel_51(ptr @1, i32 %[[VAL_45]], i32 1, i32 -1, i32 -1, ptr @{{__omp_offloading_[0-9a-z]+_[0-9a-z]+}}__Z3foov_l31_omp_outlined_omp_outlined, ptr null, ptr %[[VAL_34]], i64 4)
// CHECK-NEXT:         br label %[[VAL_74:.*]]
// CHECK:       omp.inner.for.inc:                                ; preds = %[[VAL_59]]
// CHECK-NEXT:         %[[VAL_75:.*]] = load i32, ptr %[[VAL_23]], align 4
// CHECK-NEXT:         %[[VAL_76:.*]] = load i32, ptr %[[VAL_28]], align 4
// CHECK-NEXT:         %[[VAL_77:.*]] = add nsw i32 %[[VAL_75]], %[[VAL_76]]
// CHECK-NEXT:         store i32 %[[VAL_77]], ptr %[[VAL_23]], align 4
// CHECK-NEXT:         %[[VAL_78:.*]] = load i32, ptr %[[VAL_26]], align 4
// CHECK-NEXT:         %[[VAL_79:.*]] = load i32, ptr %[[VAL_28]], align 4
// CHECK-NEXT:         %[[VAL_80:.*]] = add nsw i32 %[[VAL_78]], %[[VAL_79]]
// CHECK-NEXT:         store i32 %[[VAL_80]], ptr %[[VAL_26]], align 4
// CHECK-NEXT:         %[[VAL_81:.*]] = load i32, ptr %[[VAL_27]], align 4
// CHECK-NEXT:         %[[VAL_82:.*]] = load i32, ptr %[[VAL_28]], align 4
// CHECK-NEXT:         %[[VAL_83:.*]] = add nsw i32 %[[VAL_81]], %[[VAL_82]]
// CHECK-NEXT:         store i32 %[[VAL_83]], ptr %[[VAL_27]], align 4
// CHECK-NEXT:         %[[VAL_84:.*]] = load i32, ptr %[[VAL_27]], align 4
// CHECK-NEXT:         %[[VAL_85:.*]] = icmp sgt i32 %[[VAL_84]], 99
// CHECK-NEXT:         br i1 %[[VAL_85]], label %[[VAL_86:.*]], label %[[VAL_87:.*]]
// CHECK:       cond.true9:                                       ; preds = %[[VAL_74]]
// CHECK-NEXT:         br label %[[VAL_56]]
// CHECK:       cond.false10:                                     ; preds = %[[VAL_74]]
// CHECK-NEXT:         %[[VAL_88:.*]] = load i32, ptr %[[VAL_27]], align 4
// CHECK-NEXT:         br label %[[VAL_56]]
// CHECK:       cond.end11:                                       ; preds = %[[VAL_87]], %[[VAL_86]]
// CHECK-NEXT:         %[[VAL_89:.*]] = phi i32 [ 99, %[[VAL_86]] ], [ %[[VAL_88]], %[[VAL_87]] ]
// CHECK-NEXT:         store i32 %[[VAL_89]], ptr %[[VAL_27]], align 4
// CHECK-NEXT:         %[[VAL_90:.*]] = load i32, ptr %[[VAL_26]], align 4
// CHECK-NEXT:         store i32 %[[VAL_90]], ptr %[[VAL_23]], align 4
// CHECK-NEXT:         br label %[[VAL_55]]
// CHECK:       omp.inner.for.end:                                ; preds = %[[VAL_55]]
// CHECK-NEXT:         br label %[[VAL_91:.*]]
// CHECK:       omp.loop.exit:                                    ; preds = %[[VAL_60]]
// CHECK-NEXT:         call void @__kmpc_for_static_fini(ptr @3, i32 %[[VAL_45]])
// CHECK-NEXT:         %[[VAL_92:.*]] = load i32, ptr %[[VAL_29]], align 4
// CHECK-NEXT:         %[[VAL_93:.*]] = icmp ne i32 %[[VAL_92]], 0
// CHECK-NEXT:         br i1 %[[VAL_93]], label %[[VAL_94:.*]], label %[[VAL_95:.*]]
// CHECK:       .omp.lastprivate.then:                            ; preds = %[[VAL_91]]
// CHECK-NEXT:         store i32 10, ptr %[[VAL_30]], align 4
// CHECK-NEXT:         %[[VAL_96:.*]] = load i32, ptr %[[VAL_30]], align 4
// CHECK-NEXT:         store i32 %[[VAL_96]], ptr %[[VAL_20]], align 4
// CHECK-NEXT:         br label %[[VAL_95]]
// CHECK:       .omp.lastprivate.done:                            ; preds = %[[VAL_94]], %[[VAL_91]]
// CHECK-NEXT:         %[[VAL_97:.*]] = getelementptr inbounds [1 x ptr], ptr %[[VAL_35]], i64 0, i64 0
// CHECK-NEXT:         store ptr %[[VAL_22]], ptr %[[VAL_97]], align 8
// CHECK-NEXT:         %[[VAL_98:.*]]"_openmp_teams_reductions_buffer_$_$ptr" = call ptr @__kmpc_reduction_get_fixed_buffer()
// CHECK-NEXT:         %[[VAL_99:.*]] = call i32 @__kmpc_nvptx_teams_reduce_nowait_v2(ptr @1, ptr %[[VAL_98]]"_openmp_teams_reductions_buffer_$_$ptr", i32 1024, i64 8, ptr %[[VAL_35]], ptr @_omp_reduction_shuffle_and_reduce_func1, ptr @_omp_reduction_inter_warp_copy_func2, ptr @_omp_reduction_list_to_global_copy_func, ptr @_omp_reduction_list_to_global_reduce_func, ptr @_omp_reduction_global_to_list_copy_func, ptr @_omp_reduction_global_to_list_reduce_func)
// CHECK-NEXT:         %[[VAL_100:.*]] = icmp eq i32 %[[VAL_99]], 1
// CHECK-NEXT:         br i1 %[[VAL_100]], label %[[VAL_101:.*]], label %[[VAL_102:.*]]
// CHECK:       .omp.reduction.then:                              ; preds = %[[VAL_95]]
// CHECK-NEXT:         %[[VAL_103:.*]] = getelementptr inbounds { float, float }, ptr %[[VAL_40]], i32 0, i32 0
// CHECK-NEXT:         %[[VAL_104:.*]] = load float, ptr %[[VAL_103]], align 4
// CHECK-NEXT:         %[[VAL_105:.*]] = getelementptr inbounds { float, float }, ptr %[[VAL_40]], i32 0, i32 1
// CHECK-NEXT:         %[[VAL_106:.*]] = load float, ptr %[[VAL_105]], align 4
// CHECK-NEXT:         %[[VAL_107:.*]] = getelementptr inbounds { float, float }, ptr %[[VAL_22]], i32 0, i32 0
// CHECK-NEXT:         %[[VAL_108:.*]] = load float, ptr %[[VAL_107]], align 4
// CHECK-NEXT:         %[[VAL_109:.*]] = getelementptr inbounds { float, float }, ptr %[[VAL_22]], i32 0, i32 1
// CHECK-NEXT:         %[[VAL_110:.*]] = load float, ptr %[[VAL_109]], align 4
// CHECK-NEXT:         %[[VAL_111:.*]] = fadd float %[[VAL_104]], %[[VAL_108]]
// CHECK-NEXT:         %[[VAL_112:.*]] = fadd float %[[VAL_106]], %[[VAL_110]]
// CHECK-NEXT:         %[[VAL_113:.*]] = getelementptr inbounds { float, float }, ptr %[[VAL_40]], i32 0, i32 0
// CHECK-NEXT:         %[[VAL_114:.*]] = getelementptr inbounds { float, float }, ptr %[[VAL_40]], i32 0, i32 1
// CHECK-NEXT:         store float %[[VAL_111]], ptr %[[VAL_113]], align 4
// CHECK-NEXT:         store float %[[VAL_112]], ptr %[[VAL_114]], align 4
// CHECK-NEXT:         br label %[[VAL_102]]
// CHECK:       .omp.reduction.done:                              ; preds = %[[VAL_101]], %[[VAL_95]]
// CHECK-NEXT:         ret void
//
//
// CHECK-LABEL: define {{[^@]+}}@_omp_reduction_shuffle_and_reduce_func
// CHECK-SAME: (ptr noundef [[TMP0:%.*]], i16 noundef signext [[TMP1:%.*]], i16 noundef signext [[TMP2:%.*]], i16 noundef signext [[TMP3:%.*]]) #[[ATTR2:[0-9]+]] {
// CHECK-NEXT:  entry:
// CHECK-NEXT:         %[[VAL_228:.*]] = alloca ptr, align 8
// CHECK-NEXT:         %[[VAL_229:.*]] = alloca i16, align 2
// CHECK-NEXT:         %[[VAL_230:.*]] = alloca i16, align 2
// CHECK-NEXT:         %[[VAL_231:.*]] = alloca i16, align 2
// CHECK-NEXT:         %[[VAL_232:.*]] = alloca [1 x ptr], align 8
// CHECK-NEXT:         %[[VAL_233:.*]] = alloca { float, float }, align 8
// CHECK-NEXT:         store ptr %[[VAL_234:.*]], ptr %[[VAL_228]], align 8
// CHECK-NEXT:         store i16 %[[VAL_235:.*]], ptr %[[VAL_229]], align 2
// CHECK-NEXT:         store i16 %[[VAL_236:.*]], ptr %[[VAL_230]], align 2
// CHECK-NEXT:         store i16 %[[VAL_237:.*]], ptr %[[VAL_231]], align 2
// CHECK-NEXT:         %[[VAL_238:.*]] = load ptr, ptr %[[VAL_228]], align 8
// CHECK-NEXT:         %[[VAL_239:.*]] = load i16, ptr %[[VAL_229]], align 2
// CHECK-NEXT:         %[[VAL_240:.*]] = load i16, ptr %[[VAL_230]], align 2
// CHECK-NEXT:         %[[VAL_241:.*]] = load i16, ptr %[[VAL_231]], align 2
// CHECK-NEXT:         %[[VAL_242:.*]] = getelementptr inbounds [1 x ptr], ptr %[[VAL_238]], i64 0, i64 0
// CHECK-NEXT:         %[[VAL_243:.*]] = load ptr, ptr %[[VAL_242]], align 8
// CHECK-NEXT:         %[[VAL_244:.*]] = getelementptr inbounds [1 x ptr], ptr %[[VAL_232]], i64 0, i64 0
// CHECK-NEXT:         %[[VAL_245:.*]] = getelementptr { float, float }, ptr %[[VAL_243]], i64 1
// CHECK-NEXT:         %[[VAL_246:.*]] = load i64, ptr %[[VAL_243]], align 8
// CHECK-NEXT:         %[[VAL_247:.*]] = call i32 @__kmpc_get_warp_size()
// CHECK-NEXT:         %[[VAL_248:.*]] = trunc i32 %[[VAL_247]] to i16
// CHECK-NEXT:         %[[VAL_249:.*]] = call i64 @__kmpc_shuffle_int64(i64 %[[VAL_246]], i16 %[[VAL_240]], i16 %[[VAL_248]])
// CHECK-NEXT:         store i64 %[[VAL_249]], ptr %[[VAL_233]], align 8
// CHECK-NEXT:         %[[VAL_250:.*]] = getelementptr i64, ptr %[[VAL_243]], i64 1
// CHECK-NEXT:         %[[VAL_251:.*]] = getelementptr i64, ptr %[[VAL_233]], i64 1
// CHECK-NEXT:         store ptr %[[VAL_233]], ptr %[[VAL_244]], align 8
// CHECK-NEXT:         %[[VAL_252:.*]] = icmp eq i16 %[[VAL_241]], 0
// CHECK-NEXT:         %[[VAL_253:.*]] = icmp eq i16 %[[VAL_241]], 1
// CHECK-NEXT:         %[[VAL_254:.*]] = icmp ult i16 %[[VAL_239]], %[[VAL_240]]
// CHECK-NEXT:         %[[VAL_255:.*]] = and i1 %[[VAL_253]], %[[VAL_254]]
// CHECK-NEXT:         %[[VAL_256:.*]] = icmp eq i16 %[[VAL_241]], 2
// CHECK-NEXT:         %[[VAL_257:.*]] = and i16 %[[VAL_239]], 1
// CHECK-NEXT:         %[[VAL_258:.*]] = icmp eq i16 %[[VAL_257]], 0
// CHECK-NEXT:         %[[VAL_259:.*]] = and i1 %[[VAL_256]], %[[VAL_258]]
// CHECK-NEXT:         %[[VAL_260:.*]] = icmp sgt i16 %[[VAL_240]], 0
// CHECK-NEXT:         %[[VAL_261:.*]] = and i1 %[[VAL_259]], %[[VAL_260]]
// CHECK-NEXT:         %[[VAL_262:.*]] = or i1 %[[VAL_252]], %[[VAL_255]]
// CHECK-NEXT:         %[[VAL_263:.*]] = or i1 %[[VAL_262]], %[[VAL_261]]
// CHECK-NEXT:         br i1 %[[VAL_263]], label %[[VAL_264:.*]], label %[[VAL_265:.*]]
// CHECK:       then:                                             ; preds = %[[VAL_266:.*]]
// CHECK-NEXT:         call void @"{{__omp_offloading_[0-9a-z]+_[0-9a-z]+}}__Z3foov_l31_omp_outlined_omp_outlined_omp$reduction$reduction_func"(ptr %[[VAL_238]], ptr %[[VAL_232]]) #2
// CHECK-NEXT:         br label %[[VAL_267:.*]]
// CHECK:       else:                                             ; preds = %[[VAL_266]]
// CHECK-NEXT:         br label %[[VAL_267]]
// CHECK:       ifcont:                                           ; preds = %[[VAL_265]], %[[VAL_264]]
// CHECK-NEXT:         %[[VAL_268:.*]] = icmp eq i16 %[[VAL_241]], 1
// CHECK-NEXT:         %[[VAL_269:.*]] = icmp uge i16 %[[VAL_239]], %[[VAL_240]]
// CHECK-NEXT:         %[[VAL_270:.*]] = and i1 %[[VAL_268]], %[[VAL_269]]
// CHECK-NEXT:         br i1 %[[VAL_270]], label %[[VAL_271:.*]], label %[[VAL_272:.*]]
// CHECK:       then4:                                            ; preds = %[[VAL_267]]
// CHECK-NEXT:         %[[VAL_273:.*]] = getelementptr inbounds [1 x ptr], ptr %[[VAL_232]], i64 0, i64 0
// CHECK-NEXT:         %[[VAL_274:.*]] = load ptr, ptr %[[VAL_273]], align 8
// CHECK-NEXT:         %[[VAL_275:.*]] = getelementptr inbounds [1 x ptr], ptr %[[VAL_238]], i64 0, i64 0
// CHECK-NEXT:         %[[VAL_276:.*]] = load ptr, ptr %[[VAL_275]], align 8
// CHECK-NEXT:         %[[VAL_277:.*]] = getelementptr inbounds { float, float }, ptr %[[VAL_274]], i32 0, i32 0
// CHECK-NEXT:         %[[VAL_278:.*]] = load float, ptr %[[VAL_277]], align 4
// CHECK-NEXT:         %[[VAL_279:.*]] = getelementptr inbounds { float, float }, ptr %[[VAL_274]], i32 0, i32 1
// CHECK-NEXT:         %[[VAL_280:.*]] = load float, ptr %[[VAL_279]], align 4
// CHECK-NEXT:         %[[VAL_281:.*]] = getelementptr inbounds { float, float }, ptr %[[VAL_276]], i32 0, i32 0
// CHECK-NEXT:         %[[VAL_282:.*]] = getelementptr inbounds { float, float }, ptr %[[VAL_276]], i32 0, i32 1
// CHECK-NEXT:         store float %[[VAL_278]], ptr %[[VAL_281]], align 4
// CHECK-NEXT:         store float %[[VAL_280]], ptr %[[VAL_282]], align 4
// CHECK-NEXT:         br label %[[VAL_283:.*]]
// CHECK:       else7:                                            ; preds = %[[VAL_267]]
// CHECK-NEXT:         br label %[[VAL_283]]
// CHECK:       ifcont8:                                          ; preds = %[[VAL_272]], %[[VAL_271]]
// CHECK-NEXT:         ret void
//
//
// CHECK-LABEL: define {{[^@]+}}@_omp_reduction_inter_warp_copy_func
// CHECK-SAME: (ptr noundef [[TMP0:%.*]], i32 noundef [[TMP1:%.*]]) #[[ATTR2]] {
// CHECK-NEXT:  entry:
// CHECK-NEXT:         %[[VAL_400:.*]] = alloca ptr, align 8
// CHECK-NEXT:         %[[VAL_401:.*]] = alloca i32, align 4
// CHECK-NEXT:         %[[VAL_402:.*]] = alloca i32, align 4
// CHECK-NEXT:         %[[VAL_403:.*]] = call i32 @__kmpc_global_thread_num(ptr @1)
// CHECK-NEXT:         store ptr %[[VAL_404:.*]], ptr %[[VAL_400]], align 8
// CHECK-NEXT:         store i32 %[[VAL_405:.*]], ptr %[[VAL_401]], align 4
// CHECK-NEXT:         %[[VAL_406:.*]] = call i32 @__kmpc_get_hardware_thread_id_in_block()
// CHECK-NEXT:         %[[VAL_407:.*]] = call i32 @__kmpc_get_hardware_thread_id_in_block()
// CHECK-NEXT:         %[[VAL_408:.*]] = and i32 %[[VAL_407]], 31
// CHECK-NEXT:         %[[VAL_409:.*]] = call i32 @__kmpc_get_hardware_thread_id_in_block()
// CHECK-NEXT:         %[[VAL_410:.*]] = ashr i32 %[[VAL_409]], 5
// CHECK-NEXT:         %[[VAL_411:.*]] = load ptr, ptr %[[VAL_400]], align 8
// CHECK-NEXT:         store i32 0, ptr %[[VAL_402]], align 4
// CHECK-NEXT:         br label %[[VAL_412:.*]]
// CHECK:       precond:                                          ; preds = %[[VAL_413:.*]], %[[VAL_414:.*]]
// CHECK-NEXT:         %[[VAL_415:.*]] = load i32, ptr %[[VAL_402]], align 4
// CHECK-NEXT:         %[[VAL_416:.*]] = icmp ult i32 %[[VAL_415]], 2
// CHECK-NEXT:         br i1 %[[VAL_416]], label %[[VAL_417:.*]], label %[[VAL_418:.*]]
// CHECK:       body:                                             ; preds = %[[VAL_412]]
// CHECK-NEXT:         call void @__kmpc_barrier(ptr @4, i32 %[[VAL_403]])
// CHECK-NEXT:         %[[VAL_419:.*]] = icmp eq i32 %[[VAL_408]], 0
// CHECK-NEXT:         br i1 %[[VAL_419]], label %[[VAL_420:.*]], label %[[VAL_421:.*]]
// CHECK:       then:                                             ; preds = %[[VAL_417]]
// CHECK-NEXT:         %[[VAL_422:.*]] = getelementptr inbounds [1 x ptr], ptr %[[VAL_411]], i64 0, i64 0
// CHECK-NEXT:         %[[VAL_423:.*]] = load ptr, ptr %[[VAL_422]], align 8
// CHECK-NEXT:         %[[VAL_424:.*]] = getelementptr i32, ptr %[[VAL_423]], i32 %[[VAL_415]]
// CHECK-NEXT:         %[[VAL_425:.*]] = getelementptr inbounds [32 x i32], ptr addrspace(3) @__openmp_nvptx_data_transfer_temporary_storage, i64 0, i32 %[[VAL_410]]
// CHECK-NEXT:         %[[VAL_426:.*]] = load i32, ptr %[[VAL_424]], align 4
// CHECK-NEXT:         store volatile i32 %[[VAL_426]], ptr addrspace(3) %[[VAL_425]], align 4
// CHECK-NEXT:         br label %[[VAL_427:.*]]
// CHECK:       else:                                             ; preds = %[[VAL_417]]
// CHECK-NEXT:         br label %[[VAL_427]]
// CHECK:       ifcont:                                           ; preds = %[[VAL_421]], %[[VAL_420]]
// CHECK-NEXT:         call void @__kmpc_barrier(ptr @4, i32 %[[VAL_403]])
// CHECK-NEXT:         %[[VAL_428:.*]] = load i32, ptr %[[VAL_401]], align 4
// CHECK-NEXT:         %[[VAL_429:.*]] = icmp ult i32 %[[VAL_406]], %[[VAL_428]]
// CHECK-NEXT:         br i1 %[[VAL_429]], label %[[VAL_430:.*]], label %[[VAL_431:.*]]
// CHECK:       then2:                                            ; preds = %[[VAL_427]]
// CHECK-NEXT:         %[[VAL_432:.*]] = getelementptr inbounds [32 x i32], ptr addrspace(3) @__openmp_nvptx_data_transfer_temporary_storage, i64 0, i32 %[[VAL_406]]
// CHECK-NEXT:         %[[VAL_433:.*]] = getelementptr inbounds [1 x ptr], ptr %[[VAL_411]], i64 0, i64 0
// CHECK-NEXT:         %[[VAL_434:.*]] = load ptr, ptr %[[VAL_433]], align 8
// CHECK-NEXT:         %[[VAL_435:.*]] = getelementptr i32, ptr %[[VAL_434]], i32 %[[VAL_415]]
// CHECK-NEXT:         %[[VAL_436:.*]] = load volatile i32, ptr addrspace(3) %[[VAL_432]], align 4
// CHECK-NEXT:         store i32 %[[VAL_436]], ptr %[[VAL_435]], align 4
// CHECK-NEXT:         br label %[[VAL_413]]
// CHECK:       else3:                                            ; preds = %[[VAL_427]]
// CHECK-NEXT:         br label %[[VAL_413]]
// CHECK:       ifcont4:                                          ; preds = %[[VAL_431]], %[[VAL_430]]
// CHECK-NEXT:         %[[VAL_437:.*]] = add nsw i32 %[[VAL_415]], 1
// CHECK-NEXT:         store i32 %[[VAL_437]], ptr %[[VAL_402]], align 4
// CHECK-NEXT:         br label %[[VAL_412]]
// CHECK:       exit:                                             ; preds = %[[VAL_412]]
// CHECK-NEXT:         ret void
//
//
// CHECK1-LABEL: define {{[^@]+}}@_Z3foov
// CHECK1-SAME: () #[[ATTR0:[0-9]+]] {
// CHECK1-NEXT: entry:
// CHECK1-NEXT:         %[[VAL_0:.*]] = alloca i32, align 4
// CHECK1-NEXT:         %[[VAL_1:.*]] = alloca i32, align 4
// CHECK1-NEXT:         %[[VAL_2:.*]] = alloca { float, float }, align 4
// CHECK1-NEXT:         %[[VAL_3:.*]] = alloca i64, align 8
// CHECK1-NEXT:         %[[VAL_4:.*]] = alloca [2 x ptr], align 8
// CHECK1-NEXT:         %[[VAL_5:.*]] = alloca [2 x ptr], align 8
// CHECK1-NEXT:         %[[VAL_6:.*]] = alloca [2 x ptr], align 8
// CHECK1-NEXT:         %[[VAL_7:.*]] = alloca i32, align 4
// CHECK1-NEXT:         %[[VAL_8:.*]] = alloca i32, align 4
// CHECK1-NEXT:         %[[VAL_9:.*]] = alloca %[[VAL_10:.*]], align 8
// CHECK1-NEXT:         %[[VAL_11:.*]] = getelementptr inbounds { float, float }, ptr %[[VAL_2]], i32 0, i32 0
// CHECK1-NEXT:         %[[VAL_12:.*]] = getelementptr inbounds { float, float }, ptr %[[VAL_2]], i32 0, i32 1
// CHECK1-NEXT:         store float 0.000000e+00, ptr %[[VAL_11]], align 4
// CHECK1-NEXT:         store float 0.000000e+00, ptr %[[VAL_12]], align 4
// CHECK1-NEXT:         %[[VAL_13:.*]] = load i32, ptr %[[VAL_1]], align 4
// CHECK1-NEXT:         store i32 %[[VAL_13]], ptr %[[VAL_3]], align 4
// CHECK1-NEXT:         %[[VAL_14:.*]] = load i64, ptr %[[VAL_3]], align 8
// CHECK1-NEXT:         %[[VAL_15:.*]] = getelementptr inbounds [2 x ptr], ptr %[[VAL_4]], i32 0, i32 0
// CHECK1-NEXT:         store i64 %[[VAL_14]], ptr %[[VAL_15]], align 8
// CHECK1-NEXT:         %[[VAL_16:.*]] = getelementptr inbounds [2 x ptr], ptr %[[VAL_5]], i32 0, i32 0
// CHECK1-NEXT:         store i64 %[[VAL_14]], ptr %[[VAL_16]], align 8
// CHECK1-NEXT:         %[[VAL_17:.*]] = getelementptr inbounds [2 x ptr], ptr %[[VAL_6]], i64 0, i64 0
// CHECK1-NEXT:         store ptr null, ptr %[[VAL_17]], align 8
// CHECK1-NEXT:         %[[VAL_18:.*]] = getelementptr inbounds [2 x ptr], ptr %[[VAL_4]], i32 0, i32 1
// CHECK1-NEXT:         store ptr %[[VAL_2]], ptr %[[VAL_18]], align 8
// CHECK1-NEXT:         %[[VAL_19:.*]] = getelementptr inbounds [2 x ptr], ptr %[[VAL_5]], i32 0, i32 1
// CHECK1-NEXT:         store ptr %[[VAL_2]], ptr %[[VAL_19]], align 8
// CHECK1-NEXT:         %[[VAL_20:.*]] = getelementptr inbounds [2 x ptr], ptr %[[VAL_6]], i64 0, i64 1
// CHECK1-NEXT:         store ptr null, ptr %[[VAL_20]], align 8
// CHECK1-NEXT:         %[[VAL_21:.*]] = getelementptr inbounds [2 x ptr], ptr %[[VAL_4]], i32 0, i32 0
// CHECK1-NEXT:         %[[VAL_22:.*]] = getelementptr inbounds [2 x ptr], ptr %[[VAL_5]], i32 0, i32 0
// CHECK1-NEXT:         %[[VAL_23:.*]] = getelementptr inbounds %[[VAL_10]], ptr %[[VAL_9]], i32 0, i32 0
// CHECK1-NEXT:         store i32 2, ptr %[[VAL_23]], align 4
// CHECK1-NEXT:         %[[VAL_24:.*]] = getelementptr inbounds %[[VAL_10]], ptr %[[VAL_9]], i32 0, i32 1
// CHECK1-NEXT:         store i32 2, ptr %[[VAL_24]], align 4
// CHECK1-NEXT:         %[[VAL_25:.*]] = getelementptr inbounds %[[VAL_10]], ptr %[[VAL_9]], i32 0, i32 2
// CHECK1-NEXT:         store ptr %[[VAL_21]], ptr %[[VAL_25]], align 8
// CHECK1-NEXT:         %[[VAL_26:.*]] = getelementptr inbounds %[[VAL_10]], ptr %[[VAL_9]], i32 0, i32 3
// CHECK1-NEXT:         store ptr %[[VAL_22]], ptr %[[VAL_26]], align 8
// CHECK1-NEXT:         %[[VAL_27:.*]] = getelementptr inbounds %[[VAL_10]], ptr %[[VAL_9]], i32 0, i32 4
// CHECK1-NEXT:         store ptr @.offload_sizes, ptr %[[VAL_27]], align 8
// CHECK1-NEXT:         %[[VAL_28:.*]] = getelementptr inbounds %[[VAL_10]], ptr %[[VAL_9]], i32 0, i32 5
// CHECK1-NEXT:         store ptr @.offload_maptypes, ptr %[[VAL_28]], align 8
// CHECK1-NEXT:         %[[VAL_29:.*]] = getelementptr inbounds %[[VAL_10]], ptr %[[VAL_9]], i32 0, i32 6
// CHECK1-NEXT:         store ptr null, ptr %[[VAL_29]], align 8
// CHECK1-NEXT:         %[[VAL_30:.*]] = getelementptr inbounds %[[VAL_10]], ptr %[[VAL_9]], i32 0, i32 7
// CHECK1-NEXT:         store ptr null, ptr %[[VAL_30]], align 8
// CHECK1-NEXT:         %[[VAL_31:.*]] = getelementptr inbounds %[[VAL_10]], ptr %[[VAL_9]], i32 0, i32 8
// CHECK1-NEXT:         store i64 100, ptr %[[VAL_31]], align 8
// CHECK1-NEXT:         %[[VAL_32:.*]] = getelementptr inbounds %[[VAL_10]], ptr %[[VAL_9]], i32 0, i32 9
// CHECK1-NEXT:         store i64 0, ptr %[[VAL_32]], align 8
// CHECK1-NEXT:         %[[VAL_33:.*]] = getelementptr inbounds %[[VAL_10]], ptr %[[VAL_9]], i32 0, i32 10
// CHECK1-NEXT:         store [3 x i32] zeroinitializer, ptr %[[VAL_33]], align 4
// CHECK1-NEXT:         %[[VAL_34:.*]] = getelementptr inbounds %[[VAL_10]], ptr %[[VAL_9]], i32 0, i32 11
// CHECK1-NEXT:         store [3 x i32] zeroinitializer, ptr %[[VAL_34]], align 4
// CHECK1-NEXT:         %[[VAL_35:.*]] = getelementptr inbounds %[[VAL_10]], ptr %[[VAL_9]], i32 0, i32 12
// CHECK1-NEXT:         store i32 0, ptr %[[VAL_35]], align 4
// CHECK1-NEXT:         %[[VAL_36:.*]] = call i32 @__tgt_target_kernel(ptr @4, i64 -1, i32 0, i32 0, ptr @.{{__omp_offloading_[0-9a-z]+_[0-9a-z]+}}__Z3foov_l31.region_id, ptr %[[VAL_9]])
// CHECK1-NEXT:         %[[VAL_37:.*]] = icmp ne i32 %[[VAL_36]], 0
// CHECK1-NEXT:         br i1 %[[VAL_37]], label %[[VAL_38:.*]], label %[[VAL_39:.*]]
// CHECK1:       omp_offload.failed:                               ; preds = %[[VAL_40:.*]]
// CHECK1-NEXT:         call void @{{__omp_offloading_[0-9a-z]+_[0-9a-z]+}}__Z3foov_l31(i64 %[[VAL_14]], ptr %[[VAL_2]]) #2
// CHECK1-NEXT:         br label %[[VAL_39]]
// CHECK1:       omp_offload.cont:                                 ; preds = %[[VAL_38]], %[[VAL_40]]
// CHECK1-NEXT:         ret i32 0
//
//
// CHECK1-LABEL: define {{[^@]+}}@{{__omp_offloading_[0-9a-z]+_[0-9a-z]+}}__Z3foov_l31
// CHECK1-SAME: (i64 noundef [[J:%.*]], ptr noundef nonnull align 4 dereferenceable(8) [[SUM:%.*]]) #[[ATTR0:[0-9]+]] {
// CHECK1-NEXT:  entry:
// CHECK1-NEXT:         %[[VAL_41:.*]] = alloca i64, align 8
// CHECK1-NEXT:         %[[VAL_42:.*]] = alloca ptr, align 8
// CHECK1-NEXT:         %[[VAL_43:.*]] = alloca i64, align 8
// CHECK1-NEXT:         store i64 %[[VAL_44:.*]], ptr %[[VAL_41]], align 8
// CHECK1-NEXT:         store ptr %[[VAL_45:.*]], ptr %[[VAL_42]], align 8
// CHECK1-NEXT:         %[[VAL_46:.*]] = load ptr, ptr %[[VAL_42]], align 8
// CHECK1-NEXT:         %[[VAL_47:.*]] = load i32, ptr %[[VAL_41]], align 4
// CHECK1-NEXT:         store i32 %[[VAL_47]], ptr %[[VAL_43]], align 4
// CHECK1-NEXT:         %[[VAL_48:.*]] = load i64, ptr %[[VAL_43]], align 8
// CHECK1-NEXT:         call void (ptr, i32, ptr, ...) @__kmpc_fork_teams(ptr @4, i32 2, ptr @{{__omp_offloading_[0-9a-z]+_[0-9a-z]+}}__Z3foov_l31.omp_outlined, i64 %[[VAL_48]], ptr %[[VAL_46]])
// CHECK1-NEXT:         ret void
//
//
// CHECK1-LABEL: define {{[^@]+}}@{{__omp_offloading_[0-9a-z]+_[0-9a-z]+}}__Z3foov_l31.omp_outlined
// CHECK1-SAME: (ptr noalias noundef [[DOTGLOBAL_TID_:%.*]], ptr noalias noundef [[DOTBOUND_TID_:%.*]], i64 noundef [[J:%.*]], ptr noundef nonnull align 4 dereferenceable(8) [[SUM:%.*]]) #[[ATTR1:[0-9]+]] {
// CHECK1-NEXT:  entry:
// CHECK1-NEXT:         %[[VAL_49:.*]] = alloca ptr, align 8
// CHECK1-NEXT:         %[[VAL_50:.*]] = alloca ptr, align 8
// CHECK1-NEXT:         %[[VAL_51:.*]] = alloca i64, align 8
// CHECK1-NEXT:         %[[VAL_52:.*]] = alloca ptr, align 8
// CHECK1-NEXT:         %[[VAL_53:.*]] = alloca { float, float }, align 4
// CHECK1-NEXT:         %[[VAL_54:.*]] = alloca i32, align 4
// CHECK1-NEXT:         %[[VAL_55:.*]] = alloca i32, align 4
// CHECK1-NEXT:         %[[VAL_56:.*]] = alloca i32, align 4
// CHECK1-NEXT:         %[[VAL_57:.*]] = alloca i32, align 4
// CHECK1-NEXT:         %[[VAL_58:.*]] = alloca i32, align 4
// CHECK1-NEXT:         %[[VAL_59:.*]] = alloca i32, align 4
// CHECK1-NEXT:         %[[VAL_60:.*]] = alloca i32, align 4
// CHECK1-NEXT:         %[[VAL_61:.*]] = alloca i32, align 4
// CHECK1-NEXT:         %[[VAL_62:.*]] = alloca i32, align 4
// CHECK1-NEXT:         %[[VAL_63:.*]] = alloca i32, align 4
// CHECK1-NEXT:         %[[VAL_64:.*]] = alloca i64, align 8
// CHECK1-NEXT:         %[[VAL_65:.*]] = alloca [1 x ptr], align 8
// CHECK1-NEXT:         %[[VAL_66:.*]] = alloca { float, float }, align 4
// CHECK1-NEXT:         %[[VAL_67:.*]] = alloca { float, float }, align 4
// CHECK1-NEXT:         %[[VAL_68:.*]] = alloca { float, float }, align 4
// CHECK1-NEXT:         store ptr %[[VAL_69:.*]], ptr %[[VAL_49]], align 8
// CHECK1-NEXT:         store ptr %[[VAL_70:.*]], ptr %[[VAL_50]], align 8
// CHECK1-NEXT:         store i64 %[[VAL_71:.*]], ptr %[[VAL_51]], align 8
// CHECK1-NEXT:         store ptr %[[VAL_72:.*]], ptr %[[VAL_52]], align 8
// CHECK1-NEXT:         %[[VAL_73:.*]] = load ptr, ptr %[[VAL_52]], align 8
// CHECK1-NEXT:         %[[VAL_74:.*]] = getelementptr inbounds { float, float }, ptr %[[VAL_53]], i32 0, i32 0
// CHECK1-NEXT:         %[[VAL_75:.*]] = getelementptr inbounds { float, float }, ptr %[[VAL_53]], i32 0, i32 1
// CHECK1-NEXT:         store float 0.000000e+00, ptr %[[VAL_74]], align 4
// CHECK1-NEXT:         store float 0.000000e+00, ptr %[[VAL_75]], align 4
// CHECK1-NEXT:         store i32 0, ptr %[[VAL_57]], align 4
// CHECK1-NEXT:         store i32 99, ptr %[[VAL_58]], align 4
// CHECK1-NEXT:         store i32 1, ptr %[[VAL_59]], align 4
// CHECK1-NEXT:         store i32 0, ptr %[[VAL_60]], align 4
// CHECK1-NEXT:         %[[VAL_76:.*]] = load ptr, ptr %[[VAL_49]], align 8
// CHECK1-NEXT:         %[[VAL_77:.*]] = load i32, ptr %[[VAL_76]], align 4
// CHECK1-NEXT:         call void @__kmpc_for_static_init_4(ptr @1, i32 %[[VAL_77]], i32 92, ptr %[[VAL_60]], ptr %[[VAL_57]], ptr %[[VAL_58]], ptr %[[VAL_59]], i32 1, i32 1)
// CHECK1-NEXT:         %[[VAL_78:.*]] = load i32, ptr %[[VAL_58]], align 4
// CHECK1-NEXT:         %[[VAL_79:.*]] = icmp sgt i32 %[[VAL_78]], 99
// CHECK1-NEXT:         br i1 %[[VAL_79]], label %[[VAL_80:.*]], label %[[VAL_81:.*]]
// CHECK1:       cond.true:                                        ; preds = %[[VAL_82:.*]]
// CHECK1-NEXT:         br label %[[VAL_83:.*]]
// CHECK1:       cond.false:                                       ; preds = %[[VAL_82]]
// CHECK1-NEXT:         %[[VAL_84:.*]] = load i32, ptr %[[VAL_58]], align 4
// CHECK1-NEXT:         br label %[[VAL_83]]
// CHECK1:       cond.end:                                         ; preds = %[[VAL_81]], %[[VAL_80]]
// CHECK1-NEXT:         %[[VAL_85:.*]] = phi i32 [ 99, %[[VAL_80]] ], [ %[[VAL_84]], %[[VAL_81]] ]
// CHECK1-NEXT:         store i32 %[[VAL_85]], ptr %[[VAL_58]], align 4
// CHECK1-NEXT:         %[[VAL_86:.*]] = load i32, ptr %[[VAL_57]], align 4
// CHECK1-NEXT:         store i32 %[[VAL_86]], ptr %[[VAL_54]], align 4
// CHECK1-NEXT:         br label %[[VAL_87:.*]]
// CHECK1:       omp.inner.for.cond:                               ; preds = %[[VAL_88:.*]], %[[VAL_83]]
// CHECK1-NEXT:         %[[VAL_89:.*]] = load i32, ptr %[[VAL_54]], align 4
// CHECK1-NEXT:         %[[VAL_90:.*]] = load i32, ptr %[[VAL_58]], align 4
// CHECK1-NEXT:         %[[VAL_91:.*]] = icmp sle i32 %[[VAL_89]], %[[VAL_90]]
// CHECK1-NEXT:         br i1 %[[VAL_91]], label %[[VAL_92:.*]], label %[[VAL_93:.*]]
// CHECK1:       omp.inner.for.body:                               ; preds = %[[VAL_87]]
// CHECK1-NEXT:         %[[VAL_94:.*]] = load i32, ptr %[[VAL_57]], align 4
// CHECK1-NEXT:         %[[VAL_95:.*]] = zext i32 %[[VAL_94]] to i64
// CHECK1-NEXT:         %[[VAL_96:.*]] = load i32, ptr %[[VAL_58]], align 4
// CHECK1-NEXT:         %[[VAL_97:.*]] = zext i32 %[[VAL_96]] to i64
// CHECK1-NEXT:         %[[VAL_98:.*]] = load i32, ptr %[[VAL_61]], align 4
// CHECK1-NEXT:         store i32 %[[VAL_98]], ptr %[[VAL_64]], align 4
// CHECK1-NEXT:         %[[VAL_99:.*]] = load i64, ptr %[[VAL_64]], align 8
// CHECK1-NEXT:         call void (ptr, i32, ptr, ...) @__kmpc_fork_call(ptr @4, i32 4, ptr @{{__omp_offloading_[0-9a-z]+_[0-9a-z]+}}__Z3foov_l31.omp_outlined.omp_outlined, i64 %[[VAL_95]], i64 %[[VAL_97]], i64 %[[VAL_99]], ptr %[[VAL_53]])
// CHECK1-NEXT:         br label %[[VAL_88]]
// CHECK1:       omp.inner.for.inc:                                ; preds = %[[VAL_92]]
// CHECK1-NEXT:         %[[VAL_100:.*]] = load i32, ptr %[[VAL_54]], align 4
// CHECK1-NEXT:         %[[VAL_101:.*]] = load i32, ptr %[[VAL_59]], align 4
// CHECK1-NEXT:         %[[VAL_102:.*]] = add nsw i32 %[[VAL_100]], %[[VAL_101]]
// CHECK1-NEXT:         store i32 %[[VAL_102]], ptr %[[VAL_54]], align 4
// CHECK1-NEXT:         br label %[[VAL_87]]
// CHECK1:       omp.inner.for.end:                                ; preds = %[[VAL_87]]
// CHECK1-NEXT:         br label %[[VAL_103:.*]]
// CHECK1:       omp.loop.exit:                                    ; preds = %[[VAL_93]]
// CHECK1-NEXT:         call void @__kmpc_for_static_fini(ptr @2, i32 %[[VAL_77]])
// CHECK1-NEXT:         %[[VAL_104:.*]] = load i32, ptr %[[VAL_60]], align 4
// CHECK1-NEXT:         %[[VAL_105:.*]] = icmp ne i32 %[[VAL_104]], 0
// CHECK1-NEXT:         br i1 %[[VAL_105]], label %[[VAL_106:.*]], label %[[VAL_107:.*]]
// CHECK1:       .omp.lastprivate.then:                            ; preds = %[[VAL_103]]
// CHECK1-NEXT:         store i32 10, ptr %[[VAL_61]], align 4
// CHECK1-NEXT:         %[[VAL_108:.*]] = load i32, ptr %[[VAL_61]], align 4
// CHECK1-NEXT:         store i32 %[[VAL_108]], ptr %[[VAL_51]], align 4
// CHECK1-NEXT:         br label %[[VAL_107]]
// CHECK1:       .omp.lastprivate.done:                            ; preds = %[[VAL_106]], %[[VAL_103]]
// CHECK1-NEXT:         %[[VAL_109:.*]] = getelementptr inbounds [1 x ptr], ptr %[[VAL_65]], i64 0, i64 0
// CHECK1-NEXT:         store ptr %[[VAL_53]], ptr %[[VAL_109]], align 8
// CHECK1-NEXT:         %[[VAL_110:.*]] = call i32 @__kmpc_reduce(ptr @3, i32 %[[VAL_77]], i32 1, i64 8, ptr %[[VAL_65]], ptr @{{__omp_offloading_[0-9a-z]+_[0-9a-z]+}}__Z3foov_l31.omp_outlined.omp.reduction.reduction_func, ptr @.gomp_critical_user_.reduction.var)
// CHECK1-NEXT:         switch i32 %[[VAL_110]], label %[[VAL_111:.*]] [
// CHECK1-NEXT:           i32 1, label %[[VAL_112:.*]]
// CHECK1-NEXT:           i32 2, label %[[VAL_113:.*]]
// CHECK1-NEXT:         ]
// CHECK1:       .omp.reduction.case1:                             ; preds = %[[VAL_107]]
// CHECK1-NEXT:         %[[VAL_114:.*]] = getelementptr inbounds { float, float }, ptr %[[VAL_73]], i32 0, i32 0
// CHECK1-NEXT:         %[[VAL_115:.*]] = load float, ptr %[[VAL_114]], align 4
// CHECK1-NEXT:         %[[VAL_116:.*]] = getelementptr inbounds { float, float }, ptr %[[VAL_73]], i32 0, i32 1
// CHECK1-NEXT:         %[[VAL_117:.*]] = load float, ptr %[[VAL_116]], align 4
// CHECK1-NEXT:         %[[VAL_118:.*]] = getelementptr inbounds { float, float }, ptr %[[VAL_53]], i32 0, i32 0
// CHECK1-NEXT:         %[[VAL_119:.*]] = load float, ptr %[[VAL_118]], align 4
// CHECK1-NEXT:         %[[VAL_120:.*]] = getelementptr inbounds { float, float }, ptr %[[VAL_53]], i32 0, i32 1
// CHECK1-NEXT:         %[[VAL_121:.*]] = load float, ptr %[[VAL_120]], align 4
// CHECK1-NEXT:         %[[VAL_122:.*]] = fadd float %[[VAL_115]], %[[VAL_119]]
// CHECK1-NEXT:         %[[VAL_123:.*]] = fadd float %[[VAL_117]], %[[VAL_121]]
// CHECK1-NEXT:         %[[VAL_124:.*]] = getelementptr inbounds { float, float }, ptr %[[VAL_73]], i32 0, i32 0
// CHECK1-NEXT:         %[[VAL_125:.*]] = getelementptr inbounds { float, float }, ptr %[[VAL_73]], i32 0, i32 1
// CHECK1-NEXT:         store float %[[VAL_122]], ptr %[[VAL_124]], align 4
// CHECK1-NEXT:         store float %[[VAL_123]], ptr %[[VAL_125]], align 4
// CHECK1-NEXT:         call void @__kmpc_end_reduce(ptr @3, i32 %[[VAL_77]], ptr @.gomp_critical_user_.reduction.var)
// CHECK1-NEXT:         br label %[[VAL_111]]
// CHECK1:       .omp.reduction.case2:                             ; preds = %[[VAL_107]]
// CHECK1-NEXT:         %[[VAL_126:.*]] = getelementptr inbounds { float, float }, ptr %[[VAL_53]], i32 0, i32 0
// CHECK1-NEXT:         %[[VAL_127:.*]] = load float, ptr %[[VAL_126]], align 4
// CHECK1-NEXT:         %[[VAL_128:.*]] = getelementptr inbounds { float, float }, ptr %[[VAL_53]], i32 0, i32 1
// CHECK1-NEXT:         %[[VAL_129:.*]] = load float, ptr %[[VAL_128]], align 4
// CHECK1-NEXT:         call void @__atomic_load(i64 noundef 8, ptr noundef %[[VAL_73]], ptr noundef %[[VAL_66]], i32 noundef signext 0)
// CHECK1-NEXT:         br label %[[VAL_130:.*]]
// CHECK1:       atomic_cont:                                      ; preds = %[[VAL_130]], %[[VAL_113]]
// CHECK1-NEXT:         %[[VAL_131:.*]] = getelementptr inbounds { float, float }, ptr %[[VAL_66]], i32 0, i32 0
// CHECK1-NEXT:         %[[VAL_132:.*]] = load float, ptr %[[VAL_131]], align 4
// CHECK1-NEXT:         %[[VAL_133:.*]] = getelementptr inbounds { float, float }, ptr %[[VAL_66]], i32 0, i32 1
// CHECK1-NEXT:         %[[VAL_134:.*]] = load float, ptr %[[VAL_133]], align 4
// CHECK1-NEXT:         %[[VAL_135:.*]] = getelementptr inbounds { float, float }, ptr %[[VAL_68]], i32 0, i32 0
// CHECK1-NEXT:         %[[VAL_136:.*]] = getelementptr inbounds { float, float }, ptr %[[VAL_68]], i32 0, i32 1
// CHECK1-NEXT:         store float %[[VAL_132]], ptr %[[VAL_135]], align 4
// CHECK1-NEXT:         store float %[[VAL_134]], ptr %[[VAL_136]], align 4
// CHECK1-NEXT:         %[[VAL_137:.*]] = getelementptr inbounds { float, float }, ptr %[[VAL_68]], i32 0, i32 0
// CHECK1-NEXT:         %[[VAL_138:.*]] = load float, ptr %[[VAL_137]], align 4
// CHECK1-NEXT:         %[[VAL_139:.*]] = getelementptr inbounds { float, float }, ptr %[[VAL_68]], i32 0, i32 1
// CHECK1-NEXT:         %[[VAL_140:.*]] = load float, ptr %[[VAL_139]], align 4
// CHECK1-NEXT:         %[[VAL_141:.*]] = getelementptr inbounds { float, float }, ptr %[[VAL_53]], i32 0, i32 0
// CHECK1-NEXT:         %[[VAL_142:.*]] = load float, ptr %[[VAL_141]], align 4
// CHECK1-NEXT:         %[[VAL_143:.*]] = getelementptr inbounds { float, float }, ptr %[[VAL_53]], i32 0, i32 1
// CHECK1-NEXT:         %[[VAL_144:.*]] = load float, ptr %[[VAL_143]], align 4
// CHECK1-NEXT:         %[[VAL_145:.*]] = fadd float %[[VAL_138]], %[[VAL_142]]
// CHECK1-NEXT:         %[[VAL_146:.*]] = fadd float %[[VAL_140]], %[[VAL_144]]
// CHECK1-NEXT:         %[[VAL_147:.*]] = getelementptr inbounds { float, float }, ptr %[[VAL_67]], i32 0, i32 0
// CHECK1-NEXT:         %[[VAL_148:.*]] = getelementptr inbounds { float, float }, ptr %[[VAL_67]], i32 0, i32 1
// CHECK1-NEXT:         store float %[[VAL_145]], ptr %[[VAL_147]], align 4
// CHECK1-NEXT:         store float %[[VAL_146]], ptr %[[VAL_148]], align 4
// CHECK1-NEXT:         %[[VAL_149:.*]] = call noundef zeroext i1 @__atomic_compare_exchange(i64 noundef 8, ptr noundef %[[VAL_73]], ptr noundef %[[VAL_66]], ptr noundef %[[VAL_67]], i32 noundef signext 0, i32 noundef signext 0)
// CHECK1-NEXT:         br i1 %[[VAL_149]], label %[[VAL_150:.*]], label %[[VAL_130]]
// CHECK1:       atomic_exit:                                      ; preds = %[[VAL_130]]
// CHECK1-NEXT:         call void @__kmpc_end_reduce(ptr @3, i32 %[[VAL_77]], ptr @.gomp_critical_user_.reduction.var)
// CHECK1-NEXT:         br label %[[VAL_111]]
// CHECK1:       .omp.reduction.default:                           ; preds = %[[VAL_150]], %[[VAL_112]], %[[VAL_107]]
// CHECK1-NEXT:         ret void
//
//
// CHECK1-LABEL: define {{[^@]+}}@{{__omp_offloading_[0-9a-z]+_[0-9a-z]+}}__Z3foov_l31.omp_outlined.omp.reduction.reduction_func
// CHECK1-SAME: (ptr noundef [[TMP0:%.*]], ptr noundef [[TMP1:%.*]]) #[[ATTR3:[0-9]+]] {
// CHECK1-NEXT:       entry:
// CHECK1-NEXT:         %[[VAL_297:.*]] = alloca ptr, align 8
// CHECK1-NEXT:         %[[VAL_298:.*]] = alloca ptr, align 8
// CHECK1-NEXT:         store ptr %[[VAL_299:.*]], ptr %[[VAL_297]], align 8
// CHECK1-NEXT:         store ptr %[[VAL_300:.*]], ptr %[[VAL_298]], align 8
// CHECK1-NEXT:         %[[VAL_301:.*]] = load ptr, ptr %[[VAL_297]], align 8
// CHECK1-NEXT:         %[[VAL_302:.*]] = load ptr, ptr %[[VAL_298]], align 8
// CHECK1-NEXT:         %[[VAL_303:.*]] = getelementptr inbounds [1 x ptr], ptr %[[VAL_302]], i64 0, i64 0
// CHECK1-NEXT:         %[[VAL_304:.*]] = load ptr, ptr %[[VAL_303]], align 8
// CHECK1-NEXT:         %[[VAL_305:.*]] = getelementptr inbounds [1 x ptr], ptr %[[VAL_301]], i64 0, i64 0
// CHECK1-NEXT:         %[[VAL_306:.*]] = load ptr, ptr %[[VAL_305]], align 8
// CHECK1-NEXT:         %[[VAL_307:.*]] = getelementptr inbounds { float, float }, ptr %[[VAL_306]], i32 0, i32 0
// CHECK1-NEXT:         %[[VAL_308:.*]] = load float, ptr %[[VAL_307]], align 4
// CHECK1-NEXT:         %[[VAL_309:.*]] = getelementptr inbounds { float, float }, ptr %[[VAL_306]], i32 0, i32 1
// CHECK1-NEXT:         %[[VAL_310:.*]] = load float, ptr %[[VAL_309]], align 4
// CHECK1-NEXT:         %[[VAL_311:.*]] = getelementptr inbounds { float, float }, ptr %[[VAL_304]], i32 0, i32 0
// CHECK1-NEXT:         %[[VAL_312:.*]] = load float, ptr %[[VAL_311]], align 4
// CHECK1-NEXT:         %[[VAL_313:.*]] = getelementptr inbounds { float, float }, ptr %[[VAL_304]], i32 0, i32 1
// CHECK1-NEXT:         %[[VAL_314:.*]] = load float, ptr %[[VAL_313]], align 4
// CHECK1-NEXT:         %[[VAL_315:.*]] = fadd float %[[VAL_308]], %[[VAL_312]]
// CHECK1-NEXT:         %[[VAL_316:.*]] = fadd float %[[VAL_310]], %[[VAL_314]]
// CHECK1-NEXT:         %[[VAL_317:.*]] = getelementptr inbounds { float, float }, ptr %[[VAL_306]], i32 0, i32 0
// CHECK1-NEXT:         %[[VAL_318:.*]] = getelementptr inbounds { float, float }, ptr %[[VAL_306]], i32 0, i32 1
// CHECK1-NEXT:         store float %[[VAL_315]], ptr %[[VAL_317]], align 4
// CHECK1-NEXT:         store float %[[VAL_316]], ptr %[[VAL_318]], align 4
// CHECK1-NEXT:         ret void
//
//
// CHECK2-LABEL: define {{[^@]+}}@_Z3foov
// CHECK2-SAME: () #[[ATTR0:[0-9]+]] {
// CHECK2-NEXT:  entry:
// CHECK2-NEXT:         %[[VAL_0:.*]] = alloca i32, align 4
// CHECK2-NEXT:         %[[VAL_1:.*]] = alloca i32, align 4
// CHECK2-NEXT:         %[[VAL_2:.*]] = alloca { float, float }, align 4
// CHECK2-NEXT:         %[[VAL_3:.*]] = alloca i32, align 4
// CHECK2-NEXT:         %[[VAL_4:.*]] = alloca [2 x ptr], align 4
// CHECK2-NEXT:         %[[VAL_5:.*]] = alloca [2 x ptr], align 4
// CHECK2-NEXT:         %[[VAL_6:.*]] = alloca [2 x ptr], align 4
// CHECK2-NEXT:         %[[VAL_7:.*]] = alloca i32, align 4
// CHECK2-NEXT:         %[[VAL_8:.*]] = alloca i32, align 4
// CHECK2-NEXT:         %[[VAL_9:.*]] = alloca %[[VAL_10:.*]], align 8
// CHECK2-NEXT:         %[[VAL_11:.*]] = getelementptr inbounds { float, float }, ptr %[[VAL_2]], i32 0, i32 0
// CHECK2-NEXT:         %[[VAL_12:.*]] = getelementptr inbounds { float, float }, ptr %[[VAL_2]], i32 0, i32 1
// CHECK2-NEXT:         store float 0.000000e+00, ptr %[[VAL_11]], align 4
// CHECK2-NEXT:         store float 0.000000e+00, ptr %[[VAL_12]], align 4
// CHECK2-NEXT:         %[[VAL_13:.*]] = load i32, ptr %[[VAL_1]], align 4
// CHECK2-NEXT:         store i32 %[[VAL_13]], ptr %[[VAL_3]], align 4
// CHECK2-NEXT:         %[[VAL_14:.*]] = load i32, ptr %[[VAL_3]], align 4
// CHECK2-NEXT:         %[[VAL_15:.*]] = getelementptr inbounds [2 x ptr], ptr %[[VAL_4]], i32 0, i32 0
// CHECK2-NEXT:         store i32 %[[VAL_14]], ptr %[[VAL_15]], align 4
// CHECK2-NEXT:         %[[VAL_16:.*]] = getelementptr inbounds [2 x ptr], ptr %[[VAL_5]], i32 0, i32 0
// CHECK2-NEXT:         store i32 %[[VAL_14]], ptr %[[VAL_16]], align 4
// CHECK2-NEXT:         %[[VAL_17:.*]] = getelementptr inbounds [2 x ptr], ptr %[[VAL_6]], i32 0, i32 0
// CHECK2-NEXT:         store ptr null, ptr %[[VAL_17]], align 4
// CHECK2-NEXT:         %[[VAL_18:.*]] = getelementptr inbounds [2 x ptr], ptr %[[VAL_4]], i32 0, i32 1
// CHECK2-NEXT:         store ptr %[[VAL_2]], ptr %[[VAL_18]], align 4
// CHECK2-NEXT:         %[[VAL_19:.*]] = getelementptr inbounds [2 x ptr], ptr %[[VAL_5]], i32 0, i32 1
// CHECK2-NEXT:         store ptr %[[VAL_2]], ptr %[[VAL_19]], align 4
// CHECK2-NEXT:         %[[VAL_20:.*]] = getelementptr inbounds [2 x ptr], ptr %[[VAL_6]], i32 0, i32 1
// CHECK2-NEXT:         store ptr null, ptr %[[VAL_20]], align 4
// CHECK2-NEXT:         %[[VAL_21:.*]] = getelementptr inbounds [2 x ptr], ptr %[[VAL_4]], i32 0, i32 0
// CHECK2-NEXT:         %[[VAL_22:.*]] = getelementptr inbounds [2 x ptr], ptr %[[VAL_5]], i32 0, i32 0
// CHECK2-NEXT:         %[[VAL_23:.*]] = getelementptr inbounds %[[VAL_10]], ptr %[[VAL_9]], i32 0, i32 0
// CHECK2-NEXT:         store i32 2, ptr %[[VAL_23]], align 4
// CHECK2-NEXT:         %[[VAL_24:.*]] = getelementptr inbounds %[[VAL_10]], ptr %[[VAL_9]], i32 0, i32 1
// CHECK2-NEXT:         store i32 2, ptr %[[VAL_24]], align 4
// CHECK2-NEXT:         %[[VAL_25:.*]] = getelementptr inbounds %[[VAL_10]], ptr %[[VAL_9]], i32 0, i32 2
// CHECK2-NEXT:         store ptr %[[VAL_21]], ptr %[[VAL_25]], align 4
// CHECK2-NEXT:         %[[VAL_26:.*]] = getelementptr inbounds %[[VAL_10]], ptr %[[VAL_9]], i32 0, i32 3
// CHECK2-NEXT:         store ptr %[[VAL_22]], ptr %[[VAL_26]], align 4
// CHECK2-NEXT:         %[[VAL_27:.*]] = getelementptr inbounds %[[VAL_10]], ptr %[[VAL_9]], i32 0, i32 4
// CHECK2-NEXT:         store ptr @.offload_sizes, ptr %[[VAL_27]], align 4
// CHECK2-NEXT:         %[[VAL_28:.*]] = getelementptr inbounds %[[VAL_10]], ptr %[[VAL_9]], i32 0, i32 5
// CHECK2-NEXT:         store ptr @.offload_maptypes, ptr %[[VAL_28]], align 4
// CHECK2-NEXT:         %[[VAL_29:.*]] = getelementptr inbounds %[[VAL_10]], ptr %[[VAL_9]], i32 0, i32 6
// CHECK2-NEXT:         store ptr null, ptr %[[VAL_29]], align 4
// CHECK2-NEXT:         %[[VAL_30:.*]] = getelementptr inbounds %[[VAL_10]], ptr %[[VAL_9]], i32 0, i32 7
// CHECK2-NEXT:         store ptr null, ptr %[[VAL_30]], align 4
// CHECK2-NEXT:         %[[VAL_31:.*]] = getelementptr inbounds %[[VAL_10]], ptr %[[VAL_9]], i32 0, i32 8
// CHECK2-NEXT:         store i64 100, ptr %[[VAL_31]], align 8
// CHECK2-NEXT:         %[[VAL_32:.*]] = getelementptr inbounds %[[VAL_10]], ptr %[[VAL_9]], i32 0, i32 9
// CHECK2-NEXT:         store i64 0, ptr %[[VAL_32]], align 8
// CHECK2-NEXT:         %[[VAL_33:.*]] = getelementptr inbounds %[[VAL_10]], ptr %[[VAL_9]], i32 0, i32 10
// CHECK2-NEXT:         store [3 x i32] zeroinitializer, ptr %[[VAL_33]], align 4
// CHECK2-NEXT:         %[[VAL_34:.*]] = getelementptr inbounds %[[VAL_10]], ptr %[[VAL_9]], i32 0, i32 11
// CHECK2-NEXT:         store [3 x i32] zeroinitializer, ptr %[[VAL_34]], align 4
// CHECK2-NEXT:         %[[VAL_35:.*]] = getelementptr inbounds %[[VAL_10]], ptr %[[VAL_9]], i32 0, i32 12
// CHECK2-NEXT:         store i32 0, ptr %[[VAL_35]], align 4
// CHECK2-NEXT:         %[[VAL_36:.*]] = call i32 @__tgt_target_kernel(ptr @4, i64 -1, i32 0, i32 0, ptr @.{{__omp_offloading_[0-9a-z]+_[0-9a-z]+}}__Z3foov_l31.region_id, ptr %[[VAL_9]])
// CHECK2-NEXT:         %[[VAL_37:.*]] = icmp ne i32 %[[VAL_36]], 0
// CHECK2-NEXT:         br i1 %[[VAL_37]], label %[[VAL_38:.*]], label %[[VAL_39:.*]]
// CHECK2:       omp_offload.failed:                               ; preds = %[[VAL_40:.*]]
// CHECK2-NEXT:         call void @{{__omp_offloading_[0-9a-z]+_[0-9a-z]+}}__Z3foov_l31(i32 %[[VAL_14]], ptr %[[VAL_2]]) #2
// CHECK2-NEXT:         br label %[[VAL_39]]
// CHECK2:       omp_offload.cont:                                 ; preds = %[[VAL_38]], %[[VAL_40]]
// CHECK2-NEXT:         ret i32 0
//
//
// CHECK2-LABEL: define {{[^@]+}}@{{__omp_offloading_[0-9a-z]+_[0-9a-z]+}}__Z3foov_l31
// CHECK2-SAME: (i32 noundef [[J:%.*]], ptr noundef nonnull align 4 dereferenceable(8) [[SUM:%.*]]) #[[ATTR0:[0-9]+]] {
// CHECK2-NEXT:  entry:
// CHECK2-NEXT:         %[[VAL_41:.*]] = alloca i32, align 4
// CHECK2-NEXT:         %[[VAL_42:.*]] = alloca ptr, align 4
// CHECK2-NEXT:         %[[VAL_43:.*]] = alloca i32, align 4
// CHECK2-NEXT:         store i32 %[[VAL_44:.*]], ptr %[[VAL_41]], align 4
// CHECK2-NEXT:         store ptr %[[VAL_45:.*]], ptr %[[VAL_42]], align 4
// CHECK2-NEXT:         %[[VAL_46:.*]] = load ptr, ptr %[[VAL_42]], align 4
// CHECK2-NEXT:         %[[VAL_47:.*]] = load i32, ptr %[[VAL_41]], align 4
// CHECK2-NEXT:         store i32 %[[VAL_47]], ptr %[[VAL_43]], align 4
// CHECK2-NEXT:         %[[VAL_48:.*]] = load i32, ptr %[[VAL_43]], align 4
// CHECK2-NEXT:         call void (ptr, i32, ptr, ...) @__kmpc_fork_teams(ptr @4, i32 2, ptr @{{__omp_offloading_[0-9a-z]+_[0-9a-z]+}}__Z3foov_l31.omp_outlined, i32 %[[VAL_48]], ptr %[[VAL_46]])
// CHECK2-NEXT:         ret void
//
//
// CHECK2-LABEL: define {{[^@]+}}@{{__omp_offloading_[0-9a-z]+_[0-9a-z]+}}__Z3foov_l31.omp_outlined
// CHECK2-SAME: (ptr noalias noundef [[DOTGLOBAL_TID_:%.*]], ptr noalias noundef [[DOTBOUND_TID_:%.*]], i32 noundef [[J:%.*]], ptr noundef nonnull align 4 dereferenceable(8) [[SUM:%.*]]) #[[ATTR1:[0-9]+]] {
// CHECK2-NEXT:  entry:
// CHECK2-NEXT:         %[[VAL_49:.*]] = alloca ptr, align 4
// CHECK2-NEXT:         %[[VAL_50:.*]] = alloca ptr, align 4
// CHECK2-NEXT:         %[[VAL_51:.*]] = alloca i32, align 4
// CHECK2-NEXT:         %[[VAL_52:.*]] = alloca ptr, align 4
// CHECK2-NEXT:         %[[VAL_53:.*]] = alloca { float, float }, align 4
// CHECK2-NEXT:         %[[VAL_54:.*]] = alloca i32, align 4
// CHECK2-NEXT:         %[[VAL_55:.*]] = alloca i32, align 4
// CHECK2-NEXT:         %[[VAL_56:.*]] = alloca i32, align 4
// CHECK2-NEXT:         %[[VAL_57:.*]] = alloca i32, align 4
// CHECK2-NEXT:         %[[VAL_58:.*]] = alloca i32, align 4
// CHECK2-NEXT:         %[[VAL_59:.*]] = alloca i32, align 4
// CHECK2-NEXT:         %[[VAL_60:.*]] = alloca i32, align 4
// CHECK2-NEXT:         %[[VAL_61:.*]] = alloca i32, align 4
// CHECK2-NEXT:         %[[VAL_62:.*]] = alloca i32, align 4
// CHECK2-NEXT:         %[[VAL_63:.*]] = alloca i32, align 4
// CHECK2-NEXT:         %[[VAL_64:.*]] = alloca i32, align 4
// CHECK2-NEXT:         %[[VAL_65:.*]] = alloca [1 x ptr], align 4
// CHECK2-NEXT:         %[[VAL_66:.*]] = alloca { float, float }, align 4
// CHECK2-NEXT:         %[[VAL_67:.*]] = alloca { float, float }, align 4
// CHECK2-NEXT:         %[[VAL_68:.*]] = alloca { float, float }, align 4
// CHECK2-NEXT:         store ptr %[[VAL_69:.*]], ptr %[[VAL_49]], align 4
// CHECK2-NEXT:         store ptr %[[VAL_70:.*]], ptr %[[VAL_50]], align 4
// CHECK2-NEXT:         store i32 %[[VAL_71:.*]], ptr %[[VAL_51]], align 4
// CHECK2-NEXT:         store ptr %[[VAL_72:.*]], ptr %[[VAL_52]], align 4
// CHECK2-NEXT:         %[[VAL_73:.*]] = load ptr, ptr %[[VAL_52]], align 4
// CHECK2-NEXT:         %[[VAL_74:.*]] = getelementptr inbounds { float, float }, ptr %[[VAL_53]], i32 0, i32 0
// CHECK2-NEXT:         %[[VAL_75:.*]] = getelementptr inbounds { float, float }, ptr %[[VAL_53]], i32 0, i32 1
// CHECK2-NEXT:         store float 0.000000e+00, ptr %[[VAL_74]], align 4
// CHECK2-NEXT:         store float 0.000000e+00, ptr %[[VAL_75]], align 4
// CHECK2-NEXT:         store i32 0, ptr %[[VAL_57]], align 4
// CHECK2-NEXT:         store i32 99, ptr %[[VAL_58]], align 4
// CHECK2-NEXT:         store i32 1, ptr %[[VAL_59]], align 4
// CHECK2-NEXT:         store i32 0, ptr %[[VAL_60]], align 4
// CHECK2-NEXT:         %[[VAL_76:.*]] = load ptr, ptr %[[VAL_49]], align 4
// CHECK2-NEXT:         %[[VAL_77:.*]] = load i32, ptr %[[VAL_76]], align 4
// CHECK2-NEXT:         call void @__kmpc_for_static_init_4(ptr @1, i32 %[[VAL_77]], i32 92, ptr %[[VAL_60]], ptr %[[VAL_57]], ptr %[[VAL_58]], ptr %[[VAL_59]], i32 1, i32 1)
// CHECK2-NEXT:         %[[VAL_78:.*]] = load i32, ptr %[[VAL_58]], align 4
// CHECK2-NEXT:         %[[VAL_79:.*]] = icmp sgt i32 %[[VAL_78]], 99
// CHECK2-NEXT:         br i1 %[[VAL_79]], label %[[VAL_80:.*]], label %[[VAL_81:.*]]
// CHECK2:       cond.true:                                        ; preds = %[[VAL_82:.*]]
// CHECK2-NEXT:         br label %[[VAL_83:.*]]
// CHECK2:       cond.false:                                       ; preds = %[[VAL_82]]
// CHECK2-NEXT:         %[[VAL_84:.*]] = load i32, ptr %[[VAL_58]], align 4
// CHECK2-NEXT:         br label %[[VAL_83]]
// CHECK2:       cond.end:                                         ; preds = %[[VAL_81]], %[[VAL_80]]
// CHECK2-NEXT:         %[[VAL_85:.*]] = phi i32 [ 99, %[[VAL_80]] ], [ %[[VAL_84]], %[[VAL_81]] ]
// CHECK2-NEXT:         store i32 %[[VAL_85]], ptr %[[VAL_58]], align 4
// CHECK2-NEXT:         %[[VAL_86:.*]] = load i32, ptr %[[VAL_57]], align 4
// CHECK2-NEXT:         store i32 %[[VAL_86]], ptr %[[VAL_54]], align 4
// CHECK2-NEXT:         br label %[[VAL_87:.*]]
// CHECK2:       omp.inner.for.cond:                               ; preds = %[[VAL_88:.*]], %[[VAL_83]]
// CHECK2-NEXT:         %[[VAL_89:.*]] = load i32, ptr %[[VAL_54]], align 4
// CHECK2-NEXT:         %[[VAL_90:.*]] = load i32, ptr %[[VAL_58]], align 4
// CHECK2-NEXT:         %[[VAL_91:.*]] = icmp sle i32 %[[VAL_89]], %[[VAL_90]]
// CHECK2-NEXT:         br i1 %[[VAL_91]], label %[[VAL_92:.*]], label %[[VAL_93:.*]]
// CHECK2:       omp.inner.for.body:                               ; preds = %[[VAL_87]]
// CHECK2-NEXT:         %[[VAL_94:.*]] = load i32, ptr %[[VAL_57]], align 4
// CHECK2-NEXT:         %[[VAL_95:.*]] = load i32, ptr %[[VAL_58]], align 4
// CHECK2-NEXT:         %[[VAL_96:.*]] = load i32, ptr %[[VAL_61]], align 4
// CHECK2-NEXT:         store i32 %[[VAL_96]], ptr %[[VAL_64]], align 4
// CHECK2-NEXT:         %[[VAL_97:.*]] = load i32, ptr %[[VAL_64]], align 4
// CHECK2-NEXT:         call void (ptr, i32, ptr, ...) @__kmpc_fork_call(ptr @4, i32 4, ptr @{{__omp_offloading_[0-9a-z]+_[0-9a-z]+}}__Z3foov_l31.omp_outlined.omp_outlined, i32 %[[VAL_94]], i32 %[[VAL_95]], i32 %[[VAL_97]], ptr %[[VAL_53]])
// CHECK2-NEXT:         br label %[[VAL_88]]
// CHECK2:       omp.inner.for.inc:                                ; preds = %[[VAL_92]]
// CHECK2-NEXT:         %[[VAL_98:.*]] = load i32, ptr %[[VAL_54]], align 4
// CHECK2-NEXT:         %[[VAL_99:.*]] = load i32, ptr %[[VAL_59]], align 4
// CHECK2-NEXT:         %[[VAL_100:.*]] = add nsw i32 %[[VAL_98]], %[[VAL_99]]
// CHECK2-NEXT:         store i32 %[[VAL_100]], ptr %[[VAL_54]], align 4
// CHECK2-NEXT:         br label %[[VAL_87]]
// CHECK2:       omp.inner.for.end:                                ; preds = %[[VAL_87]]
// CHECK2-NEXT:         br label %[[VAL_101:.*]]
// CHECK2:       omp.loop.exit:                                    ; preds = %[[VAL_93]]
// CHECK2-NEXT:         call void @__kmpc_for_static_fini(ptr @2, i32 %[[VAL_77]])
// CHECK2-NEXT:         %[[VAL_102:.*]] = load i32, ptr %[[VAL_60]], align 4
// CHECK2-NEXT:         %[[VAL_103:.*]] = icmp ne i32 %[[VAL_102]], 0
// CHECK2-NEXT:         br i1 %[[VAL_103]], label %[[VAL_104:.*]], label %[[VAL_105:.*]]
// CHECK2:       .omp.lastprivate.then:                            ; preds = %[[VAL_101]]
// CHECK2-NEXT:         store i32 10, ptr %[[VAL_61]], align 4
// CHECK2-NEXT:         %[[VAL_106:.*]] = load i32, ptr %[[VAL_61]], align 4
// CHECK2-NEXT:         store i32 %[[VAL_106]], ptr %[[VAL_51]], align 4
// CHECK2-NEXT:         br label %[[VAL_105]]
// CHECK2:       .omp.lastprivate.done:                            ; preds = %[[VAL_104]], %[[VAL_101]]
// CHECK2-NEXT:         %[[VAL_107:.*]] = getelementptr inbounds [1 x ptr], ptr %[[VAL_65]], i32 0, i32 0
// CHECK2-NEXT:         store ptr %[[VAL_53]], ptr %[[VAL_107]], align 4
// CHECK2-NEXT:         %[[VAL_108:.*]] = call i32 @__kmpc_reduce(ptr @3, i32 %[[VAL_77]], i32 1, i32 4, ptr %[[VAL_65]], ptr @{{__omp_offloading_[0-9a-z]+_[0-9a-z]+}}__Z3foov_l31.omp_outlined.omp.reduction.reduction_func, ptr @.gomp_critical_user_.reduction.var)
// CHECK2-NEXT:         switch i32 %[[VAL_108]], label %[[VAL_109:.*]] [
// CHECK2-NEXT:           i32 1, label %[[VAL_110:.*]]
// CHECK2-NEXT:           i32 2, label %[[VAL_111:.*]]
// CHECK2-NEXT:         ]
// CHECK2:       .omp.reduction.case1:                             ; preds = %[[VAL_105]]
// CHECK2-NEXT:         %[[VAL_112:.*]] = getelementptr inbounds { float, float }, ptr %[[VAL_73]], i32 0, i32 0
// CHECK2-NEXT:         %[[VAL_113:.*]] = load float, ptr %[[VAL_112]], align 4
// CHECK2-NEXT:         %[[VAL_114:.*]] = getelementptr inbounds { float, float }, ptr %[[VAL_73]], i32 0, i32 1
// CHECK2-NEXT:         %[[VAL_115:.*]] = load float, ptr %[[VAL_114]], align 4
// CHECK2-NEXT:         %[[VAL_116:.*]] = getelementptr inbounds { float, float }, ptr %[[VAL_53]], i32 0, i32 0
// CHECK2-NEXT:         %[[VAL_117:.*]] = load float, ptr %[[VAL_116]], align 4
// CHECK2-NEXT:         %[[VAL_118:.*]] = getelementptr inbounds { float, float }, ptr %[[VAL_53]], i32 0, i32 1
// CHECK2-NEXT:         %[[VAL_119:.*]] = load float, ptr %[[VAL_118]], align 4
// CHECK2-NEXT:         %[[VAL_120:.*]] = fadd float %[[VAL_113]], %[[VAL_117]]
// CHECK2-NEXT:         %[[VAL_121:.*]] = fadd float %[[VAL_115]], %[[VAL_119]]
// CHECK2-NEXT:         %[[VAL_122:.*]] = getelementptr inbounds { float, float }, ptr %[[VAL_73]], i32 0, i32 0
// CHECK2-NEXT:         %[[VAL_123:.*]] = getelementptr inbounds { float, float }, ptr %[[VAL_73]], i32 0, i32 1
// CHECK2-NEXT:         store float %[[VAL_120]], ptr %[[VAL_122]], align 4
// CHECK2-NEXT:         store float %[[VAL_121]], ptr %[[VAL_123]], align 4
// CHECK2-NEXT:         call void @__kmpc_end_reduce(ptr @3, i32 %[[VAL_77]], ptr @.gomp_critical_user_.reduction.var)
// CHECK2-NEXT:         br label %[[VAL_109]]
// CHECK2:       .omp.reduction.case2:                             ; preds = %[[VAL_105]]
// CHECK2-NEXT:         %[[VAL_124:.*]] = getelementptr inbounds { float, float }, ptr %[[VAL_53]], i32 0, i32 0
// CHECK2-NEXT:         %[[VAL_125:.*]] = load float, ptr %[[VAL_124]], align 4
// CHECK2-NEXT:         %[[VAL_126:.*]] = getelementptr inbounds { float, float }, ptr %[[VAL_53]], i32 0, i32 1
// CHECK2-NEXT:         %[[VAL_127:.*]] = load float, ptr %[[VAL_126]], align 4
// CHECK2-NEXT:         call void @__atomic_load(i32 noundef 8, ptr noundef %[[VAL_73]], ptr noundef %[[VAL_66]], i32 noundef 0)
// CHECK2-NEXT:         br label %[[VAL_128:.*]]
// CHECK2:       atomic_cont:                                      ; preds = %[[VAL_128]], %[[VAL_111]]
// CHECK2-NEXT:         %[[VAL_129:.*]] = getelementptr inbounds { float, float }, ptr %[[VAL_66]], i32 0, i32 0
// CHECK2-NEXT:         %[[VAL_130:.*]] = load float, ptr %[[VAL_129]], align 4
// CHECK2-NEXT:         %[[VAL_131:.*]] = getelementptr inbounds { float, float }, ptr %[[VAL_66]], i32 0, i32 1
// CHECK2-NEXT:         %[[VAL_132:.*]] = load float, ptr %[[VAL_131]], align 4
// CHECK2-NEXT:         %[[VAL_133:.*]] = getelementptr inbounds { float, float }, ptr %[[VAL_68]], i32 0, i32 0
// CHECK2-NEXT:         %[[VAL_134:.*]] = getelementptr inbounds { float, float }, ptr %[[VAL_68]], i32 0, i32 1
// CHECK2-NEXT:         store float %[[VAL_130]], ptr %[[VAL_133]], align 4
// CHECK2-NEXT:         store float %[[VAL_132]], ptr %[[VAL_134]], align 4
// CHECK2-NEXT:         %[[VAL_135:.*]] = getelementptr inbounds { float, float }, ptr %[[VAL_68]], i32 0, i32 0
// CHECK2-NEXT:         %[[VAL_136:.*]] = load float, ptr %[[VAL_135]], align 4
// CHECK2-NEXT:         %[[VAL_137:.*]] = getelementptr inbounds { float, float }, ptr %[[VAL_68]], i32 0, i32 1
// CHECK2-NEXT:         %[[VAL_138:.*]] = load float, ptr %[[VAL_137]], align 4
// CHECK2-NEXT:         %[[VAL_139:.*]] = getelementptr inbounds { float, float }, ptr %[[VAL_53]], i32 0, i32 0
// CHECK2-NEXT:         %[[VAL_140:.*]] = load float, ptr %[[VAL_139]], align 4
// CHECK2-NEXT:         %[[VAL_141:.*]] = getelementptr inbounds { float, float }, ptr %[[VAL_53]], i32 0, i32 1
// CHECK2-NEXT:         %[[VAL_142:.*]] = load float, ptr %[[VAL_141]], align 4
// CHECK2-NEXT:         %[[VAL_143:.*]] = fadd float %[[VAL_136]], %[[VAL_140]]
// CHECK2-NEXT:         %[[VAL_144:.*]] = fadd float %[[VAL_138]], %[[VAL_142]]
// CHECK2-NEXT:         %[[VAL_145:.*]] = getelementptr inbounds { float, float }, ptr %[[VAL_67]], i32 0, i32 0
// CHECK2-NEXT:         %[[VAL_146:.*]] = getelementptr inbounds { float, float }, ptr %[[VAL_67]], i32 0, i32 1
// CHECK2-NEXT:         store float %[[VAL_143]], ptr %[[VAL_145]], align 4
// CHECK2-NEXT:         store float %[[VAL_144]], ptr %[[VAL_146]], align 4
// CHECK2-NEXT:         %[[VAL_147:.*]] = call noundef zeroext i1 @__atomic_compare_exchange(i32 noundef 8, ptr noundef %[[VAL_73]], ptr noundef %[[VAL_66]], ptr noundef %[[VAL_67]], i32 noundef 0, i32 noundef 0)
// CHECK2-NEXT:         br i1 %[[VAL_147]], label %[[VAL_148:.*]], label %[[VAL_128]]
// CHECK2:       atomic_exit:                                      ; preds = %[[VAL_128]]
// CHECK2-NEXT:         call void @__kmpc_end_reduce(ptr @3, i32 %[[VAL_77]], ptr @.gomp_critical_user_.reduction.var)
// CHECK2-NEXT:         br label %[[VAL_109]]
// CHECK2:       .omp.reduction.default:                           ; preds = %[[VAL_148]], %[[VAL_110]], %[[VAL_105]]
// CHECK2-NEXT:         ret void
//
//
// CHECK2-LABEL: define {{[^@]+}}@{{__omp_offloading_[0-9a-z]+_[0-9a-z]+}}__Z3foov_l31.omp_outlined.omp_outlined
// CHECK2-SAME: (ptr noalias noundef [[DOTGLOBAL_TID_:%.*]], ptr noalias noundef [[DOTBOUND_TID_:%.*]], i32 noundef [[J:%.*]], ptr noundef nonnull align 4 dereferenceable(8) [[SUM:%.*]]) #[[ATTR1:[0-9]+]] {
// CHECK2-NEXT:  entry:
// CHECK2-NEXT:         %[[VAL_149:.*]] = alloca ptr, align 4
// CHECK2-NEXT:         %[[VAL_150:.*]] = alloca ptr, align 4
// CHECK2-NEXT:         %[[VAL_151:.*]] = alloca i32, align 4
// CHECK2-NEXT:         %[[VAL_152:.*]] = alloca i32, align 4
// CHECK2-NEXT:         %[[VAL_153:.*]] = alloca i32, align 4
// CHECK2-NEXT:         %[[VAL_154:.*]] = alloca ptr, align 4
// CHECK2-NEXT:         %[[VAL_155:.*]] = alloca i32, align 4
// CHECK2-NEXT:         %[[VAL_156:.*]] = alloca i32, align 4
// CHECK2-NEXT:         %[[VAL_157:.*]] = alloca i32, align 4
// CHECK2-NEXT:         %[[VAL_158:.*]] = alloca i32, align 4
// CHECK2-NEXT:         %[[VAL_159:.*]] = alloca i32, align 4
// CHECK2-NEXT:         %[[VAL_160:.*]] = alloca i32, align 4
// CHECK2-NEXT:         %[[VAL_161:.*]] = alloca i32, align 4
// CHECK2-NEXT:         %[[VAL_162:.*]] = alloca i32, align 4
// CHECK2-NEXT:         %[[VAL_163:.*]] = alloca { float, float }, align 4
// CHECK2-NEXT:         %[[VAL_164:.*]] = alloca i32, align 4
// CHECK2-NEXT:         %[[VAL_165:.*]] = alloca i32, align 4
// CHECK2-NEXT:         %[[VAL_166:.*]] = alloca [1 x ptr], align 4
// CHECK2-NEXT:         %[[VAL_167:.*]] = alloca { float, float }, align 4
// CHECK2-NEXT:         %[[VAL_168:.*]] = alloca { float, float }, align 4
// CHECK2-NEXT:         %[[VAL_169:.*]] = alloca { float, float }, align 4
// CHECK2-NEXT:         store ptr %[[VAL_170:.*]], ptr %[[VAL_149]], align 4
// CHECK2-NEXT:         store ptr %[[VAL_171:.*]], ptr %[[VAL_150]], align 4
// CHECK2-NEXT:         store i32 %[[VAL_172:.*]], ptr %[[VAL_151]], align 4
// CHECK2-NEXT:         store i32 %[[VAL_173:.*]], ptr %[[VAL_152]], align 4
// CHECK2-NEXT:         store i32 %[[VAL_174:.*]], ptr %[[VAL_153]], align 4
// CHECK2-NEXT:         store ptr %[[VAL_175:.*]], ptr %[[VAL_154]], align 4
// CHECK2-NEXT:         %[[VAL_176:.*]] = load ptr, ptr %[[VAL_154]], align 4
// CHECK2-NEXT:         store i32 0, ptr %[[VAL_158]], align 4
// CHECK2-NEXT:         store i32 99, ptr %[[VAL_159]], align 4
// CHECK2-NEXT:         %[[VAL_177:.*]] = load i32, ptr %[[VAL_151]], align 4
// CHECK2-NEXT:         %[[VAL_178:.*]] = load i32, ptr %[[VAL_152]], align 4
// CHECK2-NEXT:         store i32 %[[VAL_177]], ptr %[[VAL_158]], align 4
// CHECK2-NEXT:         store i32 %[[VAL_178]], ptr %[[VAL_159]], align 4
// CHECK2-NEXT:         store i32 1, ptr %[[VAL_160]], align 4
// CHECK2-NEXT:         store i32 0, ptr %[[VAL_161]], align 4
// CHECK2-NEXT:         %[[VAL_179:.*]] = getelementptr inbounds { float, float }, ptr %[[VAL_163]], i32 0, i32 0
// CHECK2-NEXT:         %[[VAL_180:.*]] = getelementptr inbounds { float, float }, ptr %[[VAL_163]], i32 0, i32 1
// CHECK2-NEXT:         store float 0.000000e+00, ptr %[[VAL_179]], align 4
// CHECK2-NEXT:         store float 0.000000e+00, ptr %[[VAL_180]], align 4
// CHECK2-NEXT:         %[[VAL_181:.*]] = load ptr, ptr %[[VAL_149]], align 4
// CHECK2-NEXT:         %[[VAL_182:.*]] = load i32, ptr %[[VAL_181]], align 4
// CHECK2-NEXT:         call void @__kmpc_for_static_init_4(ptr @2, i32 %[[VAL_182]], i32 34, ptr %[[VAL_161]], ptr %[[VAL_158]], ptr %[[VAL_159]], ptr %[[VAL_160]], i32 1, i32 1)
// CHECK2-NEXT:         %[[VAL_183:.*]] = load i32, ptr %[[VAL_159]], align 4
// CHECK2-NEXT:         %[[VAL_184:.*]] = icmp sgt i32 %[[VAL_183]], 99
// CHECK2-NEXT:         br i1 %[[VAL_184]], label %[[VAL_185:.*]], label %[[VAL_186:.*]]
// CHECK2:       cond.true:                                        ; preds = %[[VAL_187:.*]]
// CHECK2-NEXT:         br label %[[VAL_188:.*]]
// CHECK2:       cond.false:                                       ; preds = %[[VAL_187]]
// CHECK2-NEXT:         %[[VAL_189:.*]] = load i32, ptr %[[VAL_159]], align 4
// CHECK2-NEXT:         br label %[[VAL_188]]
// CHECK2:       cond.end:                                         ; preds = %[[VAL_186]], %[[VAL_185]]
// CHECK2-NEXT:         %[[VAL_190:.*]] = phi i32 [ 99, %[[VAL_185]] ], [ %[[VAL_189]], %[[VAL_186]] ]
// CHECK2-NEXT:         store i32 %[[VAL_190]], ptr %[[VAL_159]], align 4
// CHECK2-NEXT:         %[[VAL_191:.*]] = load i32, ptr %[[VAL_158]], align 4
// CHECK2-NEXT:         store i32 %[[VAL_191]], ptr %[[VAL_155]], align 4
// CHECK2-NEXT:         br label %[[VAL_192:.*]]
// CHECK2:       omp.inner.for.cond:                               ; preds = %[[VAL_193:.*]], %[[VAL_188]]
// CHECK2-NEXT:         %[[VAL_194:.*]] = load i32, ptr %[[VAL_155]], align 4, !llvm.access.group !5
// CHECK2-NEXT:         %[[VAL_195:.*]] = load i32, ptr %[[VAL_159]], align 4, !llvm.access.group !5
// CHECK2-NEXT:         %[[VAL_196:.*]] = icmp sle i32 %[[VAL_194]], %[[VAL_195]]
// CHECK2-NEXT:         br i1 %[[VAL_196]], label %[[VAL_197:.*]], label %[[VAL_198:.*]]
// CHECK2:       omp.inner.for.body:                               ; preds = %[[VAL_192]]
// CHECK2-NEXT:         %[[VAL_199:.*]] = load i32, ptr %[[VAL_155]], align 4, !llvm.access.group !5
// CHECK2-NEXT:         %[[VAL_200:.*]] = sdiv i32 %[[VAL_199]], 10
// CHECK2-NEXT:         %[[VAL_201:.*]] = mul nsw i32 %[[VAL_200]], 1
// CHECK2-NEXT:         %[[VAL_202:.*]] = add nsw i32 0, %[[VAL_201]]
// CHECK2-NEXT:         store i32 %[[VAL_202]], ptr %[[VAL_164]], align 4, !llvm.access.group !5
// CHECK2-NEXT:         %[[VAL_203:.*]] = load i32, ptr %[[VAL_155]], align 4, !llvm.access.group !5
// CHECK2-NEXT:         %[[VAL_204:.*]] = load i32, ptr %[[VAL_155]], align 4, !llvm.access.group !5
// CHECK2-NEXT:         %[[VAL_205:.*]] = sdiv i32 %[[VAL_204]], 10
// CHECK2-NEXT:         %[[VAL_206:.*]] = mul nsw i32 %[[VAL_205]], 10
// CHECK2-NEXT:         %[[VAL_207:.*]] = sub nsw i32 %[[VAL_203]], %[[VAL_206]]
// CHECK2-NEXT:         %[[VAL_208:.*]] = mul nsw i32 %[[VAL_207]], 1
// CHECK2-NEXT:         %[[VAL_209:.*]] = add nsw i32 0, %[[VAL_208]]
// CHECK2-NEXT:         store i32 %[[VAL_209]], ptr %[[VAL_162]], align 4, !llvm.access.group !5
// CHECK2-NEXT:         %[[VAL_210:.*]] = load i32, ptr %[[VAL_164]], align 4, !llvm.access.group !5
// CHECK2-NEXT:         %[[VAL_211:.*]] = sitofp i32 %[[VAL_210]] to float
// CHECK2-NEXT:         %[[VAL_212:.*]] = getelementptr inbounds { float, float }, ptr %[[VAL_163]], i32 0, i32 0
// CHECK2-NEXT:         %[[VAL_213:.*]] = load float, ptr %[[VAL_212]], align 4, !llvm.access.group !5
// CHECK2-NEXT:         %[[VAL_214:.*]] = getelementptr inbounds { float, float }, ptr %[[VAL_163]], i32 0, i32 1
// CHECK2-NEXT:         %[[VAL_215:.*]] = load float, ptr %[[VAL_214]], align 4, !llvm.access.group !5
// CHECK2-NEXT:         %[[VAL_216:.*]] = fadd float %[[VAL_213]], %[[VAL_211]]
// CHECK2-NEXT:         %[[VAL_217:.*]] = fadd float %[[VAL_215]], 0.000000e+00
// CHECK2-NEXT:         %[[VAL_218:.*]] = getelementptr inbounds { float, float }, ptr %[[VAL_163]], i32 0, i32 0
// CHECK2-NEXT:         %[[VAL_219:.*]] = getelementptr inbounds { float, float }, ptr %[[VAL_163]], i32 0, i32 1
// CHECK2-NEXT:         store float %[[VAL_216]], ptr %[[VAL_218]], align 4, !llvm.access.group !5
// CHECK2-NEXT:         store float %[[VAL_217]], ptr %[[VAL_219]], align 4, !llvm.access.group !5
// CHECK2-NEXT:         br label %[[VAL_220:.*]]
// CHECK2:       omp.body.continue:                                ; preds = %[[VAL_197]]
// CHECK2-NEXT:         br label %[[VAL_193]]
// CHECK2:       omp.inner.for.inc:                                ; preds = %[[VAL_220]]
// CHECK2-NEXT:         %[[VAL_221:.*]] = load i32, ptr %[[VAL_155]], align 4, !llvm.access.group !5
// CHECK2-NEXT:         %[[VAL_222:.*]] = add nsw i32 %[[VAL_221]], 1
// CHECK2-NEXT:         store i32 %[[VAL_222]], ptr %[[VAL_155]], align 4, !llvm.access.group !5
// CHECK2-NEXT:         br label %[[VAL_192]], !llvm.loop !6
// CHECK2:       omp.inner.for.end:                                ; preds = %[[VAL_192]]
// CHECK2-NEXT:         br label %[[VAL_223:.*]]
// CHECK2:       omp.loop.exit:                                    ; preds = %[[VAL_198]]
// CHECK2-NEXT:         call void @__kmpc_for_static_fini(ptr @2, i32 %[[VAL_182]])
// CHECK2-NEXT:         %[[VAL_224:.*]] = getelementptr inbounds [1 x ptr], ptr %[[VAL_166]], i32 0, i32 0
// CHECK2-NEXT:         store ptr %[[VAL_163]], ptr %[[VAL_224]], align 4
// CHECK2-NEXT:         %[[VAL_225:.*]] = call i32 @__kmpc_reduce(ptr @3, i32 %[[VAL_182]], i32 1, i32 4, ptr %[[VAL_166]], ptr @{{__omp_offloading_[0-9a-z]+_[0-9a-z]+}}__Z3foov_l31.omp_outlined.omp_outlined.omp.reduction.reduction_func, ptr @.gomp_critical_user_.reduction.var)
// CHECK2-NEXT:         switch i32 %[[VAL_225]], label %[[VAL_226:.*]] [
// CHECK2-NEXT:           i32 1, label %[[VAL_227:.*]]
// CHECK2-NEXT:           i32 2, label %[[VAL_228:.*]]
// CHECK2-NEXT:         ]
// CHECK2:       .omp.reduction.case1:                             ; preds = %[[VAL_223]]
// CHECK2-NEXT:         %[[VAL_229:.*]] = getelementptr inbounds { float, float }, ptr %[[VAL_176]], i32 0, i32 0
// CHECK2-NEXT:         %[[VAL_230:.*]] = load float, ptr %[[VAL_229]], align 4
// CHECK2-NEXT:         %[[VAL_231:.*]] = getelementptr inbounds { float, float }, ptr %[[VAL_176]], i32 0, i32 1
// CHECK2-NEXT:         %[[VAL_232:.*]] = load float, ptr %[[VAL_231]], align 4
// CHECK2-NEXT:         %[[VAL_233:.*]] = getelementptr inbounds { float, float }, ptr %[[VAL_163]], i32 0, i32 0
// CHECK2-NEXT:         %[[VAL_234:.*]] = load float, ptr %[[VAL_233]], align 4
// CHECK2-NEXT:         %[[VAL_235:.*]] = getelementptr inbounds { float, float }, ptr %[[VAL_163]], i32 0, i32 1
// CHECK2-NEXT:         %[[VAL_236:.*]] = load float, ptr %[[VAL_235]], align 4
// CHECK2-NEXT:         %[[VAL_237:.*]] = fadd float %[[VAL_230]], %[[VAL_234]]
// CHECK2-NEXT:         %[[VAL_238:.*]] = fadd float %[[VAL_232]], %[[VAL_236]]
// CHECK2-NEXT:         %[[VAL_239:.*]] = getelementptr inbounds { float, float }, ptr %[[VAL_176]], i32 0, i32 0
// CHECK2-NEXT:         %[[VAL_240:.*]] = getelementptr inbounds { float, float }, ptr %[[VAL_176]], i32 0, i32 1
// CHECK2-NEXT:         store float %[[VAL_237]], ptr %[[VAL_239]], align 4
// CHECK2-NEXT:         store float %[[VAL_238]], ptr %[[VAL_240]], align 4
// CHECK2-NEXT:         call void @__kmpc_end_reduce(ptr @3, i32 %[[VAL_182]], ptr @.gomp_critical_user_.reduction.var)
// CHECK2-NEXT:         br label %[[VAL_226]]
// CHECK2:       .omp.reduction.case2:                             ; preds = %[[VAL_223]]
// CHECK2-NEXT:         %[[VAL_241:.*]] = getelementptr inbounds { float, float }, ptr %[[VAL_163]], i32 0, i32 0
// CHECK2-NEXT:         %[[VAL_242:.*]] = load float, ptr %[[VAL_241]], align 4
// CHECK2-NEXT:         %[[VAL_243:.*]] = getelementptr inbounds { float, float }, ptr %[[VAL_163]], i32 0, i32 1
// CHECK2-NEXT:         %[[VAL_244:.*]] = load float, ptr %[[VAL_243]], align 4
// CHECK2-NEXT:         call void @__atomic_load(i32 noundef 8, ptr noundef %[[VAL_176]], ptr noundef %[[VAL_167]], i32 noundef 0)
// CHECK2-NEXT:         br label %[[VAL_245:.*]]
// CHECK2:       atomic_cont:                                      ; preds = %[[VAL_245]], %[[VAL_228]]
// CHECK2-NEXT:         %[[VAL_246:.*]] = getelementptr inbounds { float, float }, ptr %[[VAL_167]], i32 0, i32 0
// CHECK2-NEXT:         %[[VAL_247:.*]] = load float, ptr %[[VAL_246]], align 4
// CHECK2-NEXT:         %[[VAL_248:.*]] = getelementptr inbounds { float, float }, ptr %[[VAL_167]], i32 0, i32 1
// CHECK2-NEXT:         %[[VAL_249:.*]] = load float, ptr %[[VAL_248]], align 4
// CHECK2-NEXT:         %[[VAL_250:.*]] = getelementptr inbounds { float, float }, ptr %[[VAL_169]], i32 0, i32 0
// CHECK2-NEXT:         %[[VAL_251:.*]] = getelementptr inbounds { float, float }, ptr %[[VAL_169]], i32 0, i32 1
// CHECK2-NEXT:         store float %[[VAL_247]], ptr %[[VAL_250]], align 4
// CHECK2-NEXT:         store float %[[VAL_249]], ptr %[[VAL_251]], align 4
// CHECK2-NEXT:         %[[VAL_252:.*]] = getelementptr inbounds { float, float }, ptr %[[VAL_169]], i32 0, i32 0
// CHECK2-NEXT:         %[[VAL_253:.*]] = load float, ptr %[[VAL_252]], align 4
// CHECK2-NEXT:         %[[VAL_254:.*]] = getelementptr inbounds { float, float }, ptr %[[VAL_169]], i32 0, i32 1
// CHECK2-NEXT:         %[[VAL_255:.*]] = load float, ptr %[[VAL_254]], align 4
// CHECK2-NEXT:         %[[VAL_256:.*]] = getelementptr inbounds { float, float }, ptr %[[VAL_163]], i32 0, i32 0
// CHECK2-NEXT:         %[[VAL_257:.*]] = load float, ptr %[[VAL_256]], align 4
// CHECK2-NEXT:         %[[VAL_258:.*]] = getelementptr inbounds { float, float }, ptr %[[VAL_163]], i32 0, i32 1
// CHECK2-NEXT:         %[[VAL_259:.*]] = load float, ptr %[[VAL_258]], align 4
// CHECK2-NEXT:         %[[VAL_260:.*]] = fadd float %[[VAL_253]], %[[VAL_257]]
// CHECK2-NEXT:         %[[VAL_261:.*]] = fadd float %[[VAL_255]], %[[VAL_259]]
// CHECK2-NEXT:         %[[VAL_262:.*]] = getelementptr inbounds { float, float }, ptr %[[VAL_168]], i32 0, i32 0
// CHECK2-NEXT:         %[[VAL_263:.*]] = getelementptr inbounds { float, float }, ptr %[[VAL_168]], i32 0, i32 1
// CHECK2-NEXT:         store float %[[VAL_260]], ptr %[[VAL_262]], align 4
// CHECK2-NEXT:         store float %[[VAL_261]], ptr %[[VAL_263]], align 4
// CHECK2-NEXT:         %[[VAL_264:.*]] = call noundef zeroext i1 @__atomic_compare_exchange(i32 noundef 8, ptr noundef %[[VAL_176]], ptr noundef %[[VAL_167]], ptr noundef %[[VAL_168]], i32 noundef 0, i32 noundef 0)
// CHECK2-NEXT:         br i1 %[[VAL_264]], label %[[VAL_265:.*]], label %[[VAL_245]]
// CHECK2:       atomic_exit:                                      ; preds = %[[VAL_245]]
// CHECK2-NEXT:         call void @__kmpc_end_reduce(ptr @3, i32 %[[VAL_182]], ptr @.gomp_critical_user_.reduction.var)
// CHECK2-NEXT:         br label %[[VAL_226]]
// CHECK2:       .omp.reduction.default:                           ; preds = %[[VAL_265]], %[[VAL_227]], %[[VAL_223]]
// CHECK2-NEXT:         %[[VAL_266:.*]] = load i32, ptr %[[VAL_161]], align 4
// CHECK2-NEXT:         %[[VAL_267:.*]] = icmp ne i32 %[[VAL_266]], 0
// CHECK2-NEXT:         br i1 %[[VAL_267]], label %[[VAL_268:.*]], label %[[VAL_269:.*]]
// CHECK2:       .omp.lastprivate.then:                            ; preds = %[[VAL_226]]
// CHECK2-NEXT:         store i32 10, ptr %[[VAL_162]], align 4
// CHECK2-NEXT:         %[[VAL_270:.*]] = load i32, ptr %[[VAL_162]], align 4
// CHECK2-NEXT:         store i32 %[[VAL_270]], ptr %[[VAL_153]], align 4
// CHECK2-NEXT:         br label %[[VAL_269]]
// CHECK2:       .omp.lastprivate.done:                            ; preds = %[[VAL_268]], %[[VAL_226]]
// CHECK2-NEXT:         ret void
//
//
// CHECK2-LABEL: define {{[^@]+}}@{{__omp_offloading_[0-9a-z]+_[0-9a-z]+}}__Z3foov_l31.omp_outlined.omp_outlined.omp.reduction.reduction_func
// CHECK2-SAME: (ptr noundef [[TMP0:%.*]], ptr noundef [[TMP1:%.*]]) #[[ATTR3:[0-9]+]] {
// CHECK2-NEXT:  entry:
// CHECK2-NEXT:         %[[VAL_271:.*]] = alloca ptr, align 4
// CHECK2-NEXT:         %[[VAL_272:.*]] = alloca ptr, align 4
// CHECK2-NEXT:         store ptr %[[VAL_273:.*]], ptr %[[VAL_271]], align 4
// CHECK2-NEXT:         store ptr %[[VAL_274:.*]], ptr %[[VAL_272]], align 4
// CHECK2-NEXT:         %[[VAL_275:.*]] = load ptr, ptr %[[VAL_271]], align 4
// CHECK2-NEXT:         %[[VAL_276:.*]] = load ptr, ptr %[[VAL_272]], align 4
// CHECK2-NEXT:         %[[VAL_277:.*]] = getelementptr inbounds [1 x ptr], ptr %[[VAL_276]], i32 0, i32 0
// CHECK2-NEXT:         %[[VAL_278:.*]] = load ptr, ptr %[[VAL_277]], align 4
// CHECK2-NEXT:         %[[VAL_279:.*]] = getelementptr inbounds [1 x ptr], ptr %[[VAL_275]], i32 0, i32 0
// CHECK2-NEXT:         %[[VAL_280:.*]] = load ptr, ptr %[[VAL_279]], align 4
// CHECK2-NEXT:         %[[VAL_281:.*]] = getelementptr inbounds { float, float }, ptr %[[VAL_280]], i32 0, i32 0
// CHECK2-NEXT:         %[[VAL_282:.*]] = load float, ptr %[[VAL_281]], align 4
// CHECK2-NEXT:         %[[VAL_283:.*]] = getelementptr inbounds { float, float }, ptr %[[VAL_280]], i32 0, i32 1
// CHECK2-NEXT:         %[[VAL_284:.*]] = load float, ptr %[[VAL_283]], align 4
// CHECK2-NEXT:         %[[VAL_285:.*]] = getelementptr inbounds { float, float }, ptr %[[VAL_278]], i32 0, i32 0
// CHECK2-NEXT:         %[[VAL_286:.*]] = load float, ptr %[[VAL_285]], align 4
// CHECK2-NEXT:         %[[VAL_287:.*]] = getelementptr inbounds { float, float }, ptr %[[VAL_278]], i32 0, i32 1
// CHECK2-NEXT:         %[[VAL_288:.*]] = load float, ptr %[[VAL_287]], align 4
// CHECK2-NEXT:         %[[VAL_289:.*]] = fadd float %[[VAL_282]], %[[VAL_286]]
// CHECK2-NEXT:         %[[VAL_290:.*]] = fadd float %[[VAL_284]], %[[VAL_288]]
// CHECK2-NEXT:         %[[VAL_291:.*]] = getelementptr inbounds { float, float }, ptr %[[VAL_280]], i32 0, i32 0
// CHECK2-NEXT:         %[[VAL_292:.*]] = getelementptr inbounds { float, float }, ptr %[[VAL_280]], i32 0, i32 1
// CHECK2-NEXT:         store float %[[VAL_289]], ptr %[[VAL_291]], align 4
// CHECK2-NEXT:         store float %[[VAL_290]], ptr %[[VAL_292]], align 4
// CHECK2-NEXT:         ret void
//
//
// CHECK2-LABEL: define {{[^@]+}}@{{__omp_offloading_[0-9a-z]+_[0-9a-z]+}}__Z3foov_l31.omp_outlined.omp.reduction.reduction_func
// CHECK2-SAME: (ptr noundef [[TMP0:%.*]], ptr noundef [[TMP1:%.*]]) #[[ATTR3:[0-9]+]] {
// CHECK2-NEXT:  entry:
// CHECK2-NEXT:         %[[VAL_293:.*]] = alloca ptr, align 4
// CHECK2-NEXT:         %[[VAL_294:.*]] = alloca ptr, align 4
// CHECK2-NEXT:         store ptr %[[VAL_295:.*]], ptr %[[VAL_293]], align 4
// CHECK2-NEXT:         store ptr %[[VAL_296:.*]], ptr %[[VAL_294]], align 4
// CHECK2-NEXT:         %[[VAL_297:.*]] = load ptr, ptr %[[VAL_293]], align 4
// CHECK2-NEXT:         %[[VAL_298:.*]] = load ptr, ptr %[[VAL_294]], align 4
// CHECK2-NEXT:         %[[VAL_299:.*]] = getelementptr inbounds [1 x ptr], ptr %[[VAL_298]], i32 0, i32 0
// CHECK2-NEXT:         %[[VAL_300:.*]] = load ptr, ptr %[[VAL_299]], align 4
// CHECK2-NEXT:         %[[VAL_301:.*]] = getelementptr inbounds [1 x ptr], ptr %[[VAL_297]], i32 0, i32 0
// CHECK2-NEXT:         %[[VAL_302:.*]] = load ptr, ptr %[[VAL_301]], align 4
// CHECK2-NEXT:         %[[VAL_303:.*]] = getelementptr inbounds { float, float }, ptr %[[VAL_302]], i32 0, i32 0
// CHECK2-NEXT:         %[[VAL_304:.*]] = load float, ptr %[[VAL_303]], align 4
// CHECK2-NEXT:         %[[VAL_305:.*]] = getelementptr inbounds { float, float }, ptr %[[VAL_302]], i32 0, i32 1
// CHECK2-NEXT:         %[[VAL_306:.*]] = load float, ptr %[[VAL_305]], align 4
// CHECK2-NEXT:         %[[VAL_307:.*]] = getelementptr inbounds { float, float }, ptr %[[VAL_300]], i32 0, i32 0
// CHECK2-NEXT:         %[[VAL_308:.*]] = load float, ptr %[[VAL_307]], align 4
// CHECK2-NEXT:         %[[VAL_309:.*]] = getelementptr inbounds { float, float }, ptr %[[VAL_300]], i32 0, i32 1
// CHECK2-NEXT:         %[[VAL_310:.*]] = load float, ptr %[[VAL_309]], align 4
// CHECK2-NEXT:         %[[VAL_311:.*]] = fadd float %[[VAL_304]], %[[VAL_308]]
// CHECK2-NEXT:         %[[VAL_312:.*]] = fadd float %[[VAL_306]], %[[VAL_310]]
// CHECK2-NEXT:         %[[VAL_313:.*]] = getelementptr inbounds { float, float }, ptr %[[VAL_302]], i32 0, i32 0
// CHECK2-NEXT:         %[[VAL_314:.*]] = getelementptr inbounds { float, float }, ptr %[[VAL_302]], i32 0, i32 1
// CHECK2-NEXT:         store float %[[VAL_311]], ptr %[[VAL_313]], align 4
// CHECK2-NEXT:         store float %[[VAL_312]], ptr %[[VAL_314]], align 4
// CHECK2-NEXT:         ret void