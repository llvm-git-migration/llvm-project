//===-- Single-precision sinpi function -------------------------------------===//
//
// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
// See https://llvm.org/LICENSE.txt for license information.
// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
//
//===----------------------------------------------------------------------===//

#include "src/math/sinpif.h"
#include "sincosf_utils.h"
#include "src/__support/FPUtil/BasicOperations.h"
#include "src/__support/FPUtil/FEnvImpl.h"
#include "src/__support/FPUtil/FPBits.h"
#include "src/__support/FPUtil/PolyEval.h"
#include "src/__support/FPUtil/multiply_add.h"
#include "src/__support/FPUtil/rounding_mode.h"
#include "src/__support/common.h"
#include "src/__support/macros/optimization.h"            // LIBC_UNLIKELY
#include "src/__support/macros/properties/cpu_features.h" // LIBC_TARGET_CPU_HAS_FMA

#include <cstdio>
#include <errno.h>
#include <iostream>

#if defined(LIBC_TARGET_CPU_HAS_FMA)
#include "range_reduction_fma.h"
#else
#include "range_reduction.h"
#endif

namespace LIBC_NAMESPACE {

float tof(int i) {
    return *(float * )&i;
}

int toi(float f) {
    return *(int *)&f;
}


double dtof(long i) {
    return *(double * )&i;
}

long dtoi(double f) {
    return *(long *)&f;
}

LLVM_LIBC_FUNCTION(float, sinpif, (float x)) {
  using FPBits = typename fputil::FPBits<float>;
  FPBits xbits(x);

  uint32_t x_u = xbits.uintval();
  uint32_t x_abs = x_u & 0x7fff'ffffU;
  double xd = static_cast<double>(x);

  // Range reduction:
  // For |x| > pi/32, we perform range reduction as follows:
  // Find k and y such that:
  //   x = (k + y) * pi/32
  //   k is an integer
  //   |y| < 0.5
  // For small range (|x| < 2^45 when FMA instructions are available, 2^22
  // otherwise), this is done by performing:
  //   k = round(x * 32/pi)
  //   y = x * 32/pi - k
  // For large range, we will omit all the higher parts of 32/pi such that the
  // least significant bits of their full products with x are larger than 63,
  // since sin((k + y + 64*i) * pi/32) = sin(x + i * 2pi) = sin(x).
  //
  // When FMA instructions are not available, we store the digits of 32/pi in
  // chunks of 28-bit precision.  This will make sure that the products:
  //   x * THIRTYTWO_OVER_PI_28[i] are all exact.
  // When FMA instructions are available, we simply store the digits of 32/pi in
  // chunks of doubles (53-bit of precision).
  // So when multiplying by the largest values of single precision, the
  // resulting output should be correct up to 2^(-208 + 128) ~ 2^-80.  By the
  // worst-case analysis of range reduction, |y| >= 2^-38, so this should give
  // us more than 40 bits of accuracy. For the worst-case estimation of range
  // reduction, see for instances:
  //   Elementary Functions by J-M. Muller, Chapter 11,
  //   Handbook of Floating-Point Arithmetic by J-M. Muller et. al.,
  //   Chapter 10.2.
  //
  // Once k and y are computed, we then deduce the answer by the sine of sum
  // formula:
  //   sin(x) = sin((k + y)*pi/32)
  //          = sin(y*pi/32) * cos(k*pi/32) + cos(y*pi/32) * sin(k*pi/32)
  // The values of sin(k*pi/32) and cos(k*pi/32) for k = 0..31 are precomputed
  // and stored using a vector of 32 doubles. Sin(y*pi/32) and cos(y*pi/32) are
  // computed using degree-7 and degree-6 minimax polynomials generated by
  // Sollya respectively.

  // |x| <= 1/16
  if (LIBC_UNLIKELY(x_abs <= 0x3d80'0000U)) {

    if (LIBC_UNLIKELY(x_abs < 0x33FC'1538U)) {
      if (LIBC_UNLIKELY(x_abs == 0U)) {
        // For signed zeros.
        return x;
      }

      double xdpi =  xd * 0x1.921fb54442d18p1; // pi
      return static_cast<float>(xdpi);
    }

    // |x| < 1/16.
    double xsq = xd * xd;

    // Degree-9 polynomial approximation:
    //   sin(x) ~ x + a_3 x^3 + a_5 x^5 + a_7 x^7 + a_9 x^9
    //          = x (1 + a_3 x^2 + ... + a_9 x^8)
    //          = x * P(x^2)
    // generated by Sollya with the following commands:
    // > display = hexadecimal;
    // > Q = fpminimax(sin(pi * x)/x, [|0, 2, 4, 6, 8|], [|D...|], [0, 1/16]);
    double result = fputil::polyeval(
        xsq, 0x1.921fb54442d18p1, -0x1.4abbce625bbf2p2, 0x1.466bc675e116ap1,
        -0x1.32d2c0b62d41cp-1, 0x1.501ec4497cb7dp-4);
    return static_cast<float>(xd * result);
  }


  if (LIBC_UNLIKELY(x_abs >= 0x7f80'0000U)) {
    if (x_abs == 0x7f80'0000U) {
      fputil::set_errno_if_required(EDOM);
      fputil::raise_except_if_required(FE_INVALID);
    }
    return x + FPBits::quiet_nan().get_val();
  }

  // Combine the results with the sine of sum formula:
  //   sin(x * pi) = sin((k + y)*pi/32)
  //          = sin(y*pi/32) * cos(k*pi/32) + cos(y*pi/32) * sin(k*pi/32)
  //          = sin_y * cos_k + (1 + cosm1_y) * sin_k
  //          = sin_y * cos_k + (cosm1_y * sin_k + sin_k)
  double sin_k, cos_k, sin_y, cosm1_y;

  sincospif_eval(xd, sin_k, cos_k, sin_y, cosm1_y);

  return static_cast<float>(fputil::multiply_add(
      sin_y, cos_k, fputil::multiply_add(cosm1_y, sin_k, sin_k)));
}

} // namespace LIBC_NAMESPACE

