#!/usr/bin/env bash
#===----------------------------------------------------------------------===##
#
# Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
# See https://llvm.org/LICENSE.txt for license information.
# SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
#
#===----------------------------------------------------------------------===##

set -ex
set -o pipefail
unset LANG
unset LC_ALL
unset LC_COLLATE

PROGNAME="$(basename "${0}")"

function usage() {
cat <<EOF
Usage:
${PROGNAME} [options] <BUILDER>

[-h|--help]         Display this help and exit.

--llvm-root <DIR>   Path to the root of the LLVM monorepo. By default, we try
                    to figure it out based on the current working directory.

--build-dir <DIR>   The directory to use for building the library. By default,
                    this is '<llvm-root>/build/<builder>'.

--osx-roots <DIR>   Path to pre-downloaded macOS dylibs. By default, we download
                    them from Green Dragon. This is only relevant at all when
                    running back-deployment testing if one wants to override
                    the old dylibs we use to run the tests with different ones.
Environment variables
CC                  The C compiler to use, this value is used by CMake. This
                    variable is optional.

CXX                 The C++ compiler to use, this value is used by CMake. This
                    variable is optional.

CMAKE               The CMake binary to use. This variable is optional.

CLANG_FORMAT        The clang-format binary to use when generating the format
                    ignore list.

ENABLE_CLANG_TIDY   Whether to compile and run clang-tidy checks. This variable
                    is optional.

EOF
}

if [[ $# == 0 ]]; then
   usage
   exit 0
fi

while [[ $# -gt 0 ]]; do
    case ${1} in
        -h|--help)
            usage
            exit 0
            ;;
        --llvm-root)
            MONOREPO_ROOT="${2}"
            shift; shift
            ;;
        --build-dir)
            BUILD_DIR="${2}"
            shift; shift
            ;;
        --osx-roots)
            OSX_ROOTS="${2}"
            shift; shift
            ;;
        *)
            BUILDER="${1}"
            shift
            ;;
    esac
done

MONOREPO_ROOT="${MONOREPO_ROOT:="$(git rev-parse --show-toplevel)"}"
BUILD_DIR="${BUILD_DIR:=${MONOREPO_ROOT}/build/${BUILDER}}"
INSTALL_DIR="${BUILD_DIR}/install"

# If we can find Ninja/CMake provided by Xcode, use those since we know their
# version will generally work with the Clang shipped in Xcode (e.g. if Clang
# knows about -std=c++20, the CMake bundled in Xcode will probably know about
# that flag too).
if xcrun --find ninja &>/dev/null; then
    NINJA="$(xcrun --find ninja)"
elif which ninja &>/dev/null; then
    # The current implementation of modules needs the absolute path to the ninja
    # binary.
    # TODO MODULES Is this still needed when CMake has libc++ module support?
    NINJA="$(which ninja)"
else
    NINJA="ninja"
fi

if [ -z "${CMAKE}" ]; then
    if xcrun --find cmake &>/dev/null; then
        CMAKE="$(xcrun --find cmake)"
    else
        CMAKE="cmake"
    fi
fi

function clean() {
    rm -rf "${BUILD_DIR}"
}

if [ -z "${ENABLE_CLANG_TIDY}" ]; then
    ENABLE_CLANG_TIDY=Off
fi

function generate-cmake-base() {
    echo "--- Generating CMake"
    ${CMAKE} \
          -S "${MONOREPO_ROOT}/runtimes" \
          -B "${BUILD_DIR}" \
          -GNinja -DCMAKE_MAKE_PROGRAM="${NINJA}" \
          -DCMAKE_BUILD_TYPE=RelWithDebInfo \
          -DCMAKE_INSTALL_PREFIX="${INSTALL_DIR}" \
          -DLIBCXX_ENABLE_WERROR=YES \
          -DLIBCXXABI_ENABLE_WERROR=YES \
          -DLIBUNWIND_ENABLE_WERROR=YES \
          -DLIBCXX_ENABLE_CLANG_TIDY=${ENABLE_CLANG_TIDY} \
          -DLLVM_LIT_ARGS="-sv --xunit-xml-output test-results.xml --timeout=1500 --time-tests" \
          "${@}"
}

function generate-cmake() {
    generate-cmake-base \
          -DLLVM_ENABLE_RUNTIMES="libcxx;libcxxabi;libunwind" \
          -DLIBCXX_CXX_ABI=libcxxabi \
          "${@}"
}

function generate-cmake-libcxx-win() {
    generate-cmake-base \
          -DLLVM_ENABLE_RUNTIMES="libcxx" \
          -DCMAKE_C_COMPILER=clang-cl \
          -DCMAKE_CXX_COMPILER=clang-cl \
          "${@}"
}

function generate-cmake-android() {
    generate-cmake-base \
          -DLLVM_ENABLE_RUNTIMES="libcxx;libcxxabi" \
          -DLIBCXX_CXX_ABI=libcxxabi \
          "${@}"
}

function check-runtimes() {
    echo "+++ Running the libc++ tests"
    ${NINJA} -vC "${BUILD_DIR}" check-cxx

    echo "+++ Running the libc++abi tests"
    ${NINJA} -vC "${BUILD_DIR}" check-cxxabi

    echo "+++ Running the libunwind tests"
    ${NINJA} -vC "${BUILD_DIR}" check-unwind

    # TODO: On macOS 13.5, the linker seems to have an issue where it will pick up
    #       a library if it exists inside a -L search path, even if we don't link
    #       against that library. This happens with libunwind.dylib if it is built
    #       at the point when we run the libc++ tests, which causes issues cause we
    #       are also linking against the system unwinder.
    #
    #       I believe this is a linker regression and I reported it as rdar://115842730.
    #       It should be possible to move this installation step back to the top once
    #       that issue has been resolved, but in the meantime it doesn't really hurt to
    #       have it here.
    echo "--- Installing libc++, libc++abi and libunwind to a fake location"
    ${NINJA} -vC "${BUILD_DIR}" install-cxx install-cxxabi install-unwind
}

# TODO: The goal is to test this against all configurations. We should also move
#       this to the Lit test suite instead of being a separate CMake target.
function check-abi-list() {
    echo "+++ Running the libc++ ABI list test"
    ${NINJA} -vC "${BUILD_DIR}" check-cxx-abilist || (
        echo "+++ Generating the libc++ ABI list after failed check"
        ${NINJA} -vC "${BUILD_DIR}" generate-cxx-abilist
        false
    )
}

function check-cxx-benchmarks() {
    echo "--- Running the benchmarks"
    ${NINJA} -vC "${BUILD_DIR}" check-cxx-benchmarks
}

function test-armv7m-picolibc() {
    clean

    # To make it easier to get this builder up and running, build picolibc
    # from scratch. Anecdotally, the build-picolibc script takes about 16 seconds.
    # This could be optimised by building picolibc into the Docker container.
    ${MONOREPO_ROOT}/libcxx/utils/ci/build-picolibc.sh \
        --build-dir "${BUILD_DIR}" \
        --install-dir "${INSTALL_DIR}" \
        --target armv7m-none-eabi

    echo "--- Generating CMake"
    flags="--sysroot=${INSTALL_DIR}"
    ${CMAKE} \
        -S "${MONOREPO_ROOT}/compiler-rt" \
        -B "${BUILD_DIR}/compiler-rt" \
        -GNinja -DCMAKE_MAKE_PROGRAM="${NINJA}" \
        -DCMAKE_BUILD_TYPE=RelWithDebInfo \
        -DCMAKE_INSTALL_PREFIX="${INSTALL_DIR}" \
        -DCMAKE_C_FLAGS="${flags}" \
        -DCMAKE_CXX_FLAGS="${flags}" \
        -DLLVM_ENABLE_PER_TARGET_RUNTIME_DIR=ON \
        "${@}"
    generate-cmake \
        -DLIBCXX_TEST_CONFIG="armv7m-picolibc-libc++.cfg.in" \
        -DLIBCXXABI_TEST_CONFIG="armv7m-picolibc-libc++abi.cfg.in" \
        -DLIBUNWIND_TEST_CONFIG="armv7m-picolibc-libunwind.cfg.in" \
        -DCMAKE_C_FLAGS="${flags}" \
        -DCMAKE_CXX_FLAGS="${flags}" \
        "${@}"

    ${NINJA} -vC "${BUILD_DIR}/compiler-rt" install
    mv "${BUILD_DIR}/install/lib/armv7m-none-eabi"/* "${BUILD_DIR}/install/lib"

    check-runtimes
}

# Print the version of a few tools to aid diagnostics in some cases
${CMAKE} --version
${NINJA} --version

if [ ! -z "${CXX}" ]; then ${CXX} --version; fi

case "${BUILDER}" in
aarch64-linux-ohos)
    # Just reuse aarch64 for a beginning
    clean
    generate-cmake -C "${MONOREPO_ROOT}/libcxx/cmake/caches/OHOS.cmake"
    check-runtimes
 ;;
*)
    echo "Temporarily skip non-OHOS builders for now"
;;
esac
