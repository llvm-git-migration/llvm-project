//===- Region.h -------------------------------------------------*- C++ -*-===//
//
// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
// See https://llvm.org/LICENSE.txt for license information.
// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
//
//===----------------------------------------------------------------------===//

#ifndef LLVM_TRANSFORMS_VECTORIZE_SANDBOXVECTORIZER_REGION_H
#define LLVM_TRANSFORMS_VECTORIZE_SANDBOXVECTORIZER_REGION_H

#include "llvm/ADT/SetVector.h"
#include "llvm/SandboxIR/SandboxIR.h"
#include "llvm/Support/InstructionCost.h"
#include "llvm/Support/raw_ostream.h"

namespace llvm {
namespace sandboxir {

/// The main job of the Region is to point to new instructions generated by
/// vectorization passes. It is the unit that RegionPasses operate on with their
/// runOnRegion() function.
///
/// The region allows us to stack transformations horizontally, meaning that
/// each transformation operates on a single region and the resulting region is
/// the input to the next transformation, as opposed to vertically, which is the
/// common way of applying a transformation across the whole BB. This enables us
/// to check for profitability and decide whether we accept or rollback at a
/// region granularity, which is much better than doing this at the BB level.
///
/// The region keeps track of the costs that correspond to that region. That is
/// the original "scalar" cost and the new "vector" cost. The cost is updated
/// automatically via SandboxIR callbacks:
/// (i) Upon deletion: If the deleted instruction is not in the region, it is an
/// original scalar, so its cost is added to the "scalar cost", otherwise it is
/// a "vector" instruction created by the vectorizer so we subtract its cost
/// from the "vector cost".
/// (ii) Upon creation: New instructions are always considered "vector" so its
/// cost is added to the "vector cost".
/// This cost tracking allows us to start with transformations that may not be
/// profitable if applied by themselves, but may end up being profitable after a
/// series of transformations.
///
//  Traditional approach: transformations applied vertically for the whole BB
//    BB
//  +----+
//  |    |
//  |    |
//  |    | -> Transform1 ->  ... -> TransformN -> Check Cost
//  |    |
//  |    |
//  +----+
//
//  Region-based approach: transformations applied horizontally, for each Region
//    BB
//  +----+
//  |Rgn1| -> Transform1 ->  ... -> TransformN -> Check Cost
//  |    |
//  |Rgn2| -> Transform1 ->  ... -> TransformN -> Check Cost
//  |    |
//  |Rgn3| -> Transform1 ->  ... -> TransformN -> Check Cost
//  +----+

class Region {
  /// All the instructions in the Region. Only new instructions generated during
  /// vectorization are part of the Region.
  SetVector<sandboxir::Instruction *> Insts;

  /// A unique ID, used for debugging.
  unsigned RegionID = 0;

  sandboxir::Context &Ctx;

  /// The basic block containing this region.
  sandboxir::BasicBlock &SBBB;

  // TODO: Add cost modeling.

  /// The cost of the original scalar instructions replaced by vector
  /// instructions in this region.
  InstructionCost ScalarCost;

  /// The cost of the vector instructions in the region.
  InstructionCost VectorCost;

  // TODO: Add a way to encode/decode region info to/from metadata.

public:
  Region(sandboxir::Context &Ctx, sandboxir::BasicBlock &SBBB);
  ~Region();

  sandboxir::BasicBlock *getParent() const { return &SBBB; }
  sandboxir::Context &getContext() const { return Ctx; }
  /// Returns the region's unique ID.
  unsigned getID() const { return RegionID; }

  /// Adds SBI to the set.
  void add(sandboxir::Instruction *SBI);
  /// Removes SBI from the set.
  void remove(sandboxir::Instruction *SBI);
  /// Returns true if SBI is in the Region.
  bool contains(sandboxir::Instruction *SBI) const {
    return Insts.contains(SBI);
  }
  /// Returns true if the Region has no instructions.
  bool empty() const { return Insts.empty(); }

  using iterator = decltype(Insts.begin());
  iterator begin() { return Insts.begin(); }
  iterator end() { return Insts.end(); }

#ifndef NDEBUG
  /// This is an expensive check, meant for testing.
  bool operator==(const sandboxir::Region &Other) const;
  void dump(raw_ostream &OS) const;
  void dump() const;
  friend raw_ostream &operator<<(raw_ostream &OS,
                                 const sandboxir::Region &Rgn) {
    Rgn.dump(OS);
    return OS;
  }
#endif
};

} // namespace sandboxir
} // namespace llvm
#endif // LLVM_TRANSFORMS_VECTORIZE_SANDBOXVECTORIZER_REGION_H
