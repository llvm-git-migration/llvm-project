; NOTE: Assertions have been autogenerated by utils/update_test_checks.py
; RUN: opt -passes=loop-unroll -disable-output -debug-only=loop-unroll %s 2>&1 | FileCheck %s

; Validate that loop unroll full doesn't try to fully unroll values whose trip counts are too large.

; CHECK: Exiting block %cont23: TripCount=2147483648, TripMultiple=0, BreakoutTrip=0
; CHECK-NEXT: Won't unroll; trip count is too large

target datalayout = "e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-i128:128-f80:128-n8:16:32:64-S128"
target triple = "x86_64-redhat-linux-gnu"

define void @foo(i64 %end) {
entry:
  br label %loopheader

loopheader:
  %iv = phi i64 [ 0, %entry ], [ %iv_new, %backedge ]
  %exit = icmp eq i64 %iv, %end
  br i1 %exit, label %for.cond.cleanup.loopexit, label %cont23

for.cond.cleanup.loopexit:
  ret void

cont23:
  %exitcond241 = icmp eq i64 %iv, 2147483647
  br i1 %exitcond241, label %handler.add_overflow, label %backedge

handler.add_overflow:
  unreachable

backedge: ; preds = %cont23
  %iv_new = add i64 %iv, 1
  br label %loopheader, !llvm.loop !0
}

!0 = distinct !{!0, !1}
!1 = !{!"llvm.loop.unroll.full"}
