; NOTE: Assertions have been autogenerated by utils/update_test_checks.py UTC_ARGS: --version 4
; RUN: opt -passes=jump-threading -S < %s | FileCheck %s

define i1 @if_else(i1 %c, i1 %c1) {
; CHECK-LABEL: define i1 @if_else(
; CHECK-SAME: i1 [[C:%.*]], i1 [[C1:%.*]]) {
; CHECK-NEXT:  entry:
; CHECK-NEXT:    br i1 [[C]], label [[THEN:%.*]], label [[RETURN:%.*]]
; CHECK:       then:
; CHECK-NEXT:    call void @dummy()
; CHECK-NEXT:    br i1 [[C1]], label [[RETURN]], label [[RETURN1:%.*]]
; CHECK:       else:
; CHECK-NEXT:    br label [[RETURN1]]
; CHECK:       return:
; CHECK-NEXT:    [[RETVAL_0:%.*]] = phi i1 [ true, [[RETURN]] ], [ false, [[THEN]] ]
; CHECK-NEXT:    ret i1 [[RETVAL_0]]
;
entry:
  br i1 %c, label %then, label %else

then:
  call void @dummy()
  br i1 %c1, label %else, label %return

else:
  br label %return

return:
  %retval.0 = phi i1 [ true, %else ], [ false, %then ]
  ret i1 %retval.0
}

define i8 @switch_uncond(i8 %arg) {
; CHECK-LABEL: define i8 @switch_uncond(
; CHECK-SAME: i8 [[ARG:%.*]]) {
; CHECK-NEXT:  entry:
; CHECK-NEXT:    switch i8 [[ARG]], label [[DEFAULT:%.*]] [
; CHECK-NEXT:      i8 0, label [[BB1:%.*]]
; CHECK-NEXT:      i8 1, label [[BB3:%.*]]
; CHECK-NEXT:      i8 2, label [[BB2:%.*]]
; CHECK-NEXT:      i8 3, label [[END:%.*]]
; CHECK-NEXT:    ]
; CHECK:       default:
; CHECK-NEXT:    unreachable
; CHECK:       bb:
; CHECK-NEXT:    call void @dummy()
; CHECK-NEXT:    br label [[BB2]]
; CHECK:       bb1:
; CHECK-NEXT:    call void @dummy()
; CHECK-NEXT:    br label [[BB2]]
; CHECK:       bb2:
; CHECK-NEXT:    br label [[END]]
; CHECK:       end:
; CHECK-NEXT:    [[PHI:%.*]] = phi i8 [ 0, [[BB2]] ], [ 1, [[ENTRY:%.*]] ]
; CHECK-NEXT:    ret i8 [[PHI]]
;
entry:
  switch i8 %arg, label %default [
  i8 0, label %bb
  i8 1, label %bb1
  i8 2, label %bb2
  i8 3, label %end
  ]

default:
  unreachable

bb:
  call void @dummy()
  br label %bb2

bb1:
  call void @dummy()
  br label %bb2

; Predecessors of %bb2 are %bb and %bb1, they are not identical.
; So we can thread %bb2.
bb2:
  br label %end

end:
  %phi = phi i8 [ 0, %bb2 ], [ 1, %entry ]
  ret i8 %phi
}

define i8 @switch_uncond_fail(i8 %arg) {
; CHECK-LABEL: define i8 @switch_uncond_fail(
; CHECK-SAME: i8 [[ARG:%.*]]) {
; CHECK-NEXT:  entry:
; CHECK-NEXT:    switch i8 [[ARG]], label [[DEFAULT:%.*]] [
; CHECK-NEXT:      i8 0, label [[BB:%.*]]
; CHECK-NEXT:      i8 1, label [[BB]]
; CHECK-NEXT:      i8 2, label [[END:%.*]]
; CHECK-NEXT:    ]
; CHECK:       default:
; CHECK-NEXT:    br label [[END]]
; CHECK:       bb:
; CHECK-NEXT:    br label [[END]]
; CHECK:       end:
; CHECK-NEXT:    [[PHI:%.*]] = phi i8 [ 0, [[BB]] ], [ 1, [[ENTRY:%.*]] ], [ 2, [[DEFAULT]] ]
; CHECK-NEXT:    ret i8 [[PHI]]
;
entry:
  switch i8 %arg, label %default [
  i8 0, label %bb
  i8 1, label %bb
  i8 2, label %end
  ]

default:
  br label %end

; Predecessor of %bb is only %entry (though there are two in predecessor list),
; thus it's unthreadable.
bb:
  br label %end

end:
  %phi = phi i8 [ 0, %bb ], [ 1, %entry ], [ 2, %default ]
  ret i8 %phi
}

declare void @dummy()
