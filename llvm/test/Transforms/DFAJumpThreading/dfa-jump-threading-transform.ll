; NOTE: Assertions have been autogenerated by utils/update_test_checks.py
; RUN: opt -S -passes=dfa-jump-threading %s | FileCheck %s

; These tests check that the DFA jump threading transformation is applied
; properly to two CFGs. It checks that blocks are cloned, branches are updated,
; and SSA form is restored.
define i32 @test1(i32 %num) {
; CHECK-LABEL: @test1(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    br label [[FOR_BODY:%.*]]
; CHECK:       for.body:
; CHECK-NEXT:    [[COUNT:%.*]] = phi i32 [ 0, [[ENTRY:%.*]] ], [ [[INC:%.*]], [[FOR_INC:%.*]] ]
; CHECK-NEXT:    [[STATE:%.*]] = phi i32 [ 1, [[ENTRY]] ], [ [[STATE_NEXT:%.*]], [[FOR_INC]] ]
; CHECK-NEXT:    switch i32 [[STATE]], label [[FOR_INC_JT1:%.*]] [
; CHECK-NEXT:      i32 1, label [[CASE1:%.*]]
; CHECK-NEXT:      i32 2, label [[CASE2:%.*]]
; CHECK-NEXT:    ]
; CHECK:       for.body.jt2:
; CHECK-NEXT:    [[COUNT_JT2:%.*]] = phi i32 [ [[INC_JT2:%.*]], [[FOR_INC_JT2:%.*]] ]
; CHECK-NEXT:    [[STATE_JT2:%.*]] = phi i32 [ [[STATE_NEXT_JT2:%.*]], [[FOR_INC_JT2]] ]
; CHECK-NEXT:    br label [[CASE2]]
; CHECK:       for.body.jt1:
; CHECK-NEXT:    [[COUNT_JT1:%.*]] = phi i32 [ [[INC_JT1:%.*]], [[FOR_INC_JT1]] ]
; CHECK-NEXT:    [[STATE_JT1:%.*]] = phi i32 [ [[STATE_NEXT_JT1:%.*]], [[FOR_INC_JT1]] ]
; CHECK-NEXT:    br label [[CASE1]]
; CHECK:       case1:
; CHECK-NEXT:    [[COUNT2:%.*]] = phi i32 [ [[COUNT_JT1]], [[FOR_BODY_JT1:%.*]] ], [ [[COUNT]], [[FOR_BODY]] ]
; CHECK-NEXT:    br label [[FOR_INC_JT2]]
; CHECK:       case2:
; CHECK-NEXT:    [[COUNT1:%.*]] = phi i32 [ [[COUNT_JT2]], [[FOR_BODY_JT2:%.*]] ], [ [[COUNT]], [[FOR_BODY]] ]
; CHECK-NEXT:    [[CMP:%.*]] = icmp eq i32 [[COUNT1]], 50
; CHECK-NEXT:    br i1 [[CMP]], label [[FOR_INC_JT1]], label [[SEL_SI_UNFOLD_FALSE_JT2:%.*]]
; CHECK:       sel.si.unfold.false:
; CHECK-NEXT:    br label [[FOR_INC]]
; CHECK:       sel.si.unfold.false.jt2:
; CHECK-NEXT:    [[DOTSI_UNFOLD_PHI_JT2:%.*]] = phi i32 [ 2, [[CASE2]] ]
; CHECK-NEXT:    br label [[FOR_INC_JT2]]
; CHECK:       for.inc:
; CHECK-NEXT:    [[STATE_NEXT]] = phi i32 [ poison, [[SEL_SI_UNFOLD_FALSE:%.*]] ]
; CHECK-NEXT:    [[INC]] = add nsw i32 undef, 1
; CHECK-NEXT:    [[CMP_EXIT:%.*]] = icmp slt i32 [[INC]], [[NUM:%.*]]
; CHECK-NEXT:    br i1 [[CMP_EXIT]], label [[FOR_BODY]], label [[FOR_END:%.*]]
; CHECK:       for.inc.jt2:
; CHECK-NEXT:    [[COUNT4:%.*]] = phi i32 [ [[COUNT1]], [[SEL_SI_UNFOLD_FALSE_JT2]] ], [ [[COUNT2]], [[CASE1]] ]
; CHECK-NEXT:    [[STATE_NEXT_JT2]] = phi i32 [ 2, [[CASE1]] ], [ [[DOTSI_UNFOLD_PHI_JT2]], [[SEL_SI_UNFOLD_FALSE_JT2]] ]
; CHECK-NEXT:    [[INC_JT2]] = add nsw i32 [[COUNT4]], 1
; CHECK-NEXT:    [[CMP_EXIT_JT2:%.*]] = icmp slt i32 [[INC_JT2]], [[NUM]]
; CHECK-NEXT:    br i1 [[CMP_EXIT_JT2]], label [[FOR_BODY_JT2]], label [[FOR_END]]
; CHECK:       for.inc.jt1:
; CHECK-NEXT:    [[COUNT3:%.*]] = phi i32 [ [[COUNT]], [[FOR_BODY]] ], [ [[COUNT1]], [[CASE2]] ]
; CHECK-NEXT:    [[STATE_NEXT_JT1]] = phi i32 [ 1, [[CASE2]] ], [ 1, [[FOR_BODY]] ]
; CHECK-NEXT:    [[INC_JT1]] = add nsw i32 [[COUNT3]], 1
; CHECK-NEXT:    [[CMP_EXIT_JT1:%.*]] = icmp slt i32 [[INC_JT1]], [[NUM]]
; CHECK-NEXT:    br i1 [[CMP_EXIT_JT1]], label [[FOR_BODY_JT1]], label [[FOR_END]]
; CHECK:       for.end:
; CHECK-NEXT:    ret i32 0
;
entry:
  br label %for.body

for.body:
  %count = phi i32 [ 0, %entry ], [ %inc, %for.inc ]
  %state = phi i32 [ 1, %entry ], [ %state.next, %for.inc ]
  switch i32 %state, label %for.inc [
  i32 1, label %case1
  i32 2, label %case2
  ]

case1:
  br label %for.inc

case2:
  %cmp = icmp eq i32 %count, 50
  %sel = select i1 %cmp, i32 1, i32 2
  br label %for.inc

for.inc:
  %state.next = phi i32 [ %sel, %case2 ], [ 1, %for.body ], [ 2, %case1 ]
  %inc = add nsw i32 %count, 1
  %cmp.exit = icmp slt i32 %inc, %num
  br i1 %cmp.exit, label %for.body, label %for.end

for.end:
  ret i32 0
}


define i32 @test2(i32 %init) {
; CHECK-LABEL: @test2(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[CMP:%.*]] = icmp eq i32 [[INIT:%.*]], 0
; CHECK-NEXT:    br i1 [[CMP]], label [[LOOP_1:%.*]], label [[SEL_SI_UNFOLD_FALSE:%.*]]
; CHECK:       state.1.be2.si.unfold.false:
; CHECK-NEXT:    [[STATE_1_BE_SI_UNFOLD_PHI:%.*]] = phi i32 [ poison, [[LOOP_1_BACKEDGE:%.*]] ]
; CHECK-NEXT:    br label [[LOOP_1]]
; CHECK:       state.1.be2.si.unfold.false.jt4:
; CHECK-NEXT:    [[STATE_1_BE_SI_UNFOLD_PHI_JT4:%.*]] = phi i32 [ [[STATE_1_BE_JT4:%.*]], [[LOOP_1_BACKEDGE_JT4:%.*]] ]
; CHECK-NEXT:    br label [[LOOP_1_JT4:%.*]]
; CHECK:       state.1.be2.si.unfold.false.jt2:
; CHECK-NEXT:    [[STATE_1_BE_SI_UNFOLD_PHI_JT2:%.*]] = phi i32 [ [[STATE_1_BE_JT2:%.*]], [[LOOP_1_BACKEDGE_JT2:%.*]] ]
; CHECK-NEXT:    br label [[LOOP_1_JT2:%.*]]
; CHECK:       sel.si.unfold.false:
; CHECK-NEXT:    [[DOTSI_UNFOLD_PHI:%.*]] = phi i32 [ 2, [[ENTRY:%.*]] ]
; CHECK-NEXT:    br label [[LOOP_1]]
; CHECK:       loop.1:
; CHECK-NEXT:    [[STATE_1:%.*]] = phi i32 [ 0, [[ENTRY]] ], [ [[STATE_1_BE_SI_UNFOLD_PHI]], [[STATE_1_BE2_SI_UNFOLD_FALSE:%.*]] ], [ [[DOTSI_UNFOLD_PHI]], [[SEL_SI_UNFOLD_FALSE]] ]
; CHECK-NEXT:    br label [[LOOP_2:%.*]]
; CHECK:       loop.1.jt4:
; CHECK-NEXT:    [[STATE_1_JT4:%.*]] = phi i32 [ [[STATE_1_BE_SI_UNFOLD_PHI_JT4]], [[STATE_1_BE2_SI_UNFOLD_FALSE_JT4:%.*]] ]
; CHECK-NEXT:    br label [[LOOP_2_JT4:%.*]]
; CHECK:       loop.1.jt2:
; CHECK-NEXT:    [[STATE_1_JT2:%.*]] = phi i32 [ [[STATE_1_BE_SI_UNFOLD_PHI_JT2]], [[STATE_1_BE2_SI_UNFOLD_FALSE_JT2:%.*]] ]
; CHECK-NEXT:    br label [[LOOP_2_JT2:%.*]]
; CHECK:       loop.1.jt1:
; CHECK-NEXT:    [[STATE_1_JT1:%.*]] = phi i32 [ 1, [[LOOP_1_BACKEDGE]] ], [ 1, [[LOOP_1_BACKEDGE_JT2]] ], [ 1, [[LOOP_1_BACKEDGE_JT4]] ]
; CHECK-NEXT:    br label [[LOOP_2_JT1:%.*]]
; CHECK:       loop.2:
; CHECK-NEXT:    [[STATE_2:%.*]] = phi i32 [ [[STATE_1]], [[LOOP_1]] ], [ poison, [[LOOP_2_BACKEDGE:%.*]] ]
; CHECK-NEXT:    br label [[LOOP_3:%.*]]
; CHECK:       loop.2.jt0:
; CHECK-NEXT:    [[STATE_2_JT0:%.*]] = phi i32 [ [[STATE_2_BE_JT0:%.*]], [[LOOP_2_BACKEDGE_JT0:%.*]] ]
; CHECK-NEXT:    br label [[LOOP_3_JT0:%.*]]
; CHECK:       loop.2.jt3:
; CHECK-NEXT:    [[STATE_2_JT3:%.*]] = phi i32 [ [[STATE_2_BE_JT3:%.*]], [[LOOP_2_BACKEDGE_JT3:%.*]] ]
; CHECK-NEXT:    br label [[LOOP_3_JT3:%.*]]
; CHECK:       loop.2.jt4:
; CHECK-NEXT:    [[STATE_2_JT4:%.*]] = phi i32 [ [[STATE_1_JT4]], [[LOOP_1_JT4]] ]
; CHECK-NEXT:    br label [[LOOP_3_JT4:%.*]]
; CHECK:       loop.2.jt2:
; CHECK-NEXT:    [[STATE_2_JT2:%.*]] = phi i32 [ [[STATE_1_JT2]], [[LOOP_1_JT2]] ]
; CHECK-NEXT:    br label [[LOOP_3_JT2:%.*]]
; CHECK:       loop.2.jt1:
; CHECK-NEXT:    [[STATE_2_JT1:%.*]] = phi i32 [ [[STATE_1_JT1]], [[LOOP_1_JT1:%.*]] ]
; CHECK-NEXT:    br label [[LOOP_3_JT1:%.*]]
; CHECK:       loop.3:
; CHECK-NEXT:    [[STATE:%.*]] = phi i32 [ [[STATE_2]], [[LOOP_2]] ]
; CHECK-NEXT:    switch i32 [[STATE]], label [[INFLOOP_I:%.*]] [
; CHECK-NEXT:      i32 2, label [[CASE2:%.*]]
; CHECK-NEXT:      i32 3, label [[CASE3:%.*]]
; CHECK-NEXT:      i32 4, label [[CASE4:%.*]]
; CHECK-NEXT:      i32 0, label [[CASE0:%.*]]
; CHECK-NEXT:      i32 1, label [[CASE1:%.*]]
; CHECK-NEXT:    ]
; CHECK:       loop.3.jt0:
; CHECK-NEXT:    [[STATE_JT0:%.*]] = phi i32 [ [[STATE_2_JT0]], [[LOOP_2_JT0:%.*]] ]
; CHECK-NEXT:    br label [[CASE0]]
; CHECK:       loop.3.jt3:
; CHECK-NEXT:    [[STATE_JT3:%.*]] = phi i32 [ 3, [[CASE2]] ], [ [[STATE_2_JT3]], [[LOOP_2_JT3:%.*]] ]
; CHECK-NEXT:    br label [[CASE3]]
; CHECK:       loop.3.jt4:
; CHECK-NEXT:    [[STATE_JT4:%.*]] = phi i32 [ [[STATE_2_JT4]], [[LOOP_2_JT4]] ]
; CHECK-NEXT:    br label [[CASE4]]
; CHECK:       loop.3.jt2:
; CHECK-NEXT:    [[STATE_JT2:%.*]] = phi i32 [ [[STATE_2_JT2]], [[LOOP_2_JT2]] ]
; CHECK-NEXT:    br label [[CASE2]]
; CHECK:       loop.3.jt1:
; CHECK-NEXT:    [[STATE_JT1:%.*]] = phi i32 [ [[STATE_2_JT1]], [[LOOP_2_JT1]] ]
; CHECK-NEXT:    br label [[CASE1]]
; CHECK:       case2:
; CHECK-NEXT:    br i1 [[CMP]], label [[LOOP_3_JT3]], label [[LOOP_1_BACKEDGE_JT4]]
; CHECK:       case3:
; CHECK-NEXT:    br i1 [[CMP]], label [[LOOP_2_BACKEDGE_JT0]], label [[CASE4]]
; CHECK:       case4:
; CHECK-NEXT:    br i1 [[CMP]], label [[LOOP_2_BACKEDGE_JT3]], label [[LOOP_1_BACKEDGE_JT2]]
; CHECK:       loop.1.backedge:
; CHECK-NEXT:    br i1 [[CMP]], label [[LOOP_1_JT1]], label [[STATE_1_BE2_SI_UNFOLD_FALSE]]
; CHECK:       loop.1.backedge.jt4:
; CHECK-NEXT:    [[STATE_1_BE_JT4]] = phi i32 [ 4, [[CASE2]] ]
; CHECK-NEXT:    br i1 [[CMP]], label [[LOOP_1_JT1]], label [[STATE_1_BE2_SI_UNFOLD_FALSE_JT4]]
; CHECK:       loop.1.backedge.jt2:
; CHECK-NEXT:    [[STATE_1_BE_JT2]] = phi i32 [ 2, [[CASE4]] ]
; CHECK-NEXT:    br i1 [[CMP]], label [[LOOP_1_JT1]], label [[STATE_1_BE2_SI_UNFOLD_FALSE_JT2]]
; CHECK:       loop.2.backedge:
; CHECK-NEXT:    br label [[LOOP_2]]
; CHECK:       loop.2.backedge.jt0:
; CHECK-NEXT:    [[STATE_2_BE_JT0]] = phi i32 [ 0, [[CASE3]] ]
; CHECK-NEXT:    br label [[LOOP_2_JT0]]
; CHECK:       loop.2.backedge.jt3:
; CHECK-NEXT:    [[STATE_2_BE_JT3]] = phi i32 [ 3, [[CASE4]] ]
; CHECK-NEXT:    br label [[LOOP_2_JT3]]
; CHECK:       case0:
; CHECK-NEXT:    br label [[EXIT:%.*]]
; CHECK:       case1:
; CHECK-NEXT:    br label [[EXIT]]
; CHECK:       infloop.i:
; CHECK-NEXT:    br label [[INFLOOP_I]]
; CHECK:       exit:
; CHECK-NEXT:    ret i32 0
;
entry:
  %cmp = icmp eq i32 %init, 0
  %sel = select i1 %cmp, i32 0, i32 2
  br label %loop.1

loop.1:
  %state.1 = phi i32 [ %sel, %entry ], [ %state.1.be2, %loop.1.backedge ]
  br label %loop.2

loop.2:
  %state.2 = phi i32 [ %state.1, %loop.1 ], [ %state.2.be, %loop.2.backedge ]
  br label %loop.3

loop.3:
  %state = phi i32 [ %state.2, %loop.2 ], [ 3, %case2 ]
  switch i32 %state, label %infloop.i [
  i32 2, label %case2
  i32 3, label %case3
  i32 4, label %case4
  i32 0, label %case0
  i32 1, label %case1
  ]

case2:
  br i1 %cmp, label %loop.3, label %loop.1.backedge

case3:
  br i1 %cmp, label %loop.2.backedge, label %case4

case4:
  br i1 %cmp, label %loop.2.backedge, label %loop.1.backedge

loop.1.backedge:
  %state.1.be = phi i32 [ 2, %case4 ], [ 4, %case2 ]
  %state.1.be2 = select i1 %cmp, i32 1, i32 %state.1.be
  br label %loop.1

loop.2.backedge:
  %state.2.be = phi i32 [ 3, %case4 ], [ 0, %case3 ]
  br label %loop.2

case0:
  br label %exit

case1:
  br label %exit

infloop.i:
  br label %infloop.i

exit:
  ret i32 0
}

define void @pr78059_bitwidth() {
; CHECK-LABEL: @pr78059_bitwidth(
; CHECK-NEXT:  .split.preheader:
; CHECK-NEXT:    br label [[DOTSPLIT:%.*]]
; CHECK:       .split:
; CHECK-NEXT:    [[TMP0:%.*]] = phi i128 [ 0, [[DOTSPLIT_PREHEADER:%.*]] ]
; CHECK-NEXT:    switch i128 [[TMP0]], label [[END:%.*]] [
; CHECK-NEXT:      i128 -1, label [[END]]
; CHECK-NEXT:      i128 0, label [[DOTSPLIT_JT18446744073709551615:%.*]]
; CHECK-NEXT:    ]
; CHECK:       .split.jt18446744073709551615:
; CHECK-NEXT:    [[TMP1:%.*]] = phi i128 [ -1, [[DOTSPLIT]] ]
; CHECK-NEXT:    br label [[END]]
; CHECK:       end:
; CHECK-NEXT:    ret void
;
.split.preheader:
  br label %.split

.split:
  %0 = phi i128 [ 0, %.split.preheader ], [ -1, %.split ]
  switch i128 %0, label %end [
  i128 -1, label %end
  i128 0, label %.split
  ]

end:
  ret void
}

define void @self-reference() {
; CHECK-LABEL: @self-reference(
; CHECK-NEXT:  .split.preheader:
; CHECK-NEXT:    br label [[DOTSPLIT:%.*]]
; CHECK:       .split:
; CHECK-NEXT:    [[TMP0:%.*]] = phi i32 [ 0, [[DOTSPLIT_PREHEADER:%.*]] ]
; CHECK-NEXT:    switch i32 [[TMP0]], label [[END:%.*]] [
; CHECK-NEXT:      i32 -1, label [[END]]
; CHECK-NEXT:      i32 0, label [[DOTSPLIT_JT4294967295:%.*]]
; CHECK-NEXT:    ]
; CHECK:       .split.jt4294967295:
; CHECK-NEXT:    [[TMP1:%.*]] = phi i32 [ -1, [[DOTSPLIT]] ]
; CHECK-NEXT:    br label [[END]]
; CHECK:       end:
; CHECK-NEXT:    ret void
;
.split.preheader:
  br label %.split

.split:
  %0 = phi i32 [ 0, %.split.preheader ], [ -1, %.split ]
  switch i32 %0, label %end [
  i32 -1, label %end
  i32 0, label %.split
  ]

end:
  ret void
}

@a = external dso_local global ptr, align 8
@b = external dso_local global i32, align 4
@c = external dso_local global i64, align 8
@d = external dso_local global i16, align 2
@e = external dso_local global i64, align 8
@f = external dso_local global i32, align 4
@g = external dso_local global i64, align 8
@h = external dso_local global i32, align 4
@i = external dso_local global ptr, align 8

define void @pr106083_invalidBBarg_fold() {
; CHECK-LABEL: @pr106083_invalidBBarg_fold(
; CHECK-NEXT:    [[TMP1:%.*]] = load i32, ptr @h, align 4
; CHECK-NEXT:    [[DOTNOT2:%.*]] = icmp eq i32 [[TMP1]], 0
; CHECK-NEXT:    [[D_PROMOTED3:%.*]] = load i16, ptr @d, align 1
; CHECK-NEXT:    br i1 [[DOTNOT2]], label [[BB0:%.*]], label [[DOT_SI_UNFOLD_FALSE:%.*]]
; CHECK:       BB0.loopexit:
; CHECK-NEXT:    [[D_PROMOTED41:%.*]] = phi i16 [ [[D_PROMOTED4_JT2:%.*]], [[BB7_JT2:%.*]] ], [ [[D_PROMOTED4:%.*]], [[BB7:%.*]] ]
; CHECK-NEXT:    br label [[BB0]]
; CHECK:       ..si.unfold.false:
; CHECK-NEXT:    [[DOTSI_UNFOLD_PHI:%.*]] = phi i32 [ 6, [[TMP0:%.*]] ]
; CHECK-NEXT:    br label [[BB0]]
; CHECK:       BB0:
; CHECK-NEXT:    [[D_PROMOTED6:%.*]] = phi i16 [ [[D_PROMOTED3]], [[TMP0]] ], [ [[D_PROMOTED41]], [[BB0_LOOPEXIT:%.*]] ], [ [[D_PROMOTED3]], [[DOT_SI_UNFOLD_FALSE]] ]
; CHECK-NEXT:    [[DOT_SI_UNFOLD_PHI:%.*]] = phi i32 [ [[DOT_SI_UNFOLD_PHI]], [[BB0_LOOPEXIT]] ], [ 0, [[TMP0]] ], [ [[DOTSI_UNFOLD_PHI]], [[DOT_SI_UNFOLD_FALSE]] ]
; CHECK-NEXT:    br label [[BB1_JT2:%.*]]
; CHECK:       BB1:
; CHECK-NEXT:    [[D_PROMOTED5:%.*]] = phi i16 [ [[D_PROMOTED4]], [[BB1_BACKEDGE:%.*]] ]
; CHECK-NEXT:    [[TMP2:%.*]] = phi i16 [ [[TMP10:%.*]], [[BB1_BACKEDGE]] ]
; CHECK-NEXT:    [[DOT1:%.*]] = phi i32 [ [[DOT3:%.*]], [[BB1_BACKEDGE]] ]
; CHECK-NEXT:    [[TMP3:%.*]] = load volatile i32, ptr @f, align 4
; CHECK-NEXT:    [[DOTNOT:%.*]] = icmp eq i32 [[TMP3]], 0
; CHECK-NEXT:    br i1 [[DOTNOT]], label [[BB7]], label [[BB2:%.*]]
; CHECK:       BB1.jt2:
; CHECK-NEXT:    [[D_PROMOTED5_JT2:%.*]] = phi i16 [ [[D_PROMOTED6]], [[BB0]] ]
; CHECK-NEXT:    [[TMP4:%.*]] = phi i16 [ [[D_PROMOTED6]], [[BB0]] ]
; CHECK-NEXT:    [[DOT1_JT2:%.*]] = phi i32 [ 2, [[BB0]] ]
; CHECK-NEXT:    [[TMP5:%.*]] = load volatile i32, ptr @f, align 4
; CHECK-NEXT:    [[DOTNOT_JT2:%.*]] = icmp eq i32 [[TMP5]], 0
; CHECK-NEXT:    br i1 [[DOTNOT_JT2]], label [[BB7_JT2]], label [[BB2_JT2:%.*]]
; CHECK:       BB2:
; CHECK-NEXT:    [[TMP6:%.*]] = add i16 [[TMP2]], 1
; CHECK-NEXT:    store i16 [[TMP6]], ptr @d, align 2
; CHECK-NEXT:    [[TMP7:%.*]] = load volatile i64, ptr @g, align 8
; CHECK-NEXT:    [[DOTNOT1:%.*]] = icmp eq i64 [[TMP7]], 0
; CHECK-NEXT:    br i1 [[DOTNOT1]], label [[BB7]], label [[SPEC_SELECT_SI_UNFOLD_FALSE:%.*]]
; CHECK:       BB2.jt2:
; CHECK-NEXT:    [[TMP8:%.*]] = add i16 [[TMP4]], 1
; CHECK-NEXT:    store i16 [[TMP8]], ptr @d, align 2
; CHECK-NEXT:    [[TMP9:%.*]] = load volatile i64, ptr @g, align 8
; CHECK-NEXT:    [[DOTNOT1_JT2:%.*]] = icmp eq i64 [[TMP9]], 0
; CHECK-NEXT:    br i1 [[DOTNOT1_JT2]], label [[BB7]], label [[SPEC_SELECT_SI_UNFOLD_FALSE_JT2:%.*]]
; CHECK:       spec.select.si.unfold.false:
; CHECK-NEXT:    [[DOT1_SI_UNFOLD_PHI:%.*]] = phi i32 [ [[DOT1]], [[BB2]] ]
; CHECK-NEXT:    br label [[BB7]]
; CHECK:       spec.select.si.unfold.false.jt2:
; CHECK-NEXT:    [[DOT1_SI_UNFOLD_PHI_JT2:%.*]] = phi i32 [ [[DOT1_JT2]], [[BB2_JT2]] ]
; CHECK-NEXT:    br label [[BB7_JT2]]
; CHECK:       BB7:
; CHECK-NEXT:    [[D_PROMOTED4]] = phi i16 [ [[D_PROMOTED5]], [[BB1:%.*]] ], [ [[TMP6]], [[BB2]] ], [ [[TMP6]], [[SPEC_SELECT_SI_UNFOLD_FALSE]] ], [ [[TMP8]], [[BB2_JT2]] ]
; CHECK-NEXT:    [[TMP10]] = phi i16 [ [[TMP2]], [[BB1]] ], [ [[TMP6]], [[BB2]] ], [ [[TMP6]], [[SPEC_SELECT_SI_UNFOLD_FALSE]] ], [ [[TMP8]], [[BB2_JT2]] ]
; CHECK-NEXT:    [[DOT3]] = phi i32 [ [[DOT1]], [[BB1]] ], [ [[DOT_SI_UNFOLD_PHI]], [[BB2]] ], [ [[DOT1_SI_UNFOLD_PHI]], [[SPEC_SELECT_SI_UNFOLD_FALSE]] ], [ [[DOT_SI_UNFOLD_PHI]], [[BB2_JT2]] ]
; CHECK-NEXT:    switch i32 [[DOT3]], label [[BB9:%.*]] [
; CHECK-NEXT:      i32 0, label [[BB1_BACKEDGE]]
; CHECK-NEXT:      i32 7, label [[BB1_BACKEDGE]]
; CHECK-NEXT:      i32 6, label [[BB8:%.*]]
; CHECK-NEXT:      i32 2, label [[BB0_LOOPEXIT]]
; CHECK-NEXT:    ]
; CHECK:       BB7.jt2:
; CHECK-NEXT:    [[D_PROMOTED4_JT2]] = phi i16 [ [[D_PROMOTED5_JT2]], [[BB1_JT2]] ], [ [[TMP8]], [[SPEC_SELECT_SI_UNFOLD_FALSE_JT2]] ]
; CHECK-NEXT:    [[TMP11:%.*]] = phi i16 [ [[TMP4]], [[BB1_JT2]] ], [ [[TMP8]], [[SPEC_SELECT_SI_UNFOLD_FALSE_JT2]] ]
; CHECK-NEXT:    [[DOT3_JT2:%.*]] = phi i32 [ [[DOT1_JT2]], [[BB1_JT2]] ], [ [[DOT1_SI_UNFOLD_PHI_JT2]], [[SPEC_SELECT_SI_UNFOLD_FALSE_JT2]] ]
; CHECK-NEXT:    br label [[BB0_LOOPEXIT]]
; CHECK:       BB1.backedge:
; CHECK-NEXT:    br label [[BB1]]
; CHECK:       BB8:
; CHECK-NEXT:    ret void
; CHECK:       BB9:
; CHECK-NEXT:    unreachable
;
  %1 = load i32, ptr @h, align 4
  %.not2 = icmp eq i32 %1, 0
  %. = select i1 %.not2, i32 0, i32 6
  %d.promoted3 = load i16, ptr @d, align 1
  br label %BB0

BB0.loopexit:                                     ; preds = %BB7
  br label %BB0

BB0:                                              ; preds = %BB0.loopexit, %0
  %d.promoted6 = phi i16 [ %d.promoted3, %0 ], [ %d.promoted4, %BB0.loopexit ]
  br label %BB1

BB1:                                              ; preds = %BB1.backedge, %BB0
  %d.promoted5 = phi i16 [ %d.promoted6, %BB0 ], [ %d.promoted4, %BB1.backedge ]
  %2 = phi i16 [ %d.promoted6, %BB0 ], [ %6, %BB1.backedge ]
  %.1 = phi i32 [ 2, %BB0 ], [ %.3, %BB1.backedge ]
  %3 = load volatile i32, ptr @f, align 4
  %.not = icmp eq i32 %3, 0
  br i1 %.not, label %BB7, label %BB2

BB2:                                              ; preds = %BB1
  %4 = add i16 %2, 1
  store i16 %4, ptr @d, align 2
  %5 = load volatile i64, ptr @g, align 8
  %.not1 = icmp eq i64 %5, 0
  %spec.select = select i1 %.not1, i32 %., i32 %.1
  br label %BB7

BB7:                                              ; preds = %BB2, %BB1
  %d.promoted4 = phi i16 [ %d.promoted5, %BB1 ], [ %4, %BB2 ]
  %6 = phi i16 [ %2, %BB1 ], [ %4, %BB2 ]
  %.3 = phi i32 [ %.1, %BB1 ], [ %spec.select, %BB2 ]
  switch i32 %.3, label %BB9 [
  i32 0, label %BB1.backedge
  i32 7, label %BB1.backedge
  i32 6, label %BB8
  i32 2, label %BB0.loopexit
  ]

BB1.backedge:                                     ; preds = %BB7, %BB7
  br label %BB1

BB8:                                              ; preds = %BB7
  ret void

BB9:                                              ; preds = %BB7
  unreachable
}


define void @pr106083_select_dead_uses() {
; CHECK-LABEL: @pr106083_select_dead_uses(
; CHECK-NEXT:    [[TMP1:%.*]] = load ptr, ptr @a, align 8
; CHECK-NEXT:    [[TMP2:%.*]] = load ptr, ptr @i, align 8
; CHECK-NEXT:    [[TMP3:%.*]] = load i64, ptr @c, align 8
; CHECK-NEXT:    [[DOTNOT3:%.*]] = icmp eq i64 [[TMP3]], 0
; CHECK-NEXT:    br i1 [[DOTNOT3]], label [[DOTLOOPEXIT6:%.*]], label [[SPEC_SELECT_SI_UNFOLD_FALSE:%.*]]
; CHECK:       .loopexit6.loopexit:
; CHECK-NEXT:    br label [[DOTLOOPEXIT6]]
; CHECK:       spec.select.si.unfold.false:
; CHECK-NEXT:    [[DOTSI_UNFOLD_PHI:%.*]] = phi i32 [ 2, [[TMP0:%.*]] ]
; CHECK-NEXT:    br label [[DOTLOOPEXIT6]]
; CHECK:       .loopexit6:
; CHECK-NEXT:    [[SPEC_SELECT_SI_UNFOLD_PHI:%.*]] = phi i32 [ [[SPEC_SELECT_SI_UNFOLD_PHI]], [[DOTLOOPEXIT6_LOOPEXIT:%.*]] ], [ 0, [[TMP0]] ], [ [[DOTSI_UNFOLD_PHI]], [[SPEC_SELECT_SI_UNFOLD_FALSE]] ]
; CHECK-NEXT:    br label [[TMP6:%.*]]
; CHECK:       4:
; CHECK-NEXT:    [[DOT1:%.*]] = phi i32 [ [[DOT21:%.*]], [[DOTBACKEDGE:%.*]] ]
; CHECK-NEXT:    [[TMP5:%.*]] = load i32, ptr [[TMP1]], align 4
; CHECK-NEXT:    [[DOTNOT:%.*]] = icmp eq i32 [[TMP5]], 0
; CHECK-NEXT:    br i1 [[DOTNOT]], label [[SELECT_UNFOLD_JT0:%.*]], label [[TMP8:%.*]]
; CHECK:       6:
; CHECK-NEXT:    [[DOT1_JT2:%.*]] = phi i32 [ 2, [[DOTLOOPEXIT6]] ]
; CHECK-NEXT:    [[TMP7:%.*]] = load i32, ptr [[TMP1]], align 4
; CHECK-NEXT:    [[DOTNOT_JT2:%.*]] = icmp eq i32 [[TMP7]], 0
; CHECK-NEXT:    br i1 [[DOTNOT_JT2]], label [[SELECT_UNFOLD_JT0]], label [[TMP10:%.*]]
; CHECK:       8:
; CHECK-NEXT:    [[TMP9:%.*]] = load i32, ptr [[TMP2]], align 4
; CHECK-NEXT:    [[DOTNOT2:%.*]] = icmp eq i32 [[TMP9]], 0
; CHECK-NEXT:    br i1 [[DOTNOT2]], label [[SELECT_UNFOLD:%.*]], label [[SPEC_SELECT7_SI_UNFOLD_FALSE:%.*]]
; CHECK:       10:
; CHECK-NEXT:    [[TMP11:%.*]] = load i32, ptr [[TMP2]], align 4
; CHECK-NEXT:    [[DOTNOT2_JT2:%.*]] = icmp eq i32 [[TMP11]], 0
; CHECK-NEXT:    br i1 [[DOTNOT2_JT2]], label [[SELECT_UNFOLD]], label [[SPEC_SELECT7_SI_UNFOLD_FALSE_JT2:%.*]]
; CHECK:       spec.select7.si.unfold.false:
; CHECK-NEXT:    [[DOT1_SI_UNFOLD_PHI:%.*]] = phi i32 [ [[DOT1]], [[TMP8]] ]
; CHECK-NEXT:    br label [[SELECT_UNFOLD]]
; CHECK:       spec.select7.si.unfold.false.jt2:
; CHECK-NEXT:    [[DOT1_SI_UNFOLD_PHI_JT2:%.*]] = phi i32 [ [[DOT1_JT2]], [[TMP10]] ]
; CHECK-NEXT:    br label [[SELECT_UNFOLD_JT2:%.*]]
; CHECK:       select.unfold:
; CHECK-NEXT:    [[DOT2:%.*]] = phi i32 [ [[SPEC_SELECT_SI_UNFOLD_PHI]], [[TMP8]] ], [ [[DOT1_SI_UNFOLD_PHI]], [[SPEC_SELECT7_SI_UNFOLD_FALSE]] ], [ [[SPEC_SELECT_SI_UNFOLD_PHI]], [[TMP10]] ]
; CHECK-NEXT:    switch i32 [[DOT2]], label [[TMP12:%.*]] [
; CHECK-NEXT:      i32 0, label [[DOTPREHEADER_PREHEADER:%.*]]
; CHECK-NEXT:      i32 2, label [[DOTLOOPEXIT6_LOOPEXIT]]
; CHECK-NEXT:    ]
; CHECK:       select.unfold.jt2:
; CHECK-NEXT:    [[DOT2_JT2:%.*]] = phi i32 [ [[DOT1_SI_UNFOLD_PHI_JT2]], [[SPEC_SELECT7_SI_UNFOLD_FALSE_JT2]] ]
; CHECK-NEXT:    br label [[DOTLOOPEXIT6_LOOPEXIT]]
; CHECK:       select.unfold.jt0:
; CHECK-NEXT:    [[DOT2_JT0:%.*]] = phi i32 [ 0, [[TMP4:%.*]] ], [ 0, [[TMP6]] ]
; CHECK-NEXT:    br label [[DOTPREHEADER_PREHEADER]]
; CHECK:       .preheader.preheader:
; CHECK-NEXT:    [[DOT21]] = phi i32 [ [[DOT2_JT0]], [[SELECT_UNFOLD_JT0]] ], [ [[DOT2]], [[SELECT_UNFOLD]] ]
; CHECK-NEXT:    store i32 0, ptr @b, align 4
; CHECK-NEXT:    br label [[DOTBACKEDGE]]
; CHECK:       .backedge:
; CHECK-NEXT:    br label [[TMP4]]
; CHECK:       12:
; CHECK-NEXT:    unreachable
;
  %1 = load ptr, ptr @a, align 8
  %2 = load ptr, ptr @i, align 8
  %3 = load i64, ptr @c, align 8
  %.not3 = icmp eq i64 %3, 0
  %spec.select = select i1 %.not3, i32 0, i32 2
  br label %.loopexit6

.loopexit6.loopexit:                              ; preds = %select.unfold
  br label %.loopexit6

.loopexit6:                                       ; preds = %.loopexit6.loopexit, %0
  br label %4

4:                                                ; preds = %.backedge, %.loopexit6
  %.1 = phi i32 [ 2, %.loopexit6 ], [ %.2, %.backedge ]
  %5 = load i32, ptr %1, align 4
  %.not = icmp eq i32 %5, 0
  br i1 %.not, label %select.unfold, label %6

6:                                                ; preds = %4
  %7 = load i32, ptr %2, align 4
  %.not2 = icmp eq i32 %7, 0
  %spec.select7 = select i1 %.not2, i32 %spec.select, i32 %.1
  br label %select.unfold

select.unfold:                                    ; preds = %6, %4
  %.2 = phi i32 [ 0, %4 ], [ %spec.select7, %6 ]
  switch i32 %.2, label %8 [
  i32 0, label %.preheader.preheader
  i32 2, label %.loopexit6.loopexit
  ]

.preheader.preheader:                             ; preds = %select.unfold
  store i32 0, ptr @b, align 4
  br label %.backedge

.backedge:                                        ; preds = %.preheader.preheader
  br label %4

8:                                                ; preds = %select.unfold
  unreachable
}
