; NOTE: Assertions have been autogenerated by utils/update_test_checks.py
; RUN: opt -O1 -S < %s | FileCheck %s

; This is a very convoluted way to write an icmp ule, which comes about by
; matching against a three-way comparison result.
define i1 @ule(i32 %a, i32 %b) {
; CHECK-LABEL: @ule(
; CHECK-NEXT:  start:
; CHECK-NEXT:    [[CMP1:%.*]] = icmp eq i32 [[A:%.*]], [[B:%.*]]
; CHECK-NEXT:    [[SEL1:%.*]] = tail call i64 @llvm.ucmp.i64.i32(i32 [[A]], i32 [[B]])
; CHECK-NEXT:    [[TMP0:%.*]] = add nsw i64 [[SEL1]], 1
; CHECK-NEXT:    [[SWITCH_SELECTCMP1:%.*]] = icmp ult i64 [[TMP0]], 2
; CHECK-NEXT:    [[SWITCH_SELECTCMP:%.*]] = select i1 [[CMP1]], i1 true, i1 [[SWITCH_SELECTCMP1]]
; CHECK-NEXT:    ret i1 [[SWITCH_SELECTCMP]]
;
start:
  %cmp1 = icmp eq i32 %a, %b
  %cmp2 = icmp ult i32 %a, %b
  %cmp3 = icmp ne i32 %a, %b
  %zext = zext i1 %cmp3 to i64
  %sel1 = select i1 %cmp2, i64 -1, i64 %zext
  %sel2 = select i1 %cmp1, i64 0, i64 %sel1
  switch i64 %sel2, label %exit [
  i64 -1, label %bb
  i64 0, label %bb
  ]

bb:
  br label %exit

exit:
  %res = phi i1 [ true, %bb ], [ false, %start ]
  ret i1 %res
}
