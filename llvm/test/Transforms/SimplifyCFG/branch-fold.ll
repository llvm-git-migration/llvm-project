; NOTE: Assertions have been autogenerated by utils/update_test_checks.py
; RUN: opt < %s -passes=simplifycfg -simplifycfg-require-and-preserve-domtree=1 -S | FileCheck %s

define void @test(ptr %P, ptr %Q, i1 %A, i1 %B) {
; CHECK-LABEL: @test(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[A_NOT:%.*]] = xor i1 [[A:%.*]], true
; CHECK-NEXT:    [[BRMERGE:%.*]] = select i1 [[A_NOT]], i1 true, i1 [[B:%.*]]
; CHECK-NEXT:    br i1 [[BRMERGE]], label [[B:%.*]], label [[COMMON_RET:%.*]]
; CHECK:       common.ret:
; CHECK-NEXT:    ret void
; CHECK:       b:
; CHECK-NEXT:    store i32 123, ptr [[P:%.*]], align 4
; CHECK-NEXT:    br label [[COMMON_RET]]
;

entry:
  br i1 %A, label %a, label %b
a:
  br i1 %B, label %b, label %c
b:
  store i32 123, ptr %P
  ret void
c:
  ret void
}

; rdar://10554090
define zeroext i1 @test2(i64 %i0, i64 %i1) nounwind uwtable readonly ssp {
; CHECK-LABEL: @test2(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[AND_I_I:%.*]] = and i64 [[I0:%.*]], 281474976710655
; CHECK-NEXT:    [[AND_I11_I:%.*]] = and i64 [[I1:%.*]], 281474976710655
; CHECK-NEXT:    [[OR_COND:%.*]] = icmp eq i64 [[AND_I_I]], [[AND_I11_I]]
; CHECK-NEXT:    br i1 [[OR_COND]], label [[C:%.*]], label [[A:%.*]]
; CHECK:       a:
; CHECK-NEXT:    [[SHR_I4_I:%.*]] = lshr i64 [[I0]], 48
; CHECK-NEXT:    [[AND_I5_I:%.*]] = and i64 [[SHR_I4_I]], 32767
; CHECK-NEXT:    [[SHR_I_I:%.*]] = lshr i64 [[I1]], 48
; CHECK-NEXT:    [[AND_I2_I:%.*]] = and i64 [[SHR_I_I]], 32767
; CHECK-NEXT:    [[CMP9_I:%.*]] = icmp ult i64 [[AND_I5_I]], [[AND_I2_I]]
; CHECK-NEXT:    br i1 [[CMP9_I]], label [[C]], label [[B:%.*]]
; CHECK:       b:
; CHECK-NEXT:    [[SHR_I13_I9:%.*]] = lshr i64 [[I1]], 48
; CHECK-NEXT:    [[AND_I14_I10:%.*]] = and i64 [[SHR_I13_I9]], 32767
; CHECK-NEXT:    [[SHR_I_I11:%.*]] = lshr i64 [[I0]], 48
; CHECK-NEXT:    [[AND_I11_I12:%.*]] = and i64 [[SHR_I_I11]], 32767
; CHECK-NEXT:    [[PHITMP:%.*]] = icmp uge i64 [[AND_I14_I10]], [[AND_I11_I12]]
; CHECK-NEXT:    br label [[C]]
; CHECK:       c:
; CHECK-NEXT:    [[O2:%.*]] = phi i1 [ false, [[A]] ], [ [[PHITMP]], [[B]] ], [ false, [[ENTRY:%.*]] ]
; CHECK-NEXT:    ret i1 [[O2]]
;
entry:
  %and.i.i = and i64 %i0, 281474976710655
  %and.i11.i = and i64 %i1, 281474976710655
  %or.cond = icmp eq i64 %and.i.i, %and.i11.i
  br i1 %or.cond, label %c, label %a

a:
  %shr.i4.i = lshr i64 %i0, 48
  %and.i5.i = and i64 %shr.i4.i, 32767
  %shr.i.i = lshr i64 %i1, 48
  %and.i2.i = and i64 %shr.i.i, 32767
  %cmp9.i = icmp ult i64 %and.i5.i, %and.i2.i
  br i1 %cmp9.i, label %c, label %b

b:
  %shr.i13.i9 = lshr i64 %i1, 48
  %and.i14.i10 = and i64 %shr.i13.i9, 32767
  %shr.i.i11 = lshr i64 %i0, 48
  %and.i11.i12 = and i64 %shr.i.i11, 32767
  %phitmp = icmp uge i64 %and.i14.i10, %and.i11.i12
  br label %c

c:
  %o2 = phi i1 [ false, %a ], [ %phitmp, %b ], [ false, %entry ]
  ret i1 %o2
}

; PR13180
define void @pr13180(i8 %p) {
; CHECK-LABEL: @pr13180(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    unreachable
;
entry:
  %tobool = icmp eq i8 %p, 0
  br i1 %tobool, label %cond.false, label %cond.true

cond.true:                                        ; preds = %entry
  br label %cond.end

cond.false:                                       ; preds = %entry
  %phitmp = icmp eq i8 %p, 0
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i1 [ undef, %cond.true ], [ %phitmp, %cond.false ]
  unreachable
}

declare void @foo()
define void @test3() {
; CHECK-LABEL: @test3(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    call void @foo()
; CHECK-NEXT:    ret void
;
entry:
  br i1 0, label %bb0, label %bb0

bb0:
  call void @foo()
  ret void
}

define i8 @common_pred(i8 noundef %arg, i1 %c1, i1 %c2) {
; CHECK-LABEL: @common_pred(
; CHECK-NEXT:  Pred:
; CHECK-NEXT:    call void @dummy()
; CHECK-NEXT:    br i1 [[C1:%.*]], label [[COMMONPRED:%.*]], label [[SUCC:%.*]]
; CHECK:       CommonPred:
; CHECK-NEXT:    call void @dummy()
; CHECK-NEXT:    [[SPEC_SELECT:%.*]] = select i1 [[C2:%.*]], i8 4, i8 1
; CHECK-NEXT:    br label [[SUCC]]
; CHECK:       Succ:
; CHECK-NEXT:    [[PHI2:%.*]] = phi i8 [ 0, [[PRED:%.*]] ], [ [[SPEC_SELECT]], [[COMMONPRED]] ]
; CHECK-NEXT:    ret i8 [[PHI2]]
;
Pred:
call void @dummy()
  br i1 %c1, label %CommonPred, label %BB

CommonPred:
call void @dummy()
  br i1 %c2, label %Succ, label %BB

BB:
  %phi1 = phi i8 [ 0, %Pred ], [1, %CommonPred]
  br label %Succ

Succ:
  %phi2 = phi i8 [ %phi1, %BB ], [ 4, %CommonPred ]
  ret i8 %phi2
}

declare void @dummy()

define void @fold_nested_branch1(i1 %cond1, i1 %cond2) {
; CHECK-LABEL: @fold_nested_branch1(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    br i1 [[COND1:%.*]], label [[BB1:%.*]], label [[BB2:%.*]]
; CHECK:       bb1:
; CHECK-NEXT:    br i1 [[COND2:%.*]], label [[BB3:%.*]], label [[BB4:%.*]]
; CHECK:       bb2:
; CHECK-NEXT:    br i1 [[COND2]], label [[BB4]], label [[BB3]]
; CHECK:       common.ret:
; CHECK-NEXT:    ret void
; CHECK:       bb3:
; CHECK-NEXT:    call void @sideeffect1()
; CHECK-NEXT:    br label [[COMMON_RET:%.*]]
; CHECK:       bb4:
; CHECK-NEXT:    call void @sideeffect2()
; CHECK-NEXT:    br label [[COMMON_RET]]
;
entry:
  br i1 %cond1, label %bb1, label %bb2

bb1:
  br i1 %cond2, label %bb3, label %bb4

bb2:
  br i1 %cond2, label %bb4, label %bb3

bb3:
  call void @sideeffect1()
  ret void

bb4:
  call void @sideeffect2()
  ret void
}

define void @fold_nested_branch2(i1 %cond1, i1 %cond2) {
; CHECK-LABEL: @fold_nested_branch2(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    br i1 [[COND1:%.*]], label [[BB1:%.*]], label [[BB2:%.*]]
; CHECK:       bb1:
; CHECK-NEXT:    br i1 [[COND2:%.*]], label [[BB3:%.*]], label [[COMMON_RET:%.*]]
; CHECK:       bb2:
; CHECK-NEXT:    br i1 [[COND2]], label [[BB4:%.*]], label [[BB3]]
; CHECK:       common.ret:
; CHECK-NEXT:    ret void
; CHECK:       bb3:
; CHECK-NEXT:    call void @sideeffect1()
; CHECK-NEXT:    br label [[COMMON_RET]]
; CHECK:       bb4:
; CHECK-NEXT:    call void @sideeffect2()
; CHECK-NEXT:    br label [[COMMON_RET]]
;
entry:
  br i1 %cond1, label %bb1, label %bb2

bb1:
  br i1 %cond2, label %bb3, label %bb5

bb2:
  br i1 %cond2, label %bb4, label %bb3

bb3:
  call void @sideeffect1()
  ret void

bb4:
  call void @sideeffect2()
  ret void

bb5:
  ret void
}

define void @fold_nested_branch3(i1 %cond1, i1 %cond2, i1 %cond3) {
; CHECK-LABEL: @fold_nested_branch3(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    br i1 [[COND1:%.*]], label [[BB1:%.*]], label [[BB2:%.*]]
; CHECK:       bb1:
; CHECK-NEXT:    br i1 [[COND2:%.*]], label [[BB3:%.*]], label [[BB4:%.*]]
; CHECK:       bb2:
; CHECK-NEXT:    br i1 [[COND3:%.*]], label [[BB4]], label [[BB3]]
; CHECK:       common.ret:
; CHECK-NEXT:    ret void
; CHECK:       bb3:
; CHECK-NEXT:    call void @sideeffect1()
; CHECK-NEXT:    br label [[COMMON_RET:%.*]]
; CHECK:       bb4:
; CHECK-NEXT:    call void @sideeffect2()
; CHECK-NEXT:    br label [[COMMON_RET]]
;
entry:
  br i1 %cond1, label %bb1, label %bb2

bb1:
  br i1 %cond2, label %bb3, label %bb4

bb2:
  br i1 %cond3, label %bb4, label %bb3

bb3:
  call void @sideeffect1()
  ret void

bb4:
  call void @sideeffect2()
  ret void
}

define void @fold_nested_branch4(i1 %cond1, i1 %cond2) {
; CHECK-LABEL: @fold_nested_branch4(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    br i1 [[COND1:%.*]], label [[BB1:%.*]], label [[BB2:%.*]]
; CHECK:       bb1:
; CHECK-NEXT:    call void @sideeffect1()
; CHECK-NEXT:    br i1 [[COND2:%.*]], label [[BB3:%.*]], label [[BB4:%.*]]
; CHECK:       bb2:
; CHECK-NEXT:    br i1 [[COND2]], label [[BB4]], label [[BB3]]
; CHECK:       common.ret:
; CHECK-NEXT:    ret void
; CHECK:       bb3:
; CHECK-NEXT:    call void @sideeffect1()
; CHECK-NEXT:    br label [[COMMON_RET:%.*]]
; CHECK:       bb4:
; CHECK-NEXT:    call void @sideeffect2()
; CHECK-NEXT:    br label [[COMMON_RET]]
;
entry:
  br i1 %cond1, label %bb1, label %bb2

bb1:
  call void @sideeffect1()
  br i1 %cond2, label %bb3, label %bb4

bb2:
  br i1 %cond2, label %bb4, label %bb3

bb3:
  call void @sideeffect1()
  ret void

bb4:
  call void @sideeffect2()
  ret void
}

define i32 @fold_nested_branch5(i1 %cond1, i1 %cond2, i32 %x) {
; CHECK-LABEL: @fold_nested_branch5(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    br i1 [[COND1:%.*]], label [[BB1:%.*]], label [[BB2:%.*]]
; CHECK:       bb1:
; CHECK-NEXT:    br i1 [[COND2:%.*]], label [[COMMON_RET:%.*]], label [[BB4:%.*]]
; CHECK:       bb2:
; CHECK-NEXT:    br i1 [[COND2]], label [[BB4]], label [[COMMON_RET]]
; CHECK:       common.ret:
; CHECK-NEXT:    [[COMMON_RET_OP:%.*]] = phi i32 [ 0, [[BB4]] ], [ 0, [[BB1]] ], [ [[X:%.*]], [[BB2]] ]
; CHECK-NEXT:    ret i32 [[COMMON_RET_OP]]
; CHECK:       bb4:
; CHECK-NEXT:    call void @sideeffect2()
; CHECK-NEXT:    br label [[COMMON_RET]]
;
entry:
  br i1 %cond1, label %bb1, label %bb2

bb1:
  br i1 %cond2, label %bb3, label %bb4

bb2:
  br i1 %cond2, label %bb4, label %bb3

bb3:
  %ret = phi i32 [ 0, %bb1 ], [ %x, %bb2 ]
  ret i32 %ret

bb4:
  call void @sideeffect2()
  ret i32 0
}

define void @fold_nested_branch6(i1 %cond1, i1 %cond2) {
; CHECK-LABEL: @fold_nested_branch6(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[COND1_NOT:%.*]] = xor i1 [[COND1:%.*]], true
; CHECK-NEXT:    [[BRMERGE:%.*]] = select i1 [[COND1_NOT]], i1 true, i1 [[COND2:%.*]]
; CHECK-NEXT:    br i1 [[BRMERGE]], label [[BB3:%.*]], label [[BB4:%.*]]
; CHECK:       common.ret:
; CHECK-NEXT:    ret void
; CHECK:       bb3:
; CHECK-NEXT:    call void @sideeffect1()
; CHECK-NEXT:    br label [[COMMON_RET:%.*]]
; CHECK:       bb4:
; CHECK-NEXT:    call void @sideeffect2()
; CHECK-NEXT:    br label [[COMMON_RET]]
;
entry:
  br i1 %cond1, label %bb1, label %bb2

bb1:
  br i1 %cond2, label %bb3, label %bb4

bb2:
  br i1 %cond2, label %bb1, label %bb3

bb3:
  call void @sideeffect1()
  ret void

bb4:
  call void @sideeffect2()
  ret void
}

define void @fold_nested_branch7(i1 %cond1, i1 %cond2) {
; CHECK-LABEL: @fold_nested_branch7(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    br label [[BB0:%.*]]
; CHECK:       bb0:
; CHECK-NEXT:    br i1 [[COND1:%.*]], label [[BB1:%.*]], label [[BB2:%.*]]
; CHECK:       bb1:
; CHECK-NEXT:    br i1 [[COND2:%.*]], label [[BB3:%.*]], label [[BB4:%.*]]
; CHECK:       bb2:
; CHECK-NEXT:    br i1 [[COND2]], label [[BB0]], label [[BB3]]
; CHECK:       common.ret:
; CHECK-NEXT:    ret void
; CHECK:       bb3:
; CHECK-NEXT:    call void @sideeffect1()
; CHECK-NEXT:    br label [[COMMON_RET:%.*]]
; CHECK:       bb4:
; CHECK-NEXT:    call void @sideeffect2()
; CHECK-NEXT:    br label [[COMMON_RET]]
;
entry:
  br label %bb0

bb0:
  br i1 %cond1, label %bb1, label %bb2

bb1:
  br i1 %cond2, label %bb3, label %bb4

bb2:
  br i1 %cond2, label %bb0, label %bb3

bb3:
  call void @sideeffect1()
  ret void

bb4:
  call void @sideeffect2()
  ret void
}

; freq(bb4) = 1 * 4 + 2 * 5 = 14
; freq(bb3) = 1 * 3 + 2 * 6 = 15
define void @fold_nested_branch_prof(i1 %cond1, i1 %cond2) {
; CHECK-LABEL: @fold_nested_branch_prof(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    br i1 [[COND1:%.*]], label [[BB1:%.*]], label [[BB2:%.*]], !prof [[PROF0:![0-9]+]]
; CHECK:       bb1:
; CHECK-NEXT:    br i1 [[COND2:%.*]], label [[BB3:%.*]], label [[BB4:%.*]], !prof [[PROF1:![0-9]+]]
; CHECK:       bb2:
; CHECK-NEXT:    br i1 [[COND2]], label [[BB4]], label [[BB3]], !prof [[PROF2:![0-9]+]]
; CHECK:       common.ret:
; CHECK-NEXT:    ret void
; CHECK:       bb3:
; CHECK-NEXT:    call void @sideeffect1()
; CHECK-NEXT:    br label [[COMMON_RET:%.*]]
; CHECK:       bb4:
; CHECK-NEXT:    call void @sideeffect2()
; CHECK-NEXT:    br label [[COMMON_RET]]
;
entry:
  br i1 %cond1, label %bb1, label %bb2, !prof !0 ; 1:2

bb1:
  br i1 %cond2, label %bb3, label %bb4, !prof !1 ; 3:4

bb2:
  br i1 %cond2, label %bb4, label %bb3, !prof !2 ; 5:6

bb3:
  call void @sideeffect1()
  ret void

bb4:
  call void @sideeffect2()
  ret void
}

!0 = !{!"branch_weights", i32 1, i32 2}
!1 = !{!"branch_weights", i32 3, i32 4}
!2 = !{!"branch_weights", i32 5, i32 6}

declare void @sideeffect1()
declare void @sideeffect2()
