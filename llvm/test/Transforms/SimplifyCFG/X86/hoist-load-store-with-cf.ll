; NOTE: Assertions have been autogenerated by utils/update_test_checks.py
; RUN: opt < %s -mtriple=x86_64 -mattr=+cf -passes=simplifycfg -simplifycfg-require-and-preserve-domtree=1 -S -simplifycfg-hoist-loads-stores-with-cond-faulting=true | FileCheck %s

;; The redundant bitcast + insertelement will be opimized out in instcombine pass.
define void @basic(i32 %a, ptr %b, ptr %p, ptr %q) {
; CHECK-LABEL: @basic(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[COND:%.*]] = icmp eq i32 [[A:%.*]], 0
; CHECK-NEXT:    [[TMP0:%.*]] = insertelement <1 x i1> undef, i1 [[COND]], i64 0
; CHECK-NEXT:    [[TMP1:%.*]] = call <1 x i32> @llvm.masked.load.v1i32.p0(ptr [[B:%.*]], i32 4, <1 x i1> [[TMP0]], <1 x i32> poison), !dbg [[DBG8:![0-9]+]]
; CHECK-NEXT:    [[TMP2:%.*]] = bitcast <1 x i32> [[TMP1]] to i32
; CHECK-NEXT:    [[TMP3:%.*]] = insertelement <1 x i32> undef, i32 [[TMP2]], i64 0
; CHECK-NEXT:    call void @llvm.masked.store.v1i32.p0(<1 x i32> [[TMP3]], ptr [[P:%.*]], i32 4, <1 x i1> [[TMP0]])
; CHECK-NEXT:    [[TMP4:%.*]] = xor i1 [[COND]], true
; CHECK-NEXT:    [[TMP5:%.*]] = insertelement <1 x i1> undef, i1 [[TMP4]], i64 0
; CHECK-NEXT:    call void @llvm.masked.store.v1i64.p0(<1 x i64> <i64 1>, ptr [[P]], i32 8, <1 x i1> [[TMP5]]), !dbg [[DBG12:![0-9]+]]
; CHECK-NEXT:    call void @llvm.masked.store.v1i16.p0(<1 x i16> <i16 2>, ptr [[Q:%.*]], i32 8, <1 x i1> [[TMP5]]), !dbg [[DBG12]]
; CHECK-NEXT:    ret void
;
entry:
  %cond = icmp eq i32 %a, 0
  br i1 %cond, label %if.true, label %if.false

if.false:
  store i64 1, ptr %p, align 8, !dbg !8
  store i16 2, ptr %q, align 8, !dbg !8
  br label %if.end

if.true:
  %0 = load i32, ptr %b, align 4,  !dbg !9
  store i32 %0, ptr %p, align 4
  br label %if.end

if.end:
  ret void
}

define void @not_supported_type(i8 %a, ptr %b, ptr %p, ptr %q) {
; CHECK-LABEL: @not_supported_type(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[COND:%.*]] = icmp eq i8 [[A:%.*]], 0
; CHECK-NEXT:    br i1 [[COND]], label [[IF_TRUE:%.*]], label [[IF_FALSE:%.*]]
; CHECK:       if.false:
; CHECK-NEXT:    store i8 1, ptr [[Q:%.*]], align 1
; CHECK-NEXT:    br label [[IF_END:%.*]]
; CHECK:       if.true:
; CHECK-NEXT:    [[TMP0:%.*]] = load i8, ptr [[B:%.*]], align 1
; CHECK-NEXT:    store i8 [[TMP0]], ptr [[P:%.*]], align 1
; CHECK-NEXT:    br label [[IF_END]]
; CHECK:       if.end:
; CHECK-NEXT:    ret void
;
entry:
  %cond = icmp eq i8 %a, 0
  br i1 %cond, label %if.true, label %if.false

if.false:
  store i8 1, ptr %q
  br label %if.end

if.true:
  %0 = load i8, ptr %b
  store i8 %0, ptr %p
  br label %if.end

if.end:
  ret void
}

define void @not_br_terminator(i32 %a, ptr %b, ptr %p, ptr %q) {
; CHECK-LABEL: @not_br_terminator(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    switch i32 [[A:%.*]], label [[IF_END:%.*]] [
; CHECK-NEXT:      i32 1, label [[IF_FALSE:%.*]]
; CHECK-NEXT:      i32 2, label [[IF_TRUE:%.*]]
; CHECK-NEXT:    ]
; CHECK:       if.false:
; CHECK-NEXT:    store i32 1, ptr [[Q:%.*]], align 4
; CHECK-NEXT:    br label [[IF_END]]
; CHECK:       if.true:
; CHECK-NEXT:    [[TMP0:%.*]] = load i32, ptr [[B:%.*]], align 4
; CHECK-NEXT:    store i32 [[TMP0]], ptr [[P:%.*]], align 4
; CHECK-NEXT:    br label [[IF_FALSE]]
; CHECK:       if.end:
; CHECK-NEXT:    ret void
;
entry:
  switch i32 %a, label %if.end [
  i32 1, label %if.false
  i32 2, label %if.true
  ]

if.false:
  store i32 1, ptr %q, align 4
  br label %if.end

if.true:
  %0 = load i32, ptr %b, align 4
  store i32 %0, ptr %p, align 4
  br label %if.false

if.end:
  ret void
}

define void @not_single_predecessor(i32 %a, ptr %b, ptr %p, ptr %q) {
; CHECK-LABEL: @not_single_predecessor(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[COND:%.*]] = icmp eq i32 [[A:%.*]], 0
; CHECK-NEXT:    br i1 [[COND]], label [[IF_TRUE:%.*]], label [[IF_FALSE:%.*]]
; CHECK:       if.false:
; CHECK-NEXT:    store i32 1, ptr [[Q:%.*]], align 4
; CHECK-NEXT:    ret void
; CHECK:       if.true:
; CHECK-NEXT:    [[TMP0:%.*]] = load i32, ptr [[B:%.*]], align 4
; CHECK-NEXT:    store i32 [[TMP0]], ptr [[P:%.*]], align 4
; CHECK-NEXT:    br label [[IF_FALSE]]
;
entry:
  %cond = icmp eq i32 %a, 0
  br i1 %cond, label %if.true, label %if.false

if.false:
  store i32 1, ptr %q, align 4
  br label %if.end

if.true:
  %0 = load i32, ptr %b, align 4
  store i32 %0, ptr %p, align 4
  br label %if.false

if.end:
  ret void
}

define void @not_simple(i32 %a, ptr %b, ptr %p, ptr %q) {
; CHECK-LABEL: @not_simple(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[COND:%.*]] = icmp eq i32 [[A:%.*]], 0
; CHECK-NEXT:    br i1 [[COND]], label [[IF_TRUE:%.*]], label [[IF_FALSE:%.*]]
; CHECK:       if.false:
; CHECK-NEXT:    store atomic i32 1, ptr [[Q:%.*]] seq_cst, align 4
; CHECK-NEXT:    br label [[IF_END:%.*]]
; CHECK:       if.true:
; CHECK-NEXT:    [[TMP0:%.*]] = load i32, ptr [[B:%.*]], align 4
; CHECK-NEXT:    store i32 [[TMP0]], ptr [[P:%.*]], align 4
; CHECK-NEXT:    br label [[IF_END]]
; CHECK:       if.end:
; CHECK-NEXT:    ret void
;
entry:
  %cond = icmp eq i32 %a, 0
  br i1 %cond, label %if.true, label %if.false

if.false:
  store atomic i32 1, ptr %q seq_cst, align 4
  br label %if.end

if.true:
  %0 = load i32, ptr %b, align 4
  store i32 %0, ptr %p, align 4
  br label %if.end

if.end:
  ret void
}

define void @not_hoistable_store(i32 %a, ptr %b, ptr %p, ptr %q) {
; CHECK-LABEL: @not_hoistable_store(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[COND:%.*]] = icmp eq i32 [[A:%.*]], 0
; CHECK-NEXT:    br i1 [[COND]], label [[IF_TRUE:%.*]], label [[IF_FALSE:%.*]]
; CHECK:       if.false:
; CHECK-NEXT:    store i32 1, ptr [[Q:%.*]], align 4
; CHECK-NEXT:    br label [[IF_END:%.*]]
; CHECK:       if.true:
; CHECK-NEXT:    [[TMP0:%.*]] = load i32, ptr [[B:%.*]], align 4
; CHECK-NEXT:    store volatile i32 [[TMP0]], ptr [[P:%.*]], align 4
; CHECK-NEXT:    br label [[IF_END]]
; CHECK:       if.end:
; CHECK-NEXT:    ret void
;
entry:
  %cond = icmp eq i32 %a, 0
  br i1 %cond, label %if.true, label %if.false

if.false:
  store i32 1, ptr %q, align 4
  br label %if.end

if.true:
  %0 = load i32, ptr %b, align 4
  store volatile i32 %0, ptr %p, align 4
  br label %if.end

if.end:
  ret void
}

define void @not_hoistable_sideeffect(i32 %a, ptr %b, ptr %p, ptr %q) {
; CHECK-LABEL: @not_hoistable_sideeffect(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[COND:%.*]] = icmp eq i32 [[A:%.*]], 0
; CHECK-NEXT:    br i1 [[COND]], label [[IF_TRUE:%.*]], label [[IF_FALSE:%.*]]
; CHECK:       if.false:
; CHECK-NEXT:    store i32 1, ptr [[Q:%.*]], align 4
; CHECK-NEXT:    br label [[IF_END:%.*]]
; CHECK:       if.true:
; CHECK-NEXT:    [[TMP0:%.*]] = load i32, ptr [[B:%.*]], align 4
; CHECK-NEXT:    [[RMW:%.*]] = atomicrmw xchg ptr [[Q]], double 4.000000e+00 seq_cst, align 8
; CHECK-NEXT:    store i32 [[TMP0]], ptr [[P:%.*]], align 4
; CHECK-NEXT:    br label [[IF_END]]
; CHECK:       if.end:
; CHECK-NEXT:    ret void
;
entry:
  %cond = icmp eq i32 %a, 0
  br i1 %cond, label %if.true, label %if.false

if.false:
  store i32 1, ptr %q, align 4
  br label %if.end

if.true:
  %0 = load i32, ptr %b, align 4
  %rmw= atomicrmw xchg ptr %q, double 4.0 seq_cst
  store i32 %0, ptr %p, align 4
  br label %if.end

if.end:
  ret void
}

define void @not_ops_dominate_br(i32 %a, ptr %b, ptr %p, ptr %q) {
; CHECK-LABEL: @not_ops_dominate_br(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[COND:%.*]] = icmp eq i32 [[A:%.*]], 0
; CHECK-NEXT:    br i1 [[COND]], label [[IF_TRUE:%.*]], label [[IF_FALSE:%.*]]
; CHECK:       if.false:
; CHECK-NEXT:    [[ADD:%.*]] = add i32 [[A]], 2
; CHECK-NEXT:    store i32 [[ADD]], ptr [[Q:%.*]], align 4
; CHECK-NEXT:    br label [[IF_END:%.*]]
; CHECK:       if.true:
; CHECK-NEXT:    [[TMP0:%.*]] = load i32, ptr [[B:%.*]], align 4
; CHECK-NEXT:    store i32 [[TMP0]], ptr [[P:%.*]], align 4
; CHECK-NEXT:    br label [[IF_END]]
; CHECK:       if.end:
; CHECK-NEXT:    ret void
;
entry:
  %cond = icmp eq i32 %a, 0
  br i1 %cond, label %if.true, label %if.false

if.false:
  %add = add i32 %a, 2
  store i32 %add, ptr %q, align 4
  br label %if.end

if.true:
  %1 = load i32, ptr %b, align 4
  store i32 %1, ptr %p, align 4
  br label %if.end

if.end:
  ret void
}

define void @load_skip_memory_read(i32 %a, ptr %b, ptr %p, ptr %q) {
; CHECK-LABEL: @load_skip_memory_read(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[COND:%.*]] = icmp eq i32 [[A:%.*]], 0
; CHECK-NEXT:    [[TMP0:%.*]] = insertelement <1 x i1> undef, i1 [[COND]], i64 0
; CHECK-NEXT:    [[TMP1:%.*]] = call <1 x i32> @llvm.masked.load.v1i32.p0(ptr [[B:%.*]], i32 4, <1 x i1> [[TMP0]], <1 x i32> poison)
; CHECK-NEXT:    [[TMP2:%.*]] = bitcast <1 x i32> [[TMP1]] to i32
; CHECK-NEXT:    [[TMP3:%.*]] = insertelement <1 x i32> undef, i32 [[TMP2]], i64 0
; CHECK-NEXT:    call void @llvm.masked.store.v1i32.p0(<1 x i32> [[TMP3]], ptr [[P:%.*]], i32 4, <1 x i1> [[TMP0]])
; CHECK-NEXT:    [[TMP4:%.*]] = xor i1 [[COND]], true
; CHECK-NEXT:    [[TMP5:%.*]] = insertelement <1 x i1> undef, i1 [[TMP4]], i64 0
; CHECK-NEXT:    [[TMP6:%.*]] = call <1 x i32> @llvm.masked.load.v1i32.p0(ptr [[Q:%.*]], i32 4, <1 x i1> [[TMP5]], <1 x i32> poison)
; CHECK-NEXT:    [[TMP7:%.*]] = bitcast <1 x i32> [[TMP6]] to i32
; CHECK-NEXT:    br i1 [[COND]], label [[IF_END:%.*]], label [[IF_FALSE:%.*]]
; CHECK:       if.false:
; CHECK-NEXT:    call void @read_memory_only()
; CHECK-NEXT:    br label [[IF_END]]
; CHECK:       if.end:
; CHECK-NEXT:    ret void
;
entry:
  %cond = icmp eq i32 %a, 0
  br i1 %cond, label %if.true, label %if.false

if.false:
  call void @read_memory_only()
  %0 = load i32, ptr %q, align 4
  br label %if.end

if.true:
  %1 = load i32, ptr %b, align 4
  store i32 %1, ptr %p, align 4
  br label %if.end

if.end:
  ret void
}

define void @not_store_skip_memory_read(i32 %a, ptr %b, ptr %p, ptr %q) {
; CHECK-LABEL: @not_store_skip_memory_read(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[COND:%.*]] = icmp eq i32 [[A:%.*]], 0
; CHECK-NEXT:    br i1 [[COND]], label [[IF_TRUE:%.*]], label [[IF_FALSE:%.*]]
; CHECK:       if.false:
; CHECK-NEXT:    call void @read_memory_only()
; CHECK-NEXT:    store i32 1, ptr [[Q:%.*]], align 4
; CHECK-NEXT:    br label [[IF_END:%.*]]
; CHECK:       if.true:
; CHECK-NEXT:    [[TMP0:%.*]] = load i32, ptr [[B:%.*]], align 4
; CHECK-NEXT:    store i32 [[TMP0]], ptr [[P:%.*]], align 4
; CHECK-NEXT:    br label [[IF_END]]
; CHECK:       if.end:
; CHECK-NEXT:    ret void
;
entry:
  %cond = icmp eq i32 %a, 0
  br i1 %cond, label %if.true, label %if.false

if.false:
  call void @read_memory_only()
  store i32 1, ptr %q, align 4
  br label %if.end

if.true:
  %1 = load i32, ptr %b, align 4
  store i32 %1, ptr %p, align 4
  br label %if.end

if.end:
  ret void
}

declare void @read_memory_only() readonly nounwind willreturn

!llvm.dbg.cu = !{!0}
!llvm.module.flags = !{!2, !3, !4, !5, !6, !7}

!0 = distinct !DICompileUnit(language: DW_LANG_C11, file: !1, producer: "clang", isOptimized: true, runtimeVersion: 0, emissionKind: LineTablesOnly, splitDebugInlining: false, nameTableKind: None)
!1 = !DIFile(filename: "test.c", directory: "/tmp")
!2 = !{i32 7, !"Dwarf Version", i32 5}
!3 = !{i32 2, !"Debug Info Version", i32 3}
!4 = !{i32 1, !"wchar_size", i32 4}
!5 = !{i32 8, !"PIC Level", i32 2}
!6 = !{i32 7, !"PIE Level", i32 2}
!7 = !{i32 7, !"uwtable", i32 2}
!8 = !DILocation(line: 1, column: 2, scope: !10)
!9 = !DILocation(line: 1, column: 3, scope: !10)
!10 = distinct !DISubprogram(name: "basic", scope: !1, file: !1, line: 1, type: !11, scopeLine: 1, flags: DIFlagPrototyped, unit: !0)
!11 = !DISubroutineType(types: !12)
!12 = !{}
