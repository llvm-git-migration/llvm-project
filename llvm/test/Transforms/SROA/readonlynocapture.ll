; NOTE: Assertions have been autogenerated by utils/update_test_checks.py
; RUN: opt < %s -passes=sroa -S | FileCheck %s

declare void @callee(ptr nocapture readonly %p)

define i32 @simple() {
; CHECK-LABEL: @simple(
; CHECK-NEXT:    [[A:%.*]] = alloca i32, align 4
; CHECK-NEXT:    store i32 0, ptr [[A]], align 4
; CHECK-NEXT:    call void @callee(ptr [[A]])
; CHECK-NEXT:    [[L1:%.*]] = load i32, ptr [[A]], align 4
; CHECK-NEXT:    ret i32 0
;
  %a = alloca i32
  store i32 0, ptr %a
  call void @callee(ptr %a)
  %l1 = load i32, ptr %a
  ret i32 %l1
}

define i32 @twoalloc() {
; CHECK-LABEL: @twoalloc(
; CHECK-NEXT:    [[A:%.*]] = alloca { i32, i32 }, align 8
; CHECK-NEXT:    store i32 0, ptr [[A]], align 4
; CHECK-NEXT:    [[B:%.*]] = getelementptr i32, ptr [[A]], i32 1
; CHECK-NEXT:    store i32 1, ptr [[B]], align 4
; CHECK-NEXT:    call void @callee(ptr [[A]])
; CHECK-NEXT:    [[L1:%.*]] = load i32, ptr [[A]], align 4
; CHECK-NEXT:    [[L2:%.*]] = load i32, ptr [[B]], align 4
; CHECK-NEXT:    ret i32 1
;
  %a = alloca {i32, i32}
  store i32 0, ptr %a
  %b = getelementptr i32, ptr %a, i32 1
  store i32 1, ptr %b
  call void @callee(ptr %a)
  %l1 = load i32, ptr %a
  %l2 = load i32, ptr %b
  ret i32 %l2
}

define i32 @twostore() {
; CHECK-LABEL: @twostore(
; CHECK-NEXT:    [[A:%.*]] = alloca i32, align 4
; CHECK-NEXT:    store i32 1, ptr [[A]], align 4
; CHECK-NEXT:    call void @callee(ptr [[A]])
; CHECK-NEXT:    store i32 2, ptr [[A]], align 4
; CHECK-NEXT:    [[L:%.*]] = load i32, ptr [[A]], align 4
; CHECK-NEXT:    ret i32 [[L]]
;
  %a = alloca i32
  store i32 1, ptr %a
  call void @callee(ptr %a)
  store i32 2, ptr %a
  %l = load i32, ptr %a
  ret i32 %l
}

define i32 @twoalloc_store64(i64 %x) {
; CHECK-LABEL: @twoalloc_store64(
; CHECK-NEXT:    [[A:%.*]] = alloca i64, align 8
; CHECK-NEXT:    store i64 [[X:%.*]], ptr [[A]], align 4
; CHECK-NEXT:    call void @callee(ptr [[A]])
; CHECK-NEXT:    [[L1:%.*]] = load i32, ptr [[A]], align 4
; CHECK-NEXT:    [[B:%.*]] = getelementptr i32, ptr [[A]], i32 1
; CHECK-NEXT:    [[L2:%.*]] = load i32, ptr [[B]], align 4
; CHECK-NEXT:    ret i32 [[L2]]
;
  %a = alloca i64
  store i64 %x, ptr %a
  call void @callee(ptr %a)
  %l1 = load i32, ptr %a
  %b = getelementptr i32, ptr %a, i32 1
  %l2 = load i32, ptr %b
  ret i32 %l2
}

define i32 @twocalls() {
; CHECK-LABEL: @twocalls(
; CHECK-NEXT:    [[A:%.*]] = alloca { i32, i32 }, align 8
; CHECK-NEXT:    store i32 0, ptr [[A]], align 4
; CHECK-NEXT:    [[B:%.*]] = getelementptr i32, ptr [[A]], i32 1
; CHECK-NEXT:    store i32 1, ptr [[B]], align 4
; CHECK-NEXT:    call void @callee(ptr [[A]])
; CHECK-NEXT:    [[L1:%.*]] = load i32, ptr [[A]], align 4
; CHECK-NEXT:    call void @callee(ptr [[A]])
; CHECK-NEXT:    [[L2:%.*]] = load i32, ptr [[B]], align 4
; CHECK-NEXT:    ret i32 1
;
  %a = alloca {i32, i32}
  store i32 0, ptr %a
  %b = getelementptr i32, ptr %a, i32 1
  store i32 1, ptr %b
  call void @callee(ptr %a)
  %l1 = load i32, ptr %a
  call void @callee(ptr %a)
  %l2 = load i32, ptr %b
  ret i32 %l2
}

define i32 @volatile() {
; CHECK-LABEL: @volatile(
; CHECK-NEXT:    [[A:%.*]] = alloca { i32, i32 }, align 8
; CHECK-NEXT:    store i32 0, ptr [[A]], align 4
; CHECK-NEXT:    [[B:%.*]] = getelementptr i32, ptr [[A]], i32 1
; CHECK-NEXT:    store i32 1, ptr [[B]], align 4
; CHECK-NEXT:    call void @callee(ptr [[A]])
; CHECK-NEXT:    [[L1:%.*]] = load volatile i32, ptr [[A]], align 4
; CHECK-NEXT:    [[L2:%.*]] = load volatile i32, ptr [[B]], align 4
; CHECK-NEXT:    ret i32 1
;
  %a = alloca {i32, i32}
  store i32 0, ptr %a
  %b = getelementptr i32, ptr %a, i32 1
  store i32 1, ptr %b
  call void @callee(ptr %a)
  %l1 = load volatile i32, ptr %a
  %l2 = load volatile i32, ptr %b
  ret i32 %l2
}

define i32 @notdominating() {
; CHECK-LABEL: @notdominating(
; CHECK-NEXT:    [[A:%.*]] = alloca { i32, i32 }, align 8
; CHECK-NEXT:    [[B:%.*]] = getelementptr i32, ptr [[A]], i32 1
; CHECK-NEXT:    [[L1:%.*]] = load volatile i32, ptr [[A]], align 4
; CHECK-NEXT:    [[L2:%.*]] = load volatile i32, ptr [[B]], align 4
; CHECK-NEXT:    store i32 0, ptr [[A]], align 4
; CHECK-NEXT:    store i32 1, ptr [[B]], align 4
; CHECK-NEXT:    call void @callee(ptr [[A]])
; CHECK-NEXT:    ret i32 [[L2]]
;
  %a = alloca {i32, i32}
  %b = getelementptr i32, ptr %a, i32 1
  %l1 = load volatile i32, ptr %a
  %l2 = load volatile i32, ptr %b
  store i32 0, ptr %a
  store i32 1, ptr %b
  call void @callee(ptr %a)
  ret i32 %l2
}

declare void @callee_notreadonly(ptr %p)
define i32 @notreadonly() {
; CHECK-LABEL: @notreadonly(
; CHECK-NEXT:    [[A:%.*]] = alloca { i32, i32 }, align 8
; CHECK-NEXT:    store i32 0, ptr [[A]], align 4
; CHECK-NEXT:    [[B:%.*]] = getelementptr i32, ptr [[A]], i32 1
; CHECK-NEXT:    store i32 1, ptr [[B]], align 4
; CHECK-NEXT:    call void @callee_notreadonly(ptr [[A]])
; CHECK-NEXT:    [[L1:%.*]] = load i32, ptr [[A]], align 4
; CHECK-NEXT:    [[L2:%.*]] = load i32, ptr [[B]], align 4
; CHECK-NEXT:    ret i32 [[L2]]
;
  %a = alloca {i32, i32}
  store i32 0, ptr %a
  %b = getelementptr i32, ptr %a, i32 1
  store i32 1, ptr %b
  call void @callee_notreadonly(ptr %a)
  %l1 = load i32, ptr %a
  %l2 = load i32, ptr %b
  ret i32 %l2
}

declare void @callee_multiuse(ptr nocapture readonly %p, ptr nocapture readonly %q)
define i32 @multiuse() {
; CHECK-LABEL: @multiuse(
; CHECK-NEXT:    [[A:%.*]] = alloca { i32, i32 }, align 8
; CHECK-NEXT:    store i32 0, ptr [[A]], align 4
; CHECK-NEXT:    [[B:%.*]] = getelementptr i32, ptr [[A]], i32 1
; CHECK-NEXT:    store i32 1, ptr [[B]], align 4
; CHECK-NEXT:    call void @callee_multiuse(ptr [[A]], ptr [[A]])
; CHECK-NEXT:    [[L1:%.*]] = load i32, ptr [[A]], align 4
; CHECK-NEXT:    [[L2:%.*]] = load i32, ptr [[B]], align 4
; CHECK-NEXT:    ret i32 1
;
  %a = alloca {i32, i32}
  store i32 0, ptr %a
  %b = getelementptr i32, ptr %a, i32 1
  store i32 1, ptr %b
  call void @callee_multiuse(ptr %a, ptr %a)
  %l1 = load i32, ptr %a
  %l2 = load i32, ptr %b
  ret i32 %l2
}

define i32 @memcpyed(ptr %src) {
; CHECK-LABEL: @memcpyed(
; CHECK-NEXT:    [[A:%.*]] = alloca i32, align 4
; CHECK-NEXT:    store i32 0, ptr [[A]], align 4
; CHECK-NEXT:    call void @callee(ptr [[A]])
; CHECK-NEXT:    call void @llvm.memcpy.p0.p0.i64(ptr [[A]], ptr [[SRC:%.*]], i64 4, i1 false)
; CHECK-NEXT:    [[L1:%.*]] = load i32, ptr [[A]], align 4
; CHECK-NEXT:    ret i32 [[L1]]
;
  %a = alloca i32
  store i32 0, ptr %a
  call void @callee(ptr %a)
  call void @llvm.memcpy.p0.p0.i64(ptr %a, ptr %src, i64 4, i1 false)
  %l1 = load i32, ptr %a
  ret i32 %l1
}

declare void @llvm.memcpy.p0.p0.i64(ptr, ptr, i64, i1)
