; NOTE: Assertions have been autogenerated by utils/update_test_checks.py UTC_ARGS: --version 4
; RUN: opt < %s -passes=memcpyopt -S -verify-memoryssa | FileCheck %s

%buf = type [7 x i8]

; We can forward `memcpy` because the copy location are the same,
define void @forward_offset(ptr %dep_src) {
; CHECK-LABEL: define void @forward_offset(
; CHECK-SAME: ptr [[DEP_SRC:%.*]]) {
; CHECK-NEXT:    [[DEP_DEST:%.*]] = alloca [7 x i8], align 1
; CHECK-NEXT:    call void @llvm.memcpy.p0.p0.i64(ptr align 1 [[DEP_DEST]], ptr align 1 [[DEP_SRC]], i64 7, i1 false)
; CHECK-NEXT:    [[SRC:%.*]] = getelementptr inbounds i8, ptr [[DEP_DEST]], i64 1
; CHECK-NEXT:    [[DEP:%.*]] = getelementptr inbounds i8, ptr [[DEP_SRC]], i64 1
; CHECK-NEXT:    call void @llvm.memmove.p0.p0.i64(ptr align 1 [[DEP]], ptr align 1 [[DEP]], i64 6, i1 false)
; CHECK-NEXT:    ret void
;
  %dep_dest = alloca %buf, align 1
  call void @llvm.memcpy.p0.p0.i64(ptr align 1 %dep_dest, ptr align 1 %dep_src, i64 7, i1 false)
  %src = getelementptr inbounds i8, ptr %dep_dest, i64 1
  %dest = getelementptr inbounds i8, ptr %dep_src, i64 1
  call void @llvm.memcpy.p0.p0.i64(ptr align 1 %dest, ptr align 1 %src, i64 6, i1 false)
  ret void
}

; We need to update the align value when forwarding.
define void @forward_offset_align(ptr %dep_src) {
; CHECK-LABEL: define void @forward_offset_align(
; CHECK-SAME: ptr [[DEP_SRC:%.*]]) {
; CHECK-NEXT:    [[DEP_DEST:%.*]] = alloca [7 x i8], align 1
; CHECK-NEXT:    call void @llvm.memcpy.p0.p0.i64(ptr align 1 [[DEP_DEST]], ptr align 2 [[DEP_SRC]], i64 7, i1 false)
; CHECK-NEXT:    [[SRC:%.*]] = getelementptr inbounds i8, ptr [[DEP_DEST]], i64 1
; CHECK-NEXT:    [[DEP:%.*]] = getelementptr inbounds i8, ptr [[DEP_SRC]], i64 1
; CHECK-NEXT:    call void @llvm.memmove.p0.p0.i64(ptr align 1 [[DEP]], ptr align 1 [[DEP]], i64 6, i1 false)
; CHECK-NEXT:    ret void
;
  %dep_dest = alloca %buf, align 1
  call void @llvm.memcpy.p0.p0.i64(ptr align 1 %dep_dest, ptr align 2 %dep_src, i64 7, i1 false)
  %src = getelementptr inbounds i8, ptr %dep_dest, i64 1
  %dest = getelementptr inbounds i8, ptr %dep_src, i64 1
  call void @llvm.memcpy.p0.p0.i64(ptr align 1 %dest, ptr align 1 %src, i64 6, i1 false)
  ret void
}

; We need to create a GEP instruction when forwarding.
define void @forward_offset_with_gep(ptr %dep_src) {
; CHECK-LABEL: define void @forward_offset_with_gep(
; CHECK-SAME: ptr [[DEP_SRC:%.*]]) {
; CHECK-NEXT:    [[DEP_DEST:%.*]] = alloca [7 x i8], align 1
; CHECK-NEXT:    call void @llvm.memcpy.p0.p0.i64(ptr align 1 [[DEP_DEST]], ptr align 1 [[DEP_SRC]], i64 7, i1 false)
; CHECK-NEXT:    [[SRC:%.*]] = getelementptr inbounds i8, ptr [[DEP_DEST]], i64 1
; CHECK-NEXT:    [[DEP1:%.*]] = getelementptr inbounds i8, ptr [[DEP_SRC]], i64 2
; CHECK-NEXT:    [[TMP1:%.*]] = getelementptr inbounds i8, ptr [[DEP_SRC]], i64 1
; CHECK-NEXT:    call void @llvm.memmove.p0.p0.i64(ptr align 1 [[DEP1]], ptr align 1 [[TMP1]], i64 6, i1 false)
; CHECK-NEXT:    ret void
;
  %dep_dest = alloca %buf, align 1
  call void @llvm.memcpy.p0.p0.i64(ptr align 1 %dep_dest, ptr align 1 %dep_src, i64 7, i1 false)
  %src = getelementptr inbounds i8, ptr %dep_dest, i64 1
  %dest = getelementptr inbounds i8, ptr %dep_src, i64 2
  call void @llvm.memcpy.p0.p0.i64(ptr align 1 %dest, ptr align 1 %src, i64 6, i1 false)
  ret void
}

; Make sure we pass the right parameters when calling `memcpy`.
define void @forward_offset_memcpy(ptr %dep_src) {
; CHECK-LABEL: define void @forward_offset_memcpy(
; CHECK-SAME: ptr [[DEP_SRC:%.*]]) {
; CHECK-NEXT:    [[DEP_DEST:%.*]] = alloca [7 x i8], align 1
; CHECK-NEXT:    [[DEST:%.*]] = alloca [7 x i8], align 1
; CHECK-NEXT:    call void @llvm.memcpy.p0.p0.i64(ptr align 1 [[DEP_DEST]], ptr align 1 [[DEP_SRC]], i64 7, i1 false)
; CHECK-NEXT:    [[SRC:%.*]] = getelementptr inbounds i8, ptr [[DEP_DEST]], i64 1
; CHECK-NEXT:    [[TMP1:%.*]] = getelementptr inbounds i8, ptr [[DEP_SRC]], i64 1
; CHECK-NEXT:    call void @llvm.memcpy.p0.p0.i64(ptr align 1 [[DEST]], ptr align 1 [[TMP1]], i64 6, i1 false)
; CHECK-NEXT:    call void @use(ptr [[DEST]])
; CHECK-NEXT:    ret void
;
  %dep_dest = alloca %buf, align 1
  %dest = alloca %buf, align 1
  call void @llvm.memcpy.p0.p0.i64(ptr align 1 %dep_dest, ptr align 1 %dep_src, i64 7, i1 false)
  %src = getelementptr inbounds i8, ptr %dep_dest, i64 1
  call void @llvm.memcpy.p0.p0.i64(ptr align 1 %dest, ptr align 1 %src, i64 6, i1 false)
  call void @use(ptr %dest)
  ret void
}

; Make sure we pass the right parameters when calling `memcpy.inline`.
define void @forward_offset_memcpy_inline(ptr %dep_src) {
; CHECK-LABEL: define void @forward_offset_memcpy_inline(
; CHECK-SAME: ptr [[DEP_SRC:%.*]]) {
; CHECK-NEXT:    [[DEP_DEST:%.*]] = alloca [7 x i8], align 1
; CHECK-NEXT:    [[DEST:%.*]] = alloca [7 x i8], align 1
; CHECK-NEXT:    call void @llvm.memcpy.p0.p0.i64(ptr align 1 [[DEP_DEST]], ptr align 1 [[DEP_SRC]], i64 7, i1 false)
; CHECK-NEXT:    [[SRC:%.*]] = getelementptr inbounds i8, ptr [[DEP_DEST]], i64 1
; CHECK-NEXT:    [[TMP1:%.*]] = getelementptr inbounds i8, ptr [[DEP_SRC]], i64 1
; CHECK-NEXT:    call void @llvm.memcpy.inline.p0.p0.i64(ptr align 1 [[DEST]], ptr align 1 [[TMP1]], i64 6, i1 false)
; CHECK-NEXT:    call void @use(ptr [[DEST]])
; CHECK-NEXT:    ret void
;
  %dep_dest = alloca %buf, align 1
  %dest = alloca %buf, align 1
  call void @llvm.memcpy.p0.p0.i64(ptr align 1 %dep_dest, ptr align 1 %dep_src, i64 7, i1 false)
  %src = getelementptr inbounds i8, ptr %dep_dest, i64 1
  call void @llvm.memcpy.inline.p0.p0.i64(ptr align 1 %dest, ptr align 1 %src, i64 6, i1 false)
  call void @use(ptr %dest)
  ret void
}

; We cannot forward `memcpy` because it exceeds the size of `memcpy` it depends on.
define void @do_not_forward_oversize_offset(ptr %dep_src) {
; CHECK-LABEL: define void @do_not_forward_oversize_offset(
; CHECK-SAME: ptr [[DEP_SRC:%.*]]) {
; CHECK-NEXT:    [[DEP_DEST:%.*]] = alloca [7 x i8], align 1
; CHECK-NEXT:    call void @llvm.memcpy.p0.p0.i64(ptr align 1 [[DEP_DEST]], ptr align 1 [[DEP_SRC]], i64 6, i1 false)
; CHECK-NEXT:    [[SRC:%.*]] = getelementptr inbounds i8, ptr [[DEP_DEST]], i64 1
; CHECK-NEXT:    [[DEP:%.*]] = getelementptr inbounds i8, ptr [[DEP_SRC]], i64 1
; CHECK-NEXT:    call void @llvm.memcpy.p0.p0.i64(ptr align 1 [[DEP]], ptr align 1 [[SRC]], i64 6, i1 false)
; CHECK-NEXT:    ret void
;
  %dep_dest = alloca %buf, align 1
  call void @llvm.memcpy.p0.p0.i64(ptr align 1 %dep_dest, ptr align 1 %dep_src, i64 6, i1 false)
  %src = getelementptr inbounds i8, ptr %dep_dest, i64 1
  %dest = getelementptr inbounds i8, ptr %dep_src, i64 1
  call void @llvm.memcpy.p0.p0.i64(ptr align 1 %dest, ptr align 1 %src, i64 6, i1 false)
  ret void
}

; We can forward `memcpy` because the write operation does not corrupt the location to be copied.
define void @forward_offset_and_store(ptr %dep_src) {
; CHECK-LABEL: define void @forward_offset_and_store(
; CHECK-SAME: ptr [[DEP_SRC:%.*]]) {
; CHECK-NEXT:    [[DEP_DEST:%.*]] = alloca [7 x i8], align 1
; CHECK-NEXT:    call void @llvm.memcpy.p0.p0.i64(ptr align 1 [[DEP_DEST]], ptr align 1 [[DEP_SRC]], i64 7, i1 false)
; CHECK-NEXT:    store i8 1, ptr [[DEP_SRC]], align 1
; CHECK-NEXT:    [[DEP_SRC_END:%.*]] = getelementptr inbounds i8, ptr [[DEP_SRC]], i64 6
; CHECK-NEXT:    store i8 1, ptr [[DEP_SRC_END]], align 1
; CHECK-NEXT:    [[SRC:%.*]] = getelementptr inbounds i8, ptr [[DEP_DEST]], i64 1
; CHECK-NEXT:    [[DEP:%.*]] = getelementptr inbounds i8, ptr [[DEP_SRC]], i64 1
; CHECK-NEXT:    call void @llvm.memmove.p0.p0.i64(ptr align 1 [[DEP]], ptr align 1 [[DEP]], i64 5, i1 false)
; CHECK-NEXT:    ret void
;
  %dep_dest = alloca %buf, align 1
  call void @llvm.memcpy.p0.p0.i64(ptr align 1 %dep_dest, ptr align 1 %dep_src, i64 7, i1 false)
  store i8 1, ptr %dep_src, align 1
  %dep_src_end = getelementptr inbounds i8, ptr %dep_src, i64 6
  store i8 1, ptr %dep_src_end, align 1
  %src = getelementptr inbounds i8, ptr %dep_dest, i64 1
  %dest = getelementptr inbounds i8, ptr %dep_src, i64 1
  call void @llvm.memcpy.p0.p0.i64(ptr align 1 %dest, ptr align 1 %src, i64 5, i1 false)
  ret void
}

; We cannot forward `memcpy` because the write operation alters the location to be copied.
; Also, make sure we have removed the GEP instruction that was created temporarily.
define void @do_not_forward_offset_and_store(ptr %dep_src) {
; CHECK-LABEL: define void @do_not_forward_offset_and_store(
; CHECK-SAME: ptr [[DEP_SRC:%.*]]) {
; CHECK-NEXT:    [[DEP_DEST:%.*]] = alloca [7 x i8], align 1
; CHECK-NEXT:    call void @llvm.memcpy.p0.p0.i64(ptr align 1 [[DEP_DEST]], ptr align 1 [[DEP_SRC]], i64 7, i1 false)
; CHECK-NEXT:    [[DEP:%.*]] = getelementptr inbounds i8, ptr [[DEP_SRC]], i64 1
; CHECK-NEXT:    store i8 1, ptr [[DEP]], align 1
; CHECK-NEXT:    [[SRC:%.*]] = getelementptr inbounds i8, ptr [[DEP_DEST]], i64 1
; CHECK-NEXT:    [[DEST:%.*]] = getelementptr inbounds i8, ptr [[DEP_SRC]], i64 2
; CHECK-NEXT:    call void @llvm.memcpy.p0.p0.i64(ptr align 1 [[DEST]], ptr align 1 [[SRC]], i64 5, i1 false)
; CHECK-NEXT:    ret void
;
  %dep_dest = alloca %buf, align 1
  call void @llvm.memcpy.p0.p0.i64(ptr align 1 %dep_dest, ptr align 1 %dep_src, i64 7, i1 false)
  %dep_src_offset = getelementptr inbounds i8, ptr %dep_src, i64 1
  store i8 1, ptr %dep_src_offset, align 1
  %src = getelementptr inbounds i8, ptr %dep_dest, i64 1
  %dest = getelementptr inbounds i8, ptr %dep_src, i64 2
  call void @llvm.memcpy.p0.p0.i64(ptr align 1 %dest, ptr align 1 %src, i64 5, i1 false)
  ret void
}

declare void @use(ptr)

declare void @llvm.memcpy.p0.p0.i64(ptr nocapture, ptr nocapture, i64, i1)
declare void @llvm.memcpy.inline.p0.p0.i64(ptr nocapture, ptr nocapture, i64, i1)
