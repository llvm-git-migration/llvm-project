; NOTE: Assertions have been autogenerated by utils/update_test_checks.py UTC_ARGS: --check-attributes --check-globals --version 2
; RUN: opt -aa-pipeline=basic-aa -passes=attributor -debug-only=attributor -attributor-manifest-internal -attributor-annotate-decl-cs  -S < %s | FileCheck %s
; RUN: opt -aa-pipeline=basic-aa -passes=attributor-cgscc -debug-only=attributor -attributor-manifest-internal -attributor-annotate-decl-cs -S < %s | FileCheck %s
; REQUIRES: asserts

; CHECK: Accesses by bin after update:
; CHECK-NEXT: [8-12] : 1
; CHECK-NEXT:      - 5 -   %1 = load i32, ptr %field22, align 4
; CHECK-NEXT:        - c: <unknown>
; CHECK-NEXT: Print the full access chain:
; CHECK-NEXT:        %1 = load i32, ptr %field22, align 4
; CHECK-NEXT:        %field22 = getelementptr i32, ptr %field2, i32 0
; CHECK-NEXT:        %field2 = getelementptr inbounds [10 x i32], ptr %f, i32 0, i32 2
; CHECK-NEXT: [4-5] : 1
; CHECK-NEXT:      - 9 -   store i8 10, ptr %field11, align 4
; CHECK-NEXT:        - c: i8 10
; CHECK-NEXT: Print the full access chain:
; CHECK-NEXT:        store i8 10, ptr %field11, align 4
; CHECK-NEXT:        %field11 = getelementptr i32, ptr %field1, i32 0
; CHECK-NEXT:        %field1 = getelementptr inbounds [10 x i32], ptr %f, i32 0, i32 1
; CHECK-NEXT: [32-36] : 1
; CHECK-NEXT:      - 9 -   store i32 %3, ptr %field8, align 4
; CHECK-NEXT:        - c:   %3 = load i32, ptr %val, align 4
; CHECK-NEXT: Print the full access chain:
; CHECK-NEXT:        store i32 %3, ptr %field8, align 4
; CHECK-NEXT:        %field8 = getelementptr inbounds [10 x i32], ptr %f, i32 0, i32 8
; CHECK-NEXT: [4-8] : 1
; CHECK-NEXT:      - 5 -   %0 = load i32, ptr %field11, align 4
; CHECK-NEXT:        - c: <unknown>
; CHECK-NEXT: Print the full access chain:
; CHECK-NEXT:        %0 = load i32, ptr %field11, align 4
; CHECK-NEXT:        %field11 = getelementptr i32, ptr %field1, i32 0
; CHECK-NEXT:        %field1 = getelementptr inbounds [10 x i32], ptr %f, i32 0, i32 1
; CHECK-NEXT: [8-9] : 1
; CHECK-NEXT:      - 9 -   store i8 12, ptr %field22, align 4
; CHECK-NEXT:        - c: i8 12
; CHECK-NEXT: Print the full access chain:
; CHECK-NEXT:        store i8 12, ptr %field22, align 4
; CHECK-NEXT:        %field22 = getelementptr i32, ptr %field2, i32 0
; CHECK-NEXT:        %field2 = getelementptr inbounds [10 x i32], ptr %f, i32 0, i32 2
define dso_local i32 @track_chain(ptr nocapture %val) #0 {
; CHECK: Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: readwrite)
; CHECK-LABEL: define dso_local i32 @track_chain
; CHECK-SAME: (ptr nocapture nofree noundef nonnull readonly align 4 dereferenceable(4) [[VAL:%.*]]) #[[ATTR0:[0-9]+]] {
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[F:%.*]] = alloca [10 x i32], align 4
; CHECK-NEXT:    [[FIELD1:%.*]] = getelementptr inbounds [10 x i32], ptr [[F]], i32 0, i32 1
; CHECK-NEXT:    [[FIELD2:%.*]] = getelementptr inbounds [10 x i32], ptr [[F]], i32 0, i32 2
; CHECK-NEXT:    [[FIELD8:%.*]] = getelementptr inbounds [10 x i32], ptr [[F]], i32 0, i32 8
; CHECK-NEXT:    store i8 10, ptr [[FIELD1]], align 4
; CHECK-NEXT:    store i8 12, ptr [[FIELD2]], align 4
; CHECK-NEXT:    [[TMP0:%.*]] = load i32, ptr [[FIELD1]], align 4
; CHECK-NEXT:    [[TMP1:%.*]] = load i32, ptr [[FIELD2]], align 4
; CHECK-NEXT:    [[TMP2:%.*]] = add i32 [[TMP0]], [[TMP1]]
; CHECK-NEXT:    [[TMP3:%.*]] = load i32, ptr [[VAL]], align 4
; CHECK-NEXT:    [[TMP4:%.*]] = add i32 [[TMP3]], [[TMP2]]
; CHECK-NEXT:    ret i32 [[TMP4]]
;
entry:
  %f = alloca [10 x i32]
  %field1 = getelementptr inbounds [10 x i32], ptr %f, i32 0, i32 1
  %field2 = getelementptr inbounds [10 x i32], ptr %f, i32 0, i32 2
  %field3 = getelementptr inbounds [10 x i32], ptr %f, i32 0, i32 3
  %field8 = getelementptr inbounds [10 x i32], ptr %f, i32 0, i32 8

  %field11 = getelementptr i32, ptr %field1, i32 0
  %field22 = getelementptr i32, ptr %field2, i32 0
  store i8 10, ptr %field11, align 4
  store i8 12, ptr %field22, align 4

  %1 = load i32, ptr %field11, align 4
  %2 = load i32, ptr %field22, align 4
  %3 = add i32 %1, %2

  %4 = load i32, ptr %val, align 4
  store i32 %4, ptr %field8, align 4

  %5 = add i32 %4, %3

  ret i32 %5
}

; TODO: Should %field11 be backtracked further in this case? 
; It is not currently because, for example the offsets of the load
; at [12-16] are different than the %field1 GEP. But we could 
; store it since it is a pointer operand, ie, comes form a GEP. 
; It could also be a function argument, (a ptr passed to a function).
; CHECK: Accesses by bin after update:
; CHECK-NEXT: [12-16] : 1
; CHECK-NEXT:      - 5 -   %0 = load i32, ptr %field11, align 4
; CHECK-NEXT:        - c: <unknown>
; CHECK-NEXT: Print the full access chain:
; CHECK-NEXT:        %0 = load i32, ptr %field11, align 4
; CHECK-NEXT:        %field11 = getelementptr i32, ptr %field1, i32 2
; CHECK-NEXT: [16-17] : 1
; CHECK-NEXT:      - 9 -   store i8 12, ptr %field22, align 4
; CHECK-NEXT:        - c: i8 12
; CHECK-NEXT: Print the full access chain:
; CHECK-NEXT:        store i8 12, ptr %field22, align 4
; CHECK-NEXT:        %field22 = getelementptr i32, ptr %field2, i32 2
; CHECK-NEXT: [32-36] : 1
; CHECK-NEXT:      - 9 -   store i32 %3, ptr %field8, align 4
; CHECK-NEXT:        - c:   %3 = load i32, ptr %val, align 4
; CHECK-NEXT: Print the full access chain:
; CHECK-NEXT:        store i32 %3, ptr %field8, align 4
; CHECK-NEXT:        %field8 = getelementptr inbounds [10 x i32], ptr %f, i32 0, i32 8
; CHECK-NEXT: [16-20] : 1
; CHECK-NEXT:      - 5 -   %1 = load i32, ptr %field22, align 4
; CHECK-NEXT:        - c: <unknown>
; CHECK-NEXT: Print the full access chain:
; CHECK-NEXT:        %1 = load i32, ptr %field22, align 4
; CHECK-NEXT:        %field22 = getelementptr i32, ptr %field2, i32 2
; CHECK-NEXT: [12-13] : 1
; CHECK-NEXT:     - 9 -   store i8 10, ptr %field11, align 4
; CHECK-NEXT:        - c: i8 10
; CHECK-NEXT: Print the full access chain:
; CHECK-NEXT:        store i8 10, ptr %field11, align 4
; CHECK-NEXT:        %field11 = getelementptr i32, ptr %field1, i32 2
define dso_local i32 @track_chain_2(ptr nocapture %val) #0 {
; CHECK: Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: readwrite)
; CHECK-LABEL: define dso_local i32 @track_chain_2
; CHECK-SAME: (ptr nocapture nofree noundef nonnull readonly align 4 dereferenceable(4) [[VAL:%.*]]) #[[ATTR0]] {
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[F:%.*]] = alloca [10 x i32], align 4
; CHECK-NEXT:    [[FIELD1:%.*]] = getelementptr inbounds [10 x i32], ptr [[F]], i32 0, i32 1
; CHECK-NEXT:    [[FIELD2:%.*]] = getelementptr inbounds [10 x i32], ptr [[F]], i32 0, i32 2
; CHECK-NEXT:    [[FIELD8:%.*]] = getelementptr inbounds [10 x i32], ptr [[F]], i32 0, i32 8
; CHECK-NEXT:    [[FIELD11:%.*]] = getelementptr i32, ptr [[FIELD1]], i32 2
; CHECK-NEXT:    [[FIELD22:%.*]] = getelementptr i32, ptr [[FIELD2]], i32 2
; CHECK-NEXT:    store i8 10, ptr [[FIELD11]], align 4
; CHECK-NEXT:    store i8 12, ptr [[FIELD22]], align 4
; CHECK-NEXT:    [[TMP0:%.*]] = load i32, ptr [[FIELD11]], align 4
; CHECK-NEXT:    [[TMP1:%.*]] = load i32, ptr [[FIELD22]], align 4
; CHECK-NEXT:    [[TMP2:%.*]] = add i32 [[TMP0]], [[TMP1]]
; CHECK-NEXT:    [[TMP3:%.*]] = load i32, ptr [[VAL]], align 4
; CHECK-NEXT:    [[TMP4:%.*]] = add i32 [[TMP3]], [[TMP2]]
; CHECK-NEXT:    ret i32 [[TMP4]]
;
entry:
  %f = alloca [10 x i32]
  %field1 = getelementptr inbounds [10 x i32], ptr %f, i32 0, i32 1
  %field2 = getelementptr inbounds [10 x i32], ptr %f, i32 0, i32 2
  %field3 = getelementptr inbounds [10 x i32], ptr %f, i32 0, i32 3
  %field8 = getelementptr inbounds [10 x i32], ptr %f, i32 0, i32 8

  %field11 = getelementptr i32, ptr %field1, i32 2
  %field22 = getelementptr i32, ptr %field2, i32 2
  store i8 10, ptr %field11, align 4
  store i8 12, ptr %field22, align 4

  %1 = load i32, ptr %field11, align 4
  %2 = load i32, ptr %field22, align 4
  %3 = add i32 %1, %2

  %4 = load i32, ptr %val, align 4
  store i32 %4, ptr %field8, align 4

  %5 = add i32 %4, %3

  ret i32 %5
}
;.
; CHECK: attributes #[[ATTR0]] = { mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: readwrite) }
;.
