; NOTE: Assertions have been autogenerated by utils/update_test_checks.py UTC_ARGS: --check-attributes --check-globals --version 2
; RUN: opt -aa-pipeline=basic-aa -passes=attributor -debug-only=attributor -attributor-manifest-internal -attributor-annotate-decl-cs  -S < %s 2>&1 | FileCheck %s
; RUN: opt -aa-pipeline=basic-aa -passes=attributor-cgscc -debug-only=attributor -attributor-manifest-internal -attributor-annotate-decl-cs -S < %s 2>&1 | FileCheck %s
; REQUIRES: asserts

; CHECK: Accesses by bin after update:
; CHECK: [8-12] : 1
; CHECK:      - 5 -   %1 = load i32, ptr %field22, align 4
; CHECK:        - c: <unknown>
; CHECK: Print the full access chain:
; CHECK-DAG:        %1 = load i32, ptr %field22, align 4
; CHECK-DAG:        %field22 = getelementptr i32, ptr %field2, i32 0
; CHECK-DAG:        %field2 = getelementptr inbounds [10 x i32], ptr %f, i32 0, i32 2
; CHECK: [4-5] : 1
; CHECK:      - 9 -   store i8 10, ptr %field11, align 4
; CHECK:        - c: i8 10
; CHECK: Print the full access chain:
; CHECK-DAG:        store i8 10, ptr %field11, align 4
; CHECK-DAG:        %field11 = getelementptr i32, ptr %field1, i32 0
; CHECK-DAG:        %field1 = getelementptr inbounds [10 x i32], ptr %f, i32 0, i32 1
; CHECK: [32-36] : 1
; CHECK:      - 9 -   store i32 %3, ptr %field8, align 4
; CHECK:        - c:   %3 = load i32, ptr %val, align 4
; CHECK: Print the full access chain:
; CHECK-DAG:        store i32 %3, ptr %field8, align 4
; CHECK-DAG:        %field8 = getelementptr inbounds [10 x i32], ptr %f, i32 0, i32 8
; CHECK: [4-8] : 1
; CHECK:      - 5 -   %0 = load i32, ptr %field11, align 4
; CHECK:        - c: <unknown>
; CHECK: Print the full access chain:
; CHECK-DAG:        %0 = load i32, ptr %field11, align 4
; CHECK-DAG:        %field11 = getelementptr i32, ptr %field1, i32 0
; CHECK-DAG:        %field1 = getelementptr inbounds [10 x i32], ptr %f, i32 0, i32 1
; CHECK: [8-9] : 1
; CHECK:      - 9 -   store i8 12, ptr %field22, align 4
; CHECK:        - c: i8 12
; CHECK: Print the full access chain:
; CHECK-DAG:        store i8 12, ptr %field22, align 4
; CHECK-DAG:        %field22 = getelementptr i32, ptr %field2, i32 0
; CHECK-DAG:        %field2 = getelementptr inbounds [10 x i32], ptr %f, i32 0, i32 2
define dso_local i32 @track_chain(ptr nocapture %val) #0 {
entry:
  %f = alloca [10 x i32]
  %field1 = getelementptr inbounds [10 x i32], ptr %f, i32 0, i32 1
  %field2 = getelementptr inbounds [10 x i32], ptr %f, i32 0, i32 2
  %field3 = getelementptr inbounds [10 x i32], ptr %f, i32 0, i32 3
  %field8 = getelementptr inbounds [10 x i32], ptr %f, i32 0, i32 8

  %field11 = getelementptr i32, ptr %field1, i32 0
  %field22 = getelementptr i32, ptr %field2, i32 0
  store i8 10, ptr %field11, align 4
  store i8 12, ptr %field22, align 4

  %1 = load i32, ptr %field11, align 4
  %2 = load i32, ptr %field22, align 4
  %3 = add i32 %1, %2

  %4 = load i32, ptr %val, align 4
  store i32 %4, ptr %field8, align 4

  %5 = add i32 %4, %3

  ret i32 %5
}

; TODO: Should %field11 be backtracked further in this case? 
; It is not currently because, for example the offsets of the load
; at [12-16] are different than the %field1 GEP. But we could 
; store it since it is a pointer operand, ie, comes form a GEP. 
; It could also be a function argument, (a ptr passed to a function).
; CHECK: Accesses by bin after update:
; CHECK: [12-16] : 1
; CHECK:      - 5 -   %0 = load i32, ptr %field11, align 4
; CHECK:        - c: <unknown>
; CHECK: Print the full access chain:
; CHECK-DAG:        %0 = load i32, ptr %field11, align 4
; CHECK-DAG:        %field11 = getelementptr i32, ptr %field1, i32 2
; CHECK: [16-17] : 1
; CHECK:      - 9 -   store i8 12, ptr %field22, align 4
; CHECK:        - c: i8 12
; CHECK: Print the full access chain:
; CHECK-DAG:        store i8 12, ptr %field22, align 4
; CHECK-DAG:        %field22 = getelementptr i32, ptr %field2, i32 2
; CHECK: [32-36] : 1
; CHECK:      - 9 -   store i32 %3, ptr %field8, align 4
; CHECK:        - c:   %3 = load i32, ptr %val, align 4
; CHECK: Print the full access chain:
; CHECK-DAG:        store i32 %3, ptr %field8, align 4
; CHECK-DAG:        %field8 = getelementptr inbounds [10 x i32], ptr %f, i32 0, i32 8
; CHECK: [16-20] : 1
; CHECK:      - 5 -   %1 = load i32, ptr %field22, align 4
; CHECK:        - c: <unknown>
; CHECK: Print the full access chain:
; CHECK-DAG:        %1 = load i32, ptr %field22, align 4
; CHECK-DAG:        %field22 = getelementptr i32, ptr %field2, i32 2
; CHECK: [12-13] : 1
; CHECK:     - 9 -   store i8 10, ptr %field11, align 4
; CHECK:        - c: i8 10
; CHECK: Print the full access chain:
; CHECK-DAG:        store i8 10, ptr %field11, align 4
; CHECK-DAG:        %field11 = getelementptr i32, ptr %field1, i32 2
define dso_local i32 @track_chain_2(ptr nocapture %val) #0 {
entry:
  %f = alloca [10 x i32]
  %field1 = getelementptr inbounds [10 x i32], ptr %f, i32 0, i32 1
  %field2 = getelementptr inbounds [10 x i32], ptr %f, i32 0, i32 2
  %field3 = getelementptr inbounds [10 x i32], ptr %f, i32 0, i32 3
  %field8 = getelementptr inbounds [10 x i32], ptr %f, i32 0, i32 8

  %field11 = getelementptr i32, ptr %field1, i32 2
  %field22 = getelementptr i32, ptr %field2, i32 2
  store i8 10, ptr %field11, align 4
  store i8 12, ptr %field22, align 4

  %1 = load i32, ptr %field11, align 4
  %2 = load i32, ptr %field22, align 4
  %3 = add i32 %1, %2

  %4 = load i32, ptr %val, align 4
  store i32 %4, ptr %field8, align 4

  %5 = add i32 %4, %3

  ret i32 %5
}
