; NOTE: Assertions have been autogenerated by utils/update_test_checks.py UTC_ARGS: --check-attributes --check-globals --version 2
; RUN: opt -aa-pipeline=basic-aa -passes=attributor -debug-only=attributor -attributor-manifest-internal -attributor-annotate-decl-cs  -S < %s 2>&1 | FileCheck %s
; RUN: opt -aa-pipeline=basic-aa -passes=attributor-cgscc -debug-only=attributor -attributor-manifest-internal -attributor-annotate-decl-cs -S < %s 2>&1 | FileCheck %s
; REQUIRES: asserts

; CHECK: Accesses by bin after update:
; CHECK: [8-12] : 1
; CHECK:      - 5 -   %1 = load i32, ptr %field22, align 4
; CHECK:        - c: <unknown>
; CHECK: Print the full access chain:
; CHECK-DAG:        %1 = load i32, ptr %field22, align 4
; CHECK-DAG:        %field22 = getelementptr i32, ptr %field2, i32 0
; CHECK-DAG:        %field2 = getelementptr inbounds [10 x i32], ptr %f, i32 0, i32 2
; CHECK: [4-5] : 1
; CHECK:      - 9 -   store i8 10, ptr %field11, align 4
; CHECK:        - c: i8 10
; CHECK: Print the full access chain:
; CHECK-DAG:        store i8 10, ptr %field11, align 4
; CHECK-DAG:        %field11 = getelementptr i32, ptr %field1, i32 0
; CHECK-DAG:        %field1 = getelementptr inbounds [10 x i32], ptr %f, i32 0, i32 1
; CHECK: [32-36] : 1
; CHECK:      - 9 -   store i32 %3, ptr %field8, align 4
; CHECK:        - c:   %3 = load i32, ptr %val, align 4
; CHECK: Print the full access chain:
; CHECK-DAG:        store i32 %3, ptr %field8, align 4
; CHECK-DAG:        %field8 = getelementptr inbounds [10 x i32], ptr %f, i32 0, i32 8
; CHECK: [4-8] : 1
; CHECK:      - 5 -   %0 = load i32, ptr %field11, align 4
; CHECK:        - c: <unknown>
; CHECK: Print the full access chain:
; CHECK-DAG:        %0 = load i32, ptr %field11, align 4
; CHECK-DAG:        %field11 = getelementptr i32, ptr %field1, i32 0
; CHECK-DAG:        %field1 = getelementptr inbounds [10 x i32], ptr %f, i32 0, i32 1
; CHECK: [8-9] : 1
; CHECK:      - 9 -   store i8 12, ptr %field22, align 4
; CHECK:        - c: i8 12
; CHECK: Print the full access chain:
; CHECK-DAG:        store i8 12, ptr %field22, align 4
; CHECK-DAG:        %field22 = getelementptr i32, ptr %field2, i32 0
; CHECK-DAG:        %field2 = getelementptr inbounds [10 x i32], ptr %f, i32 0, i32 2
define dso_local i32 @track_chain(ptr nocapture %val) #0 {
entry:
  %f = alloca [10 x i32]
  %field1 = getelementptr inbounds [10 x i32], ptr %f, i32 0, i32 1
  %field2 = getelementptr inbounds [10 x i32], ptr %f, i32 0, i32 2
  %field3 = getelementptr inbounds [10 x i32], ptr %f, i32 0, i32 3
  %field8 = getelementptr inbounds [10 x i32], ptr %f, i32 0, i32 8

  %field11 = getelementptr i32, ptr %field1, i32 0
  %field22 = getelementptr i32, ptr %field2, i32 0
  store i8 10, ptr %field11, align 4
  store i8 12, ptr %field22, align 4

  %1 = load i32, ptr %field11, align 4
  %2 = load i32, ptr %field22, align 4
  %3 = add i32 %1, %2

  %4 = load i32, ptr %val, align 4
  store i32 %4, ptr %field8, align 4

  %5 = add i32 %4, %3

  ret i32 %5
}

; TODO: Should %field11 be backtracked further in this case? 
; It is not currently because, for example the offsets of the load
; at [12-16] are different than the %field1 GEP. But we could 
; store it since it is a pointer operand, ie, comes form a GEP. 
; It could also be a function argument, (a ptr passed to a function).
; CHECK: Accesses by bin after update:
; CHECK: [12-16] : 1
; CHECK:      - 5 -   %0 = load i32, ptr %field11, align 4
; CHECK:        - c: <unknown>
; CHECK: Print the full access chain:
; CHECK-DAG:        %0 = load i32, ptr %field11, align 4
; CHECK-DAG:        %field11 = getelementptr i32, ptr %field1, i32 2
; CHECK: [16-17] : 1
; CHECK:      - 9 -   store i8 12, ptr %field22, align 4
; CHECK:        - c: i8 12
; CHECK: Print the full access chain:
; CHECK-DAG:        store i8 12, ptr %field22, align 4
; CHECK-DAG:        %field22 = getelementptr i32, ptr %field2, i32 2
; CHECK: [32-36] : 1
; CHECK:      - 9 -   store i32 %3, ptr %field8, align 4
; CHECK:        - c:   %3 = load i32, ptr %val, align 4
; CHECK: Print the full access chain:
; CHECK-DAG:        store i32 %3, ptr %field8, align 4
; CHECK-DAG:        %field8 = getelementptr inbounds [10 x i32], ptr %f, i32 0, i32 8
; CHECK: [16-20] : 1
; CHECK:      - 5 -   %1 = load i32, ptr %field22, align 4
; CHECK:        - c: <unknown>
; CHECK: Print the full access chain:
; CHECK-DAG:        %1 = load i32, ptr %field22, align 4
; CHECK-DAG:        %field22 = getelementptr i32, ptr %field2, i32 2
; CHECK: [12-13] : 1
; CHECK:     - 9 -   store i8 10, ptr %field11, align 4
; CHECK:        - c: i8 10
; CHECK: Print the full access chain:
; CHECK-DAG:        store i8 10, ptr %field11, align 4
; CHECK-DAG:        %field11 = getelementptr i32, ptr %field1, i32 2
define dso_local i32 @track_chain_2(ptr nocapture %val) #0 {
entry:
  %f = alloca [10 x i32]
  %field1 = getelementptr inbounds [10 x i32], ptr %f, i32 0, i32 1
  %field2 = getelementptr inbounds [10 x i32], ptr %f, i32 0, i32 2
  %field3 = getelementptr inbounds [10 x i32], ptr %f, i32 0, i32 3
  %field8 = getelementptr inbounds [10 x i32], ptr %f, i32 0, i32 8

  %field11 = getelementptr i32, ptr %field1, i32 2
  %field22 = getelementptr i32, ptr %field2, i32 2
  store i8 10, ptr %field11, align 4
  store i8 12, ptr %field22, align 4

  %1 = load i32, ptr %field11, align 4
  %2 = load i32, ptr %field22, align 4
  %3 = add i32 %1, %2

  %4 = load i32, ptr %val, align 4
  store i32 %4, ptr %field8, align 4

  %5 = add i32 %4, %3

  ret i32 %5
}

define dso_local i32 @track_chain_3(ptr nocapture %val, i1 %cond) #0 {
; CHECK: Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn
; CHECK-LABEL: define dso_local i32 @track_chain_3
; CHECK-SAME: (ptr nocapture nofree noundef nonnull readonly align 4 dereferenceable(4) [[VAL:%.*]], i1 [[COND:%.*]]) #[[ATTR0:[0-9]+]] {
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[F:%.*]] = alloca [10 x i32], align 4
; CHECK-NEXT:    [[FIELD1:%.*]] = getelementptr inbounds [10 x i32], ptr [[F]], i32 0, i32 1
; CHECK-NEXT:    [[FIELD2:%.*]] = getelementptr inbounds [10 x i32], ptr [[F]], i32 0, i32 2
; CHECK-NEXT:    [[FIELD3:%.*]] = getelementptr inbounds [10 x i32], ptr [[F]], i32 0, i32 3
; CHECK-NEXT:    [[FIELD8:%.*]] = getelementptr inbounds [10 x i32], ptr [[F]], i32 0, i32 8
; CHECK-NEXT:    [[FIELD11:%.*]] = getelementptr i32, ptr [[FIELD1]], i32 2
; CHECK-NEXT:    [[FIELD22:%.*]] = getelementptr i32, ptr [[FIELD2]], i32 2
; CHECK-NEXT:    store i8 10, ptr [[FIELD11]], align 4
; CHECK-NEXT:    store i8 12, ptr [[FIELD22]], align 4
; CHECK-NEXT:    [[TMP0:%.*]] = load i32, ptr [[FIELD11]], align 4
; CHECK-NEXT:    [[TMP1:%.*]] = load i32, ptr [[FIELD22]], align 4
; CHECK-NEXT:    [[TMP2:%.*]] = add i32 [[TMP0]], [[TMP1]]
; CHECK-NEXT:    [[TMP3:%.*]] = load i32, ptr [[VAL]], align 4
; CHECK-NEXT:    store i32 [[TMP3]], ptr [[FIELD8]], align 4
; CHECK-NEXT:    [[TMP4:%.*]] = add i32 [[TMP3]], [[TMP2]]
; CHECK-NEXT:    [[B:%.*]] = load i32, ptr [[FIELD3]], align 4
; CHECK-NEXT:    [[TMP5:%.*]] = select i1 [[COND]], ptr [[FIELD3]], ptr [[FIELD8]]
; CHECK-NEXT:    store i32 1000, ptr [[TMP5]], align 4
; CHECK-NEXT:    [[TMP6:%.*]] = add i32 [[TMP4]], [[B]]
; CHECK-NEXT:    [[TMP7:%.*]] = load i32, ptr [[FIELD8]], align 4
; CHECK-NEXT:    [[TMP8:%.*]] = add i32 [[TMP7]], [[TMP6]]
; CHECK-NEXT:    ret i32 [[TMP8]]
;
entry:
  %f = alloca [10 x i32]
  %field1 = getelementptr inbounds [10 x i32], ptr %f, i32 0, i32 1
  %field2 = getelementptr inbounds [10 x i32], ptr %f, i32 0, i32 2
  %field3 = getelementptr inbounds [10 x i32], ptr %f, i32 0, i32 3
  %field8 = getelementptr inbounds [10 x i32], ptr %f, i32 0, i32 8

  %field11 = getelementptr i32, ptr %field1, i32 2
  %field22 = getelementptr i32, ptr %field2, i32 2
  store i8 10, ptr %field11, align 4
  store i8 12, ptr %field22, align 4
  %1 = load i32, ptr %field11, align 4
  %2 = load i32, ptr %field22, align 4
  %3 = add i32 %1, %2
  %4 = load i32, ptr %val, align 4
  store i32 %4, ptr %field8, align 4
  %5 = add i32 %4, %3
  %6 = load i32, ptr %val
  %a1 = load i32, ptr %field8
  %a = add i32 %a1, %6
  %b = load i32, ptr %field3
  ;%b  = sub i32 %b1, %6
  %7 = select i1 %cond, ptr %field3, ptr %field8
  store i32 1000, ptr %7
  %8 = add i32 %5, %b
  %9 = load i32, ptr %field8
  %10 = add i32 %9, %8
  ret i32 %10
}

@globalBytes = internal global [1024 x i8] zeroinitializer, align 16

;.
; CHECK: @globalBytes = internal global [1024 x i8] zeroinitializer, align 16
;.
define dso_local i32 @phi_different_offsets(ptr nocapture %val, ptr nocapture %val2, i1 %cmp) {
; CHECK: Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn
; CHECK-LABEL: define dso_local i32 @phi
; CHECK-SAME: (ptr nocapture nofree readonly [[VAL:%.*]], ptr nocapture nofree readonly [[VAL2:%.*]], i1 noundef [[CMP:%.*]]) #[[ATTR0:[0-9]+]] {
; CHECK-NEXT:  entry:
; CHECK-NEXT:    br i1 [[CMP]], label [[THEN:%.*]], label [[ELSE:%.*]]
; CHECK:       then:
; CHECK-NEXT:    [[FIELD2:%.*]] = getelementptr i32, ptr @globalBytes, i32 2
; CHECK-NEXT:    [[TMP0:%.*]] = load i32, ptr [[VAL]], align 4
; CHECK-NEXT:    store i32 [[TMP0]], ptr [[FIELD2]], align 8
; CHECK-NEXT:    br label [[END:%.*]]
; CHECK:       else:
; CHECK-NEXT:    [[FIELD8:%.*]] = getelementptr i32, ptr @globalBytes, i32 8
; CHECK-NEXT:    [[TMP1:%.*]] = load i32, ptr [[VAL2]], align 4
; CHECK-NEXT:    store i32 [[TMP1]], ptr [[FIELD8]], align 16
; CHECK-NEXT:    br label [[END]]
; CHECK:       end:
; CHECK-NEXT:    [[X:%.*]] = phi ptr [ [[FIELD2]], [[THEN]] ], [ [[FIELD8]], [[ELSE]] ]
; CHECK-NEXT:    [[RET:%.*]] = load i32, ptr [[X]], align 8
; CHECK-NEXT:    ret i32 [[RET]]
;
entry:
  br i1 %cmp, label %then, label %else

then:
  %field2 = getelementptr i32, ptr @globalBytes, i32 2
  %1 = load i32, ptr %val
  store i32 %1, ptr %field2
  br label %end

else:
  %field8 = getelementptr i32, ptr @globalBytes, i32 8
  %2 = load i32, ptr %val2
  store i32 %2, ptr %field8
  br label %end

end:
  %x = phi ptr [ %field2, %then ], [ %field8, %else ]
  %ret = load i32, ptr %x
  ret i32 %ret

}

define dso_local i32 @phi_same_offsets(ptr nocapture %val, ptr nocapture %val2, i1 %cmp) {
; CHECK: Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn
; CHECK-LABEL: define dso_local i32 @phi
; CHECK-SAME: (ptr nocapture nofree readonly [[VAL:%.*]], ptr nocapture nofree readonly [[VAL2:%.*]], i1 noundef [[CMP:%.*]]) #[[ATTR0:[0-9]+]] {
; CHECK-NEXT:  entry:
; CHECK-NEXT:    br i1 [[CMP]], label [[THEN:%.*]], label [[ELSE:%.*]]
; CHECK:       then:
; CHECK-NEXT:    [[FIELD2:%.*]] = getelementptr i32, ptr @globalBytes, i32 8
; CHECK-NEXT:    [[TMP0:%.*]] = load i32, ptr [[VAL]], align 4
; CHECK-NEXT:    store i32 [[TMP0]], ptr [[FIELD2]], align 16
; CHECK-NEXT:    br label [[END:%.*]]
; CHECK:       else:
; CHECK-NEXT:    [[FIELD8:%.*]] = getelementptr i32, ptr @globalBytes, i32 8
; CHECK-NEXT:    [[TMP1:%.*]] = load i32, ptr [[VAL2]], align 4
; CHECK-NEXT:    store i32 [[TMP1]], ptr [[FIELD8]], align 16
; CHECK-NEXT:    br label [[END]]
; CHECK:       end:
; CHECK-NEXT:    [[X:%.*]] = phi ptr [ [[FIELD2]], [[THEN]] ], [ [[FIELD8]], [[ELSE]] ]
; CHECK-NEXT:    [[RET:%.*]] = load i32, ptr [[X]], align 16
; CHECK-NEXT:    ret i32 [[RET]]
;
entry:
  br i1 %cmp, label %then, label %else

then:
  %field2 = getelementptr i32, ptr @globalBytes, i32 8
  %1 = load i32, ptr %val
  store i32 %1, ptr %field2
  br label %end

else:
  %field8 = getelementptr i32, ptr @globalBytes, i32 8
  %2 = load i32, ptr %val2
  store i32 %2, ptr %field8
  br label %end

end:
  %x = phi ptr [ %field2, %then ], [ %field8, %else ]
  %ret = load i32, ptr %x
  ret i32 %ret

}