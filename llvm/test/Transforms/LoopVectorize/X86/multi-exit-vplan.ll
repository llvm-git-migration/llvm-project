; NOTE: Assertions have been autogenerated by utils/update_test_checks.py UTC_ARGS: --version 5
; RUN: opt -p loop-vectorize -mcpu=skylake-avx512 -mtriple=x86_64-apple-macosx -force-vector-interleave=1 -S -enable-multi-cond-vectorization -debug %s 2>&1 | FileCheck %s

define i64 @multi_exiting_to_different_exits_with_store(ptr %p, i64 %N) {
; CHECK-LABEL: VPlan 'Final VPlan for VF={2,4,8},UF={1}' {
; CHECK-NEXT: Live-in vp<%0> = VF
; CHECK-NEXT: Live-in vp<%1> = VF * UF
; CHECK-NEXT: Live-in vp<%2> = vector-trip-count
; CHECK-NEXT: Live-in ir<128> = original trip-count
; CHECK-EMPTY:
; CHECK-NEXT: vector.ph:
; CHECK-NEXT: Successor(s): vector loop
; CHECK-EMPTY:
; CHECK-NEXT: <x1> vector loop: {
; CHECK-NEXT:   vector.body:
; CHECK-NEXT:     EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%7>
; CHECK-NEXT:     WIDEN-INDUCTION %iv = phi %inc, 0, ir<1>, vp<%0>
; CHECK-NEXT:     vp<%4> = SCALAR-STEPS vp<%3>, ir<1>
; CHECK-NEXT:     WIDEN ir<%c.1> = icmp uge ir<%iv>, ir<%N>
; CHECK-NEXT:     EMIT vp<%5> = not ir<%c.1>
; CHECK-NEXT:     CLONE ir<%arrayidx> = getelementptr ir<%p>, vp<%4>
; CHECK-NEXT:     vp<%6> = vector-pointer ir<%arrayidx>
; CHECK-NEXT:     WIDEN store vp<%6>, ir<0>, vp<%5>
; CHECK-NEXT:     EMIT vp<%7> = add nuw vp<%3>, vp<%1>
; CHECK-NEXT:     EMIT vp<%8> = not vp<%5>
; CHECK-NEXT:     EMIT vp<%9> = any-of vp<%8>
 ; CHECK-NEXT:    EMIT vp<%10> = icmp eq vp<%7>, vp<%2>
; CHECK-NEXT:     EMIT branch-on-multi-cond vp<%9>, vp<%10>
; CHECK-NEXT:   No successors
; CHECK-NEXT: }
; CHECK-NEXT: Successor(s): ir-bb<e1>, middle.block
; CHECK-EMPTY:
; CHECK-NEXT: ir-bb<e1>:
; CHECK-NEXT:   IR %p1 = phi i64 [ 0, %loop.header ] (extra operand: ir<0>)
; CHECK-NEXT: No successors
; CHECK-EMPTY:
; CHECK-NEXT: middle.block:
; CHECK-NEXT:   EMIT vp<%12> = icmp eq ir<128>, vp<%2>
; CHECK-NEXT:   EMIT branch-on-cond vp<%12>
; CHECK-NEXT: Successor(s): ir-bb<e2>, scalar.ph
; CHECK-EMPTY:
; CHECK-NEXT: ir-bb<e2>:
; CHECK-NEXT:  IR %p2 = phi i64 [ 1, %loop.latch ] (extra operand: ir<1>)
; CHECK-NEXT: No successors
; CHECK-EMPTY:
; CHECK-NEXT: scalar.ph:
; CHECK-NEXT: No successors
; CHECK-NEXT: }
;
entry:
  br label %loop.header

loop.header:
  %iv = phi i64 [ %inc, %loop.latch ], [ 0, %entry ]
  %c.1 = icmp uge i64 %iv, %N
  br i1 %c.1, label %e1, label %loop.latch

loop.latch:
  %arrayidx = getelementptr inbounds nuw i32, ptr %p, i64 %iv
  store i32 0, ptr %arrayidx
  %inc = add nuw i64 %iv, 1
  %c.2 = icmp eq i64 %inc, 128
  br i1 %c.2, label %e2, label %loop.header

e1:
  %p1 = phi i64 [ 0, %loop.header ]
  ret i64 %p1

e2:
  %p2 = phi i64 [ 1, %loop.latch ]
  ret i64 %p2
}

define i64 @multi_exiting_to_same_exit_with_store(ptr %p, i64 %N) {
; CHECK-LABEL: VPlan 'Final VPlan for VF={2,4,8},UF={1}' {
; CHECK-NEXT: Live-in vp<%0> = VF
; CHECK-NEXT: Live-in vp<%1> = VF * UF
; CHECK-NEXT: Live-in vp<%2> = vector-trip-count
; CHECK-NEXT: Live-in ir<128> = original trip-count
; CHECK-EMPTY:
; CHECK-NEXT: vector.ph:
; CHECK-NEXT: Successor(s): vector loop
; CHECK-EMPTY:
; CHECK-NEXT: <x1> vector loop: {
; CHECK-NEXT:   vector.body:
; CHECK-NEXT:     EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%7>
; CHECK-NEXT:     WIDEN-INDUCTION %iv = phi %inc, 0, ir<1>, vp<%0>
; CHECK-NEXT:     vp<%4> = SCALAR-STEPS vp<%3>, ir<1>
; CHECK-NEXT:     WIDEN ir<%c.1> = icmp uge ir<%iv>, ir<%N>
; CHECK-NEXT:     EMIT vp<%5> = not ir<%c.1>
; CHECK-NEXT:     CLONE ir<%arrayidx> = getelementptr ir<%p>, vp<%4>
; CHECK-NEXT:     vp<%6> = vector-pointer ir<%arrayidx>
; CHECK-NEXT:     WIDEN store vp<%6>, ir<0>, vp<%5>
; CHECK-NEXT:     EMIT vp<%7> = add nuw vp<%3>, vp<%1>
; CHECK-NEXT:     EMIT vp<%8> = not vp<%5>
; CHECK-NEXT:     EMIT vp<%9> = any-of vp<%8>
 ; CHECK-NEXT:    EMIT vp<%10> = icmp eq vp<%7>, vp<%2>
; CHECK-NEXT:     EMIT branch-on-multi-cond vp<%9>, vp<%10>
; CHECK-NEXT:   No successors
; CHECK-NEXT: }
; CHECK-NEXT: Successor(s): ir-bb<e>, middle.block
; CHECK-EMPTY:
; CHECK-NEXT: ir-bb<e>:
; CHECK-NEXT:    IR   %p1 = phi i64 [ 0, %loop.header ], [ 1, %loop.latch ] (extra operand: ir<0>, ir<1>)
; CHECK-NEXT: No successors
; CHECK-EMPTY:
; CHECK-NEXT: middle.block:
; CHECK-NEXT:   EMIT vp<%12> = icmp eq ir<128>, vp<%2>
; CHECK-NEXT:   EMIT branch-on-cond vp<%12>
; CHECK-NEXT: Successor(s): ir-bb<e>, scalar.ph
; CHECK-EMPTY:
; CHECK-NEXT: scalar.ph:
; CHECK-NEXT: No successors
; CHECK-NEXT: }
;
entry:
  br label %loop.header

loop.header:
  %iv = phi i64 [ %inc, %loop.latch ], [ 0, %entry ]
  %c.1 = icmp uge i64 %iv, %N
  br i1 %c.1, label %e, label %loop.latch

loop.latch:
  %arrayidx = getelementptr inbounds nuw i32, ptr %p, i64 %iv
  store i32 0, ptr %arrayidx
  %inc = add nuw i64 %iv, 1
  %c.2 = icmp eq i64 %inc, 128
  br i1 %c.2, label %e, label %loop.header

e:
  %p1 = phi i64 [ 0, %loop.header ], [ 1, %loop.latch ]
  ret i64 %p1
}
