; NOTE: Assertions have been autogenerated by utils/update_analyze_test_checks.py UTC_ARGS: --version 5
; REQUIRES: asserts

; RUN: opt -passes=loop-vectorize -debug-only=loop-vectorize -force-vector-width=4 \
; RUN: -force-tail-folding-style=data-with-evl \
; RUN: -prefer-predicate-over-epilogue=predicate-dont-vectorize \
; RUN: -mtriple=x86_64 -mattr=+avx512f -disable-output < %s 2>&1 | FileCheck --check-prefix=IF-EVL %s

; RUN: opt -passes=loop-vectorize -debug-only=loop-vectorize -force-vector-width=4 \
; RUN: -force-tail-folding-style=none \
; RUN: -prefer-predicate-over-epilogue=predicate-else-scalar-epilogue \
; RUN: -mtriple=x86_64 -mattr=+avx512f -disable-output < %s 2>&1 | FileCheck --check-prefix=NO-VP %s

define void @foo(ptr noalias %a, ptr noalias %b, ptr noalias %c, i64 %N) {
; IF-EVL-LABEL: 'foo'
; IF-EVL-NEXT:  LV: Loop hints: force=? width=4 interleave=0
; IF-EVL-NEXT:  LV: Found a loop: for.body
; IF-EVL-NEXT:  LV: Found an induction variable.
; IF-EVL-NEXT:  LV: We can vectorize this loop!
; IF-EVL-NEXT:  LV: Found trip count: 0
; IF-EVL-NEXT:  LV: vector predicate hint/switch found.
; IF-EVL-NEXT:  LV: Not allowing scalar epilogue, creating predicated vector loop.
; IF-EVL-NEXT:  LV: The max safe fixed VF is: 67108864.
; IF-EVL-NEXT:  LV: The max safe scalable VF is: vscale x 0.
; IF-EVL-NEXT:  LV: checking if tail can be folded by masking.
; IF-EVL-NEXT:  LV: can fold tail by masking.
; IF-EVL-NEXT:  LV: Preference for VP intrinsics indicated. Will not try to generate VP Intrinsics due to non-interleaving reasons.
; IF-EVL-NEXT:  LV: Invalidate all interleaved groups due to fold-tail by masking which requires masked-interleaved support.
; IF-EVL-NEXT:  LV: Found uniform instruction: %exitcond.not = icmp eq i64 %iv.next, %N
; IF-EVL-NEXT:  LV: Found uniform instruction: %arrayidx = getelementptr inbounds i32, ptr %b, i64 %iv
; IF-EVL-NEXT:  LV: Found uniform instruction: %arrayidx2 = getelementptr inbounds i32, ptr %c, i64 %iv
; IF-EVL-NEXT:  LV: Found uniform instruction: %arrayidx4 = getelementptr inbounds i32, ptr %a, i64 %iv
; IF-EVL-NEXT:  LV: Found uniform instruction: %iv = phi i64 [ 0, %entry ], [ %iv.next, %for.body ]
; IF-EVL-NEXT:  LV: Found uniform instruction: %iv.next = add nuw nsw i64 %iv, 1
; IF-EVL-NEXT:  LV: Found an estimated cost of 0 for VF 4 For instruction: %iv = phi i64 [ 0, %entry ], [ %iv.next, %for.body ]
; IF-EVL-NEXT:  LV: Found an estimated cost of 0 for VF 4 For instruction: %arrayidx = getelementptr inbounds i32, ptr %b, i64 %iv
; IF-EVL-NEXT:  LV: Found an estimated cost of 1 for VF 4 For instruction: %0 = load i32, ptr %arrayidx, align 4
; IF-EVL-NEXT:  LV: Found an estimated cost of 0 for VF 4 For instruction: %arrayidx2 = getelementptr inbounds i32, ptr %c, i64 %iv
; IF-EVL-NEXT:  LV: Found an estimated cost of 1 for VF 4 For instruction: %1 = load i32, ptr %arrayidx2, align 4
; IF-EVL-NEXT:  LV: Found an estimated cost of 1 for VF 4 For instruction: %add = add nsw i32 %1, %0
; IF-EVL-NEXT:  LV: Found an estimated cost of 0 for VF 4 For instruction: %arrayidx4 = getelementptr inbounds i32, ptr %a, i64 %iv
; IF-EVL-NEXT:  LV: Found an estimated cost of 1 for VF 4 For instruction: store i32 %add, ptr %arrayidx4, align 4
; IF-EVL-NEXT:  LV: Found an estimated cost of 1 for VF 4 For instruction: %iv.next = add nuw nsw i64 %iv, 1
; IF-EVL-NEXT:  LV: Found an estimated cost of 1 for VF 4 For instruction: %exitcond.not = icmp eq i64 %iv.next, %N
; IF-EVL-NEXT:  LV: Found an estimated cost of 0 for VF 4 For instruction: br i1 %exitcond.not, label %for.cond.cleanup, label %for.body
; IF-EVL-NEXT:  LV: Using user VF 4.
; IF-EVL-NEXT:  LV: Scalarizing: %arrayidx = getelementptr inbounds i32, ptr %b, i64 %iv
; IF-EVL-NEXT:  LV: Scalarizing: %arrayidx2 = getelementptr inbounds i32, ptr %c, i64 %iv
; IF-EVL-NEXT:  LV: Scalarizing: %arrayidx4 = getelementptr inbounds i32, ptr %a, i64 %iv
; IF-EVL-NEXT:  LV: Scalarizing: %iv.next = add nuw nsw i64 %iv, 1
; IF-EVL-NEXT:  LV: Scalarizing: %exitcond.not = icmp eq i64 %iv.next, %N
; IF-EVL-NEXT:  VPlan 'Initial VPlan for VF={4},UF>=1' {
; IF-EVL-NEXT:  Live-in vp<%0> = VF * UF
; IF-EVL-NEXT:  Live-in vp<%1> = vector-trip-count
; IF-EVL-NEXT:  Live-in ir<%N> = original trip-count
; IF-EVL-EMPTY:
; IF-EVL-NEXT:  vector.ph:
; IF-EVL-NEXT:  Successor(s): vector loop
; IF-EVL-EMPTY:
; IF-EVL-NEXT:  <x1> vector loop: {
; IF-EVL-NEXT:    vector.body:
; IF-EVL-NEXT:      EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%9>
; IF-EVL-NEXT:      vp<%4> = SCALAR-STEPS vp<%3>, ir<1>
; IF-EVL-NEXT:      EMIT vp<%5> = active lane mask vp<%4>, ir<%N>
; IF-EVL-NEXT:      CLONE ir<%arrayidx> = getelementptr inbounds ir<%b>, vp<%4>
; IF-EVL-NEXT:      vp<%6> = vector-pointer ir<%arrayidx>
; IF-EVL-NEXT:      WIDEN ir<%0> = load vp<%6>, vp<%5>
; IF-EVL-NEXT:      CLONE ir<%arrayidx2> = getelementptr inbounds ir<%c>, vp<%4>
; IF-EVL-NEXT:      vp<%7> = vector-pointer ir<%arrayidx2>
; IF-EVL-NEXT:      WIDEN ir<%1> = load vp<%7>, vp<%5>
; IF-EVL-NEXT:      WIDEN ir<%add> = add nsw ir<%1>, ir<%0>
; IF-EVL-NEXT:      CLONE ir<%arrayidx4> = getelementptr inbounds ir<%a>, vp<%4>
; IF-EVL-NEXT:      vp<%8> = vector-pointer ir<%arrayidx4>
; IF-EVL-NEXT:      WIDEN store vp<%8>, ir<%add>, vp<%5>
; IF-EVL-NEXT:      EMIT vp<%9> = add vp<%3>, vp<%0>
; IF-EVL-NEXT:      EMIT branch-on-count vp<%9>, vp<%1>
; IF-EVL-NEXT:    No successors
; IF-EVL-NEXT:  }
; IF-EVL-NEXT:  Successor(s): middle.block
; IF-EVL-EMPTY:
; IF-EVL-NEXT:  middle.block:
; IF-EVL-NEXT:  No successors
; IF-EVL-NEXT:  }
; IF-EVL-NEXT:  LV: Interleaving is not beneficial.
; IF-EVL-NEXT:  LV: Found a vectorizable loop (4) in <stdin>
; IF-EVL-NEXT:  LEV: Unable to vectorize epilogue because no epilogue is allowed.
; IF-EVL-NEXT:  Executing best plan with VF=4, UF=1
; IF-EVL-NEXT:  VPlan 'Final VPlan for VF={4},UF>=1' {
; IF-EVL-NEXT:  Live-in vp<%0> = VF * UF
; IF-EVL-NEXT:  Live-in vp<%1> = vector-trip-count
; IF-EVL-NEXT:  Live-in ir<%N> = original trip-count
; IF-EVL-EMPTY:
; IF-EVL-NEXT:  vector.ph:
; IF-EVL-NEXT:  Successor(s): vector loop
; IF-EVL-EMPTY:
; IF-EVL-NEXT:  <x1> vector loop: {
; IF-EVL-NEXT:    vector.body:
; IF-EVL-NEXT:      EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%9>
; IF-EVL-NEXT:      vp<%4> = SCALAR-STEPS vp<%3>, ir<1>
; IF-EVL-NEXT:      EMIT vp<%5> = active lane mask vp<%4>, ir<%N>
; IF-EVL-NEXT:      CLONE ir<%arrayidx> = getelementptr inbounds ir<%b>, vp<%4>
; IF-EVL-NEXT:      vp<%6> = vector-pointer ir<%arrayidx>
; IF-EVL-NEXT:      WIDEN ir<%0> = load vp<%6>, vp<%5>
; IF-EVL-NEXT:      CLONE ir<%arrayidx2> = getelementptr inbounds ir<%c>, vp<%4>
; IF-EVL-NEXT:      vp<%7> = vector-pointer ir<%arrayidx2>
; IF-EVL-NEXT:      WIDEN ir<%1> = load vp<%7>, vp<%5>
; IF-EVL-NEXT:      WIDEN ir<%add> = add nsw ir<%1>, ir<%0>
; IF-EVL-NEXT:      CLONE ir<%arrayidx4> = getelementptr inbounds ir<%a>, vp<%4>
; IF-EVL-NEXT:      vp<%8> = vector-pointer ir<%arrayidx4>
; IF-EVL-NEXT:      WIDEN store vp<%8>, ir<%add>, vp<%5>
; IF-EVL-NEXT:      EMIT vp<%9> = add vp<%3>, vp<%0>
; IF-EVL-NEXT:      EMIT branch-on-count vp<%9>, vp<%1>
; IF-EVL-NEXT:    No successors
; IF-EVL-NEXT:  }
; IF-EVL-NEXT:  Successor(s): middle.block
; IF-EVL-EMPTY:
; IF-EVL-NEXT:  middle.block:
; IF-EVL-NEXT:  No successors
; IF-EVL-NEXT:  }
; IF-EVL-NEXT:  LV: Interleaving disabled by the pass manager
; IF-EVL-NEXT:  LV: Vectorizing: innermost loop.
;
; NO-VP-LABEL: 'foo'
; NO-VP-NEXT:  LV: Loop hints: force=? width=4 interleave=0
; NO-VP-NEXT:  LV: Found a loop: for.body
; NO-VP-NEXT:  LV: Found an induction variable.
; NO-VP-NEXT:  LV: We can vectorize this loop!
; NO-VP-NEXT:  LV: Found trip count: 0
; NO-VP-NEXT:  LV: vector predicate hint/switch found.
; NO-VP-NEXT:  LV: Not allowing scalar epilogue, creating predicated vector loop.
; NO-VP-NEXT:  LV: The max safe fixed VF is: 67108864.
; NO-VP-NEXT:  LV: The max safe scalable VF is: vscale x 0.
; NO-VP-NEXT:  LV: checking if tail can be folded by masking.
; NO-VP-NEXT:  LV: can fold tail by masking.
; NO-VP-NEXT:  LV: Cannot fold tail by masking: vectorize with a scalar epilogue instead.
; NO-VP-NEXT:  LV: Found uniform instruction: %exitcond.not = icmp eq i64 %iv.next, %N
; NO-VP-NEXT:  LV: Found uniform instruction: %arrayidx = getelementptr inbounds i32, ptr %b, i64 %iv
; NO-VP-NEXT:  LV: Found uniform instruction: %arrayidx2 = getelementptr inbounds i32, ptr %c, i64 %iv
; NO-VP-NEXT:  LV: Found uniform instruction: %arrayidx4 = getelementptr inbounds i32, ptr %a, i64 %iv
; NO-VP-NEXT:  LV: Found uniform instruction: %iv = phi i64 [ 0, %entry ], [ %iv.next, %for.body ]
; NO-VP-NEXT:  LV: Found uniform instruction: %iv.next = add nuw nsw i64 %iv, 1
; NO-VP-NEXT:  LV: Found scalar instruction: %iv = phi i64 [ 0, %entry ], [ %iv.next, %for.body ]
; NO-VP-NEXT:  LV: Found scalar instruction: %iv.next = add nuw nsw i64 %iv, 1
; NO-VP-NEXT:  LV: Found an estimated cost of 0 for VF 4 For instruction: %iv = phi i64 [ 0, %entry ], [ %iv.next, %for.body ]
; NO-VP-NEXT:  LV: Found an estimated cost of 0 for VF 4 For instruction: %arrayidx = getelementptr inbounds i32, ptr %b, i64 %iv
; NO-VP-NEXT:  LV: Found an estimated cost of 1 for VF 4 For instruction: %0 = load i32, ptr %arrayidx, align 4
; NO-VP-NEXT:  LV: Found an estimated cost of 0 for VF 4 For instruction: %arrayidx2 = getelementptr inbounds i32, ptr %c, i64 %iv
; NO-VP-NEXT:  LV: Found an estimated cost of 1 for VF 4 For instruction: %1 = load i32, ptr %arrayidx2, align 4
; NO-VP-NEXT:  LV: Found an estimated cost of 1 for VF 4 For instruction: %add = add nsw i32 %1, %0
; NO-VP-NEXT:  LV: Found an estimated cost of 0 for VF 4 For instruction: %arrayidx4 = getelementptr inbounds i32, ptr %a, i64 %iv
; NO-VP-NEXT:  LV: Found an estimated cost of 1 for VF 4 For instruction: store i32 %add, ptr %arrayidx4, align 4
; NO-VP-NEXT:  LV: Found an estimated cost of 1 for VF 4 For instruction: %iv.next = add nuw nsw i64 %iv, 1
; NO-VP-NEXT:  LV: Found an estimated cost of 1 for VF 4 For instruction: %exitcond.not = icmp eq i64 %iv.next, %N
; NO-VP-NEXT:  LV: Found an estimated cost of 0 for VF 4 For instruction: br i1 %exitcond.not, label %for.cond.cleanup, label %for.body
; NO-VP-NEXT:  LV: Using user VF 4.
; NO-VP-NEXT:  LV: Scalarizing: %arrayidx = getelementptr inbounds i32, ptr %b, i64 %iv
; NO-VP-NEXT:  LV: Scalarizing: %arrayidx2 = getelementptr inbounds i32, ptr %c, i64 %iv
; NO-VP-NEXT:  LV: Scalarizing: %arrayidx4 = getelementptr inbounds i32, ptr %a, i64 %iv
; NO-VP-NEXT:  LV: Scalarizing: %iv.next = add nuw nsw i64 %iv, 1
; NO-VP-NEXT:  LV: Scalarizing: %exitcond.not = icmp eq i64 %iv.next, %N
; NO-VP-NEXT:  VPlan 'Initial VPlan for VF={4},UF>=1' {
; NO-VP-NEXT:  Live-in vp<%0> = VF * UF
; NO-VP-NEXT:  Live-in vp<%1> = vector-trip-count
; NO-VP-NEXT:  Live-in ir<%N> = original trip-count
; NO-VP-EMPTY:
; NO-VP-NEXT:  vector.ph:
; NO-VP-NEXT:  Successor(s): vector loop
; NO-VP-EMPTY:
; NO-VP-NEXT:  <x1> vector loop: {
; NO-VP-NEXT:    vector.body:
; NO-VP-NEXT:      EMIT vp<%2> = CANONICAL-INDUCTION ir<0>, vp<%7>
; NO-VP-NEXT:      vp<%3> = SCALAR-STEPS vp<%2>, ir<1>
; NO-VP-NEXT:      CLONE ir<%arrayidx> = getelementptr inbounds ir<%b>, vp<%3>
; NO-VP-NEXT:      vp<%4> = vector-pointer ir<%arrayidx>
; NO-VP-NEXT:      WIDEN ir<%0> = load vp<%4>
; NO-VP-NEXT:      CLONE ir<%arrayidx2> = getelementptr inbounds ir<%c>, vp<%3>
; NO-VP-NEXT:      vp<%5> = vector-pointer ir<%arrayidx2>
; NO-VP-NEXT:      WIDEN ir<%1> = load vp<%5>
; NO-VP-NEXT:      WIDEN ir<%add> = add nsw ir<%1>, ir<%0>
; NO-VP-NEXT:      CLONE ir<%arrayidx4> = getelementptr inbounds ir<%a>, vp<%3>
; NO-VP-NEXT:      vp<%6> = vector-pointer ir<%arrayidx4>
; NO-VP-NEXT:      WIDEN store vp<%6>, ir<%add>
; NO-VP-NEXT:      EMIT vp<%7> = add nuw vp<%2>, vp<%0>
; NO-VP-NEXT:      EMIT branch-on-count vp<%7>, vp<%1>
; NO-VP-NEXT:    No successors
; NO-VP-NEXT:  }
; NO-VP-NEXT:  Successor(s): middle.block
; NO-VP-EMPTY:
; NO-VP-NEXT:  middle.block:
; NO-VP-NEXT:  No successors
; NO-VP-NEXT:  }
; NO-VP-NEXT:  LV: Found an estimated cost of 0 for VF 4 For instruction: %iv = phi i64 [ 0, %entry ], [ %iv.next, %for.body ]
; NO-VP-NEXT:  LV: Found an estimated cost of 0 for VF 4 For instruction: %arrayidx = getelementptr inbounds i32, ptr %b, i64 %iv
; NO-VP-NEXT:  LV: Found an estimated cost of 1 for VF 4 For instruction: %0 = load i32, ptr %arrayidx, align 4
; NO-VP-NEXT:  LV: Found an estimated cost of 0 for VF 4 For instruction: %arrayidx2 = getelementptr inbounds i32, ptr %c, i64 %iv
; NO-VP-NEXT:  LV: Found an estimated cost of 1 for VF 4 For instruction: %1 = load i32, ptr %arrayidx2, align 4
; NO-VP-NEXT:  LV: Found an estimated cost of 1 for VF 4 For instruction: %add = add nsw i32 %1, %0
; NO-VP-NEXT:  LV: Found an estimated cost of 0 for VF 4 For instruction: %arrayidx4 = getelementptr inbounds i32, ptr %a, i64 %iv
; NO-VP-NEXT:  LV: Found an estimated cost of 1 for VF 4 For instruction: store i32 %add, ptr %arrayidx4, align 4
; NO-VP-NEXT:  LV: Found an estimated cost of 1 for VF 4 For instruction: %iv.next = add nuw nsw i64 %iv, 1
; NO-VP-NEXT:  LV: Found an estimated cost of 1 for VF 4 For instruction: %exitcond.not = icmp eq i64 %iv.next, %N
; NO-VP-NEXT:  LV: Found an estimated cost of 0 for VF 4 For instruction: br i1 %exitcond.not, label %for.cond.cleanup, label %for.body
; NO-VP-NEXT:  LV(REG): Calculating max register usage:
; NO-VP-NEXT:  LV(REG): At #0 Interval # 0
; NO-VP-NEXT:  LV(REG): At #1 Interval # 1
; NO-VP-NEXT:  LV(REG): At #2 Interval # 2
; NO-VP-NEXT:  LV(REG): At #3 Interval # 2
; NO-VP-NEXT:  LV(REG): At #4 Interval # 3
; NO-VP-NEXT:  LV(REG): At #5 Interval # 3
; NO-VP-NEXT:  LV(REG): At #6 Interval # 2
; NO-VP-NEXT:  LV(REG): At #8 Interval # 1
; NO-VP-NEXT:  LV(REG): At #9 Interval # 1
; NO-VP-NEXT:  LV(REG): VF = 4
; NO-VP-NEXT:  LV(REG): Found max usage: 2 item
; NO-VP-NEXT:  LV(REG): RegisterClass: Generic::ScalarRC, 2 registers
; NO-VP-NEXT:  LV(REG): RegisterClass: Generic::VectorRC, 2 registers
; NO-VP-NEXT:  LV(REG): Found invariant usage: 0 item
; NO-VP-NEXT:  LV: The target has 16 registers of Generic::ScalarRC register class
; NO-VP-NEXT:  LV: The target has 32 registers of Generic::VectorRC register class
; NO-VP-NEXT:  LV: Loop cost is 6
; NO-VP-NEXT:  LV: IC is 4
; NO-VP-NEXT:  LV: VF is 4
; NO-VP-NEXT:  LV: Interleaving to saturate store or load ports.
; NO-VP-NEXT:  LV: Found a vectorizable loop (4) in <stdin>
; NO-VP-NEXT:  LV: Interleave Count is 4
; NO-VP-NEXT:  LEV: Epilogue vectorization is not profitable for this loop
; NO-VP-NEXT:  Executing best plan with VF=4, UF=4
; NO-VP-NEXT:  VPlan 'Final VPlan for VF={4},UF>=1' {
; NO-VP-NEXT:  Live-in vp<%0> = VF * UF
; NO-VP-NEXT:  Live-in vp<%1> = vector-trip-count
; NO-VP-NEXT:  Live-in ir<%N> = original trip-count
; NO-VP-EMPTY:
; NO-VP-NEXT:  vector.ph:
; NO-VP-NEXT:  Successor(s): vector loop
; NO-VP-EMPTY:
; NO-VP-NEXT:  <x1> vector loop: {
; NO-VP-NEXT:    vector.body:
; NO-VP-NEXT:      EMIT vp<%2> = CANONICAL-INDUCTION ir<0>, vp<%7>
; NO-VP-NEXT:      vp<%3> = SCALAR-STEPS vp<%2>, ir<1>
; NO-VP-NEXT:      CLONE ir<%arrayidx> = getelementptr inbounds ir<%b>, vp<%3>
; NO-VP-NEXT:      vp<%4> = vector-pointer ir<%arrayidx>
; NO-VP-NEXT:      WIDEN ir<%0> = load vp<%4>
; NO-VP-NEXT:      CLONE ir<%arrayidx2> = getelementptr inbounds ir<%c>, vp<%3>
; NO-VP-NEXT:      vp<%5> = vector-pointer ir<%arrayidx2>
; NO-VP-NEXT:      WIDEN ir<%1> = load vp<%5>
; NO-VP-NEXT:      WIDEN ir<%add> = add nsw ir<%1>, ir<%0>
; NO-VP-NEXT:      CLONE ir<%arrayidx4> = getelementptr inbounds ir<%a>, vp<%3>
; NO-VP-NEXT:      vp<%6> = vector-pointer ir<%arrayidx4>
; NO-VP-NEXT:      WIDEN store vp<%6>, ir<%add>
; NO-VP-NEXT:      EMIT vp<%7> = add nuw vp<%2>, vp<%0>
; NO-VP-NEXT:      EMIT branch-on-count vp<%7>, vp<%1>
; NO-VP-NEXT:    No successors
; NO-VP-NEXT:  }
; NO-VP-NEXT:  Successor(s): middle.block
; NO-VP-EMPTY:
; NO-VP-NEXT:  middle.block:
; NO-VP-NEXT:  No successors
; NO-VP-NEXT:  }
; NO-VP-NEXT:  LV: Interleaving disabled by the pass manager
; NO-VP-NEXT:  LV: Vectorizing: innermost loop.
;


entry:
  br label %for.body

for.body:
  %iv = phi i64 [ 0, %entry ], [ %iv.next, %for.body ]
  %arrayidx = getelementptr inbounds i32, ptr %b, i64 %iv
  %0 = load i32, ptr %arrayidx, align 4
  %arrayidx2 = getelementptr inbounds i32, ptr %c, i64 %iv
  %1 = load i32, ptr %arrayidx2, align 4
  %add = add nsw i32 %1, %0
  %arrayidx4 = getelementptr inbounds i32, ptr %a, i64 %iv
  store i32 %add, ptr %arrayidx4, align 4
  %iv.next = add nuw nsw i64 %iv, 1
  %exitcond.not = icmp eq i64 %iv.next, %N
  br i1 %exitcond.not, label %for.cond.cleanup, label %for.body

for.cond.cleanup:
  ret void
}
