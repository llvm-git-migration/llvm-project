; NOTE: Assertions have been autogenerated by utils/update_analyze_test_checks.py UTC_ARGS: --version 5
; REQUIRES: asserts

; RUN: opt -passes=loop-vectorize -debug-only=loop-vectorize \
; RUN: -force-tail-folding-style=data-with-evl \
; RUN: -prefer-predicate-over-epilogue=predicate-dont-vectorize \
; RUN: -mtriple=powerpc64le-unknown-linux-gnu \
; RUN: -mcpu=pwr10 -disable-output < %s 2>&1 | FileCheck %s

define void @foo(ptr noalias %a, ptr noalias %b, ptr noalias %c, i64 %N) {
; CHECK-LABEL: 'foo'
; CHECK-NEXT:  LV: Loop hints: force=? width=0 interleave=0
; CHECK-NEXT:  LV: Found a loop: for.body
; CHECK-NEXT:  LV: Found an induction variable.
; CHECK-NEXT:  LV: We can vectorize this loop!
; CHECK-NEXT:  LV: Found trip count: 0
; CHECK-NEXT:  LV: vector predicate hint/switch found.
; CHECK-NEXT:  LV: Not allowing scalar epilogue, creating predicated vector loop.
; CHECK-NEXT:  LV: The max safe fixed VF is: 67108864.
; CHECK-NEXT:  LV: The max safe scalable VF is: vscale x 0.
; CHECK-NEXT:  LV: The Smallest and Widest types: 32 / 32 bits.
; CHECK-NEXT:  LV: The Widest register safe to use is: 128 bits.
; CHECK-NEXT:  LV: The Widest register safe to use is: vscale x 0 bits.
; CHECK-NEXT:  LV: The target has no scalable vector registers.
; CHECK-NEXT:  LV: checking if tail can be folded by masking.
; CHECK-NEXT:  LV: can fold tail by masking.
; CHECK-NEXT:  LV: Preference for VP intrinsics indicated. Will not try to generate VP Intrinsics due to non-interleaving reasons.
; CHECK-NEXT:  LV: Invalidate all interleaved groups due to fold-tail by masking which requires masked-interleaved support.
; CHECK-NEXT:  LV: Found uniform instruction: %exitcond.not = icmp eq i64 %iv.next, %N
; CHECK-NEXT:  LV: Found scalar instruction: %arrayidx = getelementptr inbounds i32, ptr %b, i64 %iv
; CHECK-NEXT:  LV: Found scalar instruction: %arrayidx2 = getelementptr inbounds i32, ptr %c, i64 %iv
; CHECK-NEXT:  LV: Found scalar instruction: %arrayidx4 = getelementptr inbounds i32, ptr %a, i64 %iv
; CHECK-NEXT:  LV: Found uniform instruction: %exitcond.not = icmp eq i64 %iv.next, %N
; CHECK-NEXT:  LV: Found scalar instruction: %arrayidx = getelementptr inbounds i32, ptr %b, i64 %iv
; CHECK-NEXT:  LV: Found scalar instruction: %arrayidx2 = getelementptr inbounds i32, ptr %c, i64 %iv
; CHECK-NEXT:  LV: Found scalar instruction: %arrayidx4 = getelementptr inbounds i32, ptr %a, i64 %iv
; CHECK-NEXT:  LV: Scalarizing: %arrayidx = getelementptr inbounds i32, ptr %b, i64 %iv
; CHECK-NEXT:  LV: Scalarizing and predicating: %0 = load i32, ptr %arrayidx, align 4
; CHECK-NEXT:  LV: Scalarizing: %arrayidx2 = getelementptr inbounds i32, ptr %c, i64 %iv
; CHECK-NEXT:  LV: Scalarizing and predicating: %1 = load i32, ptr %arrayidx2, align 4
; CHECK-NEXT:  LV: Scalarizing: %add = add nsw i32 %1, %0
; CHECK-NEXT:  LV: Scalarizing: %arrayidx4 = getelementptr inbounds i32, ptr %a, i64 %iv
; CHECK-NEXT:  LV: Scalarizing and predicating: store i32 %add, ptr %arrayidx4, align 4
; CHECK-NEXT:  LV: Scalarizing: %iv.next = add nuw nsw i64 %iv, 1
; CHECK-NEXT:  LV: Scalarizing: %exitcond.not = icmp eq i64 %iv.next, %N
; CHECK-NEXT:  LV: Scalarizing: %arrayidx = getelementptr inbounds i32, ptr %b, i64 %iv
; CHECK-NEXT:  LV: Scalarizing and predicating: %0 = load i32, ptr %arrayidx, align 4
; CHECK-NEXT:  LV: Scalarizing: %arrayidx2 = getelementptr inbounds i32, ptr %c, i64 %iv
; CHECK-NEXT:  LV: Scalarizing and predicating: %1 = load i32, ptr %arrayidx2, align 4
; CHECK-NEXT:  LV: Scalarizing: %add = add nsw i32 %1, %0
; CHECK-NEXT:  LV: Scalarizing: %arrayidx4 = getelementptr inbounds i32, ptr %a, i64 %iv
; CHECK-NEXT:  LV: Scalarizing and predicating: store i32 %add, ptr %arrayidx4, align 4
; CHECK-NEXT:  LV: Scalarizing: %exitcond.not = icmp eq i64 %iv.next, %N
; CHECK-NEXT:  VPlan 'Initial VPlan for VF={1},UF>=1' {
; CHECK-NEXT:  Live-in vp<%0> = VF * UF
; CHECK-NEXT:  Live-in vp<%1> = vector-trip-count
; CHECK-NEXT:  Live-in ir<%N> = original trip-count
; CHECK-EMPTY:
; CHECK-NEXT:  vector.ph:
; CHECK-NEXT:  Successor(s): vector loop
; CHECK-EMPTY:
; CHECK-NEXT:  <x1> vector loop: {
; CHECK-NEXT:    vector.body:
; CHECK-NEXT:      EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%8>
; CHECK-NEXT:      vp<%4> = SCALAR-STEPS vp<%3>, ir<1>
; CHECK-NEXT:      EMIT vp<%5> = active lane mask vp<%4>, ir<%N>
; CHECK-NEXT:    Successor(s): pred.store
; CHECK-EMPTY:
; CHECK-NEXT:    <xVFxUF> pred.store: {
; CHECK-NEXT:      pred.store.entry:
; CHECK-NEXT:        BRANCH-ON-MASK vp<%5>
; CHECK-NEXT:      Successor(s): pred.store.if, pred.store.continue
; CHECK-EMPTY:
; CHECK-NEXT:      pred.store.if:
; CHECK-NEXT:        CLONE ir<%arrayidx> = getelementptr inbounds ir<%b>, vp<%4>
; CHECK-NEXT:        CLONE ir<%0> = load ir<%arrayidx>
; CHECK-NEXT:        CLONE ir<%arrayidx2> = getelementptr inbounds ir<%c>, vp<%4>
; CHECK-NEXT:        CLONE ir<%1> = load ir<%arrayidx2>
; CHECK-NEXT:        CLONE ir<%arrayidx4> = getelementptr inbounds ir<%a>, vp<%4>
; CHECK-NEXT:        CLONE ir<%add> = add nsw ir<%1>, ir<%0>
; CHECK-NEXT:        CLONE store ir<%add>, ir<%arrayidx4>
; CHECK-NEXT:      Successor(s): pred.store.continue
; CHECK-EMPTY:
; CHECK-NEXT:      pred.store.continue:
; CHECK-NEXT:        PHI-PREDICATED-INSTRUCTION vp<%6> = ir<%0>
; CHECK-NEXT:        PHI-PREDICATED-INSTRUCTION vp<%7> = ir<%1>
; CHECK-NEXT:      No successors
; CHECK-NEXT:    }
; CHECK-NEXT:    Successor(s): for.body.2
; CHECK-EMPTY:
; CHECK-NEXT:    for.body.2:
; CHECK-NEXT:      EMIT vp<%8> = add vp<%3>, vp<%0>
; CHECK-NEXT:      EMIT branch-on-count vp<%8>, vp<%1>
; CHECK-NEXT:    No successors
; CHECK-NEXT:  }
; CHECK-NEXT:  Successor(s): middle.block
; CHECK-EMPTY:
; CHECK-NEXT:  middle.block:
; CHECK-NEXT:  No successors
; CHECK-NEXT:  }
; CHECK-NEXT:  VPlan 'Initial VPlan for VF={2,4},UF>=1' {
; CHECK-NEXT:  Live-in vp<%0> = VF * UF
; CHECK-NEXT:  Live-in vp<%1> = vector-trip-count
; CHECK-NEXT:  Live-in ir<%N> = original trip-count
; CHECK-EMPTY:
; CHECK-NEXT:  vector.ph:
; CHECK-NEXT:  Successor(s): vector loop
; CHECK-EMPTY:
; CHECK-NEXT:  <x1> vector loop: {
; CHECK-NEXT:    vector.body:
; CHECK-NEXT:      EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%8>
; CHECK-NEXT:      vp<%4> = SCALAR-STEPS vp<%3>, ir<1>
; CHECK-NEXT:      EMIT vp<%5> = active lane mask vp<%4>, ir<%N>
; CHECK-NEXT:    Successor(s): pred.store
; CHECK-EMPTY:
; CHECK-NEXT:    <xVFxUF> pred.store: {
; CHECK-NEXT:      pred.store.entry:
; CHECK-NEXT:        BRANCH-ON-MASK vp<%5>
; CHECK-NEXT:      Successor(s): pred.store.if, pred.store.continue
; CHECK-EMPTY:
; CHECK-NEXT:      pred.store.if:
; CHECK-NEXT:        REPLICATE ir<%arrayidx> = getelementptr inbounds ir<%b>, vp<%4>
; CHECK-NEXT:        REPLICATE ir<%0> = load ir<%arrayidx>
; CHECK-NEXT:        REPLICATE ir<%arrayidx2> = getelementptr inbounds ir<%c>, vp<%4>
; CHECK-NEXT:        REPLICATE ir<%1> = load ir<%arrayidx2>
; CHECK-NEXT:        REPLICATE ir<%arrayidx4> = getelementptr inbounds ir<%a>, vp<%4>
; CHECK-NEXT:        REPLICATE ir<%add> = add nsw ir<%1>, ir<%0>
; CHECK-NEXT:        REPLICATE store ir<%add>, ir<%arrayidx4>
; CHECK-NEXT:      Successor(s): pred.store.continue
; CHECK-EMPTY:
; CHECK-NEXT:      pred.store.continue:
; CHECK-NEXT:        PHI-PREDICATED-INSTRUCTION vp<%6> = ir<%0>
; CHECK-NEXT:        PHI-PREDICATED-INSTRUCTION vp<%7> = ir<%1>
; CHECK-NEXT:      No successors
; CHECK-NEXT:    }
; CHECK-NEXT:    Successor(s): for.body.2
; CHECK-EMPTY:
; CHECK-NEXT:    for.body.2:
; CHECK-NEXT:      EMIT vp<%8> = add vp<%3>, vp<%0>
; CHECK-NEXT:      EMIT branch-on-count vp<%8>, vp<%1>
; CHECK-NEXT:    No successors
; CHECK-NEXT:  }
; CHECK-NEXT:  Successor(s): middle.block
; CHECK-EMPTY:
; CHECK-NEXT:  middle.block:
; CHECK-NEXT:  No successors
; CHECK-NEXT:  }
; CHECK-NEXT:  LV: Found an estimated cost of 0 for VF 1 For instruction: %iv = phi i64 [ 0, %entry ], [ %iv.next, %for.body ]
; CHECK-NEXT:  LV: Found an estimated cost of 0 for VF 1 For instruction: %arrayidx = getelementptr inbounds i32, ptr %b, i64 %iv
; CHECK-NEXT:  LV: Found an estimated cost of 1 for VF 1 For instruction: %0 = load i32, ptr %arrayidx, align 4
; CHECK-NEXT:  LV: Found an estimated cost of 0 for VF 1 For instruction: %arrayidx2 = getelementptr inbounds i32, ptr %c, i64 %iv
; CHECK-NEXT:  LV: Found an estimated cost of 1 for VF 1 For instruction: %1 = load i32, ptr %arrayidx2, align 4
; CHECK-NEXT:  LV: Found an estimated cost of 1 for VF 1 For instruction: %add = add nsw i32 %1, %0
; CHECK-NEXT:  LV: Found an estimated cost of 0 for VF 1 For instruction: %arrayidx4 = getelementptr inbounds i32, ptr %a, i64 %iv
; CHECK-NEXT:  LV: Found an estimated cost of 1 for VF 1 For instruction: store i32 %add, ptr %arrayidx4, align 4
; CHECK-NEXT:  LV: Found an estimated cost of 1 for VF 1 For instruction: %iv.next = add nuw nsw i64 %iv, 1
; CHECK-NEXT:  LV: Found an estimated cost of 1 for VF 1 For instruction: %exitcond.not = icmp eq i64 %iv.next, %N
; CHECK-NEXT:  LV: Found an estimated cost of 0 for VF 1 For instruction: br i1 %exitcond.not, label %for.cond.cleanup, label %for.body
; CHECK-NEXT:  LV: Scalar loop costs: 6.
; CHECK-NEXT:  LV: Found an estimated cost of 0 for VF 2 For instruction: %iv = phi i64 [ 0, %entry ], [ %iv.next, %for.body ]
; CHECK-NEXT:  LV: Found an estimated cost of 0 for VF 2 For instruction: %arrayidx = getelementptr inbounds i32, ptr %b, i64 %iv
; CHECK-NEXT:  LV: Found an estimated cost of 3000000 for VF 2 For instruction: %0 = load i32, ptr %arrayidx, align 4
; CHECK-NEXT:  LV: Found an estimated cost of 0 for VF 2 For instruction: %arrayidx2 = getelementptr inbounds i32, ptr %c, i64 %iv
; CHECK-NEXT:  LV: Found an estimated cost of 3000000 for VF 2 For instruction: %1 = load i32, ptr %arrayidx2, align 4
; CHECK-NEXT:  LV: Found an estimated cost of 3 for VF 2 For instruction: %add = add nsw i32 %1, %0
; CHECK-NEXT:  LV: Found an estimated cost of 0 for VF 2 For instruction: %arrayidx4 = getelementptr inbounds i32, ptr %a, i64 %iv
; CHECK-NEXT:  LV: Found an estimated cost of 1 for VF 2 For instruction: store i32 %add, ptr %arrayidx4, align 4
; CHECK-NEXT:  LV: Found an estimated cost of 1 for VF 2 For instruction: %iv.next = add nuw nsw i64 %iv, 1
; CHECK-NEXT:  LV: Found an estimated cost of 1 for VF 2 For instruction: %exitcond.not = icmp eq i64 %iv.next, %N
; CHECK-NEXT:  LV: Found an estimated cost of 0 for VF 2 For instruction: br i1 %exitcond.not, label %for.cond.cleanup, label %for.body
; CHECK-NEXT:  LV: Vector loop of width 2 costs: 3000003.
; CHECK-NEXT:  LV: Found an estimated cost of 0 for VF 4 For instruction: %iv = phi i64 [ 0, %entry ], [ %iv.next, %for.body ]
; CHECK-NEXT:  LV: Found an estimated cost of 0 for VF 4 For instruction: %arrayidx = getelementptr inbounds i32, ptr %b, i64 %iv
; CHECK-NEXT:  LV: Found an estimated cost of 3000000 for VF 4 For instruction: %0 = load i32, ptr %arrayidx, align 4
; CHECK-NEXT:  LV: Found an estimated cost of 0 for VF 4 For instruction: %arrayidx2 = getelementptr inbounds i32, ptr %c, i64 %iv
; CHECK-NEXT:  LV: Found an estimated cost of 3000000 for VF 4 For instruction: %1 = load i32, ptr %arrayidx2, align 4
; CHECK-NEXT:  LV: Found an estimated cost of 6 for VF 4 For instruction: %add = add nsw i32 %1, %0
; CHECK-NEXT:  LV: Found an estimated cost of 0 for VF 4 For instruction: %arrayidx4 = getelementptr inbounds i32, ptr %a, i64 %iv
; CHECK-NEXT:  LV: Found an estimated cost of 2 for VF 4 For instruction: store i32 %add, ptr %arrayidx4, align 4
; CHECK-NEXT:  LV: Found an estimated cost of 2 for VF 4 For instruction: %iv.next = add nuw nsw i64 %iv, 1
; CHECK-NEXT:  LV: Found an estimated cost of 1 for VF 4 For instruction: %exitcond.not = icmp eq i64 %iv.next, %N
; CHECK-NEXT:  LV: Found an estimated cost of 0 for VF 4 For instruction: br i1 %exitcond.not, label %for.cond.cleanup, label %for.body
; CHECK-NEXT:  LV: Vector loop of width 4 costs: 1500002.
; CHECK-NEXT:  LV: Selecting VF: 1.
; CHECK-NEXT:  LV: Vectorization is possible but not beneficial.
; CHECK-NEXT:  LV: Interleaving is not beneficial.
; CHECK-EMPTY:
;
entry:
  br label %for.body

for.body:
  %iv = phi i64 [ 0, %entry ], [ %iv.next, %for.body ]
  %arrayidx = getelementptr inbounds i32, ptr %b, i64 %iv
  %0 = load i32, ptr %arrayidx, align 4
  %arrayidx2 = getelementptr inbounds i32, ptr %c, i64 %iv
  %1 = load i32, ptr %arrayidx2, align 4
  %add = add nsw i32 %1, %0
  %arrayidx4 = getelementptr inbounds i32, ptr %a, i64 %iv
  store i32 %add, ptr %arrayidx4, align 4
  %iv.next = add nuw nsw i64 %iv, 1
  %exitcond.not = icmp eq i64 %iv.next, %N
  br i1 %exitcond.not, label %for.cond.cleanup, label %for.body

for.cond.cleanup:
  ret void
}

define void @safe_dep(ptr %p) {
; CHECK-LABEL: 'safe_dep'
; CHECK-NEXT:  LV: Loop hints: force=? width=0 interleave=0
; CHECK-NEXT:  LV: Found a loop: loop
; CHECK-NEXT:  LV: Found an induction variable.
; CHECK-NEXT:  LV: We can vectorize this loop!
; CHECK-NEXT:  LV: Found trip count: 512
; CHECK-NEXT:  LV: vector predicate hint/switch found.
; CHECK-NEXT:  LV: Not allowing scalar epilogue, creating predicated vector loop.
; CHECK-NEXT:  LV: The max safe fixed VF is: 4.
; CHECK-NEXT:  LV: The max safe scalable VF is: vscale x 0.
; CHECK-NEXT:  LV: The Smallest and Widest types: 64 / 64 bits.
; CHECK-NEXT:  LV: The Widest register safe to use is: 128 bits.
; CHECK-NEXT:  LV: The Widest register safe to use is: vscale x 0 bits.
; CHECK-NEXT:  LV: The target has no scalable vector registers.
; CHECK-NEXT:  LV: No tail will remain for any chosen VF.
; CHECK-NEXT:  LV: Found uniform instruction: %cmp = icmp ne i64 %iv, 511
; CHECK-NEXT:  LV: Found uniform instruction: %a1 = getelementptr i64, ptr %p, i64 %iv
; CHECK-NEXT:  LV: Found uniform instruction: %a2 = getelementptr i64, ptr %p, i64 %offset
; CHECK-NEXT:  LV: Found uniform instruction: %offset = add i64 %iv, 100
; CHECK-NEXT:  LV: Found uniform instruction: %iv = phi i64 [ 0, %entry ], [ %iv.next, %loop ]
; CHECK-NEXT:  LV: Found uniform instruction: %iv.next = add i64 %iv, 1
; CHECK-NEXT:  LV: Found scalar instruction: %iv = phi i64 [ 0, %entry ], [ %iv.next, %loop ]
; CHECK-NEXT:  LV: Found scalar instruction: %iv.next = add i64 %iv, 1
; CHECK-NEXT:  LV: Scalarizing: %a1 = getelementptr i64, ptr %p, i64 %iv
; CHECK-NEXT:  LV: Scalarizing: %v = load i64, ptr %a1, align 32
; CHECK-NEXT:  LV: Scalarizing: %offset = add i64 %iv, 100
; CHECK-NEXT:  LV: Scalarizing: %a2 = getelementptr i64, ptr %p, i64 %offset
; CHECK-NEXT:  LV: Scalarizing: store i64 %v, ptr %a2, align 32
; CHECK-NEXT:  LV: Scalarizing: %iv.next = add i64 %iv, 1
; CHECK-NEXT:  LV: Scalarizing: %cmp = icmp ne i64 %iv, 511
; CHECK-NEXT:  LV: Scalarizing: %a1 = getelementptr i64, ptr %p, i64 %iv
; CHECK-NEXT:  LV: Scalarizing: %offset = add i64 %iv, 100
; CHECK-NEXT:  LV: Scalarizing: %a2 = getelementptr i64, ptr %p, i64 %offset
; CHECK-NEXT:  LV: Scalarizing: %iv.next = add i64 %iv, 1
; CHECK-NEXT:  LV: Scalarizing: %cmp = icmp ne i64 %iv, 511
; CHECK-NEXT:  VPlan 'Initial VPlan for VF={1},UF>=1' {
; CHECK-NEXT:  Live-in vp<%0> = VF * UF
; CHECK-NEXT:  Live-in vp<%1> = vector-trip-count
; CHECK-NEXT:  Live-in ir<512> = original trip-count
; CHECK-EMPTY:
; CHECK-NEXT:  vector.ph:
; CHECK-NEXT:  Successor(s): vector loop
; CHECK-EMPTY:
; CHECK-NEXT:  <x1> vector loop: {
; CHECK-NEXT:    vector.body:
; CHECK-NEXT:      EMIT vp<%2> = CANONICAL-INDUCTION ir<0>, vp<%4>
; CHECK-NEXT:      vp<%3> = SCALAR-STEPS vp<%2>, ir<1>
; CHECK-NEXT:      CLONE ir<%a1> = getelementptr ir<%p>, vp<%3>
; CHECK-NEXT:      CLONE ir<%v> = load ir<%a1>
; CHECK-NEXT:      CLONE ir<%offset> = add vp<%3>, ir<100>
; CHECK-NEXT:      CLONE ir<%a2> = getelementptr ir<%p>, ir<%offset>
; CHECK-NEXT:      CLONE store ir<%v>, ir<%a2>
; CHECK-NEXT:      EMIT vp<%4> = add nuw vp<%2>, vp<%0>
; CHECK-NEXT:      EMIT branch-on-count vp<%4>, vp<%1>
; CHECK-NEXT:    No successors
; CHECK-NEXT:  }
; CHECK-NEXT:  Successor(s): middle.block
; CHECK-EMPTY:
; CHECK-NEXT:  middle.block:
; CHECK-NEXT:  No successors
; CHECK-NEXT:  }
; CHECK-NEXT:  VPlan 'Initial VPlan for VF={2},UF>=1' {
; CHECK-NEXT:  Live-in vp<%0> = VF * UF
; CHECK-NEXT:  Live-in vp<%1> = vector-trip-count
; CHECK-NEXT:  Live-in ir<512> = original trip-count
; CHECK-EMPTY:
; CHECK-NEXT:  vector.ph:
; CHECK-NEXT:  Successor(s): vector loop
; CHECK-EMPTY:
; CHECK-NEXT:  <x1> vector loop: {
; CHECK-NEXT:    vector.body:
; CHECK-NEXT:      EMIT vp<%2> = CANONICAL-INDUCTION ir<0>, vp<%6>
; CHECK-NEXT:      vp<%3> = SCALAR-STEPS vp<%2>, ir<1>
; CHECK-NEXT:      CLONE ir<%a1> = getelementptr ir<%p>, vp<%3>
; CHECK-NEXT:      vp<%4> = vector-pointer ir<%a1>
; CHECK-NEXT:      WIDEN ir<%v> = load vp<%4>
; CHECK-NEXT:      CLONE ir<%offset> = add vp<%3>, ir<100>
; CHECK-NEXT:      CLONE ir<%a2> = getelementptr ir<%p>, ir<%offset>
; CHECK-NEXT:      vp<%5> = vector-pointer ir<%a2>
; CHECK-NEXT:      WIDEN store vp<%5>, ir<%v>
; CHECK-NEXT:      EMIT vp<%6> = add nuw vp<%2>, vp<%0>
; CHECK-NEXT:      EMIT branch-on-count vp<%6>, vp<%1>
; CHECK-NEXT:    No successors
; CHECK-NEXT:  }
; CHECK-NEXT:  Successor(s): middle.block
; CHECK-EMPTY:
; CHECK-NEXT:  middle.block:
; CHECK-NEXT:  No successors
; CHECK-NEXT:  }
; CHECK-NEXT:  LV: Found an estimated cost of 0 for VF 1 For instruction: %iv = phi i64 [ 0, %entry ], [ %iv.next, %loop ]
; CHECK-NEXT:  LV: Found an estimated cost of 0 for VF 1 For instruction: %a1 = getelementptr i64, ptr %p, i64 %iv
; CHECK-NEXT:  LV: Found an estimated cost of 1 for VF 1 For instruction: %v = load i64, ptr %a1, align 32
; CHECK-NEXT:  LV: Found an estimated cost of 1 for VF 1 For instruction: %offset = add i64 %iv, 100
; CHECK-NEXT:  LV: Found an estimated cost of 0 for VF 1 For instruction: %a2 = getelementptr i64, ptr %p, i64 %offset
; CHECK-NEXT:  LV: Found an estimated cost of 1 for VF 1 For instruction: store i64 %v, ptr %a2, align 32
; CHECK-NEXT:  LV: Found an estimated cost of 1 for VF 1 For instruction: %iv.next = add i64 %iv, 1
; CHECK-NEXT:  LV: Found an estimated cost of 1 for VF 1 For instruction: %cmp = icmp ne i64 %iv, 511
; CHECK-NEXT:  LV: Found an estimated cost of 0 for VF 1 For instruction: br i1 %cmp, label %loop, label %exit
; CHECK-NEXT:  LV: Scalar loop costs: 5.
; CHECK-NEXT:  LV: Found an estimated cost of 0 for VF 2 For instruction: %iv = phi i64 [ 0, %entry ], [ %iv.next, %loop ]
; CHECK-NEXT:  LV: Found an estimated cost of 0 for VF 2 For instruction: %a1 = getelementptr i64, ptr %p, i64 %iv
; CHECK-NEXT:  LV: Found an estimated cost of 1 for VF 2 For instruction: %v = load i64, ptr %a1, align 32
; CHECK-NEXT:  LV: Found an estimated cost of 1 for VF 2 For instruction: %offset = add i64 %iv, 100
; CHECK-NEXT:  LV: Found an estimated cost of 0 for VF 2 For instruction: %a2 = getelementptr i64, ptr %p, i64 %offset
; CHECK-NEXT:  LV: Found an estimated cost of 1 for VF 2 For instruction: store i64 %v, ptr %a2, align 32
; CHECK-NEXT:  LV: Found an estimated cost of 1 for VF 2 For instruction: %iv.next = add i64 %iv, 1
; CHECK-NEXT:  LV: Found an estimated cost of 1 for VF 2 For instruction: %cmp = icmp ne i64 %iv, 511
; CHECK-NEXT:  LV: Found an estimated cost of 0 for VF 2 For instruction: br i1 %cmp, label %loop, label %exit
; CHECK-NEXT:  LV: Vector loop of width 2 costs: 2.
; CHECK-NEXT:  LV: Selecting VF: 2.
; CHECK-NEXT:  LV: Minimum required TC for runtime checks to be profitable:0
; CHECK-NEXT:  LV: Interleaving is not beneficial.
; CHECK-NEXT:  LV: Found a vectorizable loop (2) in <stdin>
; CHECK-NEXT:  LEV: Unable to vectorize epilogue because no epilogue is allowed.
; CHECK-NEXT:  Executing best plan with VF=2, UF=1
; CHECK-NEXT:  VPlan 'Final VPlan for VF={2},UF>=1' {
; CHECK-NEXT:  Live-in vp<%0> = VF * UF
; CHECK-NEXT:  Live-in vp<%1> = vector-trip-count
; CHECK-NEXT:  Live-in ir<512> = original trip-count
; CHECK-EMPTY:
; CHECK-NEXT:  vector.ph:
; CHECK-NEXT:  Successor(s): vector loop
; CHECK-EMPTY:
; CHECK-NEXT:  <x1> vector loop: {
; CHECK-NEXT:    vector.body:
; CHECK-NEXT:      EMIT vp<%2> = CANONICAL-INDUCTION ir<0>, vp<%6>
; CHECK-NEXT:      vp<%3> = SCALAR-STEPS vp<%2>, ir<1>
; CHECK-NEXT:      CLONE ir<%a1> = getelementptr ir<%p>, vp<%3>
; CHECK-NEXT:      vp<%4> = vector-pointer ir<%a1>
; CHECK-NEXT:      WIDEN ir<%v> = load vp<%4>
; CHECK-NEXT:      CLONE ir<%offset> = add vp<%3>, ir<100>
; CHECK-NEXT:      CLONE ir<%a2> = getelementptr ir<%p>, ir<%offset>
; CHECK-NEXT:      vp<%5> = vector-pointer ir<%a2>
; CHECK-NEXT:      WIDEN store vp<%5>, ir<%v>
; CHECK-NEXT:      EMIT vp<%6> = add nuw vp<%2>, vp<%0>
; CHECK-NEXT:      EMIT branch-on-count vp<%6>, vp<%1>
; CHECK-NEXT:    No successors
; CHECK-NEXT:  }
; CHECK-NEXT:  Successor(s): middle.block
; CHECK-EMPTY:
; CHECK-NEXT:  middle.block:
; CHECK-NEXT:  No successors
; CHECK-NEXT:  }
; CHECK-NEXT:  LV: Interleaving disabled by the pass manager
; CHECK-NEXT:  LV: Vectorizing: innermost loop.
;
entry:
  br label %loop

loop:
  %iv = phi i64 [0, %entry], [%iv.next, %loop]
  %a1 = getelementptr i64, ptr %p, i64 %iv
  %v = load i64, ptr %a1, align 32
  %offset = add i64 %iv, 100
  %a2 = getelementptr i64, ptr %p, i64 %offset
  store i64 %v, ptr %a2, align 32
  %iv.next = add i64 %iv, 1
  %cmp = icmp ne i64 %iv, 511
  br i1 %cmp, label %loop, label %exit

exit:
  ret void
}

