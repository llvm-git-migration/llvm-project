; NOTE: Assertions have been autogenerated by utils/update_test_checks.py UTC_ARGS: --version 5
; RUN: opt < %s -passes=correlated-propagation -S | FileCheck %s

;; Check if ICMP instruction is constant folded or not.

define void @test1(ptr addrspace(1) %out) {
; CHECK-LABEL: define void @test1(
; CHECK-SAME: ptr addrspace(1) [[OUT:%.*]]) {
; CHECK-NEXT:    [[CALL:%.*]] = call i32 @llvm.nvvm.read.ptx.sreg.tid.x(), !range [[RNG0:![0-9]+]]
; CHECK-NEXT:    [[UDIV_LHS_TRUNC:%.*]] = trunc i32 [[CALL]] to i16
; CHECK-NEXT:    [[UDIV1:%.*]] = udiv i16 [[UDIV_LHS_TRUNC]], 5
; CHECK-NEXT:    [[UDIV_ZEXT:%.*]] = zext i16 [[UDIV1]] to i32
; CHECK-NEXT:    [[ADD1:%.*]] = add nuw nsw i32 [[UDIV_ZEXT]], 768
; CHECK-NEXT:    [[ADD2:%.*]] = add nuw nsw i32 [[UDIV_ZEXT]], 896
; CHECK-NEXT:    [[IE1:%.*]] = insertelement <2 x i32> poison, i32 [[ADD1]], i64 0
; CHECK-NEXT:    [[IE2:%.*]] = insertelement <2 x i32> [[IE1]], i32 [[ADD2]], i64 1
; CHECK-NEXT:    [[EI1:%.*]] = extractelement <2 x i1> <i1 true, i1 true>, i64 0
; CHECK-NEXT:    [[EI2:%.*]] = extractelement <2 x i1> <i1 true, i1 true>, i64 1
; CHECK-NEXT:    [[ADDUP:%.*]] = add i1 [[EI1]], [[EI2]]
; CHECK-NEXT:    [[ADDUP_UPCAST:%.*]] = zext i1 [[ADDUP]] to i32
; CHECK-NEXT:    store i32 [[ADDUP_UPCAST]], ptr addrspace(1) [[OUT]], align 4
; CHECK-NEXT:    ret void
;
  %call = call i32 @llvm.nvvm.read.ptx.sreg.tid.x(), !range !1
  %udiv = udiv i32 %call, 5
  %add1 = add i32 %udiv, 768
  %add2 = add i32 %udiv, 896
  %ie1 = insertelement <2 x i32> poison, i32 %add1, i64 0
  %ie2 = insertelement <2 x i32> %ie1, i32 %add2, i64 1
  %icmp1 = icmp slt <2 x i32> %ie2, <i32 1024, i32 1024>
  %ei1 = extractelement <2 x i1> %icmp1, i64 0
  %ei2 = extractelement <2 x i1> %icmp1, i64 1
  %addUp = add i1 %ei1, %ei2
  %addUp.upcast = zext i1 %addUp to i32
  store i32 %addUp.upcast, ptr addrspace(1) %out, align 4
  ret void
}


;; Check if LVI is able to handle constant vector operands
;; in InsertElementInst and CVP is able to fold ICMP instruction.

define void @test2(ptr addrspace(1) %out) {
; CHECK-LABEL: define void @test2(
; CHECK-SAME: ptr addrspace(1) [[OUT:%.*]]) {
; CHECK-NEXT:    [[CALL:%.*]] = call i32 @llvm.nvvm.read.ptx.sreg.tid.x(), !range [[RNG0]]
; CHECK-NEXT:    [[UDIV_LHS_TRUNC:%.*]] = trunc i32 [[CALL]] to i16
; CHECK-NEXT:    [[UDIV1:%.*]] = udiv i16 [[UDIV_LHS_TRUNC]], 5
; CHECK-NEXT:    [[UDIV_ZEXT:%.*]] = zext i16 [[UDIV1]] to i32
; CHECK-NEXT:    [[ADD2:%.*]] = add nuw nsw i32 [[UDIV_ZEXT]], 896
; CHECK-NEXT:    [[IE1:%.*]] = insertelement <2 x i32> <i32 poison, i32 1>, i32 [[ADD2]], i64 0
; CHECK-NEXT:    [[EI1:%.*]] = extractelement <2 x i1> <i1 true, i1 true>, i64 0
; CHECK-NEXT:    [[EI2:%.*]] = extractelement <2 x i1> <i1 true, i1 true>, i64 1
; CHECK-NEXT:    [[ADDUP:%.*]] = add i1 [[EI1]], [[EI2]]
; CHECK-NEXT:    [[ADDUP_UPCAST:%.*]] = zext i1 [[ADDUP]] to i32
; CHECK-NEXT:    store i32 [[ADDUP_UPCAST]], ptr addrspace(1) [[OUT]], align 4
; CHECK-NEXT:    ret void
;
  %call = call i32 @llvm.nvvm.read.ptx.sreg.tid.x(), !range !1
  %udiv = udiv i32 %call, 5
  %add2 = add i32 %udiv, 896
  %ie1 = insertelement <2 x i32> <i32 poison, i32 1>, i32 %add2, i64 0
  %icmp1 = icmp slt <2 x i32> %ie1, <i32 1024, i32 1024>
  %ei1 = extractelement <2 x i1> %icmp1, i64 0
  %ei2 = extractelement <2 x i1> %icmp1, i64 1
  %addUp = add i1 %ei1, %ei2
  %addUp.upcast = zext i1 %addUp to i32
  store i32 %addUp.upcast, ptr addrspace(1) %out, align 4
  ret void
}


!1 = !{i32 0, i32 640}
;.
; CHECK: [[RNG0]] = !{i32 0, i32 640}
;.
