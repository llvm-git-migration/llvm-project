; NOTE: Assertions have been autogenerated by utils/update_test_checks.py UTC_ARGS: --version 5
; RUN: opt < %s -S -passes=instcombine | FileCheck %s

declare void @use(i1)

define void @a_or_b(i32 %a, i32 %b)  {
; CHECK-LABEL: define void @src(
; CHECK-SAME: i32 [[A:%.*]], i32 [[B:%.*]]) {
; CHECK-NEXT:    [[A_EQ_ZERO:%.*]] = icmp eq i32 [[A]], 0
; CHECK-NEXT:    [[B_NE_ZERO:%.*]] = icmp ne i32 [[B]], 0
; CHECK-NEXT:    [[AND_1:%.*]] = and i1 [[A_EQ_ZERO]], [[B_NE_ZERO]]
; CHECK-NEXT:    [[A_NE_ZERO:%.*]] = icmp ne i32 [[A]], 0
; CHECK-NEXT:    [[B_EQ_ZERO:%.*]] = icmp eq i32 [[B]], 0
; CHECK-NEXT:    [[AND_2:%.*]] = and i1 [[A_NE_ZERO]], [[B_EQ_ZERO]]
; CHECK-NEXT:    [[OR:%.*]] = or i1 [[AND_1]], [[AND_2]]
; CHECK-NEXT:    call void @use(i1 [[OR]])
; CHECK-NEXT:    ret void
;
  %a_eq_zero = icmp eq i32 %a, 0
  %b_ne_zero = icmp ne i32 %b, 0
  %and.1 = and i1 %a_eq_zero, %b_ne_zero
  %a_ne_zero = icmp ne i32 %a, 0
  %b_eq_zero = icmp eq i32 %b, 0
  %and.2 = and i1 %a_ne_zero, %b_eq_zero
  %or = or i1 %and.1, %and.2
  call void @use(i1 %or)
  ret void
}


define void @a_or_b_zero(i32 %a, i32 %b)  {
; CHECK-LABEL: define void @src(
; CHECK-SAME: i32 [[A:%.*]], i32 [[B:%.*]]) {
; CHECK-NEXT:    [[A_EQ_ZERO:%.*]] = icmp eq i32 [[A]], 0
; CHECK-NEXT:    [[B_NE_ZERO:%.*]] = icmp ne i32 [[B]], 0
; CHECK-NEXT:    [[AND_1:%.*]] = and i1 [[A_EQ_ZERO]], [[B_NE_ZERO]]
; CHECK-NEXT:    [[A_NE_ZERO:%.*]] = icmp ne i32 [[A]], 0
; CHECK-NEXT:    [[B_EQ_ZERO:%.*]] = icmp eq i32 [[B]], 0
; CHECK-NEXT:    [[AND_2:%.*]] = and i1 [[A_NE_ZERO]], [[B_EQ_ZERO]]
; CHECK-NEXT:    [[OR:%.*]] = or i1 [[AND_1]], [[AND_2]]
; CHECK-NEXT:    call void @use(i1 [[OR]])
; CHECK-NEXT:    ret void
;
  %a_eq_zero = icmp eq i32 %a, 0
  %b_ne_zero = icmp ne i32 %b, 0
  %and.1 = and i1 %a_eq_zero, %b_ne_zero
  %a_ne_zero = icmp ne i32 %a, 0
  %b_eq_zero = icmp eq i32 %b, 0
  %and.2 = and i1 %a_ne_zero, %b_eq_zero
  %or = or i1 %and.1, %and.2
  call void @use(i1 %or)
  ret void
}

define void @a_or_b_multiple_uses(i32 %a, i32 %b)  {
; CHECK-LABEL: define void @src(
; CHECK-SAME: i32 [[A:%.*]], i32 [[B:%.*]]) {
; CHECK-NEXT:    [[A_EQ_ZERO:%.*]] = icmp eq i32 [[A]], 0
; CHECK-NEXT:    [[B_NE_ZERO:%.*]] = icmp ne i32 [[B]], 0
; CHECK-NEXT:    [[AND_1:%.*]] = and i1 [[A_EQ_ZERO]], [[B_NE_ZERO]]
; CHECK-NEXT:    [[A_NE_ZERO:%.*]] = icmp ne i32 [[A]], 0
; CHECK-NEXT:    [[B_EQ_ZERO:%.*]] = icmp eq i32 [[B]], 0
; CHECK-NEXT:    [[AND_2:%.*]] = and i1 [[A_NE_ZERO]], [[B_EQ_ZERO]]
; CHECK-NEXT:    [[OR:%.*]] = or i1 [[AND_1]], [[AND_2]]
; CHECK-NEXT:    call void @use(i1 [[OR]])
; CHECK-NEXT:    ret void
;
  %a_eq_zero = icmp eq i32 %a, 0
  %b_ne_zero = icmp ne i32 %b, 0
  %and.1 = and i1 %a_eq_zero, %b_ne_zero
  %a_ne_zero = icmp ne i32 %a, 0
  %b_eq_zero = icmp eq i32 %b, 0
  %and.2 = and i1 %a_ne_zero, %b_eq_zero
  call void @use(i1 %and.2)
  %or = or i1 %and.1, %and.2
  ret void
}

define void @a_or_b_multiple_uses_2(i32 %a, i32 %b)  {
; CHECK-LABEL: define void @src(
; CHECK-SAME: i32 [[A:%.*]], i32 [[B:%.*]]) {
; CHECK-NEXT:    [[A_EQ_ZERO:%.*]] = icmp eq i32 [[A]], 0
; CHECK-NEXT:    [[B_NE_ZERO:%.*]] = icmp ne i32 [[B]], 0
; CHECK-NEXT:    [[AND_1:%.*]] = and i1 [[A_EQ_ZERO]], [[B_NE_ZERO]]
; CHECK-NEXT:    [[A_NE_ZERO:%.*]] = icmp ne i32 [[A]], 0
; CHECK-NEXT:    [[B_EQ_ZERO:%.*]] = icmp eq i32 [[B]], 0
; CHECK-NEXT:    [[AND_2:%.*]] = and i1 [[A_NE_ZERO]], [[B_EQ_ZERO]]
; CHECK-NEXT:    [[OR:%.*]] = or i1 [[AND_1]], [[AND_2]]
; CHECK-NEXT:    call void @use(i1 [[OR]])
; CHECK-NEXT:    ret void
;
  %a_eq_zero = icmp eq i32 %a, 0
  %b_ne_zero = icmp ne i32 %b, 0
  call void @use(i1 %b_ne_zero)
  %and.1 = and i1 %a_eq_zero, %b_ne_zero
  %a_ne_zero = icmp ne i32 %a, 0
  %b_eq_zero = icmp eq i32 %b, 0
  %and.2 = and i1 %a_ne_zero, %b_eq_zero
  call void @use(i1 %and.1)
  %or = or i1 %and.1, %and.2
  ret void
}


