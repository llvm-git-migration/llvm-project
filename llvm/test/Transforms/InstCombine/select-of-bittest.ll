; NOTE: Assertions have been autogenerated by utils/update_test_checks.py
; RUN: opt < %s -passes=instcombine -S | FileCheck %s

; https://bugs.llvm.org/show_bug.cgi?id=36950

; ====================== AND =======================
define i8 @src_and_bit(i8 %x, i8 %y) {
; CHECK-LABEL: @src_and_bit(
; CHECK-NEXT:    [[AND:%.*]] = and i8 [[X:%.*]], 3
; CHECK-NEXT:    [[CMP:%.*]] = icmp eq i8 [[AND]], 2
; CHECK-NEXT:    [[COND:%.*]] = select i1 [[CMP]], i8 2, i8 1
; CHECK-NEXT:    ret i8 [[COND]]
;
  %and = and i8 %x, 3
  %and1 = and i8 %x, 2
  %and2 = and i8 %and, %x
  %cmp = icmp eq i8 %and2, 2
  %cond = select i1 %cmp, i8 %and1, i8 1
  ret i8 %cond
}

define <2 x i8> @src_and_bit_vec(<2 x i8> %x, <2 x i8> %y) {
; CHECK-LABEL: @src_and_bit_vec(
; CHECK-NEXT:    [[AND:%.*]] = and <2 x i8> [[X:%.*]], <i8 3, i8 3>
; CHECK-NEXT:    [[CMP:%.*]] = icmp eq <2 x i8> [[AND]], <i8 2, i8 2>
; CHECK-NEXT:    [[COND:%.*]] = select <2 x i1> [[CMP]], <2 x i8> <i8 2, i8 2>, <2 x i8> <i8 1, i8 1>
; CHECK-NEXT:    ret <2 x i8> [[COND]]
;
  %and = and <2 x i8> %x, <i8 3, i8 3>
  %and1 = and <2 x i8> %x, <i8 2, i8 2>
  %and2 = and <2 x i8> %and, %x
  %cmp = icmp eq <2 x i8> %and2, <i8 2, i8 2>
  %cond = select <2 x i1> %cmp, <2 x i8> %and1, <2 x i8><i8 1, i8 1>
  ret <2 x i8> %cond
}

define <2 x i8> @src_and_bit_vec_poison(<2 x i8> %x, <2 x i8> %y) {
; CHECK-LABEL: @src_and_bit_vec_poison(
; CHECK-NEXT:    [[AND:%.*]] = and <2 x i8> [[X:%.*]], <i8 poison, i8 3>
; CHECK-NEXT:    [[CMP:%.*]] = icmp eq <2 x i8> [[AND]], <i8 2, i8 2>
; CHECK-NEXT:    [[COND:%.*]] = select <2 x i1> [[CMP]], <2 x i8> <i8 2, i8 2>, <2 x i8> <i8 1, i8 1>
; CHECK-NEXT:    ret <2 x i8> [[COND]]
;
  %and = and <2 x i8> %x, <i8 poison, i8 3>
  %and1 = and <2 x i8> %x, <i8 poison, i8 2>
  %and2 = and <2 x i8> %and, %x
  %cmp = icmp eq <2 x i8> %and2, <i8 2, i8 2>
  %cond = select <2 x i1> %cmp, <2 x i8> %and1, <2 x i8><i8 1, i8 1>
  ret <2 x i8> %cond
}

define <2 x i8> @src_and_bit_vec_poison2(<2 x i8> %x, <2 x i8> %y) {
; CHECK-LABEL: @src_and_bit_vec_poison2(
; CHECK-NEXT:    [[AND:%.*]] = and <2 x i8> [[X:%.*]], <i8 poison, i8 3>
; CHECK-NEXT:    [[CMP:%.*]] = icmp eq <2 x i8> [[AND]], <i8 2, i8 2>
; CHECK-NEXT:    [[COND:%.*]] = select <2 x i1> [[CMP]], <2 x i8> <i8 2, i8 2>, <2 x i8> <i8 1, i8 1>
; CHECK-NEXT:    ret <2 x i8> [[COND]]
;
  %and = and <2 x i8> %x, <i8 poison, i8 3>
  %and1 = and <2 x i8> %x, <i8 poison, i8 2>
  %and2 = and <2 x i8> %and, %x
  %cmp = icmp eq <2 x i8> %and2, <i8 2, i8 2>
  %cond = select <2 x i1> %cmp, <2 x i8> %and1, <2 x i8><i8 1, i8 1>
  ret <2 x i8> %cond
}

define i8 @src_and_bit_ne(i8 %x, i8 %y) {
; CHECK-LABEL: @src_and_bit_ne(
; CHECK-NEXT:    [[AND:%.*]] = and i8 [[X:%.*]], 3
; CHECK-NEXT:    [[CMP_NOT:%.*]] = icmp eq i8 [[AND]], 2
; CHECK-NEXT:    [[COND:%.*]] = select i1 [[CMP_NOT]], i8 2, i8 1
; CHECK-NEXT:    ret i8 [[COND]]
;
  %and = and i8 %x, 3
  %and1 = and i8 %x, 2
  %and2 = and i8 %and, %x
  %cmp = icmp ne i8 %and2, 2
  %cond = select i1 %cmp, i8 1, i8 %and1
  ret i8 %cond
}

define <2 x i8> @src_and_bit_vec_ne(<2 x i8> %x, <2 x i8> %y) {
; CHECK-LABEL: @src_and_bit_vec_ne(
; CHECK-NEXT:    [[AND:%.*]] = and <2 x i8> [[X:%.*]], <i8 3, i8 3>
; CHECK-NEXT:    [[CMP_NOT:%.*]] = icmp eq <2 x i8> [[AND]], <i8 2, i8 2>
; CHECK-NEXT:    [[COND:%.*]] = select <2 x i1> [[CMP_NOT]], <2 x i8> <i8 2, i8 2>, <2 x i8> <i8 1, i8 1>
; CHECK-NEXT:    ret <2 x i8> [[COND]]
;
  %and = and <2 x i8> %x, <i8 3, i8 3>
  %and1 = and <2 x i8> %x, <i8 2, i8 2>
  %and2 = and <2 x i8> %and, %x
  %cmp = icmp ne <2 x i8> %and2, <i8 2, i8 2>
  %cond = select <2 x i1> %cmp, <2 x i8><i8 1, i8 1>, <2 x i8> %and1
  ret <2 x i8> %cond
}

define <2 x i8> @src_and_bit_vec_poison_ne(<2 x i8> %x, <2 x i8> %y) {
; CHECK-LABEL: @src_and_bit_vec_poison_ne(
; CHECK-NEXT:    [[AND:%.*]] = and <2 x i8> [[X:%.*]], <i8 poison, i8 3>
; CHECK-NEXT:    [[CMP_NOT:%.*]] = icmp eq <2 x i8> [[AND]], <i8 2, i8 2>
; CHECK-NEXT:    [[COND:%.*]] = select <2 x i1> [[CMP_NOT]], <2 x i8> <i8 2, i8 2>, <2 x i8> <i8 1, i8 1>
; CHECK-NEXT:    ret <2 x i8> [[COND]]
;
  %and = and <2 x i8> %x, <i8 poison, i8 3>
  %and1 = and <2 x i8> %x, <i8 poison, i8 2>
  %and2 = and <2 x i8> %and, %x
  %cmp = icmp ne <2 x i8> %and2, <i8 2, i8 2>
  %cond = select <2 x i1> %cmp, <2 x i8><i8 1, i8 1>, <2 x i8> %and1
  ret <2 x i8> %cond
}

define <2 x i8> @src_and_bit_vec_poison2_ne(<2 x i8> %x, <2 x i8> %y) {
; CHECK-LABEL: @src_and_bit_vec_poison2_ne(
; CHECK-NEXT:    [[AND:%.*]] = and <2 x i8> [[X:%.*]], <i8 poison, i8 3>
; CHECK-NEXT:    [[CMP_NOT:%.*]] = icmp eq <2 x i8> [[AND]], <i8 2, i8 2>
; CHECK-NEXT:    [[COND:%.*]] = select <2 x i1> [[CMP_NOT]], <2 x i8> <i8 2, i8 2>, <2 x i8> <i8 1, i8 1>
; CHECK-NEXT:    ret <2 x i8> [[COND]]
;
  %and = and <2 x i8> %x, <i8 poison, i8 3>
  %and1 = and <2 x i8> %x, <i8 poison, i8 2>
  %and2 = and <2 x i8> %and, %x
  %cmp = icmp ne <2 x i8> %and2, <i8 2, i8 2>
  %cond = select <2 x i1> %cmp, <2 x i8><i8 1, i8 1>, <2 x i8> %and1
  ret <2 x i8> %cond
}

; ====================== OR =======================
define i8 @src_or_bit(i8 %x, i8 %y, i8 %z) {
; CHECK-LABEL: @src_or_bit(
; CHECK-NEXT:    [[AND1:%.*]] = shl i8 [[Y:%.*]], 2
; CHECK-NEXT:    [[SHL:%.*]] = and i8 [[AND1]], 12
; CHECK-NEXT:    [[OR:%.*]] = or i8 [[SHL]], [[X:%.*]]
; CHECK-NEXT:    [[CMP:%.*]] = icmp eq i8 [[OR]], 3
; CHECK-NEXT:    [[COND:%.*]] = select i1 [[CMP]], i8 3, i8 1
; CHECK-NEXT:    ret i8 [[COND]]
;
  %and = and i8 %z, 3
  %and1 = shl i8 %y, 2
  %shl = and i8 %and1, 12
  %or = or i8 %shl, %x
  %cmp = icmp eq i8 %or, 3
  %or2 = or i8 %and, %x
  %cond = select i1 %cmp, i8 %or2, i8 1
  ret i8 %cond
}

define <2 x i8> @src_or_bit_vec(<2 x i8> %x, <2 x i8> %y, <2 x i8> %z) {
; CHECK-LABEL: @src_or_bit_vec(
; CHECK-NEXT:    [[AND1:%.*]] = shl <2 x i8> [[Y:%.*]], <i8 2, i8 2>
; CHECK-NEXT:    [[SHL:%.*]] = and <2 x i8> [[AND1]], <i8 12, i8 12>
; CHECK-NEXT:    [[OR:%.*]] = or <2 x i8> [[SHL]], [[X:%.*]]
; CHECK-NEXT:    [[CMP:%.*]] = icmp eq <2 x i8> [[OR]], <i8 3, i8 3>
; CHECK-NEXT:    [[COND:%.*]] = select <2 x i1> [[CMP]], <2 x i8> <i8 3, i8 3>, <2 x i8> <i8 1, i8 1>
; CHECK-NEXT:    ret <2 x i8> [[COND]]
;
  %and = and <2 x i8> %z, <i8 3, i8 3>
  %and1 = shl <2 x i8> %y, <i8 2, i8 2>
  %shl = and <2 x i8> %and1, <i8 12, i8 12>
  %or = or <2 x i8> %shl, %x
  %cmp = icmp eq <2 x i8> %or, <i8 3, i8 3>
  %or2 = or <2 x i8> %and, %x
  %cond = select <2x i1> %cmp, <2 x i8> %or2, <2 x i8> <i8 1, i8 1>
  ret <2 x i8> %cond
}

define <2 x i8> @src_or_bit_vec_poison(<2 x i8> %x, <2 x i8> %y, <2 x i8> %z) {
; CHECK-LABEL: @src_or_bit_vec_poison(
; CHECK-NEXT:    [[AND1:%.*]] = shl <2 x i8> [[Y:%.*]], <i8 2, i8 poison>
; CHECK-NEXT:    [[SHL:%.*]] = and <2 x i8> [[AND1]], <i8 12, i8 poison>
; CHECK-NEXT:    [[OR:%.*]] = or <2 x i8> [[SHL]], [[X:%.*]]
; CHECK-NEXT:    [[CMP:%.*]] = icmp eq <2 x i8> [[OR]], <i8 3, i8 3>
; CHECK-NEXT:    [[COND:%.*]] = select <2 x i1> [[CMP]], <2 x i8> <i8 3, i8 3>, <2 x i8> <i8 1, i8 1>
; CHECK-NEXT:    ret <2 x i8> [[COND]]
;
  %and = and <2 x i8> %z, <i8 3, i8 poison>
  %and1 = shl <2 x i8> %y, <i8 2, i8 poison>
  %shl = and <2 x i8> %and1, <i8 12, i8 poison>
  %or = or <2 x i8> %shl, %x
  %cmp = icmp eq <2 x i8> %or, <i8 3, i8 3>
  %or2 = or <2 x i8> %and, %x
  %cond = select <2 x i1> %cmp, <2 x i8> %or2, <2 x i8> <i8 1, i8 1>
  ret <2 x i8> %cond
}

define <2 x i8> @src_or_bit_vec_poison2(<2 x i8> %x, <2 x i8> %y, <2 x i8> %z) {
; CHECK-LABEL: @src_or_bit_vec_poison2(
; CHECK-NEXT:    [[AND1:%.*]] = shl <2 x i8> [[Y:%.*]], <i8 poison, i8 2>
; CHECK-NEXT:    [[SHL:%.*]] = and <2 x i8> [[AND1]], <i8 poison, i8 12>
; CHECK-NEXT:    [[OR:%.*]] = or <2 x i8> [[SHL]], [[X:%.*]]
; CHECK-NEXT:    [[CMP:%.*]] = icmp eq <2 x i8> [[OR]], <i8 3, i8 3>
; CHECK-NEXT:    [[COND:%.*]] = select <2 x i1> [[CMP]], <2 x i8> <i8 3, i8 3>, <2 x i8> <i8 1, i8 1>
; CHECK-NEXT:    ret <2 x i8> [[COND]]
;
  %and = and <2 x i8> %z, <i8 poison, i8 3>
  %and1 = shl <2 x i8> %y, <i8 poison, i8 2>
  %shl = and <2 x i8> %and1, <i8 poison, i8 12>
  %or = or <2 x i8> %shl, %x
  %cmp = icmp eq <2 x i8> %or, <i8 3, i8 3>
  %or2 = or <2 x i8> %and, %x
  %cond = select <2 x i1> %cmp, <2 x i8> %or2, <2 x i8> <i8 1, i8 1>
  ret <2 x i8> %cond
}

define i8 @src_or_bit_ne(i8 %x, i8 %y, i8 %z) {
; CHECK-LABEL: @src_or_bit_ne(
; CHECK-NEXT:    [[AND1:%.*]] = shl i8 [[Y:%.*]], 2
; CHECK-NEXT:    [[SHL:%.*]] = and i8 [[AND1]], 12
; CHECK-NEXT:    [[OR:%.*]] = or i8 [[SHL]], [[X:%.*]]
; CHECK-NEXT:    [[CMP_NOT:%.*]] = icmp eq i8 [[OR]], 3
; CHECK-NEXT:    [[COND:%.*]] = select i1 [[CMP_NOT]], i8 3, i8 1
; CHECK-NEXT:    ret i8 [[COND]]
;
  %and = and i8 %z, 3
  %and1 = shl i8 %y, 2
  %shl = and i8 %and1, 12
  %or = or i8 %shl, %x
  %cmp = icmp ne i8 %or, 3
  %or2 = or i8 %and, %x
  %cond = select i1 %cmp, i8 1, i8 %or2
  ret i8 %cond
}

define <2 x i8> @src_or_bit_vec_ne(<2 x i8> %x, <2 x i8> %y, <2 x i8> %z) {
; CHECK-LABEL: @src_or_bit_vec_ne(
; CHECK-NEXT:    [[AND1:%.*]] = shl <2 x i8> [[Y:%.*]], <i8 2, i8 2>
; CHECK-NEXT:    [[SHL:%.*]] = and <2 x i8> [[AND1]], <i8 12, i8 12>
; CHECK-NEXT:    [[OR:%.*]] = or <2 x i8> [[SHL]], [[X:%.*]]
; CHECK-NEXT:    [[CMP_NOT:%.*]] = icmp eq <2 x i8> [[OR]], <i8 3, i8 3>
; CHECK-NEXT:    [[COND:%.*]] = select <2 x i1> [[CMP_NOT]], <2 x i8> <i8 3, i8 3>, <2 x i8> <i8 1, i8 1>
; CHECK-NEXT:    ret <2 x i8> [[COND]]
;
  %and = and <2 x i8> %z, <i8 3, i8 3>
  %and1 = shl <2 x i8> %y, <i8 2, i8 2>
  %shl = and <2 x i8> %and1, <i8 12, i8 12>
  %or = or <2 x i8> %shl, %x
  %cmp = icmp ne <2 x i8> %or, <i8 3, i8 3>
  %or2 = or <2 x i8> %and, %x
  %cond = select <2x i1> %cmp, <2 x i8> <i8 1, i8 1>, <2 x i8> %or2
  ret <2 x i8> %cond
}

define <2 x i8> @src_or_bit_vec_poison_ne(<2 x i8> %x, <2 x i8> %y, <2 x i8> %z) {
; CHECK-LABEL: @src_or_bit_vec_poison_ne(
; CHECK-NEXT:    [[AND1:%.*]] = shl <2 x i8> [[Y:%.*]], <i8 2, i8 poison>
; CHECK-NEXT:    [[SHL:%.*]] = and <2 x i8> [[AND1]], <i8 12, i8 poison>
; CHECK-NEXT:    [[OR:%.*]] = or <2 x i8> [[SHL]], [[X:%.*]]
; CHECK-NEXT:    [[CMP_NOT:%.*]] = icmp eq <2 x i8> [[OR]], <i8 3, i8 3>
; CHECK-NEXT:    [[COND:%.*]] = select <2 x i1> [[CMP_NOT]], <2 x i8> <i8 3, i8 3>, <2 x i8> <i8 1, i8 1>
; CHECK-NEXT:    ret <2 x i8> [[COND]]
;
  %and = and <2 x i8> %z, <i8 3, i8 poison>
  %and1 = shl <2 x i8> %y, <i8 2, i8 poison>
  %shl = and <2 x i8> %and1, <i8 12, i8 poison>
  %or = or <2 x i8> %shl, %x
  %cmp = icmp ne <2 x i8> %or, <i8 3, i8 3>
  %or2 = or <2 x i8> %and, %x
  %cond = select <2 x i1> %cmp, <2 x i8> <i8 1, i8 1>, <2 x i8> %or2
  ret <2 x i8> %cond
}

define <2 x i8> @src_or_bit_vec_poison2_ne(<2 x i8> %x, <2 x i8> %y, <2 x i8> %z) {
; CHECK-LABEL: @src_or_bit_vec_poison2_ne(
; CHECK-NEXT:    [[AND1:%.*]] = shl <2 x i8> [[Y:%.*]], <i8 poison, i8 2>
; CHECK-NEXT:    [[SHL:%.*]] = and <2 x i8> [[AND1]], <i8 poison, i8 12>
; CHECK-NEXT:    [[OR:%.*]] = or <2 x i8> [[SHL]], [[X:%.*]]
; CHECK-NEXT:    [[CMP_NOT:%.*]] = icmp eq <2 x i8> [[OR]], <i8 3, i8 3>
; CHECK-NEXT:    [[COND:%.*]] = select <2 x i1> [[CMP_NOT]], <2 x i8> <i8 3, i8 3>, <2 x i8> <i8 1, i8 1>
; CHECK-NEXT:    ret <2 x i8> [[COND]]
;
  %and = and <2 x i8> %z, <i8 poison, i8 3>
  %and1 = shl <2 x i8> %y, <i8 poison, i8 2>
  %shl = and <2 x i8> %and1, <i8 poison, i8 12>
  %or = or <2 x i8> %shl, %x
  %cmp = icmp ne <2 x i8> %or, <i8 3, i8 3>
  %or2 = or <2 x i8> %and, %x
  %cond = select <2 x i1> %cmp, <2 x i8> <i8 1, i8 1>, <2 x i8> %or2
  ret <2 x i8> %cond
}

; ====================== XOR =======================
define i8 @src_xor_bit(i8 %x, i8 %y) {
; CHECK-LABEL: @src_xor_bit(
; CHECK-NEXT:    [[AND:%.*]] = and i8 [[Y:%.*]], 12
; CHECK-NEXT:    [[XOR:%.*]] = xor i8 [[AND]], [[X:%.*]]
; CHECK-NEXT:    [[CMP:%.*]] = icmp eq i8 [[XOR]], 3
; CHECK-NEXT:    [[COND:%.*]] = select i1 [[CMP]], i8 3, i8 1
; CHECK-NEXT:    ret i8 [[COND]]
;
  %and = and i8 %y, 12
  %xor = xor i8 %and, %x
  %cmp = icmp eq i8 %xor, 3
  %and1 = and i8 %x, 3
  %cond = select i1 %cmp, i8 %and1, i8 1
  ret i8 %cond
}

define <2 x i8> @src_xor_bit_vec(<2 x i8> %x, <2 x i8> %y) {
; CHECK-LABEL: @src_xor_bit_vec(
; CHECK-NEXT:    [[AND:%.*]] = and <2 x i8> [[Y:%.*]], <i8 12, i8 12>
; CHECK-NEXT:    [[XOR:%.*]] = xor <2 x i8> [[AND]], [[X:%.*]]
; CHECK-NEXT:    [[CMP:%.*]] = icmp eq <2 x i8> [[XOR]], <i8 3, i8 3>
; CHECK-NEXT:    [[COND:%.*]] = select <2 x i1> [[CMP]], <2 x i8> <i8 3, i8 3>, <2 x i8> <i8 1, i8 1>
; CHECK-NEXT:    ret <2 x i8> [[COND]]
;
  %and = and <2 x i8> %y, <i8 12, i8 12>
  %xor = xor <2 x i8> %and, %x
  %cmp = icmp eq <2 x i8> %xor, <i8 3, i8 3>
  %and1 = and <2 x i8> %x, <i8 3, i8 3>
  %cond = select <2 x i1> %cmp, <2 x i8> %and1, <2 x i8> <i8 1, i8 1>
  ret <2 x i8> %cond
}

define <2 x i8> @src_xor_bit_vec_poison(<2 x i8> %x, <2 x i8> %y) {
; CHECK-LABEL: @src_xor_bit_vec_poison(
; CHECK-NEXT:    [[AND:%.*]] = and <2 x i8> [[Y:%.*]], <i8 poison, i8 12>
; CHECK-NEXT:    [[XOR:%.*]] = xor <2 x i8> [[AND]], [[X:%.*]]
; CHECK-NEXT:    [[CMP:%.*]] = icmp eq <2 x i8> [[XOR]], <i8 3, i8 3>
; CHECK-NEXT:    [[COND:%.*]] = select <2 x i1> [[CMP]], <2 x i8> <i8 3, i8 3>, <2 x i8> <i8 1, i8 1>
; CHECK-NEXT:    ret <2 x i8> [[COND]]
;
  %and = and <2 x i8> %y, <i8 poison, i8 12>
  %xor = xor <2 x i8> %and, %x
  %cmp = icmp eq <2 x i8> %xor, <i8 3, i8 3>
  %and1 = and <2 x i8> %x, <i8 poison, i8 3>
  %cond = select <2 x i1> %cmp, <2 x i8> %and1, <2 x i8> <i8 1, i8 1>
  ret <2 x i8> %cond
}

define <2 x i8> @src_xor_bit_vec_poison2(<2 x i8> %x, <2 x i8> %y) {
; CHECK-LABEL: @src_xor_bit_vec_poison2(
; CHECK-NEXT:    [[AND:%.*]] = and <2 x i8> [[Y:%.*]], <i8 poison, i8 12>
; CHECK-NEXT:    [[XOR:%.*]] = xor <2 x i8> [[AND]], [[X:%.*]]
; CHECK-NEXT:    [[CMP:%.*]] = icmp eq <2 x i8> [[XOR]], <i8 3, i8 3>
; CHECK-NEXT:    [[COND:%.*]] = select <2 x i1> [[CMP]], <2 x i8> <i8 3, i8 3>, <2 x i8> <i8 1, i8 1>
; CHECK-NEXT:    ret <2 x i8> [[COND]]
;
  %and = and <2 x i8> %y, <i8 poison, i8 12>
  %xor = xor <2 x i8> %and, %x
  %cmp = icmp eq <2 x i8> %xor, <i8 3, i8 3>
  %and1 = and <2 x i8> %x, <i8 3, i8 3>
  %cond = select <2 x i1> %cmp, <2 x i8> %and1, <2 x i8> <i8 1, i8 1>
  ret <2 x i8> %cond
}

define i8 @src_xor_bit_ne(i8 %x, i8 %y) {
; CHECK-LABEL: @src_xor_bit_ne(
; CHECK-NEXT:    [[AND:%.*]] = and i8 [[Y:%.*]], 12
; CHECK-NEXT:    [[XOR:%.*]] = xor i8 [[AND]], [[X:%.*]]
; CHECK-NEXT:    [[CMP_NOT:%.*]] = icmp eq i8 [[XOR]], 3
; CHECK-NEXT:    [[COND:%.*]] = select i1 [[CMP_NOT]], i8 3, i8 1
; CHECK-NEXT:    ret i8 [[COND]]
;
  %and = and i8 %y, 12
  %xor = xor i8 %and, %x
  %cmp = icmp ne i8 %xor, 3
  %and1 = and i8 %x, 3
  %cond = select i1 %cmp, i8 1, i8 %and1
  ret i8 %cond
}

define <2 x i8> @src_xor_bit_vec_ne(<2 x i8> %x, <2 x i8> %y) {
; CHECK-LABEL: @src_xor_bit_vec_ne(
; CHECK-NEXT:    [[AND:%.*]] = and <2 x i8> [[Y:%.*]], <i8 12, i8 12>
; CHECK-NEXT:    [[XOR:%.*]] = xor <2 x i8> [[AND]], [[X:%.*]]
; CHECK-NEXT:    [[CMP_NOT:%.*]] = icmp eq <2 x i8> [[XOR]], <i8 3, i8 3>
; CHECK-NEXT:    [[COND:%.*]] = select <2 x i1> [[CMP_NOT]], <2 x i8> <i8 3, i8 3>, <2 x i8> <i8 1, i8 1>
; CHECK-NEXT:    ret <2 x i8> [[COND]]
;
  %and = and <2 x i8> %y, <i8 12, i8 12>
  %xor = xor <2 x i8> %and, %x
  %cmp = icmp ne <2 x i8> %xor, <i8 3, i8 3>
  %and1 = and <2 x i8> %x, <i8 3, i8 3>
  %cond = select <2 x i1> %cmp, <2 x i8> <i8 1, i8 1>, <2 x i8> %and1
  ret <2 x i8> %cond
}

define <2 x i8> @src_xor_bit_vec_poison_ne(<2 x i8> %x, <2 x i8> %y) {
; CHECK-LABEL: @src_xor_bit_vec_poison_ne(
; CHECK-NEXT:    [[AND:%.*]] = and <2 x i8> [[Y:%.*]], <i8 poison, i8 12>
; CHECK-NEXT:    [[XOR:%.*]] = xor <2 x i8> [[AND]], [[X:%.*]]
; CHECK-NEXT:    [[CMP_NOT:%.*]] = icmp eq <2 x i8> [[XOR]], <i8 3, i8 3>
; CHECK-NEXT:    [[COND:%.*]] = select <2 x i1> [[CMP_NOT]], <2 x i8> <i8 3, i8 3>, <2 x i8> <i8 1, i8 1>
; CHECK-NEXT:    ret <2 x i8> [[COND]]
;
  %and = and <2 x i8> %y, <i8 poison, i8 12>
  %xor = xor <2 x i8> %and, %x
  %cmp = icmp ne <2 x i8> %xor, <i8 3, i8 3>
  %and1 = and <2 x i8> %x, <i8 poison, i8 3>
  %cond = select <2 x i1> %cmp, <2 x i8> <i8 1, i8 1>, <2 x i8> %and1
  ret <2 x i8> %cond
}

define <2 x i8> @src_xor_bit_vec_poison2_ne(<2 x i8> %x, <2 x i8> %y) {
; CHECK-LABEL: @src_xor_bit_vec_poison2_ne(
; CHECK-NEXT:    [[AND:%.*]] = and <2 x i8> [[Y:%.*]], <i8 poison, i8 12>
; CHECK-NEXT:    [[XOR:%.*]] = xor <2 x i8> [[AND]], [[X:%.*]]
; CHECK-NEXT:    [[CMP_NOT:%.*]] = icmp eq <2 x i8> [[XOR]], <i8 3, i8 3>
; CHECK-NEXT:    [[COND:%.*]] = select <2 x i1> [[CMP_NOT]], <2 x i8> <i8 3, i8 3>, <2 x i8> <i8 1, i8 1>
; CHECK-NEXT:    ret <2 x i8> [[COND]]
;
  %and = and <2 x i8> %y, <i8 poison, i8 12>
  %xor = xor <2 x i8> %and, %x
  %cmp = icmp ne <2 x i8> %xor, <i8 3, i8 3>
  %and1 = and <2 x i8> %x, <i8 3, i8 3>
  %cond = select <2 x i1> %cmp, <2 x i8> <i8 1, i8 1>, <2 x i8> %and1
  ret <2 x i8> %cond
}

define i32 @and_lshr_and(i32 %arg) {
; CHECK-LABEL: @and_lshr_and(
; CHECK-NEXT:    [[TMP1:%.*]] = and i32 [[ARG:%.*]], 3
; CHECK-NEXT:    [[TMP2:%.*]] = icmp ne i32 [[TMP1]], 0
; CHECK-NEXT:    [[T4:%.*]] = zext i1 [[TMP2]] to i32
; CHECK-NEXT:    ret i32 [[T4]]
;
  %t = and i32 %arg, 1
  %t1 = icmp eq i32 %t, 0
  %t2 = lshr i32 %arg, 1
  %t3 = and i32 %t2, 1
  %t4 = select i1 %t1, i32 %t3, i32 1
  ret i32 %t4
}

define <2 x i32> @and_lshr_and_splatvec(<2 x i32> %arg) {
; CHECK-LABEL: @and_lshr_and_splatvec(
; CHECK-NEXT:    [[TMP1:%.*]] = and <2 x i32> [[ARG:%.*]], <i32 3, i32 3>
; CHECK-NEXT:    [[TMP2:%.*]] = icmp ne <2 x i32> [[TMP1]], zeroinitializer
; CHECK-NEXT:    [[T4:%.*]] = zext <2 x i1> [[TMP2]] to <2 x i32>
; CHECK-NEXT:    ret <2 x i32> [[T4]]
;
  %t = and <2 x i32> %arg, <i32 1, i32 1>
  %t1 = icmp eq <2 x i32> %t, zeroinitializer
  %t2 = lshr <2 x i32> %arg, <i32 1, i32 1>
  %t3 = and <2 x i32> %t2, <i32 1, i32 1>
  %t4 = select <2 x i1> %t1, <2 x i32> %t3, <2 x i32> <i32 1, i32 1>
  ret <2 x i32> %t4
}

define <2 x i32> @and_lshr_and_vec_v0(<2 x i32> %arg) {
; CHECK-LABEL: @and_lshr_and_vec_v0(
; CHECK-NEXT:    [[TMP1:%.*]] = and <2 x i32> [[ARG:%.*]], <i32 3, i32 6>
; CHECK-NEXT:    [[TMP2:%.*]] = icmp ne <2 x i32> [[TMP1]], zeroinitializer
; CHECK-NEXT:    [[T4:%.*]] = zext <2 x i1> [[TMP2]] to <2 x i32>
; CHECK-NEXT:    ret <2 x i32> [[T4]]
;
  %t = and <2 x i32> %arg, <i32 1, i32 4> ; mask is not splat
  %t1 = icmp eq <2 x i32> %t, zeroinitializer
  %t2 = lshr <2 x i32> %arg, <i32 1, i32 1>
  %t3 = and <2 x i32> %t2, <i32 1, i32 1>
  %t4 = select <2 x i1> %t1, <2 x i32> %t3, <2 x i32> <i32 1, i32 1>
  ret <2 x i32> %t4
}

define <2 x i32> @and_lshr_and_vec_v1(<2 x i32> %arg) {
; CHECK-LABEL: @and_lshr_and_vec_v1(
; CHECK-NEXT:    [[TMP1:%.*]] = and <2 x i32> [[ARG:%.*]], <i32 3, i32 5>
; CHECK-NEXT:    [[TMP2:%.*]] = icmp ne <2 x i32> [[TMP1]], zeroinitializer
; CHECK-NEXT:    [[T4:%.*]] = zext <2 x i1> [[TMP2]] to <2 x i32>
; CHECK-NEXT:    ret <2 x i32> [[T4]]
;
  %t = and <2 x i32> %arg, <i32 1, i32 1>
  %t1 = icmp eq <2 x i32> %t, zeroinitializer
  %t2 = lshr <2 x i32> %arg, <i32 1, i32 2> ; shift is not splat
  %t3 = and <2 x i32> %t2, <i32 1, i32 1>
  %t4 = select <2 x i1> %t1, <2 x i32> %t3, <2 x i32> <i32 1, i32 1>
  ret <2 x i32> %t4
}

define <2 x i32> @and_lshr_and_vec_v2(<2 x i32> %arg) {
; CHECK-LABEL: @and_lshr_and_vec_v2(
; CHECK-NEXT:    [[TMP1:%.*]] = and <2 x i32> [[ARG:%.*]], <i32 12, i32 3>
; CHECK-NEXT:    [[TMP2:%.*]] = icmp ne <2 x i32> [[TMP1]], zeroinitializer
; CHECK-NEXT:    [[T4:%.*]] = zext <2 x i1> [[TMP2]] to <2 x i32>
; CHECK-NEXT:    ret <2 x i32> [[T4]]
;
  %t = and <2 x i32> %arg, <i32 8, i32 1> ; mask is not splat
  %t1 = icmp eq <2 x i32> %t, zeroinitializer
  %t2 = lshr <2 x i32> %arg, <i32 2, i32 1> ; shift is not splat
  %t3 = and <2 x i32> %t2, <i32 1, i32 1>
  %t4 = select <2 x i1> %t1, <2 x i32> %t3, <2 x i32> <i32 1, i32 1>
  ret <2 x i32> %t4
}

define <3 x i32> @and_lshr_and_vec_poison(<3 x i32> %arg) {
; CHECK-LABEL: @and_lshr_and_vec_poison(
; CHECK-NEXT:    [[TMP1:%.*]] = and <3 x i32> [[ARG:%.*]], <i32 3, i32 poison, i32 3>
; CHECK-NEXT:    [[TMP2:%.*]] = icmp ne <3 x i32> [[TMP1]], zeroinitializer
; CHECK-NEXT:    [[T4:%.*]] = zext <3 x i1> [[TMP2]] to <3 x i32>
; CHECK-NEXT:    ret <3 x i32> [[T4]]
;
  %t = and <3 x i32> %arg, <i32 1, i32 poison, i32 1>
  %t1 = icmp eq <3 x i32> %t, <i32 0, i32 poison, i32 0>
  %t2 = lshr <3 x i32> %arg, <i32 1, i32 poison, i32 1>
  %t3 = and <3 x i32> %t2, <i32 1, i32 poison, i32 1>
  %t4 = select <3 x i1> %t1, <3 x i32> %t3, <3 x i32> <i32 1, i32 poison, i32 1>
  ret <3 x i32> %t4
}

define i32 @and_and(i32 %arg) {
; CHECK-LABEL: @and_and(
; CHECK-NEXT:    [[TMP1:%.*]] = and i32 [[ARG:%.*]], 3
; CHECK-NEXT:    [[TMP2:%.*]] = icmp ne i32 [[TMP1]], 0
; CHECK-NEXT:    [[T3:%.*]] = zext i1 [[TMP2]] to i32
; CHECK-NEXT:    ret i32 [[T3]]
;
  %t = and i32 %arg, 2
  %t1 = icmp eq i32 %t, 0
  %t2 = and i32 %arg, 1
  %t3 = select i1 %t1, i32 %t2, i32 1
  ret i32 %t3
}

define <2 x i32> @and_and_splatvec(<2 x i32> %arg) {
; CHECK-LABEL: @and_and_splatvec(
; CHECK-NEXT:    [[TMP1:%.*]] = and <2 x i32> [[ARG:%.*]], <i32 3, i32 3>
; CHECK-NEXT:    [[TMP2:%.*]] = icmp ne <2 x i32> [[TMP1]], zeroinitializer
; CHECK-NEXT:    [[T3:%.*]] = zext <2 x i1> [[TMP2]] to <2 x i32>
; CHECK-NEXT:    ret <2 x i32> [[T3]]
;
  %t = and <2 x i32> %arg, <i32 2, i32 2>
  %t1 = icmp eq <2 x i32> %t, zeroinitializer
  %t2 = and <2 x i32> %arg, <i32 1, i32 1>
  %t3 = select <2 x i1> %t1, <2 x i32> %t2, <2 x i32> <i32 1, i32 1>
  ret <2 x i32> %t3
}

define <2 x i32> @and_and_vec(<2 x i32> %arg) {
; CHECK-LABEL: @and_and_vec(
; CHECK-NEXT:    [[TMP1:%.*]] = and <2 x i32> [[ARG:%.*]], <i32 7, i32 3>
; CHECK-NEXT:    [[TMP2:%.*]] = icmp ne <2 x i32> [[TMP1]], zeroinitializer
; CHECK-NEXT:    [[T3:%.*]] = zext <2 x i1> [[TMP2]] to <2 x i32>
; CHECK-NEXT:    ret <2 x i32> [[T3]]
;
  %t = and <2 x i32> %arg, <i32 6, i32 2> ; mask is not splat
  %t1 = icmp eq <2 x i32> %t, zeroinitializer
  %t2 = and <2 x i32> %arg, <i32 1, i32 1>
  %t3 = select <2 x i1> %t1, <2 x i32> %t2, <2 x i32> <i32 1, i32 1>
  ret <2 x i32> %t3
}

define <3 x i32> @and_and_vec_poison(<3 x i32> %arg) {
; CHECK-LABEL: @and_and_vec_poison(
; CHECK-NEXT:    [[TMP1:%.*]] = and <3 x i32> [[ARG:%.*]], <i32 3, i32 poison, i32 3>
; CHECK-NEXT:    [[TMP2:%.*]] = icmp ne <3 x i32> [[TMP1]], zeroinitializer
; CHECK-NEXT:    [[T3:%.*]] = zext <3 x i1> [[TMP2]] to <3 x i32>
; CHECK-NEXT:    ret <3 x i32> [[T3]]
;
  %t = and <3 x i32> %arg, <i32 2, i32 poison, i32 2>
  %t1 = icmp eq <3 x i32> %t, <i32 0, i32 poison, i32 0>
  %t2 = and <3 x i32> %arg, <i32 1, i32 poison, i32 1>
  %t3 = select <3 x i1> %t1, <3 x i32> %t2, <3 x i32> <i32 1, i32 poison, i32 1>
  ret <3 x i32> %t3
}

; ============================================================================ ;
; Mask can be a variable, too.
; ============================================================================ ;

define i32 @f_var0(i32 %arg, i32 %arg1) {
; CHECK-LABEL: @f_var0(
; CHECK-NEXT:    [[TMP1:%.*]] = or i32 [[ARG1:%.*]], 2
; CHECK-NEXT:    [[TMP2:%.*]] = and i32 [[TMP1]], [[ARG:%.*]]
; CHECK-NEXT:    [[TMP3:%.*]] = icmp ne i32 [[TMP2]], 0
; CHECK-NEXT:    [[T5:%.*]] = zext i1 [[TMP3]] to i32
; CHECK-NEXT:    ret i32 [[T5]]
;
  %t = and i32 %arg, %arg1
  %t2 = icmp eq i32 %t, 0
  %t3 = lshr i32 %arg, 1
  %t4 = and i32 %t3, 1
  %t5 = select i1 %t2, i32 %t4, i32 1
  ret i32 %t5
}

; Should be exactly as the previous one
define i32 @f_var0_commutative_and(i32 %arg, i32 %arg1) {
; CHECK-LABEL: @f_var0_commutative_and(
; CHECK-NEXT:    [[TMP1:%.*]] = or i32 [[ARG1:%.*]], 2
; CHECK-NEXT:    [[TMP2:%.*]] = and i32 [[TMP1]], [[ARG:%.*]]
; CHECK-NEXT:    [[TMP3:%.*]] = icmp ne i32 [[TMP2]], 0
; CHECK-NEXT:    [[T5:%.*]] = zext i1 [[TMP3]] to i32
; CHECK-NEXT:    ret i32 [[T5]]
;
  %t = and i32 %arg1, %arg ; in different order
  %t2 = icmp eq i32 %t, 0
  %t3 = lshr i32 %arg, 1
  %t4 = and i32 %t3, 1
  %t5 = select i1 %t2, i32 %t4, i32 1
  ret i32 %t5
}

define <2 x i32> @f_var0_splatvec(<2 x i32> %arg, <2 x i32> %arg1) {
; CHECK-LABEL: @f_var0_splatvec(
; CHECK-NEXT:    [[TMP1:%.*]] = or <2 x i32> [[ARG1:%.*]], <i32 2, i32 2>
; CHECK-NEXT:    [[TMP2:%.*]] = and <2 x i32> [[TMP1]], [[ARG:%.*]]
; CHECK-NEXT:    [[TMP3:%.*]] = icmp ne <2 x i32> [[TMP2]], zeroinitializer
; CHECK-NEXT:    [[T5:%.*]] = zext <2 x i1> [[TMP3]] to <2 x i32>
; CHECK-NEXT:    ret <2 x i32> [[T5]]
;
  %t = and <2 x i32> %arg, %arg1
  %t2 = icmp eq <2 x i32> %t, zeroinitializer
  %t3 = lshr <2 x i32> %arg, <i32 1, i32 1>
  %t4 = and <2 x i32> %t3, <i32 1, i32 1>
  %t5 = select <2 x i1> %t2, <2 x i32> %t4, <2 x i32> <i32 1, i32 1>
  ret <2 x i32> %t5
}

define <2 x i32> @f_var0_vec(<2 x i32> %arg, <2 x i32> %arg1) {
; CHECK-LABEL: @f_var0_vec(
; CHECK-NEXT:    [[TMP1:%.*]] = or <2 x i32> [[ARG1:%.*]], <i32 2, i32 4>
; CHECK-NEXT:    [[TMP2:%.*]] = and <2 x i32> [[TMP1]], [[ARG:%.*]]
; CHECK-NEXT:    [[TMP3:%.*]] = icmp ne <2 x i32> [[TMP2]], zeroinitializer
; CHECK-NEXT:    [[T5:%.*]] = zext <2 x i1> [[TMP3]] to <2 x i32>
; CHECK-NEXT:    ret <2 x i32> [[T5]]
;
  %t = and <2 x i32> %arg, %arg1
  %t2 = icmp eq <2 x i32> %t, zeroinitializer
  %t3 = lshr <2 x i32> %arg, <i32 1, i32 2> ; shift is not splat
  %t4 = and <2 x i32> %t3, <i32 1, i32 1>
  %t5 = select <2 x i1> %t2, <2 x i32> %t4, <2 x i32> <i32 1, i32 1>
  ret <2 x i32> %t5
}

define <3 x i32> @f_var0_vec_poison(<3 x i32> %arg, <3 x i32> %arg1) {
; CHECK-LABEL: @f_var0_vec_poison(
; CHECK-NEXT:    [[TMP1:%.*]] = or <3 x i32> [[ARG1:%.*]], <i32 2, i32 poison, i32 2>
; CHECK-NEXT:    [[TMP2:%.*]] = and <3 x i32> [[TMP1]], [[ARG:%.*]]
; CHECK-NEXT:    [[TMP3:%.*]] = icmp ne <3 x i32> [[TMP2]], zeroinitializer
; CHECK-NEXT:    [[T5:%.*]] = zext <3 x i1> [[TMP3]] to <3 x i32>
; CHECK-NEXT:    ret <3 x i32> [[T5]]
;
  %t = and <3 x i32> %arg, %arg1
  %t2 = icmp eq <3 x i32> %t, <i32 0, i32 poison, i32 0>
  %t3 = lshr <3 x i32> %arg, <i32 1, i32 poison, i32 1>
  %t4 = and <3 x i32> %t3, <i32 1, i32 poison, i32 1>
  ; The second element of %t5 is poison because it is (poison ? poison : poison).
  %t5 = select <3 x i1> %t2, <3 x i32> %t4, <3 x i32> <i32 1, i32 poison, i32 1>
  ret <3 x i32> %t5
}

define i32 @f_var1(i32 %arg, i32 %arg1) {
; CHECK-LABEL: @f_var1(
; CHECK-NEXT:    [[TMP1:%.*]] = or i32 [[ARG1:%.*]], 1
; CHECK-NEXT:    [[TMP2:%.*]] = and i32 [[TMP1]], [[ARG:%.*]]
; CHECK-NEXT:    [[TMP3:%.*]] = icmp ne i32 [[TMP2]], 0
; CHECK-NEXT:    [[T4:%.*]] = zext i1 [[TMP3]] to i32
; CHECK-NEXT:    ret i32 [[T4]]
;
  %t = and i32 %arg, %arg1
  %t2 = icmp eq i32 %t, 0
  %t3 = and i32 %arg, 1
  %t4 = select i1 %t2, i32 %t3, i32 1
  ret i32 %t4
}

; Should be exactly as the previous one
define i32 @f_var1_commutative_and(i32 %arg, i32 %arg1) {
; CHECK-LABEL: @f_var1_commutative_and(
; CHECK-NEXT:    [[TMP1:%.*]] = or i32 [[ARG1:%.*]], 1
; CHECK-NEXT:    [[TMP2:%.*]] = and i32 [[TMP1]], [[ARG:%.*]]
; CHECK-NEXT:    [[TMP3:%.*]] = icmp ne i32 [[TMP2]], 0
; CHECK-NEXT:    [[T4:%.*]] = zext i1 [[TMP3]] to i32
; CHECK-NEXT:    ret i32 [[T4]]
;
  %t = and i32 %arg1, %arg ; in different order
  %t2 = icmp eq i32 %t, 0
  %t3 = and i32 %arg, 1
  %t4 = select i1 %t2, i32 %t3, i32 1
  ret i32 %t4
}

define <2 x i32> @f_var1_vec(<2 x i32> %arg, <2 x i32> %arg1) {
; CHECK-LABEL: @f_var1_vec(
; CHECK-NEXT:    [[TMP1:%.*]] = or <2 x i32> [[ARG1:%.*]], <i32 1, i32 1>
; CHECK-NEXT:    [[TMP2:%.*]] = and <2 x i32> [[TMP1]], [[ARG:%.*]]
; CHECK-NEXT:    [[TMP3:%.*]] = icmp ne <2 x i32> [[TMP2]], zeroinitializer
; CHECK-NEXT:    [[T4:%.*]] = zext <2 x i1> [[TMP3]] to <2 x i32>
; CHECK-NEXT:    ret <2 x i32> [[T4]]
;
  %t = and <2 x i32> %arg, %arg1
  %t2 = icmp eq <2 x i32> %t, zeroinitializer
  %t3 = and <2 x i32> %arg, <i32 1, i32 1>
  %t4 = select <2 x i1> %t2, <2 x i32> %t3, <2 x i32> <i32 1, i32 1>
  ret <2 x i32> %t4
}

define <3 x i32> @f_var1_vec_poison(<3 x i32> %arg, <3 x i32> %arg1) {
; CHECK-LABEL: @f_var1_vec_poison(
; CHECK-NEXT:    [[TMP1:%.*]] = or <3 x i32> [[ARG1:%.*]], <i32 1, i32 1, i32 1>
; CHECK-NEXT:    [[TMP2:%.*]] = and <3 x i32> [[TMP1]], [[ARG:%.*]]
; CHECK-NEXT:    [[TMP3:%.*]] = icmp ne <3 x i32> [[TMP2]], zeroinitializer
; CHECK-NEXT:    [[T4:%.*]] = zext <3 x i1> [[TMP3]] to <3 x i32>
; CHECK-NEXT:    ret <3 x i32> [[T4]]
;
  %t = and <3 x i32> %arg, %arg1
  %t2 = icmp eq <3 x i32> %t, <i32 0, i32 poison, i32 0>
  %t3 = and <3 x i32> %arg, <i32 1, i32 poison, i32 1>
  %t4 = select <3 x i1> %t2, <3 x i32> %t3, <3 x i32> <i32 1, i32 poison, i32 1>
  ret <3 x i32> %t4
}

; ============================================================================ ;
; Shift can't be a variable in general.
; ============================================================================ ;

define i32 @f_var2(i32 %arg, i32 %arg1) {
; CHECK-LABEL: @f_var2(
; CHECK-NEXT:    [[T:%.*]] = and i32 [[ARG:%.*]], 1
; CHECK-NEXT:    [[T2:%.*]] = icmp eq i32 [[T]], 0
; CHECK-NEXT:    [[T3:%.*]] = lshr i32 [[ARG]], [[ARG1:%.*]]
; CHECK-NEXT:    [[T4:%.*]] = and i32 [[T3]], 1
; CHECK-NEXT:    [[T5:%.*]] = select i1 [[T2]], i32 [[T4]], i32 1
; CHECK-NEXT:    ret i32 [[T5]]
;
  %t = and i32 %arg, 1
  %t2 = icmp eq i32 %t, 0
  %t3 = lshr i32 %arg, %arg1
  %t4 = and i32 %t3, 1
  %t5 = select i1 %t2, i32 %t4, i32 1
  ret i32 %t5
}

define <2 x i32> @f_var2_splatvec(<2 x i32> %arg, <2 x i32> %arg1) {
; CHECK-LABEL: @f_var2_splatvec(
; CHECK-NEXT:    [[T:%.*]] = and <2 x i32> [[ARG:%.*]], <i32 1, i32 1>
; CHECK-NEXT:    [[T2:%.*]] = icmp eq <2 x i32> [[T]], zeroinitializer
; CHECK-NEXT:    [[T3:%.*]] = lshr <2 x i32> [[ARG]], [[ARG1:%.*]]
; CHECK-NEXT:    [[T4:%.*]] = and <2 x i32> [[T3]], <i32 1, i32 1>
; CHECK-NEXT:    [[T5:%.*]] = select <2 x i1> [[T2]], <2 x i32> [[T4]], <2 x i32> <i32 1, i32 1>
; CHECK-NEXT:    ret <2 x i32> [[T5]]
;
  %t = and <2 x i32> %arg, <i32 1, i32 1>
  %t2 = icmp eq <2 x i32> %t, zeroinitializer
  %t3 = lshr <2 x i32> %arg, %arg1
  %t4 = and <2 x i32> %t3, <i32 1, i32 1>
  %t5 = select <2 x i1> %t2, <2 x i32> %t4, <2 x i32> <i32 1, i32 1>
  ret <2 x i32> %t5
}

define <2 x i32> @f_var2_vec(<2 x i32> %arg, <2 x i32> %arg1) {
; CHECK-LABEL: @f_var2_vec(
; CHECK-NEXT:    [[T:%.*]] = and <2 x i32> [[ARG:%.*]], <i32 2, i32 1>
; CHECK-NEXT:    [[T2:%.*]] = icmp eq <2 x i32> [[T]], zeroinitializer
; CHECK-NEXT:    [[T3:%.*]] = lshr <2 x i32> [[ARG]], [[ARG1:%.*]]
; CHECK-NEXT:    [[T4:%.*]] = and <2 x i32> [[T3]], <i32 1, i32 1>
; CHECK-NEXT:    [[T5:%.*]] = select <2 x i1> [[T2]], <2 x i32> [[T4]], <2 x i32> <i32 1, i32 1>
; CHECK-NEXT:    ret <2 x i32> [[T5]]
;
  %t = and <2 x i32> %arg, <i32 2, i32 1>; mask is not splat
  %t2 = icmp eq <2 x i32> %t, zeroinitializer
  %t3 = lshr <2 x i32> %arg, %arg1
  %t4 = and <2 x i32> %t3, <i32 1, i32 1>
  %t5 = select <2 x i1> %t2, <2 x i32> %t4, <2 x i32> <i32 1, i32 1>
  ret <2 x i32> %t5
}

define <3 x i32> @f_var2_vec_poison(<3 x i32> %arg, <3 x i32> %arg1) {
; CHECK-LABEL: @f_var2_vec_poison(
; CHECK-NEXT:    [[T:%.*]] = and <3 x i32> [[ARG:%.*]], <i32 1, i32 poison, i32 1>
; CHECK-NEXT:    [[T2:%.*]] = icmp eq <3 x i32> [[T]], <i32 0, i32 poison, i32 0>
; CHECK-NEXT:    [[T3:%.*]] = lshr <3 x i32> [[ARG]], [[ARG1:%.*]]
; CHECK-NEXT:    [[T4:%.*]] = and <3 x i32> [[T3]], <i32 1, i32 poison, i32 1>
; CHECK-NEXT:    [[T5:%.*]] = select <3 x i1> [[T2]], <3 x i32> [[T4]], <3 x i32> <i32 1, i32 poison, i32 1>
; CHECK-NEXT:    ret <3 x i32> [[T5]]
;
  %t = and <3 x i32> %arg, <i32 1, i32 poison, i32 1>
  %t2 = icmp eq <3 x i32> %t, <i32 0, i32 poison, i32 0>
  %t3 = lshr <3 x i32> %arg, %arg1
  %t4 = and <3 x i32> %t3, <i32 1, i32 poison, i32 1>
  %t5 = select <3 x i1> %t2, <3 x i32> %t4, <3 x i32> <i32 1, i32 poison, i32 1>
  ret <3 x i32> %t5
}

; ============================================================================ ;
; The worst case: both Mask and Shift are variables
; ============================================================================ ;

define i32 @f_var3(i32 %arg, i32 %arg1, i32 %arg2) {
; CHECK-LABEL: @f_var3(
; CHECK-NEXT:    [[T:%.*]] = and i32 [[ARG:%.*]], [[ARG1:%.*]]
; CHECK-NEXT:    [[T3:%.*]] = icmp eq i32 [[T]], 0
; CHECK-NEXT:    [[T4:%.*]] = lshr i32 [[ARG]], [[ARG2:%.*]]
; CHECK-NEXT:    [[T5:%.*]] = and i32 [[T4]], 1
; CHECK-NEXT:    [[T6:%.*]] = select i1 [[T3]], i32 [[T5]], i32 1
; CHECK-NEXT:    ret i32 [[T6]]
;
  %t = and i32 %arg, %arg1
  %t3 = icmp eq i32 %t, 0
  %t4 = lshr i32 %arg, %arg2
  %t5 = and i32 %t4, 1
  %t6 = select i1 %t3, i32 %t5, i32 1
  ret i32 %t6
}

; Should be exactly as the previous one
define i32 @f_var3_commutative_and(i32 %arg, i32 %arg1, i32 %arg2) {
; CHECK-LABEL: @f_var3_commutative_and(
; CHECK-NEXT:    [[T:%.*]] = and i32 [[ARG1:%.*]], [[ARG:%.*]]
; CHECK-NEXT:    [[T3:%.*]] = icmp eq i32 [[T]], 0
; CHECK-NEXT:    [[T4:%.*]] = lshr i32 [[ARG]], [[ARG2:%.*]]
; CHECK-NEXT:    [[T5:%.*]] = and i32 [[T4]], 1
; CHECK-NEXT:    [[T6:%.*]] = select i1 [[T3]], i32 [[T5]], i32 1
; CHECK-NEXT:    ret i32 [[T6]]
;
  %t = and i32 %arg1, %arg ; in different order
  %t3 = icmp eq i32 %t, 0
  %t4 = lshr i32 %arg, %arg2
  %t5 = and i32 %t4, 1
  %t6 = select i1 %t3, i32 %t5, i32 1
  ret i32 %t6
}

define <2 x i32> @f_var3_splatvec(<2 x i32> %arg, <2 x i32> %arg1, <2 x i32> %arg2) {
; CHECK-LABEL: @f_var3_splatvec(
; CHECK-NEXT:    [[T:%.*]] = and <2 x i32> [[ARG:%.*]], [[ARG1:%.*]]
; CHECK-NEXT:    [[T3:%.*]] = icmp eq <2 x i32> [[T]], zeroinitializer
; CHECK-NEXT:    [[T4:%.*]] = lshr <2 x i32> [[ARG]], [[ARG2:%.*]]
; CHECK-NEXT:    [[T5:%.*]] = and <2 x i32> [[T4]], <i32 1, i32 1>
; CHECK-NEXT:    [[T6:%.*]] = select <2 x i1> [[T3]], <2 x i32> [[T5]], <2 x i32> <i32 1, i32 1>
; CHECK-NEXT:    ret <2 x i32> [[T6]]
;
  %t = and <2 x i32> %arg, %arg1
  %t3 = icmp eq <2 x i32> %t, zeroinitializer
  %t4 = lshr <2 x i32> %arg, %arg2
  %t5 = and <2 x i32> %t4, <i32 1, i32 1>
  %t6 = select <2 x i1> %t3, <2 x i32> %t5, <2 x i32> <i32 1, i32 1>
  ret <2 x i32> %t6
}

define <3 x i32> @f_var3_vec_poison(<3 x i32> %arg, <3 x i32> %arg1, <3 x i32> %arg2) {
; CHECK-LABEL: @f_var3_vec_poison(
; CHECK-NEXT:    [[T:%.*]] = and <3 x i32> [[ARG:%.*]], [[ARG1:%.*]]
; CHECK-NEXT:    [[T3:%.*]] = icmp eq <3 x i32> [[T]], <i32 0, i32 poison, i32 0>
; CHECK-NEXT:    [[T4:%.*]] = lshr <3 x i32> [[ARG]], [[ARG2:%.*]]
; CHECK-NEXT:    [[T5:%.*]] = and <3 x i32> [[T4]], <i32 1, i32 poison, i32 1>
; CHECK-NEXT:    [[T6:%.*]] = select <3 x i1> [[T3]], <3 x i32> [[T5]], <3 x i32> <i32 1, i32 poison, i32 1>
; CHECK-NEXT:    ret <3 x i32> [[T6]]
;
  %t = and <3 x i32> %arg, %arg1
  %t3 = icmp eq <3 x i32> %t, <i32 0, i32 poison, i32 0>
  %t4 = lshr <3 x i32> %arg, %arg2
  %t5 = and <3 x i32> %t4, <i32 1, i32 poison, i32 1>
  %t6 = select <3 x i1> %t3, <3 x i32> %t5, <3 x i32> <i32 1, i32 poison, i32 1>
  ret <3 x i32> %t6
}

; ============================================================================ ;
; Negative tests. Should not be folded.
; ============================================================================ ;

; One use only.

declare void @use32(i32)

declare void @use1(i1)

define i32 @n_var0_oneuse(i32 %arg, i32 %arg1, i32 %arg2) {
; CHECK-LABEL: @n_var0_oneuse(
; CHECK-NEXT:    [[T:%.*]] = and i32 [[ARG:%.*]], [[ARG1:%.*]]
; CHECK-NEXT:    [[T3:%.*]] = icmp eq i32 [[T]], 0
; CHECK-NEXT:    [[T4:%.*]] = lshr i32 [[ARG]], [[ARG2:%.*]]
; CHECK-NEXT:    [[T5:%.*]] = and i32 [[T4]], 1
; CHECK-NEXT:    [[T6:%.*]] = select i1 [[T3]], i32 [[T5]], i32 1
; CHECK-NEXT:    call void @use32(i32 [[T]])
; CHECK-NEXT:    call void @use1(i1 [[T3]])
; CHECK-NEXT:    call void @use32(i32 [[T4]])
; CHECK-NEXT:    call void @use32(i32 [[T5]])
; CHECK-NEXT:    ret i32 [[T6]]
;
  %t = and i32 %arg, %arg1
  %t3 = icmp eq i32 %t, 0
  %t4 = lshr i32 %arg, %arg2
  %t5 = and i32 %t4, 1
  %t6 = select i1 %t3, i32 %t5, i32 1
  call void @use32(i32 %t)
  call void @use1(i1 %t3)
  call void @use32(i32 %t4)
  call void @use32(i32 %t5)
  ret i32 %t6
}

define i32 @n_var1_oneuse(i32 %arg, i32 %arg1) {
; CHECK-LABEL: @n_var1_oneuse(
; CHECK-NEXT:    [[T:%.*]] = and i32 [[ARG:%.*]], [[ARG1:%.*]]
; CHECK-NEXT:    [[T2:%.*]] = icmp eq i32 [[T]], 0
; CHECK-NEXT:    [[T3:%.*]] = and i32 [[ARG]], 1
; CHECK-NEXT:    [[T4:%.*]] = select i1 [[T2]], i32 [[T3]], i32 1
; CHECK-NEXT:    call void @use32(i32 [[T]])
; CHECK-NEXT:    call void @use1(i1 [[T2]])
; CHECK-NEXT:    call void @use32(i32 [[T3]])
; CHECK-NEXT:    ret i32 [[T4]]
;
  %t = and i32 %arg, %arg1
  %t2 = icmp eq i32 %t, 0
  %t3 = and i32 %arg, 1
  %t4 = select i1 %t2, i32 %t3, i32 1
  call void @use32(i32 %t)
  call void @use1(i1 %t2)
  call void @use32(i32 %t3)
  ret i32 %t4
}

; Different variables are used

define i32 @n0(i32 %arg, i32 %arg1) {
; CHECK-LABEL: @n0(
; CHECK-NEXT:    [[T:%.*]] = and i32 [[ARG:%.*]], 1
; CHECK-NEXT:    [[T2:%.*]] = icmp eq i32 [[T]], 0
; CHECK-NEXT:    [[T3:%.*]] = lshr i32 [[ARG1:%.*]], 1
; CHECK-NEXT:    [[T4:%.*]] = and i32 [[T3]], 1
; CHECK-NEXT:    [[T5:%.*]] = select i1 [[T2]], i32 [[T4]], i32 1
; CHECK-NEXT:    ret i32 [[T5]]
;
  %t = and i32 %arg, 1
  %t2 = icmp eq i32 %t, 0
  %t3 = lshr i32 %arg1, 1 ; works on %arg1 instead of %arg
  %t4 = and i32 %t3, 1
  %t5 = select i1 %t2, i32 %t4, i32 1
  ret i32 %t5
}

define i32 @n1(i32 %arg, i32 %arg1) {
; CHECK-LABEL: @n1(
; CHECK-NEXT:    [[T:%.*]] = and i32 [[ARG:%.*]], 2
; CHECK-NEXT:    [[T2:%.*]] = icmp eq i32 [[T]], 0
; CHECK-NEXT:    [[T3:%.*]] = and i32 [[ARG1:%.*]], 1
; CHECK-NEXT:    [[T4:%.*]] = select i1 [[T2]], i32 [[T3]], i32 1
; CHECK-NEXT:    ret i32 [[T4]]
;
  %t = and i32 %arg, 2
  %t2 = icmp eq i32 %t, 0
  %t3 = and i32 %arg1, 1 ; works on %arg1 instead of %arg
  %t4 = select i1 %t2, i32 %t3, i32 1
  ret i32 %t4
}

; False-value is not 1

define i32 @n2(i32 %arg) {
; CHECK-LABEL: @n2(
; CHECK-NEXT:    [[T:%.*]] = and i32 [[ARG:%.*]], 1
; CHECK-NEXT:    [[T1:%.*]] = icmp eq i32 [[T]], 0
; CHECK-NEXT:    [[T2:%.*]] = lshr i32 [[ARG]], 2
; CHECK-NEXT:    [[T3:%.*]] = and i32 [[T2]], 1
; CHECK-NEXT:    [[T4:%.*]] = select i1 [[T1]], i32 [[T3]], i32 0
; CHECK-NEXT:    ret i32 [[T4]]
;
  %t = and i32 %arg, 1
  %t1 = icmp eq i32 %t, 0
  %t2 = lshr i32 %arg, 2
  %t3 = and i32 %t2, 1
  %t4 = select i1 %t1, i32 %t3, i32 0 ; 0 instead of 1
  ret i32 %t4
}

define i32 @n3(i32 %arg) {
; CHECK-LABEL: @n3(
; CHECK-NEXT:    [[T:%.*]] = and i32 [[ARG:%.*]], 2
; CHECK-NEXT:    [[T1:%.*]] = icmp eq i32 [[T]], 0
; CHECK-NEXT:    [[T2:%.*]] = and i32 [[ARG]], 1
; CHECK-NEXT:    [[T3:%.*]] = select i1 [[T1]], i32 [[T2]], i32 0
; CHECK-NEXT:    ret i32 [[T3]]
;
  %t = and i32 %arg, 2
  %t1 = icmp eq i32 %t, 0
  %t2 = and i32 %arg, 1
  %t3 = select i1 %t1, i32 %t2, i32 0 ; 0 instead of 1
  ret i32 %t3
}

; Mask of second and is not one

define i32 @n4(i32 %arg) {
; CHECK-LABEL: @n4(
; CHECK-NEXT:    [[T:%.*]] = and i32 [[ARG:%.*]], 1
; CHECK-NEXT:    [[T1:%.*]] = icmp eq i32 [[T]], 0
; CHECK-NEXT:    [[T2:%.*]] = lshr i32 [[ARG]], 2
; CHECK-NEXT:    [[T3:%.*]] = and i32 [[T2]], 2
; CHECK-NEXT:    [[T4:%.*]] = select i1 [[T1]], i32 [[T3]], i32 1
; CHECK-NEXT:    ret i32 [[T4]]
;
  %t = and i32 %arg, 1
  %t1 = icmp eq i32 %t, 0
  %t2 = lshr i32 %arg, 2
  %t3 = and i32 %t2, 2 ; 2 instead of 1
  %t4 = select i1 %t1, i32 %t3, i32 1
  ret i32 %t4
}

define i32 @n5(i32 %arg) {
; CHECK-LABEL: @n5(
; CHECK-NEXT:    [[T:%.*]] = and i32 [[ARG:%.*]], 2
; CHECK-NEXT:    [[T1:%.*]] = icmp eq i32 [[T]], 0
; CHECK-NEXT:    [[T2:%.*]] = and i32 [[ARG]], 3
; CHECK-NEXT:    [[T3:%.*]] = select i1 [[T1]], i32 [[T2]], i32 1
; CHECK-NEXT:    ret i32 [[T3]]
;
  %t = and i32 %arg, 2
  %t1 = icmp eq i32 %t, 0
  %t2 = and i32 %arg, 3 ; 3 instead of 2
  %t3 = select i1 %t1, i32 %t2, i32 1
  ret i32 %t3
}

; Wrong icmp pred

define i32 @n6(i32 %arg) {
; CHECK-LABEL: @n6(
; CHECK-NEXT:    [[T:%.*]] = and i32 [[ARG:%.*]], 1
; CHECK-NEXT:    [[T1_NOT:%.*]] = icmp eq i32 [[T]], 0
; CHECK-NEXT:    [[T2:%.*]] = lshr i32 [[ARG]], 2
; CHECK-NEXT:    [[T3:%.*]] = and i32 [[T2]], 1
; CHECK-NEXT:    [[T4:%.*]] = select i1 [[T1_NOT]], i32 1, i32 [[T3]]
; CHECK-NEXT:    ret i32 [[T4]]
;
  %t = and i32 %arg, 1
  %t1 = icmp ne i32 %t, 0 ; ne, not eq
  %t2 = lshr i32 %arg, 2
  %t3 = and i32 %t2, 1
  %t4 = select i1 %t1, i32 %t3, i32 1
  ret i32 %t4
}

define i32 @n7(i32 %arg) {
; CHECK-LABEL: @n7(
; CHECK-NEXT:    [[T:%.*]] = and i32 [[ARG:%.*]], 2
; CHECK-NEXT:    [[T1_NOT:%.*]] = icmp eq i32 [[T]], 0
; CHECK-NEXT:    [[T2:%.*]] = and i32 [[ARG]], 1
; CHECK-NEXT:    [[T3:%.*]] = select i1 [[T1_NOT]], i32 1, i32 [[T2]]
; CHECK-NEXT:    ret i32 [[T3]]
;
  %t = and i32 %arg, 2
  %t1 = icmp ne i32 %t, 0 ; ne, not eq
  %t2 = and i32 %arg, 1
  %t3 = select i1 %t1, i32 %t2, i32 1
  ret i32 %t3
}

; icmp second operand is not zero

define i32 @n8(i32 %arg) {
; CHECK-LABEL: @n8(
; CHECK-NEXT:    [[T:%.*]] = and i32 [[ARG:%.*]], 1
; CHECK-NEXT:    [[T1_NOT:%.*]] = icmp eq i32 [[T]], 0
; CHECK-NEXT:    [[T2:%.*]] = lshr i32 [[ARG]], 2
; CHECK-NEXT:    [[T3:%.*]] = and i32 [[T2]], 1
; CHECK-NEXT:    [[T4:%.*]] = select i1 [[T1_NOT]], i32 1, i32 [[T3]]
; CHECK-NEXT:    ret i32 [[T4]]
;
  %t = and i32 %arg, 1
  %t1 = icmp eq i32 %t, 1
  %t2 = lshr i32 %arg, 2
  %t3 = and i32 %t2, 1
  %t4 = select i1 %t1, i32 %t3, i32 1
  ret i32 %t4
}
