; NOTE: Assertions have been autogenerated by utils/update_test_checks.py
; RUN: opt < %s -loop-reduce -S | FileCheck %s

target datalayout = "e-m:e-p:64:64-i64:64-i128:128-n64-S128"
target triple = "riscv64"


define void @icmp_zero(i64 %N, ptr %p) {
; CHECK-LABEL: @icmp_zero(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    br label [[VECTOR_BODY:%.*]]
; CHECK:       vector.body:
; CHECK-NEXT:    [[LSR_IV:%.*]] = phi i64 [ [[LSR_IV_NEXT:%.*]], [[VECTOR_BODY]] ], [ [[N:%.*]], [[ENTRY:%.*]] ]
; CHECK-NEXT:    store i64 0, ptr [[P:%.*]], align 8
; CHECK-NEXT:    [[LSR_IV_NEXT]] = add i64 [[LSR_IV]], -2
; CHECK-NEXT:    [[DONE:%.*]] = icmp eq i64 [[LSR_IV_NEXT]], 0
; CHECK-NEXT:    br i1 [[DONE]], label [[EXIT:%.*]], label [[VECTOR_BODY]]
; CHECK:       exit:
; CHECK-NEXT:    ret void
;
entry:
  br label %vector.body

vector.body:
  %iv = phi i64 [ 0, %entry ], [ %iv.next, %vector.body ]
  store i64 0, ptr %p
  %iv.next = add i64 %iv, 2
  %done = icmp eq i64 %iv.next, %N
  br i1 %done, label %exit, label %vector.body

exit:
  ret void
}

define void @icmp_zero_urem_nonzero_con(i64 %N, ptr %p) {
; CHECK-LABEL: @icmp_zero_urem_nonzero_con(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[UREM:%.*]] = urem i64 [[N:%.*]], 16
; CHECK-NEXT:    br label [[VECTOR_BODY:%.*]]
; CHECK:       vector.body:
; CHECK-NEXT:    [[LSR_IV:%.*]] = phi i64 [ [[LSR_IV_NEXT:%.*]], [[VECTOR_BODY]] ], [ [[UREM]], [[ENTRY:%.*]] ]
; CHECK-NEXT:    store i64 0, ptr [[P:%.*]], align 8
; CHECK-NEXT:    [[LSR_IV_NEXT]] = add i64 [[LSR_IV]], -2
; CHECK-NEXT:    [[DONE:%.*]] = icmp eq i64 [[LSR_IV_NEXT]], 0
; CHECK-NEXT:    br i1 [[DONE]], label [[EXIT:%.*]], label [[VECTOR_BODY]]
; CHECK:       exit:
; CHECK-NEXT:    ret void
;
entry:
  %urem = urem i64 %N, 16
  br label %vector.body

vector.body:
  %iv = phi i64 [ 0, %entry ], [ %iv.next, %vector.body ]
  store i64 0, ptr %p
  %iv.next = add i64 %iv, 2
  %done = icmp eq i64 %iv.next, %urem
  br i1 %done, label %exit, label %vector.body

exit:
  ret void
}

define void @icmp_zero_urem_invariant(i64 %N, i64 %M, ptr %p) {
; CHECK-LABEL: @icmp_zero_urem_invariant(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[UREM:%.*]] = urem i64 [[N:%.*]], [[M:%.*]]
; CHECK-NEXT:    br label [[VECTOR_BODY:%.*]]
; CHECK:       vector.body:
; CHECK-NEXT:    [[LSR_IV:%.*]] = phi i64 [ [[LSR_IV_NEXT:%.*]], [[VECTOR_BODY]] ], [ [[UREM]], [[ENTRY:%.*]] ]
; CHECK-NEXT:    store i64 0, ptr [[P:%.*]], align 8
; CHECK-NEXT:    [[LSR_IV_NEXT]] = add i64 [[LSR_IV]], -2
; CHECK-NEXT:    [[DONE:%.*]] = icmp eq i64 [[LSR_IV_NEXT]], 0
; CHECK-NEXT:    br i1 [[DONE]], label [[EXIT:%.*]], label [[VECTOR_BODY]]
; CHECK:       exit:
; CHECK-NEXT:    ret void
;
entry:
  %urem = urem i64 %N, %M
  br label %vector.body

vector.body:
  %iv = phi i64 [ 0, %entry ], [ %iv.next, %vector.body ]
  store i64 0, ptr %p
  %iv.next = add i64 %iv, 2
  %done = icmp eq i64 %iv.next, %urem
  br i1 %done, label %exit, label %vector.body

exit:
  ret void
}

; We have to be careful here as SCEV can only compute a subtraction from
; two pointers with the same base.  If we hide %end inside a unknown, we
; can no longer compute the subtract.
define void @icmp_zero_urem_invariant_ptr(i64 %N, i64 %M, ptr %p) {
; CHECK-LABEL: @icmp_zero_urem_invariant_ptr(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[UREM:%.*]] = urem i64 [[N:%.*]], [[M:%.*]]
; CHECK-NEXT:    [[END:%.*]] = getelementptr i64, ptr [[P:%.*]], i64 [[UREM]]
; CHECK-NEXT:    br label [[VECTOR_BODY:%.*]]
; CHECK:       vector.body:
; CHECK-NEXT:    [[IV:%.*]] = phi ptr [ [[P]], [[ENTRY:%.*]] ], [ [[IV_NEXT:%.*]], [[VECTOR_BODY]] ]
; CHECK-NEXT:    store i64 0, ptr [[P]], align 8
; CHECK-NEXT:    [[IV_NEXT]] = getelementptr i64, ptr [[IV]], i64 1
; CHECK-NEXT:    [[DONE:%.*]] = icmp eq ptr [[IV_NEXT]], [[END]]
; CHECK-NEXT:    br i1 [[DONE]], label [[EXIT:%.*]], label [[VECTOR_BODY]]
; CHECK:       exit:
; CHECK-NEXT:    ret void
;
entry:
  %urem = urem i64 %N, %M
  %end = getelementptr i64, ptr %p, i64 %urem
  br label %vector.body

vector.body:
  %iv = phi ptr [ %p, %entry ], [ %iv.next, %vector.body ]
  store i64 0, ptr %p
  %iv.next = getelementptr i64, ptr %iv, i64 1
  %done = icmp eq ptr %iv.next, %end
  br i1 %done, label %exit, label %vector.body

exit:
  ret void
}

; Negative test - We can not hoist because we don't know value of %M.
define void @icmp_zero_urem_nohoist(i64 %N, i64 %M, ptr %p) {
; CHECK-LABEL: @icmp_zero_urem_nohoist(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    br label [[VECTOR_BODY:%.*]]
; CHECK:       vector.body:
; CHECK-NEXT:    [[IV:%.*]] = phi i64 [ 0, [[ENTRY:%.*]] ], [ [[IV_NEXT:%.*]], [[VECTOR_BODY]] ]
; CHECK-NEXT:    store i64 0, ptr [[P:%.*]], align 8
; CHECK-NEXT:    [[IV_NEXT]] = add i64 [[IV]], 2
; CHECK-NEXT:    [[UREM:%.*]] = urem i64 [[N:%.*]], [[M:%.*]]
; CHECK-NEXT:    [[DONE:%.*]] = icmp eq i64 [[IV_NEXT]], [[UREM]]
; CHECK-NEXT:    br i1 [[DONE]], label [[EXIT:%.*]], label [[VECTOR_BODY]]
; CHECK:       exit:
; CHECK-NEXT:    ret void
;
entry:
  br label %vector.body

vector.body:
  %iv = phi i64 [ 0, %entry ], [ %iv.next, %vector.body ]
  store i64 0, ptr %p
  %iv.next = add i64 %iv, 2
  %urem = urem i64 %N, %M
  %done = icmp eq i64 %iv.next, %urem
  br i1 %done, label %exit, label %vector.body

exit:
  ret void
}

define void @icmp_zero_urem_nonzero(i64 %N, i64 %M, ptr %p) {
; CHECK-LABEL: @icmp_zero_urem_nonzero(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[NONZERO:%.*]] = add nuw i64 [[M:%.*]], 1
; CHECK-NEXT:    [[UREM:%.*]] = urem i64 [[N:%.*]], [[NONZERO]]
; CHECK-NEXT:    br label [[VECTOR_BODY:%.*]]
; CHECK:       vector.body:
; CHECK-NEXT:    [[LSR_IV:%.*]] = phi i64 [ [[LSR_IV_NEXT:%.*]], [[VECTOR_BODY]] ], [ [[UREM]], [[ENTRY:%.*]] ]
; CHECK-NEXT:    store i64 0, ptr [[P:%.*]], align 8
; CHECK-NEXT:    [[LSR_IV_NEXT]] = add i64 [[LSR_IV]], -2
; CHECK-NEXT:    [[DONE:%.*]] = icmp eq i64 [[LSR_IV_NEXT]], 0
; CHECK-NEXT:    br i1 [[DONE]], label [[EXIT:%.*]], label [[VECTOR_BODY]]
; CHECK:       exit:
; CHECK-NEXT:    ret void
;
entry:
  %nonzero = add nuw i64 %M, 1
  %urem = urem i64 %N, %nonzero
  br label %vector.body

vector.body:
  %iv = phi i64 [ 0, %entry ], [ %iv.next, %vector.body ]
  store i64 0, ptr %p
  %iv.next = add i64 %iv, 2
  %done = icmp eq i64 %iv.next, %urem
  br i1 %done, label %exit, label %vector.body

exit:
  ret void
}

define void @icmp_zero_urem_vscale(i64 %N, ptr %p) {
; CHECK-LABEL: @icmp_zero_urem_vscale(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[VSCALE:%.*]] = call i64 @llvm.vscale.i64()
; CHECK-NEXT:    [[UREM:%.*]] = urem i64 [[N:%.*]], [[VSCALE]]
; CHECK-NEXT:    br label [[VECTOR_BODY:%.*]]
; CHECK:       vector.body:
; CHECK-NEXT:    [[LSR_IV:%.*]] = phi i64 [ [[LSR_IV_NEXT:%.*]], [[VECTOR_BODY]] ], [ [[UREM]], [[ENTRY:%.*]] ]
; CHECK-NEXT:    store i64 0, ptr [[P:%.*]], align 8
; CHECK-NEXT:    [[LSR_IV_NEXT]] = add i64 [[LSR_IV]], -2
; CHECK-NEXT:    [[DONE:%.*]] = icmp eq i64 [[LSR_IV_NEXT]], 0
; CHECK-NEXT:    br i1 [[DONE]], label [[EXIT:%.*]], label [[VECTOR_BODY]]
; CHECK:       exit:
; CHECK-NEXT:    ret void
;
entry:
  %vscale = call i64 @llvm.vscale.i64()
  %urem = urem i64 %N, %vscale
  br label %vector.body

vector.body:
  %iv = phi i64 [ 0, %entry ], [ %iv.next, %vector.body ]
  store i64 0, ptr %p
  %iv.next = add i64 %iv, 2
  %done = icmp eq i64 %iv.next, %urem
  br i1 %done, label %exit, label %vector.body

exit:
  ret void
}

define void @icmp_zero_urem_vscale_mul8(i64 %N, ptr %p) {
; CHECK-LABEL: @icmp_zero_urem_vscale_mul8(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[VSCALE:%.*]] = call i64 @llvm.vscale.i64()
; CHECK-NEXT:    [[MUL:%.*]] = mul nuw nsw i64 [[VSCALE]], 8
; CHECK-NEXT:    [[UREM:%.*]] = urem i64 [[N:%.*]], [[MUL]]
; CHECK-NEXT:    br label [[VECTOR_BODY:%.*]]
; CHECK:       vector.body:
; CHECK-NEXT:    [[LSR_IV:%.*]] = phi i64 [ [[LSR_IV_NEXT:%.*]], [[VECTOR_BODY]] ], [ [[UREM]], [[ENTRY:%.*]] ]
; CHECK-NEXT:    store i64 0, ptr [[P:%.*]], align 8
; CHECK-NEXT:    [[LSR_IV_NEXT]] = add i64 [[LSR_IV]], -2
; CHECK-NEXT:    [[DONE:%.*]] = icmp eq i64 [[LSR_IV_NEXT]], 0
; CHECK-NEXT:    br i1 [[DONE]], label [[EXIT:%.*]], label [[VECTOR_BODY]]
; CHECK:       exit:
; CHECK-NEXT:    ret void
;
entry:
  %vscale = call i64 @llvm.vscale.i64()
  %mul = mul nuw nsw i64 %vscale, 8
  %urem = urem i64 %N, %mul
  br label %vector.body

vector.body:
  %iv = phi i64 [ 0, %entry ], [ %iv.next, %vector.body ]
  store i64 0, ptr %p
  %iv.next = add i64 %iv, 2
  %done = icmp eq i64 %iv.next, %urem
  br i1 %done, label %exit, label %vector.body

exit:
  ret void
}


define void @icmp_zero_urem_vscale_mul64(i64 %N, ptr %p) {
; CHECK-LABEL: @icmp_zero_urem_vscale_mul64(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[VSCALE:%.*]] = call i64 @llvm.vscale.i64()
; CHECK-NEXT:    [[MUL:%.*]] = mul nuw nsw i64 [[VSCALE]], 64
; CHECK-NEXT:    [[UREM:%.*]] = urem i64 [[N:%.*]], [[MUL]]
; CHECK-NEXT:    br label [[VECTOR_BODY:%.*]]
; CHECK:       vector.body:
; CHECK-NEXT:    [[LSR_IV:%.*]] = phi i64 [ [[LSR_IV_NEXT:%.*]], [[VECTOR_BODY]] ], [ [[UREM]], [[ENTRY:%.*]] ]
; CHECK-NEXT:    store i64 0, ptr [[P:%.*]], align 8
; CHECK-NEXT:    [[LSR_IV_NEXT]] = add i64 [[LSR_IV]], -2
; CHECK-NEXT:    [[DONE:%.*]] = icmp eq i64 [[LSR_IV_NEXT]], 0
; CHECK-NEXT:    br i1 [[DONE]], label [[EXIT:%.*]], label [[VECTOR_BODY]]
; CHECK:       exit:
; CHECK-NEXT:    ret void
;
entry:
  %vscale = call i64 @llvm.vscale.i64()
  %mul = mul nuw nsw i64 %vscale, 64
  %urem = urem i64 %N, %mul
  br label %vector.body

vector.body:
  %iv = phi i64 [ 0, %entry ], [ %iv.next, %vector.body ]
  store i64 0, ptr %p
  %iv.next = add i64 %iv, 2
  %done = icmp eq i64 %iv.next, %urem
  br i1 %done, label %exit, label %vector.body

exit:
  ret void
}

define void @icmp_zero_urem_vscale_shl3(i64 %N, ptr %p) {
; CHECK-LABEL: @icmp_zero_urem_vscale_shl3(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[VSCALE:%.*]] = call i64 @llvm.vscale.i64()
; CHECK-NEXT:    [[SHL:%.*]] = shl i64 [[VSCALE]], 3
; CHECK-NEXT:    [[UREM:%.*]] = urem i64 [[N:%.*]], [[SHL]]
; CHECK-NEXT:    br label [[VECTOR_BODY:%.*]]
; CHECK:       vector.body:
; CHECK-NEXT:    [[LSR_IV:%.*]] = phi i64 [ [[LSR_IV_NEXT:%.*]], [[VECTOR_BODY]] ], [ [[UREM]], [[ENTRY:%.*]] ]
; CHECK-NEXT:    store i64 0, ptr [[P:%.*]], align 8
; CHECK-NEXT:    [[LSR_IV_NEXT]] = add i64 [[LSR_IV]], -2
; CHECK-NEXT:    [[DONE:%.*]] = icmp eq i64 [[LSR_IV_NEXT]], 0
; CHECK-NEXT:    br i1 [[DONE]], label [[EXIT:%.*]], label [[VECTOR_BODY]]
; CHECK:       exit:
; CHECK-NEXT:    ret void
;
entry:
  %vscale = call i64 @llvm.vscale.i64()
  %shl = shl i64 %vscale, 3
  %urem = urem i64 %N, %shl
  br label %vector.body

vector.body:
  %iv = phi i64 [ 0, %entry ], [ %iv.next, %vector.body ]
  store i64 0, ptr %p
  %iv.next = add i64 %iv, 2
  %done = icmp eq i64 %iv.next, %urem
  br i1 %done, label %exit, label %vector.body

exit:
  ret void
}

define void @icmp_zero_urem_vscale_shl6(i64 %N, ptr %p) {
; CHECK-LABEL: @icmp_zero_urem_vscale_shl6(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[VSCALE:%.*]] = call i64 @llvm.vscale.i64()
; CHECK-NEXT:    [[SHL:%.*]] = shl i64 [[VSCALE]], 6
; CHECK-NEXT:    [[UREM:%.*]] = urem i64 [[N:%.*]], [[SHL]]
; CHECK-NEXT:    br label [[VECTOR_BODY:%.*]]
; CHECK:       vector.body:
; CHECK-NEXT:    [[LSR_IV:%.*]] = phi i64 [ [[LSR_IV_NEXT:%.*]], [[VECTOR_BODY]] ], [ [[UREM]], [[ENTRY:%.*]] ]
; CHECK-NEXT:    store i64 0, ptr [[P:%.*]], align 8
; CHECK-NEXT:    [[LSR_IV_NEXT]] = add i64 [[LSR_IV]], -2
; CHECK-NEXT:    [[DONE:%.*]] = icmp eq i64 [[LSR_IV_NEXT]], 0
; CHECK-NEXT:    br i1 [[DONE]], label [[EXIT:%.*]], label [[VECTOR_BODY]]
; CHECK:       exit:
; CHECK-NEXT:    ret void
;
entry:
  %vscale = call i64 @llvm.vscale.i64()
  %shl = shl i64 %vscale, 6
  %urem = urem i64 %N, %shl
  br label %vector.body

vector.body:
  %iv = phi i64 [ 0, %entry ], [ %iv.next, %vector.body ]
  store i64 0, ptr %p
  %iv.next = add i64 %iv, 2
  %done = icmp eq i64 %iv.next, %urem
  br i1 %done, label %exit, label %vector.body

exit:
  ret void
}

; Loop invariant does not neccessarily mean dominating the loop.  Forming
; an ICmpZero from this example would be illegal even though the operands
; to the compare are loop invariant.
define void @loop_invariant_definition(i64 %arg) {
; CHECK-LABEL: @loop_invariant_definition(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    br label [[T1:%.*]]
; CHECK:       t1:
; CHECK-NEXT:    [[LSR_IV:%.*]] = phi i64 [ [[LSR_IV_NEXT:%.*]], [[T1]] ], [ -1, [[ENTRY:%.*]] ]
; CHECK-NEXT:    [[LSR_IV_NEXT]] = add nsw i64 [[LSR_IV]], 1
; CHECK-NEXT:    br i1 true, label [[T4:%.*]], label [[T1]]
; CHECK:       t4:
; CHECK-NEXT:    [[T5:%.*]] = trunc i64 [[LSR_IV_NEXT]] to i32
; CHECK-NEXT:    [[T6:%.*]] = add i32 [[T5]], 1
; CHECK-NEXT:    [[T7:%.*]] = icmp eq i32 [[T5]], [[T6]]
; CHECK-NEXT:    ret void
;
entry:
  br label %t1

t1:                                                ; preds = %1, %0
  %t2 = phi i64 [ %t3, %t1 ], [ 0, %entry ]
  %t3 = add nuw i64 %t2, 1
  br i1 true, label %t4, label %t1

t4:                                                ; preds = %1
  %t5 = trunc i64 %t2 to i32
  %t6 = add i32 %t5, 1
  %t7 = icmp eq i32 %t5, %t6
  ret void
}

define ptr @loop_repeated_scev_icmp_zero(ptr %first, ptr %end, i8 %data, i64 %num) {
; CHECK-LABEL: @loop_repeated_scev_icmp_zero(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[CMP:%.*]] = getelementptr i8, ptr [[FIRST:%.*]], i64 [[NUM:%.*]]
; CHECK-NEXT:    br label [[T1:%.*]]
; CHECK:       t1:
; CHECK-NEXT:    [[T2:%.*]] = phi ptr [ [[T18:%.*]], [[T17:%.*]] ], [ [[FIRST]], [[ENTRY:%.*]] ]
; CHECK-NEXT:    [[T3:%.*]] = load i8, ptr [[T2]], align 1
; CHECK-NEXT:    [[T4:%.*]] = icmp eq i8 [[T3]], [[DATA:%.*]]
; CHECK-NEXT:    br i1 [[T4]], label [[T20:%.*]], label [[T5:%.*]]
; CHECK:       t5:
; CHECK-NEXT:    [[T6:%.*]] = getelementptr inbounds i8, ptr [[T2]], i64 1
; CHECK-NEXT:    [[T7:%.*]] = load i8, ptr [[T6]], align 1
; CHECK-NEXT:    [[T8:%.*]] = icmp eq i8 [[T7]], [[DATA]]
; CHECK-NEXT:    br i1 [[T8]], label [[T21:%.*]], label [[T9:%.*]]
; CHECK:       t9:
; CHECK-NEXT:    [[T10:%.*]] = getelementptr inbounds i8, ptr [[T2]], i64 2
; CHECK-NEXT:    [[T11:%.*]] = load i8, ptr [[T10]], align 1
; CHECK-NEXT:    [[T12:%.*]] = icmp eq i8 [[T11]], [[DATA]]
; CHECK-NEXT:    br i1 [[T12]], label [[T23:%.*]], label [[T13:%.*]]
; CHECK:       t13:
; CHECK-NEXT:    [[T14:%.*]] = getelementptr inbounds i8, ptr [[T2]], i64 3
; CHECK-NEXT:    [[T15:%.*]] = load i8, ptr [[T14]], align 1
; CHECK-NEXT:    [[T16:%.*]] = icmp eq i8 [[T15]], [[DATA]]
; CHECK-NEXT:    br i1 [[T16]], label [[T25:%.*]], label [[T17]]
; CHECK:       t17:
; CHECK-NEXT:    [[T18]] = getelementptr inbounds i8, ptr [[T2]], i64 4
; CHECK-NEXT:    [[T19:%.*]] = icmp eq ptr [[T18]], [[CMP]]
; CHECK-NEXT:    br i1 [[T19]], label [[T20]], label [[T1]]
; CHECK:       t20:
; CHECK-NEXT:    [[T2_LCSSA:%.*]] = phi ptr [ [[T2]], [[T17]] ], [ [[T2]], [[T1]] ]
; CHECK-NEXT:    br label [[T27:%.*]]
; CHECK:       t21:
; CHECK-NEXT:    [[T2_LCSSA1:%.*]] = phi ptr [ [[T2]], [[T5]] ]
; CHECK-NEXT:    [[T22:%.*]] = getelementptr inbounds i8, ptr [[T2_LCSSA1]], i64 1
; CHECK-NEXT:    [[SCEVGEP5:%.*]] = getelementptr i8, ptr [[T2]], i64 1
; CHECK-NEXT:    br label [[T27]]
; CHECK:       t23:
; CHECK-NEXT:    [[T2_LCSSA2:%.*]] = phi ptr [ [[T2]], [[T9]] ]
; CHECK-NEXT:    [[T24:%.*]] = getelementptr inbounds i8, ptr [[T2_LCSSA2]], i64 2
; CHECK-NEXT:    [[SCEVGEP4:%.*]] = getelementptr i8, ptr [[T2]], i64 2
; CHECK-NEXT:    br label [[T27]]
; CHECK:       t25:
; CHECK-NEXT:    [[T2_LCSSA3:%.*]] = phi ptr [ [[T2]], [[T13]] ]
; CHECK-NEXT:    [[T26:%.*]] = getelementptr inbounds i8, ptr [[T2_LCSSA3]], i64 3
; CHECK-NEXT:    [[SCEVGEP:%.*]] = getelementptr i8, ptr [[T2]], i64 3
; CHECK-NEXT:    br label [[T27]]
; CHECK:       t27:
; CHECK-NEXT:    [[T28:%.*]] = phi ptr [ [[T2_LCSSA]], [[T20]] ], [ [[SCEVGEP5]], [[T21]] ], [ [[SCEVGEP4]], [[T23]] ], [ [[SCEVGEP]], [[T25]] ]
; CHECK-NEXT:    ret ptr [[T28]]
;
entry:
  %cmp = getelementptr i8, ptr %first, i64 %num
  br label %t1

t1:
  %t2 = phi ptr [ %t18, %t17 ], [ %first, %entry ]
  %t3 = load i8, ptr %t2, align 1
  %t4 = icmp eq i8 %t3, %data
  br i1 %t4, label %t20, label %t5

t5:                                               ; preds = %t1
  %t6 = getelementptr inbounds i8, ptr %t2, i64 1
  %t7 = load i8, ptr %t6, align 1
  %t8 = icmp eq i8 %t7, %data
  br i1 %t8, label %t21, label %t9

t9:                                               ; preds = %t5
  %t10 = getelementptr inbounds i8, ptr %t2, i64 2
  %t11 = load i8, ptr %t10, align 1
  %t12 = icmp eq i8 %t11, %data
  br i1 %t12, label %t23, label %t13

t13:                                               ; preds = %t9
  %t14 = getelementptr inbounds i8, ptr %t2, i64 3
  %t15 = load i8, ptr %t14, align 1
  %t16 = icmp eq i8 %t15, %data
  br i1 %t16, label %t25, label %t17

t17:                                               ; preds = %t13
  %t18 = getelementptr inbounds i8, ptr %t2, i64 4
  %t19 = icmp eq ptr %t18, %cmp
  br i1 %t19, label %t20, label %t1

t20:
  br label %t27

t21:
  %t22 = getelementptr inbounds i8, ptr %t2, i64 1
  br label %t27

t23:
  %t24 = getelementptr inbounds i8, ptr %t2, i64 2
  br label %t27

t25:
  %t26 = getelementptr inbounds i8, ptr %t2, i64 3
  br label %t27

t27:
  %t28 = phi ptr [ %t2, %t20 ], [ %t6, %t21 ], [ %t10, %t23 ], [ %t14, %t25 ]
  ret ptr %t28
}

declare i64 @llvm.vscale.i64()
