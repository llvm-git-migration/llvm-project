; NOTE: Assertions have been autogenerated by utils/update_test_checks.py UTC_ARGS: --version 2
; RUN: opt < %s -passes=infer-alignment -S | FileCheck %s

target datalayout = "p1:64:64:64:32"

declare i1 @cond()

define void @test_recur_i8_128(ptr align 128 %dst) {
; CHECK-LABEL: define void @test_recur_i8_128
; CHECK-SAME: (ptr align 128 [[DST:%.*]]) {
; CHECK-NEXT:  entry:
; CHECK-NEXT:    br label [[LOOP:%.*]]
; CHECK:       loop:
; CHECK-NEXT:    [[IV:%.*]] = phi ptr [ [[DST]], [[ENTRY:%.*]] ], [ [[IV_NEXT:%.*]], [[LOOP]] ]
; CHECK-NEXT:    store i64 0, ptr [[IV]], align 1
; CHECK-NEXT:    [[IV_NEXT]] = getelementptr inbounds i8, ptr [[IV]], i64 128
; CHECK-NEXT:    [[C:%.*]] = call i1 @cond()
; CHECK-NEXT:    br i1 [[C]], label [[LOOP]], label [[EXIT:%.*]]
; CHECK:       exit:
; CHECK-NEXT:    ret void
;
entry:
  br label %loop

loop:
  %iv = phi ptr [ %dst, %entry ], [ %iv.next, %loop ]
  store i64 0, ptr %iv, align 1
  %iv.next = getelementptr inbounds i8, ptr %iv, i64 128
  %c = call i1 @cond()
  br i1 %c, label %loop, label %exit

exit:
  ret void
}

define void @test_recur_i8_128_no_inbounds(ptr align 128 %dst) {
; CHECK-LABEL: define void @test_recur_i8_128_no_inbounds
; CHECK-SAME: (ptr align 128 [[DST:%.*]]) {
; CHECK-NEXT:  entry:
; CHECK-NEXT:    br label [[LOOP:%.*]]
; CHECK:       loop:
; CHECK-NEXT:    [[IV:%.*]] = phi ptr [ [[DST]], [[ENTRY:%.*]] ], [ [[IV_NEXT:%.*]], [[LOOP]] ]
; CHECK-NEXT:    store i64 0, ptr [[IV]], align 1
; CHECK-NEXT:    [[IV_NEXT]] = getelementptr i8, ptr [[IV]], i64 128
; CHECK-NEXT:    [[C:%.*]] = call i1 @cond()
; CHECK-NEXT:    br i1 [[C]], label [[LOOP]], label [[EXIT:%.*]]
; CHECK:       exit:
; CHECK-NEXT:    ret void
;
entry:
  br label %loop

loop:
  %iv = phi ptr [ %dst, %entry ], [ %iv.next, %loop ]
  store i64 0, ptr %iv, align 1
  %iv.next = getelementptr i8, ptr %iv, i64 128
  %c = call i1 @cond()
  br i1 %c, label %loop, label %exit

exit:
  ret void
}

define void @test_recur_i8_64(ptr align 128 %dst) {
; CHECK-LABEL: define void @test_recur_i8_64
; CHECK-SAME: (ptr align 128 [[DST:%.*]]) {
; CHECK-NEXT:  entry:
; CHECK-NEXT:    br label [[LOOP:%.*]]
; CHECK:       loop:
; CHECK-NEXT:    [[IV:%.*]] = phi ptr [ [[DST]], [[ENTRY:%.*]] ], [ [[IV_NEXT:%.*]], [[LOOP]] ]
; CHECK-NEXT:    store i64 0, ptr [[IV]], align 1
; CHECK-NEXT:    [[IV_NEXT]] = getelementptr inbounds i8, ptr [[IV]], i64 64
; CHECK-NEXT:    [[C:%.*]] = call i1 @cond()
; CHECK-NEXT:    br i1 [[C]], label [[LOOP]], label [[EXIT:%.*]]
; CHECK:       exit:
; CHECK-NEXT:    ret void
;
entry:
  br label %loop

loop:
  %iv = phi ptr [ %dst, %entry ], [ %iv.next, %loop ]
  store i64 0, ptr %iv, align 1
  %iv.next = getelementptr inbounds i8, ptr %iv, i64 64
  %c = call i1 @cond()
  br i1 %c, label %loop, label %exit

exit:
  ret void
}

define void @test_recur_i8_63(ptr align 128 %dst) {
; CHECK-LABEL: define void @test_recur_i8_63
; CHECK-SAME: (ptr align 128 [[DST:%.*]]) {
; CHECK-NEXT:  entry:
; CHECK-NEXT:    br label [[LOOP:%.*]]
; CHECK:       loop:
; CHECK-NEXT:    [[IV:%.*]] = phi ptr [ [[DST]], [[ENTRY:%.*]] ], [ [[IV_NEXT:%.*]], [[LOOP]] ]
; CHECK-NEXT:    store i64 0, ptr [[IV]], align 1
; CHECK-NEXT:    [[IV_NEXT]] = getelementptr inbounds i8, ptr [[IV]], i64 63
; CHECK-NEXT:    [[C:%.*]] = call i1 @cond()
; CHECK-NEXT:    br i1 [[C]], label [[LOOP]], label [[EXIT:%.*]]
; CHECK:       exit:
; CHECK-NEXT:    ret void
;
entry:
  br label %loop

loop:
  %iv = phi ptr [ %dst, %entry ], [ %iv.next, %loop ]
  store i64 0, ptr %iv, align 1
  %iv.next = getelementptr inbounds i8, ptr %iv, i64 63
  %c = call i1 @cond()
  br i1 %c, label %loop, label %exit

exit:
  ret void
}

define void @test_recur_i8_32(ptr align 128 %dst) {
; CHECK-LABEL: define void @test_recur_i8_32
; CHECK-SAME: (ptr align 128 [[DST:%.*]]) {
; CHECK-NEXT:  entry:
; CHECK-NEXT:    br label [[LOOP:%.*]]
; CHECK:       loop:
; CHECK-NEXT:    [[IV:%.*]] = phi ptr [ [[DST]], [[ENTRY:%.*]] ], [ [[IV_NEXT:%.*]], [[LOOP]] ]
; CHECK-NEXT:    store i64 0, ptr [[IV]], align 1
; CHECK-NEXT:    [[IV_NEXT]] = getelementptr inbounds i8, ptr [[IV]], i64 32
; CHECK-NEXT:    [[C:%.*]] = call i1 @cond()
; CHECK-NEXT:    br i1 [[C]], label [[LOOP]], label [[EXIT:%.*]]
; CHECK:       exit:
; CHECK-NEXT:    ret void
;
entry:
  br label %loop

loop:
  %iv = phi ptr [ %dst, %entry ], [ %iv.next, %loop ]
  store i64 0, ptr %iv, align 1
  %iv.next = getelementptr inbounds i8, ptr %iv, i64 32
  %c = call i1 @cond()
  br i1 %c, label %loop, label %exit

exit:
  ret void
}

define void @test_recur_i8_16(ptr align 128 %dst) {
; CHECK-LABEL: define void @test_recur_i8_16
; CHECK-SAME: (ptr align 128 [[DST:%.*]]) {
; CHECK-NEXT:  entry:
; CHECK-NEXT:    br label [[LOOP:%.*]]
; CHECK:       loop:
; CHECK-NEXT:    [[IV:%.*]] = phi ptr [ [[DST]], [[ENTRY:%.*]] ], [ [[IV_NEXT:%.*]], [[LOOP]] ]
; CHECK-NEXT:    store i64 0, ptr [[IV]], align 1
; CHECK-NEXT:    [[IV_NEXT]] = getelementptr inbounds i8, ptr [[IV]], i64 16
; CHECK-NEXT:    [[C:%.*]] = call i1 @cond()
; CHECK-NEXT:    br i1 [[C]], label [[LOOP]], label [[EXIT:%.*]]
; CHECK:       exit:
; CHECK-NEXT:    ret void
;
entry:
  br label %loop

loop:
  %iv = phi ptr [ %dst, %entry ], [ %iv.next, %loop ]
  store i64 0, ptr %iv, align 1
  %iv.next = getelementptr inbounds i8, ptr %iv, i64 16
  %c = call i1 @cond()
  br i1 %c, label %loop, label %exit

exit:
  ret void
}

define void @test_recur_i8_8(ptr align 128 %dst) {
; CHECK-LABEL: define void @test_recur_i8_8
; CHECK-SAME: (ptr align 128 [[DST:%.*]]) {
; CHECK-NEXT:  entry:
; CHECK-NEXT:    br label [[LOOP:%.*]]
; CHECK:       loop:
; CHECK-NEXT:    [[IV:%.*]] = phi ptr [ [[DST]], [[ENTRY:%.*]] ], [ [[IV_NEXT:%.*]], [[LOOP]] ]
; CHECK-NEXT:    store i64 0, ptr [[IV]], align 1
; CHECK-NEXT:    [[IV_NEXT]] = getelementptr inbounds i8, ptr [[IV]], i64 8
; CHECK-NEXT:    [[C:%.*]] = call i1 @cond()
; CHECK-NEXT:    br i1 [[C]], label [[LOOP]], label [[EXIT:%.*]]
; CHECK:       exit:
; CHECK-NEXT:    ret void
;
entry:
  br label %loop

loop:
  %iv = phi ptr [ %dst, %entry ], [ %iv.next, %loop ]
  store i64 0, ptr %iv, align 1
  %iv.next = getelementptr inbounds i8, ptr %iv, i64 8
  %c = call i1 @cond()
  br i1 %c, label %loop, label %exit

exit:
  ret void
}

define void @test_recur_i8_4(ptr align 128 %dst) {
; CHECK-LABEL: define void @test_recur_i8_4
; CHECK-SAME: (ptr align 128 [[DST:%.*]]) {
; CHECK-NEXT:  entry:
; CHECK-NEXT:    br label [[LOOP:%.*]]
; CHECK:       loop:
; CHECK-NEXT:    [[IV:%.*]] = phi ptr [ [[DST]], [[ENTRY:%.*]] ], [ [[IV_NEXT:%.*]], [[LOOP]] ]
; CHECK-NEXT:    store i64 0, ptr [[IV]], align 1
; CHECK-NEXT:    [[IV_NEXT]] = getelementptr inbounds i8, ptr [[IV]], i64 4
; CHECK-NEXT:    [[C:%.*]] = call i1 @cond()
; CHECK-NEXT:    br i1 [[C]], label [[LOOP]], label [[EXIT:%.*]]
; CHECK:       exit:
; CHECK-NEXT:    ret void
;
entry:
  br label %loop

loop:
  %iv = phi ptr [ %dst, %entry ], [ %iv.next, %loop ]
  store i64 0, ptr %iv, align 1
  %iv.next = getelementptr inbounds i8, ptr %iv, i64 4
  %c = call i1 @cond()
  br i1 %c, label %loop, label %exit

exit:
  ret void
}

define void @test_recur_i8_2(ptr align 128 %dst) {
; CHECK-LABEL: define void @test_recur_i8_2
; CHECK-SAME: (ptr align 128 [[DST:%.*]]) {
; CHECK-NEXT:  entry:
; CHECK-NEXT:    br label [[LOOP:%.*]]
; CHECK:       loop:
; CHECK-NEXT:    [[IV:%.*]] = phi ptr [ [[DST]], [[ENTRY:%.*]] ], [ [[IV_NEXT:%.*]], [[LOOP]] ]
; CHECK-NEXT:    store i64 0, ptr [[IV]], align 1
; CHECK-NEXT:    [[IV_NEXT]] = getelementptr inbounds i8, ptr [[IV]], i64 2
; CHECK-NEXT:    [[C:%.*]] = call i1 @cond()
; CHECK-NEXT:    br i1 [[C]], label [[LOOP]], label [[EXIT:%.*]]
; CHECK:       exit:
; CHECK-NEXT:    ret void
;
entry:
  br label %loop

loop:
  %iv = phi ptr [ %dst, %entry ], [ %iv.next, %loop ]
  store i64 0, ptr %iv, align 1
  %iv.next = getelementptr inbounds i8, ptr %iv, i64 2
  %c = call i1 @cond()
  br i1 %c, label %loop, label %exit

exit:
  ret void
}

define void @test_recur_i8_1(ptr align 128 %dst) {
; CHECK-LABEL: define void @test_recur_i8_1
; CHECK-SAME: (ptr align 128 [[DST:%.*]]) {
; CHECK-NEXT:  entry:
; CHECK-NEXT:    br label [[LOOP:%.*]]
; CHECK:       loop:
; CHECK-NEXT:    [[IV:%.*]] = phi ptr [ [[DST]], [[ENTRY:%.*]] ], [ [[IV_NEXT:%.*]], [[LOOP]] ]
; CHECK-NEXT:    store i64 0, ptr [[IV]], align 1
; CHECK-NEXT:    [[IV_NEXT]] = getelementptr inbounds i8, ptr [[IV]], i64 1
; CHECK-NEXT:    [[C:%.*]] = call i1 @cond()
; CHECK-NEXT:    br i1 [[C]], label [[LOOP]], label [[EXIT:%.*]]
; CHECK:       exit:
; CHECK-NEXT:    ret void
;
entry:
  br label %loop

loop:
  %iv = phi ptr [ %dst, %entry ], [ %iv.next, %loop ]
  store i64 0, ptr %iv, align 1
  %iv.next = getelementptr inbounds i8, ptr %iv, i64 1
  %c = call i1 @cond()
  br i1 %c, label %loop, label %exit

exit:
  ret void
}

define void @test_recur_i32_4(ptr align 128 %dst) {
; CHECK-LABEL: define void @test_recur_i32_4
; CHECK-SAME: (ptr align 128 [[DST:%.*]]) {
; CHECK-NEXT:  entry:
; CHECK-NEXT:    br label [[LOOP:%.*]]
; CHECK:       loop:
; CHECK-NEXT:    [[IV:%.*]] = phi ptr [ [[DST]], [[ENTRY:%.*]] ], [ [[IV_NEXT:%.*]], [[LOOP]] ]
; CHECK-NEXT:    store i64 0, ptr [[IV]], align 1
; CHECK-NEXT:    [[IV_NEXT]] = getelementptr inbounds i32, ptr [[IV]], i64 4
; CHECK-NEXT:    [[C:%.*]] = call i1 @cond()
; CHECK-NEXT:    br i1 [[C]], label [[LOOP]], label [[EXIT:%.*]]
; CHECK:       exit:
; CHECK-NEXT:    ret void
;
entry:
  br label %loop

loop:
  %iv = phi ptr [ %dst, %entry ], [ %iv.next, %loop ]
  store i64 0, ptr %iv, align 1
  %iv.next = getelementptr inbounds i32, ptr %iv, i64 4
  %c = call i1 @cond()
  br i1 %c, label %loop, label %exit

exit:
  ret void
}


define void @test_recur_i32_3(ptr align 128 %dst) {
; CHECK-LABEL: define void @test_recur_i32_3
; CHECK-SAME: (ptr align 128 [[DST:%.*]]) {
; CHECK-NEXT:  entry:
; CHECK-NEXT:    br label [[LOOP:%.*]]
; CHECK:       loop:
; CHECK-NEXT:    [[IV:%.*]] = phi ptr [ [[DST]], [[ENTRY:%.*]] ], [ [[IV_NEXT:%.*]], [[LOOP]] ]
; CHECK-NEXT:    store i64 0, ptr [[IV]], align 1
; CHECK-NEXT:    [[IV_NEXT]] = getelementptr inbounds i32, ptr [[IV]], i64 4
; CHECK-NEXT:    [[C:%.*]] = call i1 @cond()
; CHECK-NEXT:    br i1 [[C]], label [[LOOP]], label [[EXIT:%.*]]
; CHECK:       exit:
; CHECK-NEXT:    ret void
;
entry:
  br label %loop

loop:
  %iv = phi ptr [ %dst, %entry ], [ %iv.next, %loop ]
  store i64 0, ptr %iv, align 1
  %iv.next = getelementptr inbounds i32, ptr %iv, i64 4
  %c = call i1 @cond()
  br i1 %c, label %loop, label %exit

exit:
  ret void
}

define void @test_recur_i8_neg_128(ptr align 128 %dst) {
; CHECK-LABEL: define void @test_recur_i8_neg_128
; CHECK-SAME: (ptr align 128 [[DST:%.*]]) {
; CHECK-NEXT:  entry:
; CHECK-NEXT:    br label [[LOOP:%.*]]
; CHECK:       loop:
; CHECK-NEXT:    [[IV:%.*]] = phi ptr [ [[DST]], [[ENTRY:%.*]] ], [ [[IV_NEXT:%.*]], [[LOOP]] ]
; CHECK-NEXT:    store i64 0, ptr [[IV]], align 1
; CHECK-NEXT:    [[IV_NEXT]] = getelementptr inbounds i8, ptr [[IV]], i64 -128
; CHECK-NEXT:    [[C:%.*]] = call i1 @cond()
; CHECK-NEXT:    br i1 [[C]], label [[LOOP]], label [[EXIT:%.*]]
; CHECK:       exit:
; CHECK-NEXT:    ret void
;
entry:
  br label %loop

loop:
  %iv = phi ptr [ %dst, %entry ], [ %iv.next, %loop ]
  store i64 0, ptr %iv, align 1
  %iv.next = getelementptr inbounds i8, ptr %iv, i64 -128
  %c = call i1 @cond()
  br i1 %c, label %loop, label %exit

exit:
  ret void
}

define void @test_recur_i8_neg64(ptr align 128 %dst) {
; CHECK-LABEL: define void @test_recur_i8_neg64
; CHECK-SAME: (ptr align 128 [[DST:%.*]]) {
; CHECK-NEXT:  entry:
; CHECK-NEXT:    br label [[LOOP:%.*]]
; CHECK:       loop:
; CHECK-NEXT:    [[IV:%.*]] = phi ptr [ [[DST]], [[ENTRY:%.*]] ], [ [[IV_NEXT:%.*]], [[LOOP]] ]
; CHECK-NEXT:    store i64 0, ptr [[IV]], align 1
; CHECK-NEXT:    [[IV_NEXT]] = getelementptr inbounds i8, ptr [[IV]], i64 -64
; CHECK-NEXT:    [[C:%.*]] = call i1 @cond()
; CHECK-NEXT:    br i1 [[C]], label [[LOOP]], label [[EXIT:%.*]]
; CHECK:       exit:
; CHECK-NEXT:    ret void
;
entry:
  br label %loop

loop:
  %iv = phi ptr [ %dst, %entry ], [ %iv.next, %loop ]
  store i64 0, ptr %iv, align 1
  %iv.next = getelementptr inbounds i8, ptr %iv, i64 -64
  %c = call i1 @cond()
  br i1 %c, label %loop, label %exit

exit:
  ret void
}

define void @test_recur_i8_neg_63(ptr align 128 %dst) {
; CHECK-LABEL: define void @test_recur_i8_neg_63
; CHECK-SAME: (ptr align 128 [[DST:%.*]]) {
; CHECK-NEXT:  entry:
; CHECK-NEXT:    br label [[LOOP:%.*]]
; CHECK:       loop:
; CHECK-NEXT:    [[IV:%.*]] = phi ptr [ [[DST]], [[ENTRY:%.*]] ], [ [[IV_NEXT:%.*]], [[LOOP]] ]
; CHECK-NEXT:    store i64 0, ptr [[IV]], align 1
; CHECK-NEXT:    [[IV_NEXT]] = getelementptr inbounds i8, ptr [[IV]], i64 -63
; CHECK-NEXT:    [[C:%.*]] = call i1 @cond()
; CHECK-NEXT:    br i1 [[C]], label [[LOOP]], label [[EXIT:%.*]]
; CHECK:       exit:
; CHECK-NEXT:    ret void
;
entry:
  br label %loop

loop:
  %iv = phi ptr [ %dst, %entry ], [ %iv.next, %loop ]
  store i64 0, ptr %iv, align 1
  %iv.next = getelementptr inbounds i8, ptr %iv, i64 -63
  %c = call i1 @cond()
  br i1 %c, label %loop, label %exit

exit:
  ret void
}

define void @test_recur_i8_neg_32(ptr align 128 %dst) {
; CHECK-LABEL: define void @test_recur_i8_neg_32
; CHECK-SAME: (ptr align 128 [[DST:%.*]]) {
; CHECK-NEXT:  entry:
; CHECK-NEXT:    br label [[LOOP:%.*]]
; CHECK:       loop:
; CHECK-NEXT:    [[IV:%.*]] = phi ptr [ [[DST]], [[ENTRY:%.*]] ], [ [[IV_NEXT:%.*]], [[LOOP]] ]
; CHECK-NEXT:    store i64 0, ptr [[IV]], align 1
; CHECK-NEXT:    [[IV_NEXT]] = getelementptr inbounds i8, ptr [[IV]], i64 -32
; CHECK-NEXT:    [[C:%.*]] = call i1 @cond()
; CHECK-NEXT:    br i1 [[C]], label [[LOOP]], label [[EXIT:%.*]]
; CHECK:       exit:
; CHECK-NEXT:    ret void
;
entry:
  br label %loop

loop:
  %iv = phi ptr [ %dst, %entry ], [ %iv.next, %loop ]
  store i64 0, ptr %iv, align 1
  %iv.next = getelementptr inbounds i8, ptr %iv, i64 -32
  %c = call i1 @cond()
  br i1 %c, label %loop, label %exit

exit:
  ret void
}
