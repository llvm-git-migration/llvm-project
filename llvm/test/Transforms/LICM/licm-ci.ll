; NOTE: Assertions have been autogenerated by utils/update_test_checks.py
; RUN: opt -S -passes=licm < %s | FileCheck %s

define void @vmp_test_vmp(ptr addrspace(3) noalias %in1, i32 %y.0, ptr addrspace(3) noalias %in2, ptr addrspace(3) noalias %in3, ptr addrspace(3) noalias %in4, ptr noalias nocapture writeonly %sum1.0.lcssa.out, ptr noalias nocapture writeonly %sum2.0.lcssa.out, ptr noalias nocapture writeonly %sum3.0.lcssa.out, ptr noalias nocapture writeonly %sum4.0.lcssa.out) local_unnamed_addr #2 {
; CHECK-LABEL: @vmp_test_vmp(
; CHECK-NEXT:  one.iter.loop.entry15:
; CHECK-NEXT:    br label [[ONE_ITER_LOOP_ENTRY:%.*]]
; CHECK:       one.iter.loop.entry:
; CHECK-NEXT:    [[ONE_ITER_IV:%.*]] = phi i32 [ 0, [[ONE_ITER_LOOP_ENTRY15:%.*]] ], [ [[ONE_ITER_IV_NEXT:%.*]], [[ONE_ITER_LOOP_ENTRY]] ]
; CHECK-NEXT:    [[ONE_ITER_IV_NEXT]] = add i32 [[ONE_ITER_IV]], 1
; CHECK-NEXT:    [[TMP0:%.*]] = icmp eq i32 [[ONE_ITER_IV_NEXT]], 1
; CHECK-NEXT:    br i1 [[TMP0]], label [[ONE_ITER_LOOP_EXIT:%.*]], label [[ONE_ITER_LOOP_ENTRY]]
; CHECK:       one.iter.loop.exit:
; CHECK-NEXT:    [[MUL_LE:%.*]] = mul nsw i32 [[Y_0:%.*]], 48
; CHECK-NEXT:    [[TMP1:%.*]] = getelementptr inbounds i16, ptr addrspace(3) [[IN1:%.*]], i32 [[MUL_LE]]
; CHECK-NEXT:    [[WIDE_MASKED_LOAD_LE:%.*]] = tail call <4 x i16> @llvm.masked.load.v4i16.p3(ptr addrspace(3) [[TMP1]], i32 2, <4 x i1> <i1 true, i1 false, i1 true, i1 false>, <4 x i16> <i16 0, i16 poison, i16 0, i16 poison>)
; CHECK-NEXT:    [[TMP2:%.*]] = tail call i16 @llvm.vector.reduce.add.v4i16(<4 x i16> [[WIDE_MASKED_LOAD_LE]])
; CHECK-NEXT:    store i16 [[TMP2]], ptr [[SUM1_0_LCSSA_OUT:%.*]], align 4
; CHECK-NEXT:    ret void
;
one.iter.loop.entry15:
  br label %one.iter.loop.entry

one.iter.loop.entry:                              ; preds = %one.iter.loop.entry, %one.iter.loop.entry15
  %one.iter.iv = phi i32 [ 0, %one.iter.loop.entry15 ], [ %one.iter.iv.next, %one.iter.loop.entry ]
  %mul = mul nsw i32 %y.0, 48
  %0 = getelementptr inbounds i16, ptr addrspace(3) %in1, i32 %mul
  %wide.masked.load = tail call <4 x i16> @llvm.masked.load.v4i16.p3(ptr addrspace(3) %0, i32 2, <4 x i1> <i1 true, i1 false, i1 true, i1 false>, <4 x i16> <i16 0, i16 poison, i16 0, i16 poison>), !alias.scope !1, !noalias !2

  %2 = tail call i16 @llvm.vector.reduce.add.v4i16(<4 x i16> %wide.masked.load)

  %one.iter.iv.next = add i32 %one.iter.iv, 1
  %16 = icmp eq i32 %one.iter.iv.next, 1
  br i1 %16, label %one.iter.loop.exit, label %one.iter.loop.entry

one.iter.loop.exit:                               ; preds = %one.iter.loop.entry
  %.lcssa18 = phi i16 [ %2, %one.iter.loop.entry ]
  store i16 %.lcssa18, ptr %sum1.0.lcssa.out, align 4
  ret void
}

!1 = !{}
!2 = !{}
