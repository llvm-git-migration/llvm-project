; NOTE: Assertions have been autogenerated by utils/update_test_checks.py UTC_ARGS: --version 5
; REQUIRES: asserts
; RUN: opt -passes='loop-mssa(loop-rotate,licm)' %s -disable-output -debug-only=licm 2>&1 | FileCheck %s -check-prefix=LICM
; RUN: opt -passes='loop-mssa(loop-rotate,licm)' %s -S  | FileCheck %s

; LICM-NOT: LICM sinking instruction:   %.pre = load i8, ptr %arrayidx.phi.trans.insert


target datalayout = "E-m:e-i1:8:16-i8:8:16-i64:64-f128:64-a:8:16-n32:64"
target triple = "s390x-unknown-linux-gnu"

define void @fn1(i1 %arg) {
; CHECK-LABEL: define void @fn1(
; CHECK-SAME: i1 [[ARG:%.*]]) {
; CHECK-NEXT:  [[ENTRY:.*]]:
; CHECK-NEXT:    [[G:%.*]] = alloca [9 x i8], align 1
; CHECK-NEXT:    store i8 2, ptr [[G]], align 1
; CHECK-NEXT:    br i1 [[ARG]], label %[[FOR_END18:.*]], label %[[FOR_BODY_FOR_BODY_CRIT_EDGE_LR_PH:.*]]
; CHECK:       [[FOR_BODY_FOR_BODY_CRIT_EDGE_LR_PH]]:
; CHECK-NEXT:    br label %[[FOR_BODY_FOR_BODY_CRIT_EDGE:.*]]
; CHECK:       [[FOR_BODY_FOR_BODY_CRIT_EDGE]]:
; CHECK-NEXT:    [[INDVARS_IV_NEXT1:%.*]] = phi i64 [ 1, %[[FOR_BODY_FOR_BODY_CRIT_EDGE_LR_PH]] ], [ [[INDVARS_IV_NEXT:%.*]], %[[FOR_BODY_FOR_BODY_CRIT_EDGE]] ]
; CHECK-NEXT:    [[ARRAYIDX_PHI_TRANS_INSERT:%.*]] = getelementptr inbounds [9 x i8], ptr [[G]], i64 0, i64 [[INDVARS_IV_NEXT1]]
; CHECK-NEXT:    [[DOTPRE:%.*]] = load i8, ptr [[ARRAYIDX_PHI_TRANS_INSERT]], align 1
; CHECK-NEXT:    [[ARRAYIDX:%.*]] = getelementptr inbounds [9 x i8], ptr [[G]], i64 0, i64 [[INDVARS_IV_NEXT1]]
; CHECK-NEXT:    store i8 2, ptr [[ARRAYIDX]], align 1
; CHECK-NEXT:    [[INDVARS_IV_NEXT]] = add nuw nsw i64 [[INDVARS_IV_NEXT1]], 1
; CHECK-NEXT:    br i1 [[ARG]], label %[[FOR_BODY_FOR_END18_CRIT_EDGE:.*]], label %[[FOR_BODY_FOR_BODY_CRIT_EDGE]]
; CHECK:       [[FOR_BODY_FOR_END18_CRIT_EDGE]]:
; CHECK-NEXT:    [[DOTPRE_LCSSA:%.*]] = phi i8 [ [[DOTPRE]], %[[FOR_BODY_FOR_BODY_CRIT_EDGE]] ]
; CHECK-NEXT:    [[PHITMP_LE:%.*]] = zext i8 [[DOTPRE_LCSSA]] to i64
; CHECK-NEXT:    br label %[[FOR_END18]]
; CHECK:       [[FOR_END18]]:
; CHECK-NEXT:    [[DOTLCSSA:%.*]] = phi i64 [ [[PHITMP_LE]], %[[FOR_BODY_FOR_END18_CRIT_EDGE]] ], [ 0, %[[ENTRY]] ]
; CHECK-NEXT:    store i64 [[DOTLCSSA]], ptr undef, align 8
; CHECK-NEXT:    ret void
;
entry:
  %g = alloca [9 x i8], align 1
  br label %for.body

for.body:                                         ; preds = %for.body.for.body_crit_edge, %entry
  %0 = phi i64 [ 0, %entry ], [ %phitmp, %for.body.for.body_crit_edge ]
  %indvars.iv = phi i64 [ 0, %entry ], [ %indvars.iv.next, %for.body.for.body_crit_edge ]
  %arrayidx = getelementptr inbounds [9 x i8], ptr %g, i64 0, i64 %indvars.iv
  store i8 2, ptr %arrayidx, align 1
  %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1
  br i1 %arg, label %for.end18, label %for.body.for.body_crit_edge

for.body.for.body_crit_edge:                      ; preds = %for.body
  %arrayidx.phi.trans.insert = getelementptr inbounds [9 x i8], ptr %g, i64 0, i64 %indvars.iv.next
  %.pre = load i8, ptr %arrayidx.phi.trans.insert, align 1
  %phitmp = zext i8 %.pre to i64
  br label %for.body

for.end18:                                        ; preds = %for.body
  store i64 %0, ptr undef, align 8
  ret void
}

;; NOTE: These prefixes are unused and the list is autogenerated. Do not add tests below this line:
; LICM: {{.*}}
