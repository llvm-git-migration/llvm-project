; NOTE: Assertions have been autogenerated by utils/update_analyze_test_checks.py
; RUN: opt -disable-output -passes="loop-vectorize,print<scalar-evolution>" < %s 2>&1 | FileCheck %s

target triple = "x86_64-unknown-linux-gnu"

@g_var = external local_unnamed_addr global i32, align 4

define void @test(i32 noundef %x) {
; CHECK-LABEL: 'test'
; CHECK-NEXT:  Classifying expressions for: @test
; CHECK-NEXT:    %g_var.promoted = load i32, ptr @g_var, align 4
; CHECK-NEXT:    --> %g_var.promoted U: full-set S: full-set
; CHECK-NEXT:    %smax = call i32 @llvm.smax.i32(i32 %x, i32 1)
; CHECK-NEXT:    --> (1 smax %x) U: [1,-2147483648) S: [1,-2147483648)
; CHECK-NEXT:    %0 = add nsw i32 %smax, -1
; CHECK-NEXT:    --> (-1 + (1 smax %x))<nsw> U: [0,2147483647) S: [0,2147483647)
; CHECK-NEXT:    %1 = udiv i32 %0, %x
; CHECK-NEXT:    --> ((-1 + (1 smax %x))<nsw> /u %x) U: [0,2147483647) S: [0,2147483647)
; CHECK-NEXT:    %2 = add nuw nsw i32 %1, 1
; CHECK-NEXT:    --> (1 + ((-1 + (1 smax %x))<nsw> /u %x))<nuw><nsw> U: [1,-2147483648) S: [1,-2147483648)
;
; CHECK-NEXT:  Determining loop execution counts for: @test
; CHECK-NEXT:  Loop %for.body: backedge-taken count is ((((-1 * (%x + %bc.resume.val)<nsw>) + (-1 * (1 umin ((-1 * (%x + %bc.resume.val)<nsw>) + (1 smax (%x + %bc.resume.val)<nsw>))))<nuw><nsw> + (1 smax (%x + %bc.resume.val)<nsw>)) /u (1 umax %x)) + (1 umin ((-1 * (%x + %bc.resume.val)<nsw>) + (1 smax (%x + %bc.resume.val)<nsw>))))
; CHECK-NEXT:  Loop %for.body: constant max backedge-taken count is i32 -2147483647
; CHECK-NEXT:  Loop %for.body: symbolic max backedge-taken count is ((((-1 * (%x + %bc.resume.val)<nsw>) + (-1 * (1 umin ((-1 * (%x + %bc.resume.val)<nsw>) + (1 smax (%x + %bc.resume.val)<nsw>))))<nuw><nsw> + (1 smax (%x + %bc.resume.val)<nsw>)) /u (1 umax %x)) + (1 umin ((-1 * (%x + %bc.resume.val)<nsw>) + (1 smax (%x + %bc.resume.val)<nsw>))))
; CHECK-NEXT:  Loop %for.body: Trip multiple is 1
;
entry:
  %g_var.promoted = load i32, ptr @g_var, align 4
  br label %for.body

for.cond.cleanup:                                 ; preds = %for.body
  %add.lcssa = phi i32 [ %add, %for.body ]
  store i32 %add.lcssa, ptr @g_var, align 4
  ret void

for.body:                                         ; preds = %entry, %for.body
  %i.06 = phi i32 [ 0, %entry ], [ %add1, %for.body ]
  %add45 = phi i32 [ %g_var.promoted, %entry ], [ %add, %for.body ]
  %add = add nsw i32 %add45, %x
  %add1 = add nsw i32 %i.06, %x
  %cmp = icmp slt i32 %add1, 1
  br i1 %cmp, label %for.body, label %for.cond.cleanup, !llvm.loop !0
}

!0 = distinct !{!0, !1}
!1 = !{!"llvm.loop.mustprogress"}
