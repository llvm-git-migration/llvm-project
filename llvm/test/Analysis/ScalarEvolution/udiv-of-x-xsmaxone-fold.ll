; NOTE: Assertions have been autogenerated by utils/update_analyze_test_checks.py
; RUN: opt -disable-output -passes="loop-vectorize,print<scalar-evolution>" < %s 2>&1 | FileCheck %s

target triple = "x86_64-unknown-linux-gnu"

@g_var = external local_unnamed_addr global i32, align 4

define void @test(i32 noundef %x) {
; CHECK-LABEL: 'test'
; CHECK-NEXT:  Classifying expressions for: @test
; CHECK-NEXT:    %g_var.promoted = load i32, ptr @g_var, align 4
; CHECK-NEXT:    --> %g_var.promoted U: full-set S: full-set
; CHECK-NEXT:    %add.lcssa = phi i32 [ %add, %for.body ]
; CHECK-NEXT:    --> {(%x + %g_var.promoted),+,%x}<nw><%for.body> U: full-set S: full-set --> (%x + %g_var.promoted) U: full-set S: full-set
; CHECK-NEXT:    %i.06 = phi i32 [ 0, %entry ], [ %add1, %for.body ]
; CHECK-NEXT:    --> {0,+,%x}<nuw><nsw><%for.body> U: [0,1) S: [0,1) Exits: 0 LoopDispositions: { %for.body: Computable }
; CHECK-NEXT:    %add45 = phi i32 [ %g_var.promoted, %entry ], [ %add, %for.body ]
; CHECK-NEXT:    --> {%g_var.promoted,+,%x}<nsw><%for.body> U: full-set S: full-set Exits: %g_var.promoted LoopDispositions: { %for.body: Computable }
; CHECK-NEXT:    %add = add nsw i32 %add45, %x
; CHECK-NEXT:    --> {(%x + %g_var.promoted),+,%x}<nw><%for.body> U: full-set S: full-set Exits: (%x + %g_var.promoted) LoopDispositions: { %for.body: Computable }
; CHECK-NEXT:    %add1 = add nsw i32 %i.06, %x
; CHECK-NEXT:    --> {%x,+,%x}<nsw><%for.body> U: full-set S: full-set Exits: %x LoopDispositions: { %for.body: Computable }
; CHECK-NEXT:  Determining loop execution counts for: @test
; CHECK-NEXT:  Loop %for.body: backedge-taken count is i32 0
; CHECK-NEXT:  Loop %for.body: constant max backedge-taken count is i32 0
; CHECK-NEXT:  Loop %for.body: symbolic max backedge-taken count is i32 0
; CHECK-NEXT:  Loop %for.body: Trip multiple is 1
;
entry:
  %g_var.promoted = load i32, ptr @g_var, align 4
  br label %for.body

for.cond.cleanup:                                 ; preds = %for.body
  %add.lcssa = phi i32 [ %add, %for.body ]
  store i32 %add.lcssa, ptr @g_var, align 4
  ret void

for.body:                                         ; preds = %entry, %for.body
  %i.06 = phi i32 [ 0, %entry ], [ %add1, %for.body ]
  %add45 = phi i32 [ %g_var.promoted, %entry ], [ %add, %for.body ]
  %add = add nsw i32 %add45, %x
  %add1 = add nsw i32 %i.06, %x
  %cmp = icmp slt i32 %add1, 1
  br i1 %cmp, label %for.body, label %for.cond.cleanup, !llvm.loop !0
}

!0 = distinct !{!0, !1}
!1 = !{!"llvm.loop.mustprogress"}
