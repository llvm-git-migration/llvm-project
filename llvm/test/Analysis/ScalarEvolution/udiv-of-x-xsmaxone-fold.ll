; NOTE: Assertions have been autogenerated by utils/update_analyze_test_checks.py
; RUN: opt -disable-output -passes="print<scalar-evolution>" < %s 2>&1 | FileCheck %s

@g_var = external global i32, align 4

define void @test(i32 %x) {
; CHECK-LABEL: 'test'
; CHECK-NEXT:  Classifying expressions for: @test
; CHECK-NEXT:    %g_var.promoted = load i32, ptr @g_var, align 4
; CHECK-NEXT:    --> %g_var.promoted U: full-set S: full-set
; CHECK-NEXT:    %smax = tail call i32 @llvm.smax.i32(i32 %x, i32 1)
; CHECK-NEXT:    --> (1 smax %x) U: [1,-2147483648) S: [1,-2147483648)
; CHECK-NEXT:    %add = add nsw i32 %smax, -1
; CHECK-NEXT:    --> (-1 + (1 smax %x))<nsw> U: [0,2147483647) S: [0,2147483647)
; CHECK-NEXT:    %udiv = udiv i32 %add, %x
; CHECK-NEXT:    --> ((-1 + (1 smax %x))<nsw> /u %x) U: [0,2147483647) S: [0,2147483647)
;
; CHECK-NEXT:  Determining loop execution counts for: @test
; CHECK-NEXT:  Loop %for.body: Unpredictable backedge-taken count.
; CHECK-NEXT:  Loop %for.body: Unpredictable constant max backedge-taken count.
; CHECK-NEXT:  Loop %for.body: Unpredictable symbolic max backedge-taken count.
;
entry:
  %g_var.promoted = load i32, ptr @g_var, align 4
  %smax = tail call i32 @llvm.smax.i32(i32 %x, i32 1)
  %add = add nsw i32 %smax, -1
  %udiv = udiv i32 %add, %x
  %cond = icmp ult i32 %udiv, 7
  br i1 %cond, label %for.body, label %exit

for.body:                                         ; preds = %for.body, %entry
  %iv = phi i32 [ 0, %entry ], [ %iv.next, %for.body ]
  %val = phi i32 [ %g_var.promoted, %entry ], [ %add.1, %for.body ]
  %add.1 = add nsw i32 %val, %x
  %iv.next = add nsw i32 %iv, %x
  %cond.1 = icmp slt i32 %iv.next, 1
  br i1 %cond.1, label %for.body, label %for.cond.cleanup

for.cond.cleanup:                                 ; preds = %for.body
  store i32 %add.1, ptr @g_var, align 4
  br label %exit

exit:                                             ; preds = %entry, %for.cond.cleanup
  ret void
}
