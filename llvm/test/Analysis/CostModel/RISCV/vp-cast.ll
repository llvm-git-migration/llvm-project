; NOTE: Assertions have been autogenerated by utils/update_analyze_test_checks.py
; RUN: opt < %s -passes="print<cost-model>" 2>&1 -disable-output -S -mtriple=riscv32 -mattr=+v | FileCheck %s --check-prefixes=RV32
; RUN: opt < %s -passes="print<cost-model>" 2>&1 -disable-output -S -mtriple=riscv32 -mattr=+v --type-based-intrinsic-cost=true | FileCheck %s --check-prefixes=RV32_TYPEBASED
; RUN: opt < %s -passes="print<cost-model>" 2>&1 -disable-output -S -mtriple=riscv64 -mattr=+v | FileCheck %s --check-prefixes=RV64
; RUN: opt < %s -passes="print<cost-model>" 2>&1 -disable-output -S -mtriple=riscv64 -mattr=+v --type-based-intrinsic-cost=true | FileCheck %s --check-prefixes=RV64_TYPEBASED

define void @int_truncate() {
; RV32-LABEL: 'int_truncate'
; RV32-NEXT:  Cost Model: Found an estimated cost of 0 for instruction: %1 = trunc i32 undef to i8
; RV32-NEXT:  Cost Model: Found an estimated cost of 2 for instruction: %2 = trunc <1 x i32> undef to <1 x i8>
; RV32-NEXT:  Cost Model: Found an estimated cost of 2 for instruction: %3 = trunc <2 x i32> undef to <2 x i8>
; RV32-NEXT:  Cost Model: Found an estimated cost of 2 for instruction: %4 = trunc <4 x i32> undef to <4 x i8>
; RV32-NEXT:  Cost Model: Found an estimated cost of 2 for instruction: %5 = trunc <8 x i32> undef to <8 x i8>
; RV32-NEXT:  Cost Model: Found an estimated cost of 3 for instruction: %6 = trunc <16 x i32> undef to <16 x i8>
; RV32-NEXT:  Cost Model: Found an estimated cost of 2 for instruction: %7 = trunc <vscale x 1 x i32> undef to <vscale x 1 x i8>
; RV32-NEXT:  Cost Model: Found an estimated cost of 2 for instruction: %8 = trunc <vscale x 2 x i32> undef to <vscale x 2 x i8>
; RV32-NEXT:  Cost Model: Found an estimated cost of 2 for instruction: %9 = trunc <vscale x 4 x i32> undef to <vscale x 4 x i8>
; RV32-NEXT:  Cost Model: Found an estimated cost of 3 for instruction: %10 = trunc <vscale x 8 x i32> undef to <vscale x 8 x i8>
; RV32-NEXT:  Cost Model: Found an estimated cost of 2 for instruction: %11 = call <1 x i8> @llvm.vp.trunc.v1i8.v1i32(<1 x i32> undef, <1 x i1> undef, i32 undef)
; RV32-NEXT:  Cost Model: Found an estimated cost of 2 for instruction: %12 = call <2 x i8> @llvm.vp.trunc.v2i8.v2i32(<2 x i32> undef, <2 x i1> undef, i32 undef)
; RV32-NEXT:  Cost Model: Found an estimated cost of 2 for instruction: %13 = call <4 x i8> @llvm.vp.trunc.v4i8.v4i32(<4 x i32> undef, <4 x i1> undef, i32 undef)
; RV32-NEXT:  Cost Model: Found an estimated cost of 2 for instruction: %14 = call <8 x i8> @llvm.vp.trunc.v8i8.v8i32(<8 x i32> undef, <8 x i1> undef, i32 undef)
; RV32-NEXT:  Cost Model: Found an estimated cost of 3 for instruction: %15 = call <16 x i8> @llvm.vp.trunc.v16i8.v16i32(<16 x i32> undef, <16 x i1> undef, i32 undef)
; RV32-NEXT:  Cost Model: Found an estimated cost of 2 for instruction: %16 = call <vscale x 1 x i8> @llvm.vp.trunc.nxv1i8.nxv1i32(<vscale x 1 x i32> undef, <vscale x 1 x i1> undef, i32 undef)
; RV32-NEXT:  Cost Model: Found an estimated cost of 2 for instruction: %17 = call <vscale x 2 x i8> @llvm.vp.trunc.nxv2i8.nxv2i32(<vscale x 2 x i32> undef, <vscale x 2 x i1> undef, i32 undef)
; RV32-NEXT:  Cost Model: Found an estimated cost of 2 for instruction: %18 = call <vscale x 4 x i8> @llvm.vp.trunc.nxv4i8.nxv4i32(<vscale x 4 x i32> undef, <vscale x 4 x i1> undef, i32 undef)
; RV32-NEXT:  Cost Model: Found an estimated cost of 3 for instruction: %19 = call <vscale x 8 x i8> @llvm.vp.trunc.nxv8i8.nxv8i32(<vscale x 8 x i32> undef, <vscale x 8 x i1> undef, i32 undef)
; RV32-NEXT:  Cost Model: Found an estimated cost of 0 for instruction: ret void
;
; RV32_TYPEBASED-LABEL: 'int_truncate'
; RV32_TYPEBASED-NEXT:  Cost Model: Found an estimated cost of 0 for instruction: %1 = trunc i32 undef to i8
; RV32_TYPEBASED-NEXT:  Cost Model: Found an estimated cost of 2 for instruction: %2 = trunc <1 x i32> undef to <1 x i8>
; RV32_TYPEBASED-NEXT:  Cost Model: Found an estimated cost of 2 for instruction: %3 = trunc <2 x i32> undef to <2 x i8>
; RV32_TYPEBASED-NEXT:  Cost Model: Found an estimated cost of 2 for instruction: %4 = trunc <4 x i32> undef to <4 x i8>
; RV32_TYPEBASED-NEXT:  Cost Model: Found an estimated cost of 2 for instruction: %5 = trunc <8 x i32> undef to <8 x i8>
; RV32_TYPEBASED-NEXT:  Cost Model: Found an estimated cost of 3 for instruction: %6 = trunc <16 x i32> undef to <16 x i8>
; RV32_TYPEBASED-NEXT:  Cost Model: Found an estimated cost of 2 for instruction: %7 = trunc <vscale x 1 x i32> undef to <vscale x 1 x i8>
; RV32_TYPEBASED-NEXT:  Cost Model: Found an estimated cost of 2 for instruction: %8 = trunc <vscale x 2 x i32> undef to <vscale x 2 x i8>
; RV32_TYPEBASED-NEXT:  Cost Model: Found an estimated cost of 2 for instruction: %9 = trunc <vscale x 4 x i32> undef to <vscale x 4 x i8>
; RV32_TYPEBASED-NEXT:  Cost Model: Found an estimated cost of 3 for instruction: %10 = trunc <vscale x 8 x i32> undef to <vscale x 8 x i8>
; RV32_TYPEBASED-NEXT:  Cost Model: Found an estimated cost of 2 for instruction: %11 = call <1 x i8> @llvm.vp.trunc.v1i8.v1i32(<1 x i32> undef, <1 x i1> undef, i32 undef)
; RV32_TYPEBASED-NEXT:  Cost Model: Found an estimated cost of 2 for instruction: %12 = call <2 x i8> @llvm.vp.trunc.v2i8.v2i32(<2 x i32> undef, <2 x i1> undef, i32 undef)
; RV32_TYPEBASED-NEXT:  Cost Model: Found an estimated cost of 2 for instruction: %13 = call <4 x i8> @llvm.vp.trunc.v4i8.v4i32(<4 x i32> undef, <4 x i1> undef, i32 undef)
; RV32_TYPEBASED-NEXT:  Cost Model: Found an estimated cost of 2 for instruction: %14 = call <8 x i8> @llvm.vp.trunc.v8i8.v8i32(<8 x i32> undef, <8 x i1> undef, i32 undef)
; RV32_TYPEBASED-NEXT:  Cost Model: Found an estimated cost of 3 for instruction: %15 = call <16 x i8> @llvm.vp.trunc.v16i8.v16i32(<16 x i32> undef, <16 x i1> undef, i32 undef)
; RV32_TYPEBASED-NEXT:  Cost Model: Found an estimated cost of 2 for instruction: %16 = call <vscale x 1 x i8> @llvm.vp.trunc.nxv1i8.nxv1i32(<vscale x 1 x i32> undef, <vscale x 1 x i1> undef, i32 undef)
; RV32_TYPEBASED-NEXT:  Cost Model: Found an estimated cost of 2 for instruction: %17 = call <vscale x 2 x i8> @llvm.vp.trunc.nxv2i8.nxv2i32(<vscale x 2 x i32> undef, <vscale x 2 x i1> undef, i32 undef)
; RV32_TYPEBASED-NEXT:  Cost Model: Found an estimated cost of 2 for instruction: %18 = call <vscale x 4 x i8> @llvm.vp.trunc.nxv4i8.nxv4i32(<vscale x 4 x i32> undef, <vscale x 4 x i1> undef, i32 undef)
; RV32_TYPEBASED-NEXT:  Cost Model: Found an estimated cost of 3 for instruction: %19 = call <vscale x 8 x i8> @llvm.vp.trunc.nxv8i8.nxv8i32(<vscale x 8 x i32> undef, <vscale x 8 x i1> undef, i32 undef)
; RV32_TYPEBASED-NEXT:  Cost Model: Found an estimated cost of 0 for instruction: ret void
;
; RV64-LABEL: 'int_truncate'
; RV64-NEXT:  Cost Model: Found an estimated cost of 0 for instruction: %1 = trunc i32 undef to i8
; RV64-NEXT:  Cost Model: Found an estimated cost of 2 for instruction: %2 = trunc <1 x i32> undef to <1 x i8>
; RV64-NEXT:  Cost Model: Found an estimated cost of 2 for instruction: %3 = trunc <2 x i32> undef to <2 x i8>
; RV64-NEXT:  Cost Model: Found an estimated cost of 2 for instruction: %4 = trunc <4 x i32> undef to <4 x i8>
; RV64-NEXT:  Cost Model: Found an estimated cost of 2 for instruction: %5 = trunc <8 x i32> undef to <8 x i8>
; RV64-NEXT:  Cost Model: Found an estimated cost of 3 for instruction: %6 = trunc <16 x i32> undef to <16 x i8>
; RV64-NEXT:  Cost Model: Found an estimated cost of 2 for instruction: %7 = trunc <vscale x 1 x i32> undef to <vscale x 1 x i8>
; RV64-NEXT:  Cost Model: Found an estimated cost of 2 for instruction: %8 = trunc <vscale x 2 x i32> undef to <vscale x 2 x i8>
; RV64-NEXT:  Cost Model: Found an estimated cost of 2 for instruction: %9 = trunc <vscale x 4 x i32> undef to <vscale x 4 x i8>
; RV64-NEXT:  Cost Model: Found an estimated cost of 3 for instruction: %10 = trunc <vscale x 8 x i32> undef to <vscale x 8 x i8>
; RV64-NEXT:  Cost Model: Found an estimated cost of 2 for instruction: %11 = call <1 x i8> @llvm.vp.trunc.v1i8.v1i32(<1 x i32> undef, <1 x i1> undef, i32 undef)
; RV64-NEXT:  Cost Model: Found an estimated cost of 2 for instruction: %12 = call <2 x i8> @llvm.vp.trunc.v2i8.v2i32(<2 x i32> undef, <2 x i1> undef, i32 undef)
; RV64-NEXT:  Cost Model: Found an estimated cost of 2 for instruction: %13 = call <4 x i8> @llvm.vp.trunc.v4i8.v4i32(<4 x i32> undef, <4 x i1> undef, i32 undef)
; RV64-NEXT:  Cost Model: Found an estimated cost of 2 for instruction: %14 = call <8 x i8> @llvm.vp.trunc.v8i8.v8i32(<8 x i32> undef, <8 x i1> undef, i32 undef)
; RV64-NEXT:  Cost Model: Found an estimated cost of 3 for instruction: %15 = call <16 x i8> @llvm.vp.trunc.v16i8.v16i32(<16 x i32> undef, <16 x i1> undef, i32 undef)
; RV64-NEXT:  Cost Model: Found an estimated cost of 2 for instruction: %16 = call <vscale x 1 x i8> @llvm.vp.trunc.nxv1i8.nxv1i32(<vscale x 1 x i32> undef, <vscale x 1 x i1> undef, i32 undef)
; RV64-NEXT:  Cost Model: Found an estimated cost of 2 for instruction: %17 = call <vscale x 2 x i8> @llvm.vp.trunc.nxv2i8.nxv2i32(<vscale x 2 x i32> undef, <vscale x 2 x i1> undef, i32 undef)
; RV64-NEXT:  Cost Model: Found an estimated cost of 2 for instruction: %18 = call <vscale x 4 x i8> @llvm.vp.trunc.nxv4i8.nxv4i32(<vscale x 4 x i32> undef, <vscale x 4 x i1> undef, i32 undef)
; RV64-NEXT:  Cost Model: Found an estimated cost of 3 for instruction: %19 = call <vscale x 8 x i8> @llvm.vp.trunc.nxv8i8.nxv8i32(<vscale x 8 x i32> undef, <vscale x 8 x i1> undef, i32 undef)
; RV64-NEXT:  Cost Model: Found an estimated cost of 0 for instruction: ret void
;
; RV64_TYPEBASED-LABEL: 'int_truncate'
; RV64_TYPEBASED-NEXT:  Cost Model: Found an estimated cost of 0 for instruction: %1 = trunc i32 undef to i8
; RV64_TYPEBASED-NEXT:  Cost Model: Found an estimated cost of 2 for instruction: %2 = trunc <1 x i32> undef to <1 x i8>
; RV64_TYPEBASED-NEXT:  Cost Model: Found an estimated cost of 2 for instruction: %3 = trunc <2 x i32> undef to <2 x i8>
; RV64_TYPEBASED-NEXT:  Cost Model: Found an estimated cost of 2 for instruction: %4 = trunc <4 x i32> undef to <4 x i8>
; RV64_TYPEBASED-NEXT:  Cost Model: Found an estimated cost of 2 for instruction: %5 = trunc <8 x i32> undef to <8 x i8>
; RV64_TYPEBASED-NEXT:  Cost Model: Found an estimated cost of 3 for instruction: %6 = trunc <16 x i32> undef to <16 x i8>
; RV64_TYPEBASED-NEXT:  Cost Model: Found an estimated cost of 2 for instruction: %7 = trunc <vscale x 1 x i32> undef to <vscale x 1 x i8>
; RV64_TYPEBASED-NEXT:  Cost Model: Found an estimated cost of 2 for instruction: %8 = trunc <vscale x 2 x i32> undef to <vscale x 2 x i8>
; RV64_TYPEBASED-NEXT:  Cost Model: Found an estimated cost of 2 for instruction: %9 = trunc <vscale x 4 x i32> undef to <vscale x 4 x i8>
; RV64_TYPEBASED-NEXT:  Cost Model: Found an estimated cost of 3 for instruction: %10 = trunc <vscale x 8 x i32> undef to <vscale x 8 x i8>
; RV64_TYPEBASED-NEXT:  Cost Model: Found an estimated cost of 2 for instruction: %11 = call <1 x i8> @llvm.vp.trunc.v1i8.v1i32(<1 x i32> undef, <1 x i1> undef, i32 undef)
; RV64_TYPEBASED-NEXT:  Cost Model: Found an estimated cost of 2 for instruction: %12 = call <2 x i8> @llvm.vp.trunc.v2i8.v2i32(<2 x i32> undef, <2 x i1> undef, i32 undef)
; RV64_TYPEBASED-NEXT:  Cost Model: Found an estimated cost of 2 for instruction: %13 = call <4 x i8> @llvm.vp.trunc.v4i8.v4i32(<4 x i32> undef, <4 x i1> undef, i32 undef)
; RV64_TYPEBASED-NEXT:  Cost Model: Found an estimated cost of 2 for instruction: %14 = call <8 x i8> @llvm.vp.trunc.v8i8.v8i32(<8 x i32> undef, <8 x i1> undef, i32 undef)
; RV64_TYPEBASED-NEXT:  Cost Model: Found an estimated cost of 3 for instruction: %15 = call <16 x i8> @llvm.vp.trunc.v16i8.v16i32(<16 x i32> undef, <16 x i1> undef, i32 undef)
; RV64_TYPEBASED-NEXT:  Cost Model: Found an estimated cost of 2 for instruction: %16 = call <vscale x 1 x i8> @llvm.vp.trunc.nxv1i8.nxv1i32(<vscale x 1 x i32> undef, <vscale x 1 x i1> undef, i32 undef)
; RV64_TYPEBASED-NEXT:  Cost Model: Found an estimated cost of 2 for instruction: %17 = call <vscale x 2 x i8> @llvm.vp.trunc.nxv2i8.nxv2i32(<vscale x 2 x i32> undef, <vscale x 2 x i1> undef, i32 undef)
; RV64_TYPEBASED-NEXT:  Cost Model: Found an estimated cost of 2 for instruction: %18 = call <vscale x 4 x i8> @llvm.vp.trunc.nxv4i8.nxv4i32(<vscale x 4 x i32> undef, <vscale x 4 x i1> undef, i32 undef)
; RV64_TYPEBASED-NEXT:  Cost Model: Found an estimated cost of 3 for instruction: %19 = call <vscale x 8 x i8> @llvm.vp.trunc.nxv8i8.nxv8i32(<vscale x 8 x i32> undef, <vscale x 8 x i1> undef, i32 undef)
; RV64_TYPEBASED-NEXT:  Cost Model: Found an estimated cost of 0 for instruction: ret void
;
  trunc i32 undef to i8
  trunc <1 x i32> undef to <1 x i8>
  trunc <2 x i32> undef to <2 x i8>
  trunc <4 x i32> undef to <4 x i8>
  trunc <8 x i32> undef to <8 x i8>
  trunc <16 x i32> undef to <16 x i8>
  trunc <vscale x 1 x i32> undef to <vscale x 1 x i8>
  trunc <vscale x 2 x i32> undef to <vscale x 2 x i8>
  trunc <vscale x 4 x i32> undef to <vscale x 4 x i8>
  trunc <vscale x 8 x i32> undef to <vscale x 8 x i8>
  call <1 x i8> @llvm.vp.trunc.v1i32.v1i8(<1 x i32> undef, <1 x i1> undef, i32 undef)
  call <2 x i8> @llvm.vp.trunc.v2i32.v2i8(<2 x i32> undef, <2 x i1> undef, i32 undef)
  call <4 x i8> @llvm.vp.trunc.v4i32.v4i8(<4 x i32> undef, <4 x i1> undef, i32 undef)
  call <8 x i8> @llvm.vp.trunc.v8i32.v8i8(<8 x i32> undef, <8 x i1> undef, i32 undef)
  call <16 x i8> @llvm.vp.trunc.v16.v16(<16 x i32> undef, <16 x i1> undef, i32 undef)
  call <vscale x 1 x i8> @llvm.vp.trunc.nxv1i32.nxv1i8(<vscale x 1 x i32> undef, <vscale x 1 x i1> undef, i32 undef)
  call <vscale x 2 x i8> @llvm.vp.trunc.nxv2i32.nxv2i8(<vscale x 2 x i32> undef, <vscale x 2 x i1> undef, i32 undef)
  call <vscale x 4 x i8> @llvm.vp.trunc.nxv4i32.nxv4i8(<vscale x 4 x i32> undef, <vscale x 4 x i1> undef, i32 undef)
  call <vscale x 8 x i8> @llvm.vp.trunc.nxv8i32.nxv8i8(<vscale x 8 x i32> undef, <vscale x 8 x i1> undef, i32 undef)
  ret void
}

define void @int_zext() {
; RV32-LABEL: 'int_zext'
; RV32-NEXT:  Cost Model: Found an estimated cost of 1 for instruction: %1 = zext i32 undef to i64
; RV32-NEXT:  Cost Model: Found an estimated cost of 1 for instruction: %2 = zext <1 x i32> undef to <1 x i64>
; RV32-NEXT:  Cost Model: Found an estimated cost of 1 for instruction: %3 = zext <2 x i32> undef to <2 x i64>
; RV32-NEXT:  Cost Model: Found an estimated cost of 2 for instruction: %4 = zext <4 x i32> undef to <4 x i64>
; RV32-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: %5 = zext <8 x i32> undef to <8 x i64>
; RV32-NEXT:  Cost Model: Found an estimated cost of 8 for instruction: %6 = zext <16 x i32> undef to <16 x i64>
; RV32-NEXT:  Cost Model: Found an estimated cost of 1 for instruction: %7 = zext <vscale x 1 x i32> undef to <vscale x 1 x i64>
; RV32-NEXT:  Cost Model: Found an estimated cost of 2 for instruction: %8 = zext <vscale x 2 x i32> undef to <vscale x 2 x i64>
; RV32-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: %9 = zext <vscale x 4 x i32> undef to <vscale x 4 x i64>
; RV32-NEXT:  Cost Model: Found an estimated cost of 8 for instruction: %10 = zext <vscale x 8 x i32> undef to <vscale x 8 x i64>
; RV32-NEXT:  Cost Model: Found an estimated cost of 1 for instruction: %11 = call <1 x i64> @llvm.vp.zext.v1i64.v1i32(<1 x i32> undef, <1 x i1> undef, i32 undef)
; RV32-NEXT:  Cost Model: Found an estimated cost of 1 for instruction: %12 = call <2 x i64> @llvm.vp.zext.v2i64.v2i32(<2 x i32> undef, <2 x i1> undef, i32 undef)
; RV32-NEXT:  Cost Model: Found an estimated cost of 2 for instruction: %13 = call <4 x i64> @llvm.vp.zext.v4i64.v4i32(<4 x i32> undef, <4 x i1> undef, i32 undef)
; RV32-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: %14 = call <8 x i64> @llvm.vp.zext.v8i64.v8i32(<8 x i32> undef, <8 x i1> undef, i32 undef)
; RV32-NEXT:  Cost Model: Found an estimated cost of 8 for instruction: %15 = call <16 x i64> @llvm.vp.zext.v16i64.v16i32(<16 x i32> undef, <16 x i1> undef, i32 undef)
; RV32-NEXT:  Cost Model: Found an estimated cost of 1 for instruction: %16 = call <vscale x 1 x i64> @llvm.vp.zext.nxv1i64.nxv1i32(<vscale x 1 x i32> undef, <vscale x 1 x i1> undef, i32 undef)
; RV32-NEXT:  Cost Model: Found an estimated cost of 2 for instruction: %17 = call <vscale x 2 x i64> @llvm.vp.zext.nxv2i64.nxv2i32(<vscale x 2 x i32> undef, <vscale x 2 x i1> undef, i32 undef)
; RV32-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: %18 = call <vscale x 4 x i64> @llvm.vp.zext.nxv4i64.nxv4i32(<vscale x 4 x i32> undef, <vscale x 4 x i1> undef, i32 undef)
; RV32-NEXT:  Cost Model: Found an estimated cost of 8 for instruction: %19 = call <vscale x 8 x i64> @llvm.vp.zext.nxv8i64.nxv8i32(<vscale x 8 x i32> undef, <vscale x 8 x i1> undef, i32 undef)
; RV32-NEXT:  Cost Model: Found an estimated cost of 0 for instruction: ret void
;
; RV32_TYPEBASED-LABEL: 'int_zext'
; RV32_TYPEBASED-NEXT:  Cost Model: Found an estimated cost of 1 for instruction: %1 = zext i32 undef to i64
; RV32_TYPEBASED-NEXT:  Cost Model: Found an estimated cost of 1 for instruction: %2 = zext <1 x i32> undef to <1 x i64>
; RV32_TYPEBASED-NEXT:  Cost Model: Found an estimated cost of 1 for instruction: %3 = zext <2 x i32> undef to <2 x i64>
; RV32_TYPEBASED-NEXT:  Cost Model: Found an estimated cost of 2 for instruction: %4 = zext <4 x i32> undef to <4 x i64>
; RV32_TYPEBASED-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: %5 = zext <8 x i32> undef to <8 x i64>
; RV32_TYPEBASED-NEXT:  Cost Model: Found an estimated cost of 8 for instruction: %6 = zext <16 x i32> undef to <16 x i64>
; RV32_TYPEBASED-NEXT:  Cost Model: Found an estimated cost of 1 for instruction: %7 = zext <vscale x 1 x i32> undef to <vscale x 1 x i64>
; RV32_TYPEBASED-NEXT:  Cost Model: Found an estimated cost of 2 for instruction: %8 = zext <vscale x 2 x i32> undef to <vscale x 2 x i64>
; RV32_TYPEBASED-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: %9 = zext <vscale x 4 x i32> undef to <vscale x 4 x i64>
; RV32_TYPEBASED-NEXT:  Cost Model: Found an estimated cost of 8 for instruction: %10 = zext <vscale x 8 x i32> undef to <vscale x 8 x i64>
; RV32_TYPEBASED-NEXT:  Cost Model: Found an estimated cost of 1 for instruction: %11 = call <1 x i64> @llvm.vp.zext.v1i64.v1i32(<1 x i32> undef, <1 x i1> undef, i32 undef)
; RV32_TYPEBASED-NEXT:  Cost Model: Found an estimated cost of 1 for instruction: %12 = call <2 x i64> @llvm.vp.zext.v2i64.v2i32(<2 x i32> undef, <2 x i1> undef, i32 undef)
; RV32_TYPEBASED-NEXT:  Cost Model: Found an estimated cost of 2 for instruction: %13 = call <4 x i64> @llvm.vp.zext.v4i64.v4i32(<4 x i32> undef, <4 x i1> undef, i32 undef)
; RV32_TYPEBASED-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: %14 = call <8 x i64> @llvm.vp.zext.v8i64.v8i32(<8 x i32> undef, <8 x i1> undef, i32 undef)
; RV32_TYPEBASED-NEXT:  Cost Model: Found an estimated cost of 8 for instruction: %15 = call <16 x i64> @llvm.vp.zext.v16i64.v16i32(<16 x i32> undef, <16 x i1> undef, i32 undef)
; RV32_TYPEBASED-NEXT:  Cost Model: Found an estimated cost of 1 for instruction: %16 = call <vscale x 1 x i64> @llvm.vp.zext.nxv1i64.nxv1i32(<vscale x 1 x i32> undef, <vscale x 1 x i1> undef, i32 undef)
; RV32_TYPEBASED-NEXT:  Cost Model: Found an estimated cost of 2 for instruction: %17 = call <vscale x 2 x i64> @llvm.vp.zext.nxv2i64.nxv2i32(<vscale x 2 x i32> undef, <vscale x 2 x i1> undef, i32 undef)
; RV32_TYPEBASED-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: %18 = call <vscale x 4 x i64> @llvm.vp.zext.nxv4i64.nxv4i32(<vscale x 4 x i32> undef, <vscale x 4 x i1> undef, i32 undef)
; RV32_TYPEBASED-NEXT:  Cost Model: Found an estimated cost of 8 for instruction: %19 = call <vscale x 8 x i64> @llvm.vp.zext.nxv8i64.nxv8i32(<vscale x 8 x i32> undef, <vscale x 8 x i1> undef, i32 undef)
; RV32_TYPEBASED-NEXT:  Cost Model: Found an estimated cost of 0 for instruction: ret void
;
; RV64-LABEL: 'int_zext'
; RV64-NEXT:  Cost Model: Found an estimated cost of 1 for instruction: %1 = zext i32 undef to i64
; RV64-NEXT:  Cost Model: Found an estimated cost of 1 for instruction: %2 = zext <1 x i32> undef to <1 x i64>
; RV64-NEXT:  Cost Model: Found an estimated cost of 1 for instruction: %3 = zext <2 x i32> undef to <2 x i64>
; RV64-NEXT:  Cost Model: Found an estimated cost of 2 for instruction: %4 = zext <4 x i32> undef to <4 x i64>
; RV64-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: %5 = zext <8 x i32> undef to <8 x i64>
; RV64-NEXT:  Cost Model: Found an estimated cost of 8 for instruction: %6 = zext <16 x i32> undef to <16 x i64>
; RV64-NEXT:  Cost Model: Found an estimated cost of 1 for instruction: %7 = zext <vscale x 1 x i32> undef to <vscale x 1 x i64>
; RV64-NEXT:  Cost Model: Found an estimated cost of 2 for instruction: %8 = zext <vscale x 2 x i32> undef to <vscale x 2 x i64>
; RV64-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: %9 = zext <vscale x 4 x i32> undef to <vscale x 4 x i64>
; RV64-NEXT:  Cost Model: Found an estimated cost of 8 for instruction: %10 = zext <vscale x 8 x i32> undef to <vscale x 8 x i64>
; RV64-NEXT:  Cost Model: Found an estimated cost of 1 for instruction: %11 = call <1 x i64> @llvm.vp.zext.v1i64.v1i32(<1 x i32> undef, <1 x i1> undef, i32 undef)
; RV64-NEXT:  Cost Model: Found an estimated cost of 1 for instruction: %12 = call <2 x i64> @llvm.vp.zext.v2i64.v2i32(<2 x i32> undef, <2 x i1> undef, i32 undef)
; RV64-NEXT:  Cost Model: Found an estimated cost of 2 for instruction: %13 = call <4 x i64> @llvm.vp.zext.v4i64.v4i32(<4 x i32> undef, <4 x i1> undef, i32 undef)
; RV64-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: %14 = call <8 x i64> @llvm.vp.zext.v8i64.v8i32(<8 x i32> undef, <8 x i1> undef, i32 undef)
; RV64-NEXT:  Cost Model: Found an estimated cost of 8 for instruction: %15 = call <16 x i64> @llvm.vp.zext.v16i64.v16i32(<16 x i32> undef, <16 x i1> undef, i32 undef)
; RV64-NEXT:  Cost Model: Found an estimated cost of 1 for instruction: %16 = call <vscale x 1 x i64> @llvm.vp.zext.nxv1i64.nxv1i32(<vscale x 1 x i32> undef, <vscale x 1 x i1> undef, i32 undef)
; RV64-NEXT:  Cost Model: Found an estimated cost of 2 for instruction: %17 = call <vscale x 2 x i64> @llvm.vp.zext.nxv2i64.nxv2i32(<vscale x 2 x i32> undef, <vscale x 2 x i1> undef, i32 undef)
; RV64-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: %18 = call <vscale x 4 x i64> @llvm.vp.zext.nxv4i64.nxv4i32(<vscale x 4 x i32> undef, <vscale x 4 x i1> undef, i32 undef)
; RV64-NEXT:  Cost Model: Found an estimated cost of 8 for instruction: %19 = call <vscale x 8 x i64> @llvm.vp.zext.nxv8i64.nxv8i32(<vscale x 8 x i32> undef, <vscale x 8 x i1> undef, i32 undef)
; RV64-NEXT:  Cost Model: Found an estimated cost of 0 for instruction: ret void
;
; RV64_TYPEBASED-LABEL: 'int_zext'
; RV64_TYPEBASED-NEXT:  Cost Model: Found an estimated cost of 1 for instruction: %1 = zext i32 undef to i64
; RV64_TYPEBASED-NEXT:  Cost Model: Found an estimated cost of 1 for instruction: %2 = zext <1 x i32> undef to <1 x i64>
; RV64_TYPEBASED-NEXT:  Cost Model: Found an estimated cost of 1 for instruction: %3 = zext <2 x i32> undef to <2 x i64>
; RV64_TYPEBASED-NEXT:  Cost Model: Found an estimated cost of 2 for instruction: %4 = zext <4 x i32> undef to <4 x i64>
; RV64_TYPEBASED-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: %5 = zext <8 x i32> undef to <8 x i64>
; RV64_TYPEBASED-NEXT:  Cost Model: Found an estimated cost of 8 for instruction: %6 = zext <16 x i32> undef to <16 x i64>
; RV64_TYPEBASED-NEXT:  Cost Model: Found an estimated cost of 1 for instruction: %7 = zext <vscale x 1 x i32> undef to <vscale x 1 x i64>
; RV64_TYPEBASED-NEXT:  Cost Model: Found an estimated cost of 2 for instruction: %8 = zext <vscale x 2 x i32> undef to <vscale x 2 x i64>
; RV64_TYPEBASED-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: %9 = zext <vscale x 4 x i32> undef to <vscale x 4 x i64>
; RV64_TYPEBASED-NEXT:  Cost Model: Found an estimated cost of 8 for instruction: %10 = zext <vscale x 8 x i32> undef to <vscale x 8 x i64>
; RV64_TYPEBASED-NEXT:  Cost Model: Found an estimated cost of 1 for instruction: %11 = call <1 x i64> @llvm.vp.zext.v1i64.v1i32(<1 x i32> undef, <1 x i1> undef, i32 undef)
; RV64_TYPEBASED-NEXT:  Cost Model: Found an estimated cost of 1 for instruction: %12 = call <2 x i64> @llvm.vp.zext.v2i64.v2i32(<2 x i32> undef, <2 x i1> undef, i32 undef)
; RV64_TYPEBASED-NEXT:  Cost Model: Found an estimated cost of 2 for instruction: %13 = call <4 x i64> @llvm.vp.zext.v4i64.v4i32(<4 x i32> undef, <4 x i1> undef, i32 undef)
; RV64_TYPEBASED-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: %14 = call <8 x i64> @llvm.vp.zext.v8i64.v8i32(<8 x i32> undef, <8 x i1> undef, i32 undef)
; RV64_TYPEBASED-NEXT:  Cost Model: Found an estimated cost of 8 for instruction: %15 = call <16 x i64> @llvm.vp.zext.v16i64.v16i32(<16 x i32> undef, <16 x i1> undef, i32 undef)
; RV64_TYPEBASED-NEXT:  Cost Model: Found an estimated cost of 1 for instruction: %16 = call <vscale x 1 x i64> @llvm.vp.zext.nxv1i64.nxv1i32(<vscale x 1 x i32> undef, <vscale x 1 x i1> undef, i32 undef)
; RV64_TYPEBASED-NEXT:  Cost Model: Found an estimated cost of 2 for instruction: %17 = call <vscale x 2 x i64> @llvm.vp.zext.nxv2i64.nxv2i32(<vscale x 2 x i32> undef, <vscale x 2 x i1> undef, i32 undef)
; RV64_TYPEBASED-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: %18 = call <vscale x 4 x i64> @llvm.vp.zext.nxv4i64.nxv4i32(<vscale x 4 x i32> undef, <vscale x 4 x i1> undef, i32 undef)
; RV64_TYPEBASED-NEXT:  Cost Model: Found an estimated cost of 8 for instruction: %19 = call <vscale x 8 x i64> @llvm.vp.zext.nxv8i64.nxv8i32(<vscale x 8 x i32> undef, <vscale x 8 x i1> undef, i32 undef)
; RV64_TYPEBASED-NEXT:  Cost Model: Found an estimated cost of 0 for instruction: ret void
;
  zext i32 undef to i64
  zext <1 x i32> undef to <1 x i64>
  zext <2 x i32> undef to <2 x i64>
  zext <4 x i32> undef to <4 x i64>
  zext <8 x i32> undef to <8 x i64>
  zext <16 x i32> undef to <16 x i64>
  zext <vscale x 1 x i32> undef to <vscale x 1 x i64>
  zext <vscale x 2 x i32> undef to <vscale x 2 x i64>
  zext <vscale x 4 x i32> undef to <vscale x 4 x i64>
  zext <vscale x 8 x i32> undef to <vscale x 8 x i64>
  call <1 x i64> @llvm.vp.zext.v1i32.v1i64(<1 x i32> undef, <1 x i1> undef, i32 undef)
  call <2 x i64> @llvm.vp.zext.v2i32.v2i64(<2 x i32> undef, <2 x i1> undef, i32 undef)
  call <4 x i64> @llvm.vp.zext.v4i32.v4i64(<4 x i32> undef, <4 x i1> undef, i32 undef)
  call <8 x i64> @llvm.vp.zext.v8i32.v8i64(<8 x i32> undef, <8 x i1> undef, i32 undef)
  call <16 x i64> @llvm.vp.zext.v16.v16(<16 x i32> undef, <16 x i1> undef, i32 undef)
  call <vscale x 1 x i64> @llvm.vp.zext.nxv1i32.nxv1i64(<vscale x 1 x i32> undef, <vscale x 1 x i1> undef, i32 undef)
  call <vscale x 2 x i64> @llvm.vp.zext.nxv2i32.nxv2i64(<vscale x 2 x i32> undef, <vscale x 2 x i1> undef, i32 undef)
  call <vscale x 4 x i64> @llvm.vp.zext.nxv4i32.nxv4i64(<vscale x 4 x i32> undef, <vscale x 4 x i1> undef, i32 undef)
  call <vscale x 8 x i64> @llvm.vp.zext.nxv8i32.nxv8i64(<vscale x 8 x i32> undef, <vscale x 8 x i1> undef, i32 undef)
  ret void
}

define void @int_sext() {
; RV32-LABEL: 'int_sext'
; RV32-NEXT:  Cost Model: Found an estimated cost of 1 for instruction: %1 = sext i32 undef to i64
; RV32-NEXT:  Cost Model: Found an estimated cost of 1 for instruction: %2 = sext <1 x i32> undef to <1 x i64>
; RV32-NEXT:  Cost Model: Found an estimated cost of 1 for instruction: %3 = sext <2 x i32> undef to <2 x i64>
; RV32-NEXT:  Cost Model: Found an estimated cost of 2 for instruction: %4 = sext <4 x i32> undef to <4 x i64>
; RV32-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: %5 = sext <8 x i32> undef to <8 x i64>
; RV32-NEXT:  Cost Model: Found an estimated cost of 8 for instruction: %6 = sext <16 x i32> undef to <16 x i64>
; RV32-NEXT:  Cost Model: Found an estimated cost of 1 for instruction: %7 = sext <vscale x 1 x i32> undef to <vscale x 1 x i64>
; RV32-NEXT:  Cost Model: Found an estimated cost of 2 for instruction: %8 = sext <vscale x 2 x i32> undef to <vscale x 2 x i64>
; RV32-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: %9 = sext <vscale x 4 x i32> undef to <vscale x 4 x i64>
; RV32-NEXT:  Cost Model: Found an estimated cost of 8 for instruction: %10 = sext <vscale x 8 x i32> undef to <vscale x 8 x i64>
; RV32-NEXT:  Cost Model: Found an estimated cost of 1 for instruction: %11 = call <1 x i64> @llvm.vp.sext.v1i64.v1i32(<1 x i32> undef, <1 x i1> undef, i32 undef)
; RV32-NEXT:  Cost Model: Found an estimated cost of 1 for instruction: %12 = call <2 x i64> @llvm.vp.sext.v2i64.v2i32(<2 x i32> undef, <2 x i1> undef, i32 undef)
; RV32-NEXT:  Cost Model: Found an estimated cost of 2 for instruction: %13 = call <4 x i64> @llvm.vp.sext.v4i64.v4i32(<4 x i32> undef, <4 x i1> undef, i32 undef)
; RV32-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: %14 = call <8 x i64> @llvm.vp.sext.v8i64.v8i32(<8 x i32> undef, <8 x i1> undef, i32 undef)
; RV32-NEXT:  Cost Model: Found an estimated cost of 8 for instruction: %15 = call <16 x i64> @llvm.vp.sext.v16i64.v16i32(<16 x i32> undef, <16 x i1> undef, i32 undef)
; RV32-NEXT:  Cost Model: Found an estimated cost of 1 for instruction: %16 = call <vscale x 1 x i64> @llvm.vp.sext.nxv1i64.nxv1i32(<vscale x 1 x i32> undef, <vscale x 1 x i1> undef, i32 undef)
; RV32-NEXT:  Cost Model: Found an estimated cost of 2 for instruction: %17 = call <vscale x 2 x i64> @llvm.vp.sext.nxv2i64.nxv2i32(<vscale x 2 x i32> undef, <vscale x 2 x i1> undef, i32 undef)
; RV32-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: %18 = call <vscale x 4 x i64> @llvm.vp.sext.nxv4i64.nxv4i32(<vscale x 4 x i32> undef, <vscale x 4 x i1> undef, i32 undef)
; RV32-NEXT:  Cost Model: Found an estimated cost of 8 for instruction: %19 = call <vscale x 8 x i64> @llvm.vp.sext.nxv8i64.nxv8i32(<vscale x 8 x i32> undef, <vscale x 8 x i1> undef, i32 undef)
; RV32-NEXT:  Cost Model: Found an estimated cost of 0 for instruction: ret void
;
; RV32_TYPEBASED-LABEL: 'int_sext'
; RV32_TYPEBASED-NEXT:  Cost Model: Found an estimated cost of 1 for instruction: %1 = sext i32 undef to i64
; RV32_TYPEBASED-NEXT:  Cost Model: Found an estimated cost of 1 for instruction: %2 = sext <1 x i32> undef to <1 x i64>
; RV32_TYPEBASED-NEXT:  Cost Model: Found an estimated cost of 1 for instruction: %3 = sext <2 x i32> undef to <2 x i64>
; RV32_TYPEBASED-NEXT:  Cost Model: Found an estimated cost of 2 for instruction: %4 = sext <4 x i32> undef to <4 x i64>
; RV32_TYPEBASED-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: %5 = sext <8 x i32> undef to <8 x i64>
; RV32_TYPEBASED-NEXT:  Cost Model: Found an estimated cost of 8 for instruction: %6 = sext <16 x i32> undef to <16 x i64>
; RV32_TYPEBASED-NEXT:  Cost Model: Found an estimated cost of 1 for instruction: %7 = sext <vscale x 1 x i32> undef to <vscale x 1 x i64>
; RV32_TYPEBASED-NEXT:  Cost Model: Found an estimated cost of 2 for instruction: %8 = sext <vscale x 2 x i32> undef to <vscale x 2 x i64>
; RV32_TYPEBASED-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: %9 = sext <vscale x 4 x i32> undef to <vscale x 4 x i64>
; RV32_TYPEBASED-NEXT:  Cost Model: Found an estimated cost of 8 for instruction: %10 = sext <vscale x 8 x i32> undef to <vscale x 8 x i64>
; RV32_TYPEBASED-NEXT:  Cost Model: Found an estimated cost of 1 for instruction: %11 = call <1 x i64> @llvm.vp.sext.v1i64.v1i32(<1 x i32> undef, <1 x i1> undef, i32 undef)
; RV32_TYPEBASED-NEXT:  Cost Model: Found an estimated cost of 1 for instruction: %12 = call <2 x i64> @llvm.vp.sext.v2i64.v2i32(<2 x i32> undef, <2 x i1> undef, i32 undef)
; RV32_TYPEBASED-NEXT:  Cost Model: Found an estimated cost of 2 for instruction: %13 = call <4 x i64> @llvm.vp.sext.v4i64.v4i32(<4 x i32> undef, <4 x i1> undef, i32 undef)
; RV32_TYPEBASED-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: %14 = call <8 x i64> @llvm.vp.sext.v8i64.v8i32(<8 x i32> undef, <8 x i1> undef, i32 undef)
; RV32_TYPEBASED-NEXT:  Cost Model: Found an estimated cost of 8 for instruction: %15 = call <16 x i64> @llvm.vp.sext.v16i64.v16i32(<16 x i32> undef, <16 x i1> undef, i32 undef)
; RV32_TYPEBASED-NEXT:  Cost Model: Found an estimated cost of 1 for instruction: %16 = call <vscale x 1 x i64> @llvm.vp.sext.nxv1i64.nxv1i32(<vscale x 1 x i32> undef, <vscale x 1 x i1> undef, i32 undef)
; RV32_TYPEBASED-NEXT:  Cost Model: Found an estimated cost of 2 for instruction: %17 = call <vscale x 2 x i64> @llvm.vp.sext.nxv2i64.nxv2i32(<vscale x 2 x i32> undef, <vscale x 2 x i1> undef, i32 undef)
; RV32_TYPEBASED-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: %18 = call <vscale x 4 x i64> @llvm.vp.sext.nxv4i64.nxv4i32(<vscale x 4 x i32> undef, <vscale x 4 x i1> undef, i32 undef)
; RV32_TYPEBASED-NEXT:  Cost Model: Found an estimated cost of 8 for instruction: %19 = call <vscale x 8 x i64> @llvm.vp.sext.nxv8i64.nxv8i32(<vscale x 8 x i32> undef, <vscale x 8 x i1> undef, i32 undef)
; RV32_TYPEBASED-NEXT:  Cost Model: Found an estimated cost of 0 for instruction: ret void
;
; RV64-LABEL: 'int_sext'
; RV64-NEXT:  Cost Model: Found an estimated cost of 1 for instruction: %1 = sext i32 undef to i64
; RV64-NEXT:  Cost Model: Found an estimated cost of 1 for instruction: %2 = sext <1 x i32> undef to <1 x i64>
; RV64-NEXT:  Cost Model: Found an estimated cost of 1 for instruction: %3 = sext <2 x i32> undef to <2 x i64>
; RV64-NEXT:  Cost Model: Found an estimated cost of 2 for instruction: %4 = sext <4 x i32> undef to <4 x i64>
; RV64-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: %5 = sext <8 x i32> undef to <8 x i64>
; RV64-NEXT:  Cost Model: Found an estimated cost of 8 for instruction: %6 = sext <16 x i32> undef to <16 x i64>
; RV64-NEXT:  Cost Model: Found an estimated cost of 1 for instruction: %7 = sext <vscale x 1 x i32> undef to <vscale x 1 x i64>
; RV64-NEXT:  Cost Model: Found an estimated cost of 2 for instruction: %8 = sext <vscale x 2 x i32> undef to <vscale x 2 x i64>
; RV64-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: %9 = sext <vscale x 4 x i32> undef to <vscale x 4 x i64>
; RV64-NEXT:  Cost Model: Found an estimated cost of 8 for instruction: %10 = sext <vscale x 8 x i32> undef to <vscale x 8 x i64>
; RV64-NEXT:  Cost Model: Found an estimated cost of 1 for instruction: %11 = call <1 x i64> @llvm.vp.sext.v1i64.v1i32(<1 x i32> undef, <1 x i1> undef, i32 undef)
; RV64-NEXT:  Cost Model: Found an estimated cost of 1 for instruction: %12 = call <2 x i64> @llvm.vp.sext.v2i64.v2i32(<2 x i32> undef, <2 x i1> undef, i32 undef)
; RV64-NEXT:  Cost Model: Found an estimated cost of 2 for instruction: %13 = call <4 x i64> @llvm.vp.sext.v4i64.v4i32(<4 x i32> undef, <4 x i1> undef, i32 undef)
; RV64-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: %14 = call <8 x i64> @llvm.vp.sext.v8i64.v8i32(<8 x i32> undef, <8 x i1> undef, i32 undef)
; RV64-NEXT:  Cost Model: Found an estimated cost of 8 for instruction: %15 = call <16 x i64> @llvm.vp.sext.v16i64.v16i32(<16 x i32> undef, <16 x i1> undef, i32 undef)
; RV64-NEXT:  Cost Model: Found an estimated cost of 1 for instruction: %16 = call <vscale x 1 x i64> @llvm.vp.sext.nxv1i64.nxv1i32(<vscale x 1 x i32> undef, <vscale x 1 x i1> undef, i32 undef)
; RV64-NEXT:  Cost Model: Found an estimated cost of 2 for instruction: %17 = call <vscale x 2 x i64> @llvm.vp.sext.nxv2i64.nxv2i32(<vscale x 2 x i32> undef, <vscale x 2 x i1> undef, i32 undef)
; RV64-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: %18 = call <vscale x 4 x i64> @llvm.vp.sext.nxv4i64.nxv4i32(<vscale x 4 x i32> undef, <vscale x 4 x i1> undef, i32 undef)
; RV64-NEXT:  Cost Model: Found an estimated cost of 8 for instruction: %19 = call <vscale x 8 x i64> @llvm.vp.sext.nxv8i64.nxv8i32(<vscale x 8 x i32> undef, <vscale x 8 x i1> undef, i32 undef)
; RV64-NEXT:  Cost Model: Found an estimated cost of 0 for instruction: ret void
;
; RV64_TYPEBASED-LABEL: 'int_sext'
; RV64_TYPEBASED-NEXT:  Cost Model: Found an estimated cost of 1 for instruction: %1 = sext i32 undef to i64
; RV64_TYPEBASED-NEXT:  Cost Model: Found an estimated cost of 1 for instruction: %2 = sext <1 x i32> undef to <1 x i64>
; RV64_TYPEBASED-NEXT:  Cost Model: Found an estimated cost of 1 for instruction: %3 = sext <2 x i32> undef to <2 x i64>
; RV64_TYPEBASED-NEXT:  Cost Model: Found an estimated cost of 2 for instruction: %4 = sext <4 x i32> undef to <4 x i64>
; RV64_TYPEBASED-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: %5 = sext <8 x i32> undef to <8 x i64>
; RV64_TYPEBASED-NEXT:  Cost Model: Found an estimated cost of 8 for instruction: %6 = sext <16 x i32> undef to <16 x i64>
; RV64_TYPEBASED-NEXT:  Cost Model: Found an estimated cost of 1 for instruction: %7 = sext <vscale x 1 x i32> undef to <vscale x 1 x i64>
; RV64_TYPEBASED-NEXT:  Cost Model: Found an estimated cost of 2 for instruction: %8 = sext <vscale x 2 x i32> undef to <vscale x 2 x i64>
; RV64_TYPEBASED-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: %9 = sext <vscale x 4 x i32> undef to <vscale x 4 x i64>
; RV64_TYPEBASED-NEXT:  Cost Model: Found an estimated cost of 8 for instruction: %10 = sext <vscale x 8 x i32> undef to <vscale x 8 x i64>
; RV64_TYPEBASED-NEXT:  Cost Model: Found an estimated cost of 1 for instruction: %11 = call <1 x i64> @llvm.vp.sext.v1i64.v1i32(<1 x i32> undef, <1 x i1> undef, i32 undef)
; RV64_TYPEBASED-NEXT:  Cost Model: Found an estimated cost of 1 for instruction: %12 = call <2 x i64> @llvm.vp.sext.v2i64.v2i32(<2 x i32> undef, <2 x i1> undef, i32 undef)
; RV64_TYPEBASED-NEXT:  Cost Model: Found an estimated cost of 2 for instruction: %13 = call <4 x i64> @llvm.vp.sext.v4i64.v4i32(<4 x i32> undef, <4 x i1> undef, i32 undef)
; RV64_TYPEBASED-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: %14 = call <8 x i64> @llvm.vp.sext.v8i64.v8i32(<8 x i32> undef, <8 x i1> undef, i32 undef)
; RV64_TYPEBASED-NEXT:  Cost Model: Found an estimated cost of 8 for instruction: %15 = call <16 x i64> @llvm.vp.sext.v16i64.v16i32(<16 x i32> undef, <16 x i1> undef, i32 undef)
; RV64_TYPEBASED-NEXT:  Cost Model: Found an estimated cost of 1 for instruction: %16 = call <vscale x 1 x i64> @llvm.vp.sext.nxv1i64.nxv1i32(<vscale x 1 x i32> undef, <vscale x 1 x i1> undef, i32 undef)
; RV64_TYPEBASED-NEXT:  Cost Model: Found an estimated cost of 2 for instruction: %17 = call <vscale x 2 x i64> @llvm.vp.sext.nxv2i64.nxv2i32(<vscale x 2 x i32> undef, <vscale x 2 x i1> undef, i32 undef)
; RV64_TYPEBASED-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: %18 = call <vscale x 4 x i64> @llvm.vp.sext.nxv4i64.nxv4i32(<vscale x 4 x i32> undef, <vscale x 4 x i1> undef, i32 undef)
; RV64_TYPEBASED-NEXT:  Cost Model: Found an estimated cost of 8 for instruction: %19 = call <vscale x 8 x i64> @llvm.vp.sext.nxv8i64.nxv8i32(<vscale x 8 x i32> undef, <vscale x 8 x i1> undef, i32 undef)
; RV64_TYPEBASED-NEXT:  Cost Model: Found an estimated cost of 0 for instruction: ret void
;
  sext i32 undef to i64
  sext <1 x i32> undef to <1 x i64>
  sext <2 x i32> undef to <2 x i64>
  sext <4 x i32> undef to <4 x i64>
  sext <8 x i32> undef to <8 x i64>
  sext <16 x i32> undef to <16 x i64>
  sext <vscale x 1 x i32> undef to <vscale x 1 x i64>
  sext <vscale x 2 x i32> undef to <vscale x 2 x i64>
  sext <vscale x 4 x i32> undef to <vscale x 4 x i64>
  sext <vscale x 8 x i32> undef to <vscale x 8 x i64>
  call <1 x i64> @llvm.vp.sext.v1i32.v1i64(<1 x i32> undef, <1 x i1> undef, i32 undef)
  call <2 x i64> @llvm.vp.sext.v2i32.v2i64(<2 x i32> undef, <2 x i1> undef, i32 undef)
  call <4 x i64> @llvm.vp.sext.v4i32.v4i64(<4 x i32> undef, <4 x i1> undef, i32 undef)
  call <8 x i64> @llvm.vp.sext.v8i32.v8i64(<8 x i32> undef, <8 x i1> undef, i32 undef)
  call <16 x i64> @llvm.vp.sext.v16.v16(<16 x i32> undef, <16 x i1> undef, i32 undef)
  call <vscale x 1 x i64> @llvm.vp.sext.nxv1i32.nxv1i64(<vscale x 1 x i32> undef, <vscale x 1 x i1> undef, i32 undef)
  call <vscale x 2 x i64> @llvm.vp.sext.nxv2i32.nxv2i64(<vscale x 2 x i32> undef, <vscale x 2 x i1> undef, i32 undef)
  call <vscale x 4 x i64> @llvm.vp.sext.nxv4i32.nxv4i64(<vscale x 4 x i32> undef, <vscale x 4 x i1> undef, i32 undef)
  call <vscale x 8 x i64> @llvm.vp.sext.nxv8i32.nxv8i64(<vscale x 8 x i32> undef, <vscale x 8 x i1> undef, i32 undef)
  ret void
}

define void @fp_truncate() {
; RV32-LABEL: 'fp_truncate'
; RV32-NEXT:  Cost Model: Found an estimated cost of 1 for instruction: %1 = fptrunc double undef to float
; RV32-NEXT:  Cost Model: Found an estimated cost of 1 for instruction: %2 = fptrunc <1 x double> undef to <1 x float>
; RV32-NEXT:  Cost Model: Found an estimated cost of 1 for instruction: %3 = fptrunc <2 x double> undef to <2 x float>
; RV32-NEXT:  Cost Model: Found an estimated cost of 1 for instruction: %4 = fptrunc <4 x double> undef to <4 x float>
; RV32-NEXT:  Cost Model: Found an estimated cost of 2 for instruction: %5 = fptrunc <8 x double> undef to <8 x float>
; RV32-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: %6 = fptrunc <16 x double> undef to <16 x float>
; RV32-NEXT:  Cost Model: Found an estimated cost of 1 for instruction: %7 = fptrunc <vscale x 1 x double> undef to <vscale x 1 x float>
; RV32-NEXT:  Cost Model: Found an estimated cost of 1 for instruction: %8 = fptrunc <vscale x 2 x double> undef to <vscale x 2 x float>
; RV32-NEXT:  Cost Model: Found an estimated cost of 2 for instruction: %9 = fptrunc <vscale x 4 x double> undef to <vscale x 4 x float>
; RV32-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: %10 = fptrunc <vscale x 8 x double> undef to <vscale x 8 x float>
; RV32-NEXT:  Cost Model: Found an estimated cost of 1 for instruction: %11 = call <1 x float> @llvm.vp.fptrunc.v1f32.v1f64(<1 x double> undef, <1 x i1> undef, i32 undef)
; RV32-NEXT:  Cost Model: Found an estimated cost of 1 for instruction: %12 = call <2 x float> @llvm.vp.fptrunc.v2f32.v2f64(<2 x double> undef, <2 x i1> undef, i32 undef)
; RV32-NEXT:  Cost Model: Found an estimated cost of 1 for instruction: %13 = call <4 x float> @llvm.vp.fptrunc.v4f32.v4f64(<4 x double> undef, <4 x i1> undef, i32 undef)
; RV32-NEXT:  Cost Model: Found an estimated cost of 2 for instruction: %14 = call <8 x float> @llvm.vp.fptrunc.v8f32.v8f64(<8 x double> undef, <8 x i1> undef, i32 undef)
; RV32-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: %15 = call <16 x float> @llvm.vp.fptrunc.v16f32.v16f64(<16 x double> undef, <16 x i1> undef, i32 undef)
; RV32-NEXT:  Cost Model: Found an estimated cost of 1 for instruction: %16 = call <vscale x 1 x float> @llvm.vp.fptrunc.nxv1f32.nxv1f64(<vscale x 1 x double> undef, <vscale x 1 x i1> undef, i32 undef)
; RV32-NEXT:  Cost Model: Found an estimated cost of 1 for instruction: %17 = call <vscale x 2 x float> @llvm.vp.fptrunc.nxv2f32.nxv2f64(<vscale x 2 x double> undef, <vscale x 2 x i1> undef, i32 undef)
; RV32-NEXT:  Cost Model: Found an estimated cost of 2 for instruction: %18 = call <vscale x 4 x float> @llvm.vp.fptrunc.nxv4f32.nxv4f64(<vscale x 4 x double> undef, <vscale x 4 x i1> undef, i32 undef)
; RV32-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: %19 = call <vscale x 8 x float> @llvm.vp.fptrunc.nxv8f32.nxv8f64(<vscale x 8 x double> undef, <vscale x 8 x i1> undef, i32 undef)
; RV32-NEXT:  Cost Model: Found an estimated cost of 0 for instruction: ret void
;
; RV32_TYPEBASED-LABEL: 'fp_truncate'
; RV32_TYPEBASED-NEXT:  Cost Model: Found an estimated cost of 1 for instruction: %1 = fptrunc double undef to float
; RV32_TYPEBASED-NEXT:  Cost Model: Found an estimated cost of 1 for instruction: %2 = fptrunc <1 x double> undef to <1 x float>
; RV32_TYPEBASED-NEXT:  Cost Model: Found an estimated cost of 1 for instruction: %3 = fptrunc <2 x double> undef to <2 x float>
; RV32_TYPEBASED-NEXT:  Cost Model: Found an estimated cost of 1 for instruction: %4 = fptrunc <4 x double> undef to <4 x float>
; RV32_TYPEBASED-NEXT:  Cost Model: Found an estimated cost of 2 for instruction: %5 = fptrunc <8 x double> undef to <8 x float>
; RV32_TYPEBASED-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: %6 = fptrunc <16 x double> undef to <16 x float>
; RV32_TYPEBASED-NEXT:  Cost Model: Found an estimated cost of 1 for instruction: %7 = fptrunc <vscale x 1 x double> undef to <vscale x 1 x float>
; RV32_TYPEBASED-NEXT:  Cost Model: Found an estimated cost of 1 for instruction: %8 = fptrunc <vscale x 2 x double> undef to <vscale x 2 x float>
; RV32_TYPEBASED-NEXT:  Cost Model: Found an estimated cost of 2 for instruction: %9 = fptrunc <vscale x 4 x double> undef to <vscale x 4 x float>
; RV32_TYPEBASED-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: %10 = fptrunc <vscale x 8 x double> undef to <vscale x 8 x float>
; RV32_TYPEBASED-NEXT:  Cost Model: Found an estimated cost of 1 for instruction: %11 = call <1 x float> @llvm.vp.fptrunc.v1f32.v1f64(<1 x double> undef, <1 x i1> undef, i32 undef)
; RV32_TYPEBASED-NEXT:  Cost Model: Found an estimated cost of 1 for instruction: %12 = call <2 x float> @llvm.vp.fptrunc.v2f32.v2f64(<2 x double> undef, <2 x i1> undef, i32 undef)
; RV32_TYPEBASED-NEXT:  Cost Model: Found an estimated cost of 1 for instruction: %13 = call <4 x float> @llvm.vp.fptrunc.v4f32.v4f64(<4 x double> undef, <4 x i1> undef, i32 undef)
; RV32_TYPEBASED-NEXT:  Cost Model: Found an estimated cost of 2 for instruction: %14 = call <8 x float> @llvm.vp.fptrunc.v8f32.v8f64(<8 x double> undef, <8 x i1> undef, i32 undef)
; RV32_TYPEBASED-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: %15 = call <16 x float> @llvm.vp.fptrunc.v16f32.v16f64(<16 x double> undef, <16 x i1> undef, i32 undef)
; RV32_TYPEBASED-NEXT:  Cost Model: Found an estimated cost of 1 for instruction: %16 = call <vscale x 1 x float> @llvm.vp.fptrunc.nxv1f32.nxv1f64(<vscale x 1 x double> undef, <vscale x 1 x i1> undef, i32 undef)
; RV32_TYPEBASED-NEXT:  Cost Model: Found an estimated cost of 1 for instruction: %17 = call <vscale x 2 x float> @llvm.vp.fptrunc.nxv2f32.nxv2f64(<vscale x 2 x double> undef, <vscale x 2 x i1> undef, i32 undef)
; RV32_TYPEBASED-NEXT:  Cost Model: Found an estimated cost of 2 for instruction: %18 = call <vscale x 4 x float> @llvm.vp.fptrunc.nxv4f32.nxv4f64(<vscale x 4 x double> undef, <vscale x 4 x i1> undef, i32 undef)
; RV32_TYPEBASED-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: %19 = call <vscale x 8 x float> @llvm.vp.fptrunc.nxv8f32.nxv8f64(<vscale x 8 x double> undef, <vscale x 8 x i1> undef, i32 undef)
; RV32_TYPEBASED-NEXT:  Cost Model: Found an estimated cost of 0 for instruction: ret void
;
; RV64-LABEL: 'fp_truncate'
; RV64-NEXT:  Cost Model: Found an estimated cost of 1 for instruction: %1 = fptrunc double undef to float
; RV64-NEXT:  Cost Model: Found an estimated cost of 1 for instruction: %2 = fptrunc <1 x double> undef to <1 x float>
; RV64-NEXT:  Cost Model: Found an estimated cost of 1 for instruction: %3 = fptrunc <2 x double> undef to <2 x float>
; RV64-NEXT:  Cost Model: Found an estimated cost of 1 for instruction: %4 = fptrunc <4 x double> undef to <4 x float>
; RV64-NEXT:  Cost Model: Found an estimated cost of 2 for instruction: %5 = fptrunc <8 x double> undef to <8 x float>
; RV64-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: %6 = fptrunc <16 x double> undef to <16 x float>
; RV64-NEXT:  Cost Model: Found an estimated cost of 1 for instruction: %7 = fptrunc <vscale x 1 x double> undef to <vscale x 1 x float>
; RV64-NEXT:  Cost Model: Found an estimated cost of 1 for instruction: %8 = fptrunc <vscale x 2 x double> undef to <vscale x 2 x float>
; RV64-NEXT:  Cost Model: Found an estimated cost of 2 for instruction: %9 = fptrunc <vscale x 4 x double> undef to <vscale x 4 x float>
; RV64-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: %10 = fptrunc <vscale x 8 x double> undef to <vscale x 8 x float>
; RV64-NEXT:  Cost Model: Found an estimated cost of 1 for instruction: %11 = call <1 x float> @llvm.vp.fptrunc.v1f32.v1f64(<1 x double> undef, <1 x i1> undef, i32 undef)
; RV64-NEXT:  Cost Model: Found an estimated cost of 1 for instruction: %12 = call <2 x float> @llvm.vp.fptrunc.v2f32.v2f64(<2 x double> undef, <2 x i1> undef, i32 undef)
; RV64-NEXT:  Cost Model: Found an estimated cost of 1 for instruction: %13 = call <4 x float> @llvm.vp.fptrunc.v4f32.v4f64(<4 x double> undef, <4 x i1> undef, i32 undef)
; RV64-NEXT:  Cost Model: Found an estimated cost of 2 for instruction: %14 = call <8 x float> @llvm.vp.fptrunc.v8f32.v8f64(<8 x double> undef, <8 x i1> undef, i32 undef)
; RV64-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: %15 = call <16 x float> @llvm.vp.fptrunc.v16f32.v16f64(<16 x double> undef, <16 x i1> undef, i32 undef)
; RV64-NEXT:  Cost Model: Found an estimated cost of 1 for instruction: %16 = call <vscale x 1 x float> @llvm.vp.fptrunc.nxv1f32.nxv1f64(<vscale x 1 x double> undef, <vscale x 1 x i1> undef, i32 undef)
; RV64-NEXT:  Cost Model: Found an estimated cost of 1 for instruction: %17 = call <vscale x 2 x float> @llvm.vp.fptrunc.nxv2f32.nxv2f64(<vscale x 2 x double> undef, <vscale x 2 x i1> undef, i32 undef)
; RV64-NEXT:  Cost Model: Found an estimated cost of 2 for instruction: %18 = call <vscale x 4 x float> @llvm.vp.fptrunc.nxv4f32.nxv4f64(<vscale x 4 x double> undef, <vscale x 4 x i1> undef, i32 undef)
; RV64-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: %19 = call <vscale x 8 x float> @llvm.vp.fptrunc.nxv8f32.nxv8f64(<vscale x 8 x double> undef, <vscale x 8 x i1> undef, i32 undef)
; RV64-NEXT:  Cost Model: Found an estimated cost of 0 for instruction: ret void
;
; RV64_TYPEBASED-LABEL: 'fp_truncate'
; RV64_TYPEBASED-NEXT:  Cost Model: Found an estimated cost of 1 for instruction: %1 = fptrunc double undef to float
; RV64_TYPEBASED-NEXT:  Cost Model: Found an estimated cost of 1 for instruction: %2 = fptrunc <1 x double> undef to <1 x float>
; RV64_TYPEBASED-NEXT:  Cost Model: Found an estimated cost of 1 for instruction: %3 = fptrunc <2 x double> undef to <2 x float>
; RV64_TYPEBASED-NEXT:  Cost Model: Found an estimated cost of 1 for instruction: %4 = fptrunc <4 x double> undef to <4 x float>
; RV64_TYPEBASED-NEXT:  Cost Model: Found an estimated cost of 2 for instruction: %5 = fptrunc <8 x double> undef to <8 x float>
; RV64_TYPEBASED-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: %6 = fptrunc <16 x double> undef to <16 x float>
; RV64_TYPEBASED-NEXT:  Cost Model: Found an estimated cost of 1 for instruction: %7 = fptrunc <vscale x 1 x double> undef to <vscale x 1 x float>
; RV64_TYPEBASED-NEXT:  Cost Model: Found an estimated cost of 1 for instruction: %8 = fptrunc <vscale x 2 x double> undef to <vscale x 2 x float>
; RV64_TYPEBASED-NEXT:  Cost Model: Found an estimated cost of 2 for instruction: %9 = fptrunc <vscale x 4 x double> undef to <vscale x 4 x float>
; RV64_TYPEBASED-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: %10 = fptrunc <vscale x 8 x double> undef to <vscale x 8 x float>
; RV64_TYPEBASED-NEXT:  Cost Model: Found an estimated cost of 1 for instruction: %11 = call <1 x float> @llvm.vp.fptrunc.v1f32.v1f64(<1 x double> undef, <1 x i1> undef, i32 undef)
; RV64_TYPEBASED-NEXT:  Cost Model: Found an estimated cost of 1 for instruction: %12 = call <2 x float> @llvm.vp.fptrunc.v2f32.v2f64(<2 x double> undef, <2 x i1> undef, i32 undef)
; RV64_TYPEBASED-NEXT:  Cost Model: Found an estimated cost of 1 for instruction: %13 = call <4 x float> @llvm.vp.fptrunc.v4f32.v4f64(<4 x double> undef, <4 x i1> undef, i32 undef)
; RV64_TYPEBASED-NEXT:  Cost Model: Found an estimated cost of 2 for instruction: %14 = call <8 x float> @llvm.vp.fptrunc.v8f32.v8f64(<8 x double> undef, <8 x i1> undef, i32 undef)
; RV64_TYPEBASED-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: %15 = call <16 x float> @llvm.vp.fptrunc.v16f32.v16f64(<16 x double> undef, <16 x i1> undef, i32 undef)
; RV64_TYPEBASED-NEXT:  Cost Model: Found an estimated cost of 1 for instruction: %16 = call <vscale x 1 x float> @llvm.vp.fptrunc.nxv1f32.nxv1f64(<vscale x 1 x double> undef, <vscale x 1 x i1> undef, i32 undef)
; RV64_TYPEBASED-NEXT:  Cost Model: Found an estimated cost of 1 for instruction: %17 = call <vscale x 2 x float> @llvm.vp.fptrunc.nxv2f32.nxv2f64(<vscale x 2 x double> undef, <vscale x 2 x i1> undef, i32 undef)
; RV64_TYPEBASED-NEXT:  Cost Model: Found an estimated cost of 2 for instruction: %18 = call <vscale x 4 x float> @llvm.vp.fptrunc.nxv4f32.nxv4f64(<vscale x 4 x double> undef, <vscale x 4 x i1> undef, i32 undef)
; RV64_TYPEBASED-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: %19 = call <vscale x 8 x float> @llvm.vp.fptrunc.nxv8f32.nxv8f64(<vscale x 8 x double> undef, <vscale x 8 x i1> undef, i32 undef)
; RV64_TYPEBASED-NEXT:  Cost Model: Found an estimated cost of 0 for instruction: ret void
;
  fptrunc double undef to float
  fptrunc <1 x double> undef to <1 x float>
  fptrunc <2 x double> undef to <2 x float>
  fptrunc <4 x double> undef to <4 x float>
  fptrunc <8 x double> undef to <8 x float>
  fptrunc <16 x double> undef to <16 x float>
  fptrunc <vscale x 1 x double> undef to <vscale x 1 x float>
  fptrunc <vscale x 2 x double> undef to <vscale x 2 x float>
  fptrunc <vscale x 4 x double> undef to <vscale x 4 x float>
  fptrunc <vscale x 8 x double> undef to <vscale x 8 x float>
  call <1 x float> @llvm.vp.fptrunc.v1double.v1float(<1 x double> undef, <1 x i1> undef, i32 undef)
  call <2 x float> @llvm.vp.fptrunc.v2double.v2float(<2 x double> undef, <2 x i1> undef, i32 undef)
  call <4 x float> @llvm.vp.fptrunc.v4double.v4float(<4 x double> undef, <4 x i1> undef, i32 undef)
  call <8 x float> @llvm.vp.fptrunc.v8double.v8float(<8 x double> undef, <8 x i1> undef, i32 undef)
  call <16 x float> @llvm.vp.fptrunc.v16.v16(<16 x double> undef, <16 x i1> undef, i32 undef)
  call <vscale x 1 x float> @llvm.vp.fptrunc.nxv1double.nxv1float(<vscale x 1 x double> undef, <vscale x 1 x i1> undef, i32 undef)
  call <vscale x 2 x float> @llvm.vp.fptrunc.nxv2double.nxv2float(<vscale x 2 x double> undef, <vscale x 2 x i1> undef, i32 undef)
  call <vscale x 4 x float> @llvm.vp.fptrunc.nxv4double.nxv4float(<vscale x 4 x double> undef, <vscale x 4 x i1> undef, i32 undef)
  call <vscale x 8 x float> @llvm.vp.fptrunc.nxv8double.nxv8float(<vscale x 8 x double> undef, <vscale x 8 x i1> undef, i32 undef)
  ret void
}

define void @fpext() {
; RV32-LABEL: 'fpext'
; RV32-NEXT:  Cost Model: Found an estimated cost of 1 for instruction: %1 = fpext float undef to double
; RV32-NEXT:  Cost Model: Found an estimated cost of 1 for instruction: %2 = fpext <1 x float> undef to <1 x double>
; RV32-NEXT:  Cost Model: Found an estimated cost of 1 for instruction: %3 = fpext <2 x float> undef to <2 x double>
; RV32-NEXT:  Cost Model: Found an estimated cost of 2 for instruction: %4 = fpext <4 x float> undef to <4 x double>
; RV32-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: %5 = fpext <8 x float> undef to <8 x double>
; RV32-NEXT:  Cost Model: Found an estimated cost of 8 for instruction: %6 = fpext <16 x float> undef to <16 x double>
; RV32-NEXT:  Cost Model: Found an estimated cost of 1 for instruction: %7 = fpext <vscale x 1 x float> undef to <vscale x 1 x double>
; RV32-NEXT:  Cost Model: Found an estimated cost of 2 for instruction: %8 = fpext <vscale x 2 x float> undef to <vscale x 2 x double>
; RV32-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: %9 = fpext <vscale x 4 x float> undef to <vscale x 4 x double>
; RV32-NEXT:  Cost Model: Found an estimated cost of 8 for instruction: %10 = fpext <vscale x 8 x float> undef to <vscale x 8 x double>
; RV32-NEXT:  Cost Model: Found an estimated cost of 1 for instruction: %11 = call <1 x double> @llvm.vp.fpext.v1f64.v1f32(<1 x float> undef, <1 x i1> undef, i32 undef)
; RV32-NEXT:  Cost Model: Found an estimated cost of 1 for instruction: %12 = call <2 x double> @llvm.vp.fpext.v2f64.v2f32(<2 x float> undef, <2 x i1> undef, i32 undef)
; RV32-NEXT:  Cost Model: Found an estimated cost of 2 for instruction: %13 = call <4 x double> @llvm.vp.fpext.v4f64.v4f32(<4 x float> undef, <4 x i1> undef, i32 undef)
; RV32-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: %14 = call <8 x double> @llvm.vp.fpext.v8f64.v8f32(<8 x float> undef, <8 x i1> undef, i32 undef)
; RV32-NEXT:  Cost Model: Found an estimated cost of 8 for instruction: %15 = call <16 x double> @llvm.vp.fpext.v16f64.v16f32(<16 x float> undef, <16 x i1> undef, i32 undef)
; RV32-NEXT:  Cost Model: Found an estimated cost of 1 for instruction: %16 = call <vscale x 1 x double> @llvm.vp.fpext.nxv1f64.nxv1f32(<vscale x 1 x float> undef, <vscale x 1 x i1> undef, i32 undef)
; RV32-NEXT:  Cost Model: Found an estimated cost of 2 for instruction: %17 = call <vscale x 2 x double> @llvm.vp.fpext.nxv2f64.nxv2f32(<vscale x 2 x float> undef, <vscale x 2 x i1> undef, i32 undef)
; RV32-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: %18 = call <vscale x 4 x double> @llvm.vp.fpext.nxv4f64.nxv4f32(<vscale x 4 x float> undef, <vscale x 4 x i1> undef, i32 undef)
; RV32-NEXT:  Cost Model: Found an estimated cost of 8 for instruction: %19 = call <vscale x 8 x double> @llvm.vp.fpext.nxv8f64.nxv8f32(<vscale x 8 x float> undef, <vscale x 8 x i1> undef, i32 undef)
; RV32-NEXT:  Cost Model: Found an estimated cost of 0 for instruction: ret void
;
; RV32_TYPEBASED-LABEL: 'fpext'
; RV32_TYPEBASED-NEXT:  Cost Model: Found an estimated cost of 1 for instruction: %1 = fpext float undef to double
; RV32_TYPEBASED-NEXT:  Cost Model: Found an estimated cost of 1 for instruction: %2 = fpext <1 x float> undef to <1 x double>
; RV32_TYPEBASED-NEXT:  Cost Model: Found an estimated cost of 1 for instruction: %3 = fpext <2 x float> undef to <2 x double>
; RV32_TYPEBASED-NEXT:  Cost Model: Found an estimated cost of 2 for instruction: %4 = fpext <4 x float> undef to <4 x double>
; RV32_TYPEBASED-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: %5 = fpext <8 x float> undef to <8 x double>
; RV32_TYPEBASED-NEXT:  Cost Model: Found an estimated cost of 8 for instruction: %6 = fpext <16 x float> undef to <16 x double>
; RV32_TYPEBASED-NEXT:  Cost Model: Found an estimated cost of 1 for instruction: %7 = fpext <vscale x 1 x float> undef to <vscale x 1 x double>
; RV32_TYPEBASED-NEXT:  Cost Model: Found an estimated cost of 2 for instruction: %8 = fpext <vscale x 2 x float> undef to <vscale x 2 x double>
; RV32_TYPEBASED-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: %9 = fpext <vscale x 4 x float> undef to <vscale x 4 x double>
; RV32_TYPEBASED-NEXT:  Cost Model: Found an estimated cost of 8 for instruction: %10 = fpext <vscale x 8 x float> undef to <vscale x 8 x double>
; RV32_TYPEBASED-NEXT:  Cost Model: Found an estimated cost of 1 for instruction: %11 = call <1 x double> @llvm.vp.fpext.v1f64.v1f32(<1 x float> undef, <1 x i1> undef, i32 undef)
; RV32_TYPEBASED-NEXT:  Cost Model: Found an estimated cost of 1 for instruction: %12 = call <2 x double> @llvm.vp.fpext.v2f64.v2f32(<2 x float> undef, <2 x i1> undef, i32 undef)
; RV32_TYPEBASED-NEXT:  Cost Model: Found an estimated cost of 2 for instruction: %13 = call <4 x double> @llvm.vp.fpext.v4f64.v4f32(<4 x float> undef, <4 x i1> undef, i32 undef)
; RV32_TYPEBASED-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: %14 = call <8 x double> @llvm.vp.fpext.v8f64.v8f32(<8 x float> undef, <8 x i1> undef, i32 undef)
; RV32_TYPEBASED-NEXT:  Cost Model: Found an estimated cost of 8 for instruction: %15 = call <16 x double> @llvm.vp.fpext.v16f64.v16f32(<16 x float> undef, <16 x i1> undef, i32 undef)
; RV32_TYPEBASED-NEXT:  Cost Model: Found an estimated cost of 1 for instruction: %16 = call <vscale x 1 x double> @llvm.vp.fpext.nxv1f64.nxv1f32(<vscale x 1 x float> undef, <vscale x 1 x i1> undef, i32 undef)
; RV32_TYPEBASED-NEXT:  Cost Model: Found an estimated cost of 2 for instruction: %17 = call <vscale x 2 x double> @llvm.vp.fpext.nxv2f64.nxv2f32(<vscale x 2 x float> undef, <vscale x 2 x i1> undef, i32 undef)
; RV32_TYPEBASED-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: %18 = call <vscale x 4 x double> @llvm.vp.fpext.nxv4f64.nxv4f32(<vscale x 4 x float> undef, <vscale x 4 x i1> undef, i32 undef)
; RV32_TYPEBASED-NEXT:  Cost Model: Found an estimated cost of 8 for instruction: %19 = call <vscale x 8 x double> @llvm.vp.fpext.nxv8f64.nxv8f32(<vscale x 8 x float> undef, <vscale x 8 x i1> undef, i32 undef)
; RV32_TYPEBASED-NEXT:  Cost Model: Found an estimated cost of 0 for instruction: ret void
;
; RV64-LABEL: 'fpext'
; RV64-NEXT:  Cost Model: Found an estimated cost of 1 for instruction: %1 = fpext float undef to double
; RV64-NEXT:  Cost Model: Found an estimated cost of 1 for instruction: %2 = fpext <1 x float> undef to <1 x double>
; RV64-NEXT:  Cost Model: Found an estimated cost of 1 for instruction: %3 = fpext <2 x float> undef to <2 x double>
; RV64-NEXT:  Cost Model: Found an estimated cost of 2 for instruction: %4 = fpext <4 x float> undef to <4 x double>
; RV64-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: %5 = fpext <8 x float> undef to <8 x double>
; RV64-NEXT:  Cost Model: Found an estimated cost of 8 for instruction: %6 = fpext <16 x float> undef to <16 x double>
; RV64-NEXT:  Cost Model: Found an estimated cost of 1 for instruction: %7 = fpext <vscale x 1 x float> undef to <vscale x 1 x double>
; RV64-NEXT:  Cost Model: Found an estimated cost of 2 for instruction: %8 = fpext <vscale x 2 x float> undef to <vscale x 2 x double>
; RV64-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: %9 = fpext <vscale x 4 x float> undef to <vscale x 4 x double>
; RV64-NEXT:  Cost Model: Found an estimated cost of 8 for instruction: %10 = fpext <vscale x 8 x float> undef to <vscale x 8 x double>
; RV64-NEXT:  Cost Model: Found an estimated cost of 1 for instruction: %11 = call <1 x double> @llvm.vp.fpext.v1f64.v1f32(<1 x float> undef, <1 x i1> undef, i32 undef)
; RV64-NEXT:  Cost Model: Found an estimated cost of 1 for instruction: %12 = call <2 x double> @llvm.vp.fpext.v2f64.v2f32(<2 x float> undef, <2 x i1> undef, i32 undef)
; RV64-NEXT:  Cost Model: Found an estimated cost of 2 for instruction: %13 = call <4 x double> @llvm.vp.fpext.v4f64.v4f32(<4 x float> undef, <4 x i1> undef, i32 undef)
; RV64-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: %14 = call <8 x double> @llvm.vp.fpext.v8f64.v8f32(<8 x float> undef, <8 x i1> undef, i32 undef)
; RV64-NEXT:  Cost Model: Found an estimated cost of 8 for instruction: %15 = call <16 x double> @llvm.vp.fpext.v16f64.v16f32(<16 x float> undef, <16 x i1> undef, i32 undef)
; RV64-NEXT:  Cost Model: Found an estimated cost of 1 for instruction: %16 = call <vscale x 1 x double> @llvm.vp.fpext.nxv1f64.nxv1f32(<vscale x 1 x float> undef, <vscale x 1 x i1> undef, i32 undef)
; RV64-NEXT:  Cost Model: Found an estimated cost of 2 for instruction: %17 = call <vscale x 2 x double> @llvm.vp.fpext.nxv2f64.nxv2f32(<vscale x 2 x float> undef, <vscale x 2 x i1> undef, i32 undef)
; RV64-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: %18 = call <vscale x 4 x double> @llvm.vp.fpext.nxv4f64.nxv4f32(<vscale x 4 x float> undef, <vscale x 4 x i1> undef, i32 undef)
; RV64-NEXT:  Cost Model: Found an estimated cost of 8 for instruction: %19 = call <vscale x 8 x double> @llvm.vp.fpext.nxv8f64.nxv8f32(<vscale x 8 x float> undef, <vscale x 8 x i1> undef, i32 undef)
; RV64-NEXT:  Cost Model: Found an estimated cost of 0 for instruction: ret void
;
; RV64_TYPEBASED-LABEL: 'fpext'
; RV64_TYPEBASED-NEXT:  Cost Model: Found an estimated cost of 1 for instruction: %1 = fpext float undef to double
; RV64_TYPEBASED-NEXT:  Cost Model: Found an estimated cost of 1 for instruction: %2 = fpext <1 x float> undef to <1 x double>
; RV64_TYPEBASED-NEXT:  Cost Model: Found an estimated cost of 1 for instruction: %3 = fpext <2 x float> undef to <2 x double>
; RV64_TYPEBASED-NEXT:  Cost Model: Found an estimated cost of 2 for instruction: %4 = fpext <4 x float> undef to <4 x double>
; RV64_TYPEBASED-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: %5 = fpext <8 x float> undef to <8 x double>
; RV64_TYPEBASED-NEXT:  Cost Model: Found an estimated cost of 8 for instruction: %6 = fpext <16 x float> undef to <16 x double>
; RV64_TYPEBASED-NEXT:  Cost Model: Found an estimated cost of 1 for instruction: %7 = fpext <vscale x 1 x float> undef to <vscale x 1 x double>
; RV64_TYPEBASED-NEXT:  Cost Model: Found an estimated cost of 2 for instruction: %8 = fpext <vscale x 2 x float> undef to <vscale x 2 x double>
; RV64_TYPEBASED-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: %9 = fpext <vscale x 4 x float> undef to <vscale x 4 x double>
; RV64_TYPEBASED-NEXT:  Cost Model: Found an estimated cost of 8 for instruction: %10 = fpext <vscale x 8 x float> undef to <vscale x 8 x double>
; RV64_TYPEBASED-NEXT:  Cost Model: Found an estimated cost of 1 for instruction: %11 = call <1 x double> @llvm.vp.fpext.v1f64.v1f32(<1 x float> undef, <1 x i1> undef, i32 undef)
; RV64_TYPEBASED-NEXT:  Cost Model: Found an estimated cost of 1 for instruction: %12 = call <2 x double> @llvm.vp.fpext.v2f64.v2f32(<2 x float> undef, <2 x i1> undef, i32 undef)
; RV64_TYPEBASED-NEXT:  Cost Model: Found an estimated cost of 2 for instruction: %13 = call <4 x double> @llvm.vp.fpext.v4f64.v4f32(<4 x float> undef, <4 x i1> undef, i32 undef)
; RV64_TYPEBASED-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: %14 = call <8 x double> @llvm.vp.fpext.v8f64.v8f32(<8 x float> undef, <8 x i1> undef, i32 undef)
; RV64_TYPEBASED-NEXT:  Cost Model: Found an estimated cost of 8 for instruction: %15 = call <16 x double> @llvm.vp.fpext.v16f64.v16f32(<16 x float> undef, <16 x i1> undef, i32 undef)
; RV64_TYPEBASED-NEXT:  Cost Model: Found an estimated cost of 1 for instruction: %16 = call <vscale x 1 x double> @llvm.vp.fpext.nxv1f64.nxv1f32(<vscale x 1 x float> undef, <vscale x 1 x i1> undef, i32 undef)
; RV64_TYPEBASED-NEXT:  Cost Model: Found an estimated cost of 2 for instruction: %17 = call <vscale x 2 x double> @llvm.vp.fpext.nxv2f64.nxv2f32(<vscale x 2 x float> undef, <vscale x 2 x i1> undef, i32 undef)
; RV64_TYPEBASED-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: %18 = call <vscale x 4 x double> @llvm.vp.fpext.nxv4f64.nxv4f32(<vscale x 4 x float> undef, <vscale x 4 x i1> undef, i32 undef)
; RV64_TYPEBASED-NEXT:  Cost Model: Found an estimated cost of 8 for instruction: %19 = call <vscale x 8 x double> @llvm.vp.fpext.nxv8f64.nxv8f32(<vscale x 8 x float> undef, <vscale x 8 x i1> undef, i32 undef)
; RV64_TYPEBASED-NEXT:  Cost Model: Found an estimated cost of 0 for instruction: ret void
;
  fpext float undef to double
  fpext <1 x float> undef to <1 x double>
  fpext <2 x float> undef to <2 x double>
  fpext <4 x float> undef to <4 x double>
  fpext <8 x float> undef to <8 x double>
  fpext <16 x float> undef to <16 x double>
  fpext <vscale x 1 x float> undef to <vscale x 1 x double>
  fpext <vscale x 2 x float> undef to <vscale x 2 x double>
  fpext <vscale x 4 x float> undef to <vscale x 4 x double>
  fpext <vscale x 8 x float> undef to <vscale x 8 x double>
  call <1 x double> @llvm.vp.fpext.v1float.v1double(<1 x float> undef, <1 x i1> undef, i32 undef)
  call <2 x double> @llvm.vp.fpext.v2float.v2double(<2 x float> undef, <2 x i1> undef, i32 undef)
  call <4 x double> @llvm.vp.fpext.v4float.v4double(<4 x float> undef, <4 x i1> undef, i32 undef)
  call <8 x double> @llvm.vp.fpext.v8float.v8double(<8 x float> undef, <8 x i1> undef, i32 undef)
  call <16 x double> @llvm.vp.fpext.v16.v16(<16 x float> undef, <16 x i1> undef, i32 undef)
  call <vscale x 1 x double> @llvm.vp.fpext.nxv1float.nxv1double(<vscale x 1 x float> undef, <vscale x 1 x i1> undef, i32 undef)
  call <vscale x 2 x double> @llvm.vp.fpext.nxv2float.nxv2double(<vscale x 2 x float> undef, <vscale x 2 x i1> undef, i32 undef)
  call <vscale x 4 x double> @llvm.vp.fpext.nxv4float.nxv4double(<vscale x 4 x float> undef, <vscale x 4 x i1> undef, i32 undef)
  call <vscale x 8 x double> @llvm.vp.fpext.nxv8float.nxv8double(<vscale x 8 x float> undef, <vscale x 8 x i1> undef, i32 undef)
  ret void
}

define void @fptoui() {
; RV32-LABEL: 'fptoui'
; RV32-NEXT:  Cost Model: Found an estimated cost of 1 for instruction: %1 = fptoui float undef to i32
; RV32-NEXT:  Cost Model: Found an estimated cost of 1 for instruction: %2 = fptoui <1 x float> undef to <1 x i32>
; RV32-NEXT:  Cost Model: Found an estimated cost of 1 for instruction: %3 = fptoui <2 x float> undef to <2 x i32>
; RV32-NEXT:  Cost Model: Found an estimated cost of 1 for instruction: %4 = fptoui <4 x float> undef to <4 x i32>
; RV32-NEXT:  Cost Model: Found an estimated cost of 1 for instruction: %5 = fptoui <8 x float> undef to <8 x i32>
; RV32-NEXT:  Cost Model: Found an estimated cost of 1 for instruction: %6 = fptoui <16 x float> undef to <16 x i32>
; RV32-NEXT:  Cost Model: Found an estimated cost of 1 for instruction: %7 = fptoui <vscale x 1 x float> undef to <vscale x 1 x i32>
; RV32-NEXT:  Cost Model: Found an estimated cost of 1 for instruction: %8 = fptoui <vscale x 2 x float> undef to <vscale x 2 x i32>
; RV32-NEXT:  Cost Model: Found an estimated cost of 1 for instruction: %9 = fptoui <vscale x 4 x float> undef to <vscale x 4 x i32>
; RV32-NEXT:  Cost Model: Found an estimated cost of 1 for instruction: %10 = fptoui <vscale x 8 x float> undef to <vscale x 8 x i32>
; RV32-NEXT:  Cost Model: Found an estimated cost of 1 for instruction: %11 = call <1 x i32> @llvm.vp.fptoui.v1i32.v1f32(<1 x float> undef, <1 x i1> undef, i32 undef)
; RV32-NEXT:  Cost Model: Found an estimated cost of 1 for instruction: %12 = call <2 x i32> @llvm.vp.fptoui.v2i32.v2f32(<2 x float> undef, <2 x i1> undef, i32 undef)
; RV32-NEXT:  Cost Model: Found an estimated cost of 1 for instruction: %13 = call <4 x i32> @llvm.vp.fptoui.v4i32.v4f32(<4 x float> undef, <4 x i1> undef, i32 undef)
; RV32-NEXT:  Cost Model: Found an estimated cost of 1 for instruction: %14 = call <8 x i32> @llvm.vp.fptoui.v8i32.v8f32(<8 x float> undef, <8 x i1> undef, i32 undef)
; RV32-NEXT:  Cost Model: Found an estimated cost of 1 for instruction: %15 = call <16 x i32> @llvm.vp.fptoui.v16i32.v16f32(<16 x float> undef, <16 x i1> undef, i32 undef)
; RV32-NEXT:  Cost Model: Found an estimated cost of 1 for instruction: %16 = call <vscale x 1 x i32> @llvm.vp.fptoui.nxv1i32.nxv1f32(<vscale x 1 x float> undef, <vscale x 1 x i1> undef, i32 undef)
; RV32-NEXT:  Cost Model: Found an estimated cost of 1 for instruction: %17 = call <vscale x 2 x i32> @llvm.vp.fptoui.nxv2i32.nxv2f32(<vscale x 2 x float> undef, <vscale x 2 x i1> undef, i32 undef)
; RV32-NEXT:  Cost Model: Found an estimated cost of 1 for instruction: %18 = call <vscale x 4 x i32> @llvm.vp.fptoui.nxv4i32.nxv4f32(<vscale x 4 x float> undef, <vscale x 4 x i1> undef, i32 undef)
; RV32-NEXT:  Cost Model: Found an estimated cost of 1 for instruction: %19 = call <vscale x 8 x i32> @llvm.vp.fptoui.nxv8i32.nxv8f32(<vscale x 8 x float> undef, <vscale x 8 x i1> undef, i32 undef)
; RV32-NEXT:  Cost Model: Found an estimated cost of 0 for instruction: ret void
;
; RV32_TYPEBASED-LABEL: 'fptoui'
; RV32_TYPEBASED-NEXT:  Cost Model: Found an estimated cost of 1 for instruction: %1 = fptoui float undef to i32
; RV32_TYPEBASED-NEXT:  Cost Model: Found an estimated cost of 1 for instruction: %2 = fptoui <1 x float> undef to <1 x i32>
; RV32_TYPEBASED-NEXT:  Cost Model: Found an estimated cost of 1 for instruction: %3 = fptoui <2 x float> undef to <2 x i32>
; RV32_TYPEBASED-NEXT:  Cost Model: Found an estimated cost of 1 for instruction: %4 = fptoui <4 x float> undef to <4 x i32>
; RV32_TYPEBASED-NEXT:  Cost Model: Found an estimated cost of 1 for instruction: %5 = fptoui <8 x float> undef to <8 x i32>
; RV32_TYPEBASED-NEXT:  Cost Model: Found an estimated cost of 1 for instruction: %6 = fptoui <16 x float> undef to <16 x i32>
; RV32_TYPEBASED-NEXT:  Cost Model: Found an estimated cost of 1 for instruction: %7 = fptoui <vscale x 1 x float> undef to <vscale x 1 x i32>
; RV32_TYPEBASED-NEXT:  Cost Model: Found an estimated cost of 1 for instruction: %8 = fptoui <vscale x 2 x float> undef to <vscale x 2 x i32>
; RV32_TYPEBASED-NEXT:  Cost Model: Found an estimated cost of 1 for instruction: %9 = fptoui <vscale x 4 x float> undef to <vscale x 4 x i32>
; RV32_TYPEBASED-NEXT:  Cost Model: Found an estimated cost of 1 for instruction: %10 = fptoui <vscale x 8 x float> undef to <vscale x 8 x i32>
; RV32_TYPEBASED-NEXT:  Cost Model: Found an estimated cost of 1 for instruction: %11 = call <1 x i32> @llvm.vp.fptoui.v1i32.v1f32(<1 x float> undef, <1 x i1> undef, i32 undef)
; RV32_TYPEBASED-NEXT:  Cost Model: Found an estimated cost of 1 for instruction: %12 = call <2 x i32> @llvm.vp.fptoui.v2i32.v2f32(<2 x float> undef, <2 x i1> undef, i32 undef)
; RV32_TYPEBASED-NEXT:  Cost Model: Found an estimated cost of 1 for instruction: %13 = call <4 x i32> @llvm.vp.fptoui.v4i32.v4f32(<4 x float> undef, <4 x i1> undef, i32 undef)
; RV32_TYPEBASED-NEXT:  Cost Model: Found an estimated cost of 1 for instruction: %14 = call <8 x i32> @llvm.vp.fptoui.v8i32.v8f32(<8 x float> undef, <8 x i1> undef, i32 undef)
; RV32_TYPEBASED-NEXT:  Cost Model: Found an estimated cost of 1 for instruction: %15 = call <16 x i32> @llvm.vp.fptoui.v16i32.v16f32(<16 x float> undef, <16 x i1> undef, i32 undef)
; RV32_TYPEBASED-NEXT:  Cost Model: Found an estimated cost of 1 for instruction: %16 = call <vscale x 1 x i32> @llvm.vp.fptoui.nxv1i32.nxv1f32(<vscale x 1 x float> undef, <vscale x 1 x i1> undef, i32 undef)
; RV32_TYPEBASED-NEXT:  Cost Model: Found an estimated cost of 1 for instruction: %17 = call <vscale x 2 x i32> @llvm.vp.fptoui.nxv2i32.nxv2f32(<vscale x 2 x float> undef, <vscale x 2 x i1> undef, i32 undef)
; RV32_TYPEBASED-NEXT:  Cost Model: Found an estimated cost of 1 for instruction: %18 = call <vscale x 4 x i32> @llvm.vp.fptoui.nxv4i32.nxv4f32(<vscale x 4 x float> undef, <vscale x 4 x i1> undef, i32 undef)
; RV32_TYPEBASED-NEXT:  Cost Model: Found an estimated cost of 1 for instruction: %19 = call <vscale x 8 x i32> @llvm.vp.fptoui.nxv8i32.nxv8f32(<vscale x 8 x float> undef, <vscale x 8 x i1> undef, i32 undef)
; RV32_TYPEBASED-NEXT:  Cost Model: Found an estimated cost of 0 for instruction: ret void
;
; RV64-LABEL: 'fptoui'
; RV64-NEXT:  Cost Model: Found an estimated cost of 1 for instruction: %1 = fptoui float undef to i32
; RV64-NEXT:  Cost Model: Found an estimated cost of 1 for instruction: %2 = fptoui <1 x float> undef to <1 x i32>
; RV64-NEXT:  Cost Model: Found an estimated cost of 1 for instruction: %3 = fptoui <2 x float> undef to <2 x i32>
; RV64-NEXT:  Cost Model: Found an estimated cost of 1 for instruction: %4 = fptoui <4 x float> undef to <4 x i32>
; RV64-NEXT:  Cost Model: Found an estimated cost of 1 for instruction: %5 = fptoui <8 x float> undef to <8 x i32>
; RV64-NEXT:  Cost Model: Found an estimated cost of 1 for instruction: %6 = fptoui <16 x float> undef to <16 x i32>
; RV64-NEXT:  Cost Model: Found an estimated cost of 1 for instruction: %7 = fptoui <vscale x 1 x float> undef to <vscale x 1 x i32>
; RV64-NEXT:  Cost Model: Found an estimated cost of 1 for instruction: %8 = fptoui <vscale x 2 x float> undef to <vscale x 2 x i32>
; RV64-NEXT:  Cost Model: Found an estimated cost of 1 for instruction: %9 = fptoui <vscale x 4 x float> undef to <vscale x 4 x i32>
; RV64-NEXT:  Cost Model: Found an estimated cost of 1 for instruction: %10 = fptoui <vscale x 8 x float> undef to <vscale x 8 x i32>
; RV64-NEXT:  Cost Model: Found an estimated cost of 1 for instruction: %11 = call <1 x i32> @llvm.vp.fptoui.v1i32.v1f32(<1 x float> undef, <1 x i1> undef, i32 undef)
; RV64-NEXT:  Cost Model: Found an estimated cost of 1 for instruction: %12 = call <2 x i32> @llvm.vp.fptoui.v2i32.v2f32(<2 x float> undef, <2 x i1> undef, i32 undef)
; RV64-NEXT:  Cost Model: Found an estimated cost of 1 for instruction: %13 = call <4 x i32> @llvm.vp.fptoui.v4i32.v4f32(<4 x float> undef, <4 x i1> undef, i32 undef)
; RV64-NEXT:  Cost Model: Found an estimated cost of 1 for instruction: %14 = call <8 x i32> @llvm.vp.fptoui.v8i32.v8f32(<8 x float> undef, <8 x i1> undef, i32 undef)
; RV64-NEXT:  Cost Model: Found an estimated cost of 1 for instruction: %15 = call <16 x i32> @llvm.vp.fptoui.v16i32.v16f32(<16 x float> undef, <16 x i1> undef, i32 undef)
; RV64-NEXT:  Cost Model: Found an estimated cost of 1 for instruction: %16 = call <vscale x 1 x i32> @llvm.vp.fptoui.nxv1i32.nxv1f32(<vscale x 1 x float> undef, <vscale x 1 x i1> undef, i32 undef)
; RV64-NEXT:  Cost Model: Found an estimated cost of 1 for instruction: %17 = call <vscale x 2 x i32> @llvm.vp.fptoui.nxv2i32.nxv2f32(<vscale x 2 x float> undef, <vscale x 2 x i1> undef, i32 undef)
; RV64-NEXT:  Cost Model: Found an estimated cost of 1 for instruction: %18 = call <vscale x 4 x i32> @llvm.vp.fptoui.nxv4i32.nxv4f32(<vscale x 4 x float> undef, <vscale x 4 x i1> undef, i32 undef)
; RV64-NEXT:  Cost Model: Found an estimated cost of 1 for instruction: %19 = call <vscale x 8 x i32> @llvm.vp.fptoui.nxv8i32.nxv8f32(<vscale x 8 x float> undef, <vscale x 8 x i1> undef, i32 undef)
; RV64-NEXT:  Cost Model: Found an estimated cost of 0 for instruction: ret void
;
; RV64_TYPEBASED-LABEL: 'fptoui'
; RV64_TYPEBASED-NEXT:  Cost Model: Found an estimated cost of 1 for instruction: %1 = fptoui float undef to i32
; RV64_TYPEBASED-NEXT:  Cost Model: Found an estimated cost of 1 for instruction: %2 = fptoui <1 x float> undef to <1 x i32>
; RV64_TYPEBASED-NEXT:  Cost Model: Found an estimated cost of 1 for instruction: %3 = fptoui <2 x float> undef to <2 x i32>
; RV64_TYPEBASED-NEXT:  Cost Model: Found an estimated cost of 1 for instruction: %4 = fptoui <4 x float> undef to <4 x i32>
; RV64_TYPEBASED-NEXT:  Cost Model: Found an estimated cost of 1 for instruction: %5 = fptoui <8 x float> undef to <8 x i32>
; RV64_TYPEBASED-NEXT:  Cost Model: Found an estimated cost of 1 for instruction: %6 = fptoui <16 x float> undef to <16 x i32>
; RV64_TYPEBASED-NEXT:  Cost Model: Found an estimated cost of 1 for instruction: %7 = fptoui <vscale x 1 x float> undef to <vscale x 1 x i32>
; RV64_TYPEBASED-NEXT:  Cost Model: Found an estimated cost of 1 for instruction: %8 = fptoui <vscale x 2 x float> undef to <vscale x 2 x i32>
; RV64_TYPEBASED-NEXT:  Cost Model: Found an estimated cost of 1 for instruction: %9 = fptoui <vscale x 4 x float> undef to <vscale x 4 x i32>
; RV64_TYPEBASED-NEXT:  Cost Model: Found an estimated cost of 1 for instruction: %10 = fptoui <vscale x 8 x float> undef to <vscale x 8 x i32>
; RV64_TYPEBASED-NEXT:  Cost Model: Found an estimated cost of 1 for instruction: %11 = call <1 x i32> @llvm.vp.fptoui.v1i32.v1f32(<1 x float> undef, <1 x i1> undef, i32 undef)
; RV64_TYPEBASED-NEXT:  Cost Model: Found an estimated cost of 1 for instruction: %12 = call <2 x i32> @llvm.vp.fptoui.v2i32.v2f32(<2 x float> undef, <2 x i1> undef, i32 undef)
; RV64_TYPEBASED-NEXT:  Cost Model: Found an estimated cost of 1 for instruction: %13 = call <4 x i32> @llvm.vp.fptoui.v4i32.v4f32(<4 x float> undef, <4 x i1> undef, i32 undef)
; RV64_TYPEBASED-NEXT:  Cost Model: Found an estimated cost of 1 for instruction: %14 = call <8 x i32> @llvm.vp.fptoui.v8i32.v8f32(<8 x float> undef, <8 x i1> undef, i32 undef)
; RV64_TYPEBASED-NEXT:  Cost Model: Found an estimated cost of 1 for instruction: %15 = call <16 x i32> @llvm.vp.fptoui.v16i32.v16f32(<16 x float> undef, <16 x i1> undef, i32 undef)
; RV64_TYPEBASED-NEXT:  Cost Model: Found an estimated cost of 1 for instruction: %16 = call <vscale x 1 x i32> @llvm.vp.fptoui.nxv1i32.nxv1f32(<vscale x 1 x float> undef, <vscale x 1 x i1> undef, i32 undef)
; RV64_TYPEBASED-NEXT:  Cost Model: Found an estimated cost of 1 for instruction: %17 = call <vscale x 2 x i32> @llvm.vp.fptoui.nxv2i32.nxv2f32(<vscale x 2 x float> undef, <vscale x 2 x i1> undef, i32 undef)
; RV64_TYPEBASED-NEXT:  Cost Model: Found an estimated cost of 1 for instruction: %18 = call <vscale x 4 x i32> @llvm.vp.fptoui.nxv4i32.nxv4f32(<vscale x 4 x float> undef, <vscale x 4 x i1> undef, i32 undef)
; RV64_TYPEBASED-NEXT:  Cost Model: Found an estimated cost of 1 for instruction: %19 = call <vscale x 8 x i32> @llvm.vp.fptoui.nxv8i32.nxv8f32(<vscale x 8 x float> undef, <vscale x 8 x i1> undef, i32 undef)
; RV64_TYPEBASED-NEXT:  Cost Model: Found an estimated cost of 0 for instruction: ret void
;
  fptoui float undef to i32
  fptoui <1 x float> undef to <1 x i32>
  fptoui <2 x float> undef to <2 x i32>
  fptoui <4 x float> undef to <4 x i32>
  fptoui <8 x float> undef to <8 x i32>
  fptoui <16 x float> undef to <16 x i32>
  fptoui <vscale x 1 x float> undef to <vscale x 1 x i32>
  fptoui <vscale x 2 x float> undef to <vscale x 2 x i32>
  fptoui <vscale x 4 x float> undef to <vscale x 4 x i32>
  fptoui <vscale x 8 x float> undef to <vscale x 8 x i32>
  call <1 x i32> @llvm.vp.fptoui.v1float.v1i32(<1 x float> undef, <1 x i1> undef, i32 undef)
  call <2 x i32> @llvm.vp.fptoui.v2float.v2i32(<2 x float> undef, <2 x i1> undef, i32 undef)
  call <4 x i32> @llvm.vp.fptoui.v4float.v4i32(<4 x float> undef, <4 x i1> undef, i32 undef)
  call <8 x i32> @llvm.vp.fptoui.v8float.v8i32(<8 x float> undef, <8 x i1> undef, i32 undef)
  call <16 x i32> @llvm.vp.fptoui.v16.v16(<16 x float> undef, <16 x i1> undef, i32 undef)
  call <vscale x 1 x i32> @llvm.vp.fptoui.nxv1float.nxv1i32(<vscale x 1 x float> undef, <vscale x 1 x i1> undef, i32 undef)
  call <vscale x 2 x i32> @llvm.vp.fptoui.nxv2float.nxv2i32(<vscale x 2 x float> undef, <vscale x 2 x i1> undef, i32 undef)
  call <vscale x 4 x i32> @llvm.vp.fptoui.nxv4float.nxv4i32(<vscale x 4 x float> undef, <vscale x 4 x i1> undef, i32 undef)
  call <vscale x 8 x i32> @llvm.vp.fptoui.nxv8float.nxv8i32(<vscale x 8 x float> undef, <vscale x 8 x i1> undef, i32 undef)
  ret void
}

define void @fptosi() {
; RV32-LABEL: 'fptosi'
; RV32-NEXT:  Cost Model: Found an estimated cost of 1 for instruction: %1 = fptosi float undef to i32
; RV32-NEXT:  Cost Model: Found an estimated cost of 1 for instruction: %2 = fptosi <1 x float> undef to <1 x i32>
; RV32-NEXT:  Cost Model: Found an estimated cost of 1 for instruction: %3 = fptosi <2 x float> undef to <2 x i32>
; RV32-NEXT:  Cost Model: Found an estimated cost of 1 for instruction: %4 = fptosi <4 x float> undef to <4 x i32>
; RV32-NEXT:  Cost Model: Found an estimated cost of 1 for instruction: %5 = fptosi <8 x float> undef to <8 x i32>
; RV32-NEXT:  Cost Model: Found an estimated cost of 1 for instruction: %6 = fptosi <16 x float> undef to <16 x i32>
; RV32-NEXT:  Cost Model: Found an estimated cost of 1 for instruction: %7 = fptosi <vscale x 1 x float> undef to <vscale x 1 x i32>
; RV32-NEXT:  Cost Model: Found an estimated cost of 1 for instruction: %8 = fptosi <vscale x 2 x float> undef to <vscale x 2 x i32>
; RV32-NEXT:  Cost Model: Found an estimated cost of 1 for instruction: %9 = fptosi <vscale x 4 x float> undef to <vscale x 4 x i32>
; RV32-NEXT:  Cost Model: Found an estimated cost of 1 for instruction: %10 = fptosi <vscale x 8 x float> undef to <vscale x 8 x i32>
; RV32-NEXT:  Cost Model: Found an estimated cost of 1 for instruction: %11 = call <1 x i32> @llvm.vp.fptosi.v1i32.v1f32(<1 x float> undef, <1 x i1> undef, i32 undef)
; RV32-NEXT:  Cost Model: Found an estimated cost of 1 for instruction: %12 = call <2 x i32> @llvm.vp.fptosi.v2i32.v2f32(<2 x float> undef, <2 x i1> undef, i32 undef)
; RV32-NEXT:  Cost Model: Found an estimated cost of 1 for instruction: %13 = call <4 x i32> @llvm.vp.fptosi.v4i32.v4f32(<4 x float> undef, <4 x i1> undef, i32 undef)
; RV32-NEXT:  Cost Model: Found an estimated cost of 1 for instruction: %14 = call <8 x i32> @llvm.vp.fptosi.v8i32.v8f32(<8 x float> undef, <8 x i1> undef, i32 undef)
; RV32-NEXT:  Cost Model: Found an estimated cost of 1 for instruction: %15 = call <16 x i32> @llvm.vp.fptosi.v16i32.v16f32(<16 x float> undef, <16 x i1> undef, i32 undef)
; RV32-NEXT:  Cost Model: Found an estimated cost of 1 for instruction: %16 = call <vscale x 1 x i32> @llvm.vp.fptosi.nxv1i32.nxv1f32(<vscale x 1 x float> undef, <vscale x 1 x i1> undef, i32 undef)
; RV32-NEXT:  Cost Model: Found an estimated cost of 1 for instruction: %17 = call <vscale x 2 x i32> @llvm.vp.fptosi.nxv2i32.nxv2f32(<vscale x 2 x float> undef, <vscale x 2 x i1> undef, i32 undef)
; RV32-NEXT:  Cost Model: Found an estimated cost of 1 for instruction: %18 = call <vscale x 4 x i32> @llvm.vp.fptosi.nxv4i32.nxv4f32(<vscale x 4 x float> undef, <vscale x 4 x i1> undef, i32 undef)
; RV32-NEXT:  Cost Model: Found an estimated cost of 1 for instruction: %19 = call <vscale x 8 x i32> @llvm.vp.fptosi.nxv8i32.nxv8f32(<vscale x 8 x float> undef, <vscale x 8 x i1> undef, i32 undef)
; RV32-NEXT:  Cost Model: Found an estimated cost of 0 for instruction: ret void
;
; RV32_TYPEBASED-LABEL: 'fptosi'
; RV32_TYPEBASED-NEXT:  Cost Model: Found an estimated cost of 1 for instruction: %1 = fptosi float undef to i32
; RV32_TYPEBASED-NEXT:  Cost Model: Found an estimated cost of 1 for instruction: %2 = fptosi <1 x float> undef to <1 x i32>
; RV32_TYPEBASED-NEXT:  Cost Model: Found an estimated cost of 1 for instruction: %3 = fptosi <2 x float> undef to <2 x i32>
; RV32_TYPEBASED-NEXT:  Cost Model: Found an estimated cost of 1 for instruction: %4 = fptosi <4 x float> undef to <4 x i32>
; RV32_TYPEBASED-NEXT:  Cost Model: Found an estimated cost of 1 for instruction: %5 = fptosi <8 x float> undef to <8 x i32>
; RV32_TYPEBASED-NEXT:  Cost Model: Found an estimated cost of 1 for instruction: %6 = fptosi <16 x float> undef to <16 x i32>
; RV32_TYPEBASED-NEXT:  Cost Model: Found an estimated cost of 1 for instruction: %7 = fptosi <vscale x 1 x float> undef to <vscale x 1 x i32>
; RV32_TYPEBASED-NEXT:  Cost Model: Found an estimated cost of 1 for instruction: %8 = fptosi <vscale x 2 x float> undef to <vscale x 2 x i32>
; RV32_TYPEBASED-NEXT:  Cost Model: Found an estimated cost of 1 for instruction: %9 = fptosi <vscale x 4 x float> undef to <vscale x 4 x i32>
; RV32_TYPEBASED-NEXT:  Cost Model: Found an estimated cost of 1 for instruction: %10 = fptosi <vscale x 8 x float> undef to <vscale x 8 x i32>
; RV32_TYPEBASED-NEXT:  Cost Model: Found an estimated cost of 1 for instruction: %11 = call <1 x i32> @llvm.vp.fptosi.v1i32.v1f32(<1 x float> undef, <1 x i1> undef, i32 undef)
; RV32_TYPEBASED-NEXT:  Cost Model: Found an estimated cost of 1 for instruction: %12 = call <2 x i32> @llvm.vp.fptosi.v2i32.v2f32(<2 x float> undef, <2 x i1> undef, i32 undef)
; RV32_TYPEBASED-NEXT:  Cost Model: Found an estimated cost of 1 for instruction: %13 = call <4 x i32> @llvm.vp.fptosi.v4i32.v4f32(<4 x float> undef, <4 x i1> undef, i32 undef)
; RV32_TYPEBASED-NEXT:  Cost Model: Found an estimated cost of 1 for instruction: %14 = call <8 x i32> @llvm.vp.fptosi.v8i32.v8f32(<8 x float> undef, <8 x i1> undef, i32 undef)
; RV32_TYPEBASED-NEXT:  Cost Model: Found an estimated cost of 1 for instruction: %15 = call <16 x i32> @llvm.vp.fptosi.v16i32.v16f32(<16 x float> undef, <16 x i1> undef, i32 undef)
; RV32_TYPEBASED-NEXT:  Cost Model: Found an estimated cost of 1 for instruction: %16 = call <vscale x 1 x i32> @llvm.vp.fptosi.nxv1i32.nxv1f32(<vscale x 1 x float> undef, <vscale x 1 x i1> undef, i32 undef)
; RV32_TYPEBASED-NEXT:  Cost Model: Found an estimated cost of 1 for instruction: %17 = call <vscale x 2 x i32> @llvm.vp.fptosi.nxv2i32.nxv2f32(<vscale x 2 x float> undef, <vscale x 2 x i1> undef, i32 undef)
; RV32_TYPEBASED-NEXT:  Cost Model: Found an estimated cost of 1 for instruction: %18 = call <vscale x 4 x i32> @llvm.vp.fptosi.nxv4i32.nxv4f32(<vscale x 4 x float> undef, <vscale x 4 x i1> undef, i32 undef)
; RV32_TYPEBASED-NEXT:  Cost Model: Found an estimated cost of 1 for instruction: %19 = call <vscale x 8 x i32> @llvm.vp.fptosi.nxv8i32.nxv8f32(<vscale x 8 x float> undef, <vscale x 8 x i1> undef, i32 undef)
; RV32_TYPEBASED-NEXT:  Cost Model: Found an estimated cost of 0 for instruction: ret void
;
; RV64-LABEL: 'fptosi'
; RV64-NEXT:  Cost Model: Found an estimated cost of 1 for instruction: %1 = fptosi float undef to i32
; RV64-NEXT:  Cost Model: Found an estimated cost of 1 for instruction: %2 = fptosi <1 x float> undef to <1 x i32>
; RV64-NEXT:  Cost Model: Found an estimated cost of 1 for instruction: %3 = fptosi <2 x float> undef to <2 x i32>
; RV64-NEXT:  Cost Model: Found an estimated cost of 1 for instruction: %4 = fptosi <4 x float> undef to <4 x i32>
; RV64-NEXT:  Cost Model: Found an estimated cost of 1 for instruction: %5 = fptosi <8 x float> undef to <8 x i32>
; RV64-NEXT:  Cost Model: Found an estimated cost of 1 for instruction: %6 = fptosi <16 x float> undef to <16 x i32>
; RV64-NEXT:  Cost Model: Found an estimated cost of 1 for instruction: %7 = fptosi <vscale x 1 x float> undef to <vscale x 1 x i32>
; RV64-NEXT:  Cost Model: Found an estimated cost of 1 for instruction: %8 = fptosi <vscale x 2 x float> undef to <vscale x 2 x i32>
; RV64-NEXT:  Cost Model: Found an estimated cost of 1 for instruction: %9 = fptosi <vscale x 4 x float> undef to <vscale x 4 x i32>
; RV64-NEXT:  Cost Model: Found an estimated cost of 1 for instruction: %10 = fptosi <vscale x 8 x float> undef to <vscale x 8 x i32>
; RV64-NEXT:  Cost Model: Found an estimated cost of 1 for instruction: %11 = call <1 x i32> @llvm.vp.fptosi.v1i32.v1f32(<1 x float> undef, <1 x i1> undef, i32 undef)
; RV64-NEXT:  Cost Model: Found an estimated cost of 1 for instruction: %12 = call <2 x i32> @llvm.vp.fptosi.v2i32.v2f32(<2 x float> undef, <2 x i1> undef, i32 undef)
; RV64-NEXT:  Cost Model: Found an estimated cost of 1 for instruction: %13 = call <4 x i32> @llvm.vp.fptosi.v4i32.v4f32(<4 x float> undef, <4 x i1> undef, i32 undef)
; RV64-NEXT:  Cost Model: Found an estimated cost of 1 for instruction: %14 = call <8 x i32> @llvm.vp.fptosi.v8i32.v8f32(<8 x float> undef, <8 x i1> undef, i32 undef)
; RV64-NEXT:  Cost Model: Found an estimated cost of 1 for instruction: %15 = call <16 x i32> @llvm.vp.fptosi.v16i32.v16f32(<16 x float> undef, <16 x i1> undef, i32 undef)
; RV64-NEXT:  Cost Model: Found an estimated cost of 1 for instruction: %16 = call <vscale x 1 x i32> @llvm.vp.fptosi.nxv1i32.nxv1f32(<vscale x 1 x float> undef, <vscale x 1 x i1> undef, i32 undef)
; RV64-NEXT:  Cost Model: Found an estimated cost of 1 for instruction: %17 = call <vscale x 2 x i32> @llvm.vp.fptosi.nxv2i32.nxv2f32(<vscale x 2 x float> undef, <vscale x 2 x i1> undef, i32 undef)
; RV64-NEXT:  Cost Model: Found an estimated cost of 1 for instruction: %18 = call <vscale x 4 x i32> @llvm.vp.fptosi.nxv4i32.nxv4f32(<vscale x 4 x float> undef, <vscale x 4 x i1> undef, i32 undef)
; RV64-NEXT:  Cost Model: Found an estimated cost of 1 for instruction: %19 = call <vscale x 8 x i32> @llvm.vp.fptosi.nxv8i32.nxv8f32(<vscale x 8 x float> undef, <vscale x 8 x i1> undef, i32 undef)
; RV64-NEXT:  Cost Model: Found an estimated cost of 0 for instruction: ret void
;
; RV64_TYPEBASED-LABEL: 'fptosi'
; RV64_TYPEBASED-NEXT:  Cost Model: Found an estimated cost of 1 for instruction: %1 = fptosi float undef to i32
; RV64_TYPEBASED-NEXT:  Cost Model: Found an estimated cost of 1 for instruction: %2 = fptosi <1 x float> undef to <1 x i32>
; RV64_TYPEBASED-NEXT:  Cost Model: Found an estimated cost of 1 for instruction: %3 = fptosi <2 x float> undef to <2 x i32>
; RV64_TYPEBASED-NEXT:  Cost Model: Found an estimated cost of 1 for instruction: %4 = fptosi <4 x float> undef to <4 x i32>
; RV64_TYPEBASED-NEXT:  Cost Model: Found an estimated cost of 1 for instruction: %5 = fptosi <8 x float> undef to <8 x i32>
; RV64_TYPEBASED-NEXT:  Cost Model: Found an estimated cost of 1 for instruction: %6 = fptosi <16 x float> undef to <16 x i32>
; RV64_TYPEBASED-NEXT:  Cost Model: Found an estimated cost of 1 for instruction: %7 = fptosi <vscale x 1 x float> undef to <vscale x 1 x i32>
; RV64_TYPEBASED-NEXT:  Cost Model: Found an estimated cost of 1 for instruction: %8 = fptosi <vscale x 2 x float> undef to <vscale x 2 x i32>
; RV64_TYPEBASED-NEXT:  Cost Model: Found an estimated cost of 1 for instruction: %9 = fptosi <vscale x 4 x float> undef to <vscale x 4 x i32>
; RV64_TYPEBASED-NEXT:  Cost Model: Found an estimated cost of 1 for instruction: %10 = fptosi <vscale x 8 x float> undef to <vscale x 8 x i32>
; RV64_TYPEBASED-NEXT:  Cost Model: Found an estimated cost of 1 for instruction: %11 = call <1 x i32> @llvm.vp.fptosi.v1i32.v1f32(<1 x float> undef, <1 x i1> undef, i32 undef)
; RV64_TYPEBASED-NEXT:  Cost Model: Found an estimated cost of 1 for instruction: %12 = call <2 x i32> @llvm.vp.fptosi.v2i32.v2f32(<2 x float> undef, <2 x i1> undef, i32 undef)
; RV64_TYPEBASED-NEXT:  Cost Model: Found an estimated cost of 1 for instruction: %13 = call <4 x i32> @llvm.vp.fptosi.v4i32.v4f32(<4 x float> undef, <4 x i1> undef, i32 undef)
; RV64_TYPEBASED-NEXT:  Cost Model: Found an estimated cost of 1 for instruction: %14 = call <8 x i32> @llvm.vp.fptosi.v8i32.v8f32(<8 x float> undef, <8 x i1> undef, i32 undef)
; RV64_TYPEBASED-NEXT:  Cost Model: Found an estimated cost of 1 for instruction: %15 = call <16 x i32> @llvm.vp.fptosi.v16i32.v16f32(<16 x float> undef, <16 x i1> undef, i32 undef)
; RV64_TYPEBASED-NEXT:  Cost Model: Found an estimated cost of 1 for instruction: %16 = call <vscale x 1 x i32> @llvm.vp.fptosi.nxv1i32.nxv1f32(<vscale x 1 x float> undef, <vscale x 1 x i1> undef, i32 undef)
; RV64_TYPEBASED-NEXT:  Cost Model: Found an estimated cost of 1 for instruction: %17 = call <vscale x 2 x i32> @llvm.vp.fptosi.nxv2i32.nxv2f32(<vscale x 2 x float> undef, <vscale x 2 x i1> undef, i32 undef)
; RV64_TYPEBASED-NEXT:  Cost Model: Found an estimated cost of 1 for instruction: %18 = call <vscale x 4 x i32> @llvm.vp.fptosi.nxv4i32.nxv4f32(<vscale x 4 x float> undef, <vscale x 4 x i1> undef, i32 undef)
; RV64_TYPEBASED-NEXT:  Cost Model: Found an estimated cost of 1 for instruction: %19 = call <vscale x 8 x i32> @llvm.vp.fptosi.nxv8i32.nxv8f32(<vscale x 8 x float> undef, <vscale x 8 x i1> undef, i32 undef)
; RV64_TYPEBASED-NEXT:  Cost Model: Found an estimated cost of 0 for instruction: ret void
;
  fptosi float undef to i32
  fptosi <1 x float> undef to <1 x i32>
  fptosi <2 x float> undef to <2 x i32>
  fptosi <4 x float> undef to <4 x i32>
  fptosi <8 x float> undef to <8 x i32>
  fptosi <16 x float> undef to <16 x i32>
  fptosi <vscale x 1 x float> undef to <vscale x 1 x i32>
  fptosi <vscale x 2 x float> undef to <vscale x 2 x i32>
  fptosi <vscale x 4 x float> undef to <vscale x 4 x i32>
  fptosi <vscale x 8 x float> undef to <vscale x 8 x i32>
  call <1 x i32> @llvm.vp.fptosi.v1float.v1i32(<1 x float> undef, <1 x i1> undef, i32 undef)
  call <2 x i32> @llvm.vp.fptosi.v2float.v2i32(<2 x float> undef, <2 x i1> undef, i32 undef)
  call <4 x i32> @llvm.vp.fptosi.v4float.v4i32(<4 x float> undef, <4 x i1> undef, i32 undef)
  call <8 x i32> @llvm.vp.fptosi.v8float.v8i32(<8 x float> undef, <8 x i1> undef, i32 undef)
  call <16 x i32> @llvm.vp.fptosi.v16.v16(<16 x float> undef, <16 x i1> undef, i32 undef)
  call <vscale x 1 x i32> @llvm.vp.fptosi.nxv1float.nxv1i32(<vscale x 1 x float> undef, <vscale x 1 x i1> undef, i32 undef)
  call <vscale x 2 x i32> @llvm.vp.fptosi.nxv2float.nxv2i32(<vscale x 2 x float> undef, <vscale x 2 x i1> undef, i32 undef)
  call <vscale x 4 x i32> @llvm.vp.fptosi.nxv4float.nxv4i32(<vscale x 4 x float> undef, <vscale x 4 x i1> undef, i32 undef)
  call <vscale x 8 x i32> @llvm.vp.fptosi.nxv8float.nxv8i32(<vscale x 8 x float> undef, <vscale x 8 x i1> undef, i32 undef)
  ret void
}

define void @uitofp() {
; RV32-LABEL: 'uitofp'
; RV32-NEXT:  Cost Model: Found an estimated cost of 1 for instruction: %1 = uitofp i64 undef to double
; RV32-NEXT:  Cost Model: Found an estimated cost of 1 for instruction: %2 = uitofp <1 x i64> undef to <1 x double>
; RV32-NEXT:  Cost Model: Found an estimated cost of 1 for instruction: %3 = uitofp <2 x i64> undef to <2 x double>
; RV32-NEXT:  Cost Model: Found an estimated cost of 1 for instruction: %4 = uitofp <4 x i64> undef to <4 x double>
; RV32-NEXT:  Cost Model: Found an estimated cost of 1 for instruction: %5 = uitofp <8 x i64> undef to <8 x double>
; RV32-NEXT:  Cost Model: Found an estimated cost of 1 for instruction: %6 = uitofp <16 x i64> undef to <16 x double>
; RV32-NEXT:  Cost Model: Found an estimated cost of 1 for instruction: %7 = uitofp <vscale x 1 x i64> undef to <vscale x 1 x double>
; RV32-NEXT:  Cost Model: Found an estimated cost of 1 for instruction: %8 = uitofp <vscale x 2 x i64> undef to <vscale x 2 x double>
; RV32-NEXT:  Cost Model: Found an estimated cost of 1 for instruction: %9 = uitofp <vscale x 4 x i64> undef to <vscale x 4 x double>
; RV32-NEXT:  Cost Model: Found an estimated cost of 1 for instruction: %10 = uitofp <vscale x 8 x i64> undef to <vscale x 8 x double>
; RV32-NEXT:  Cost Model: Found an estimated cost of 1 for instruction: %11 = call <1 x double> @llvm.vp.uitofp.v1f64.v1i64(<1 x i64> undef, <1 x i1> undef, i32 undef)
; RV32-NEXT:  Cost Model: Found an estimated cost of 1 for instruction: %12 = call <2 x double> @llvm.vp.uitofp.v2f64.v2i64(<2 x i64> undef, <2 x i1> undef, i32 undef)
; RV32-NEXT:  Cost Model: Found an estimated cost of 1 for instruction: %13 = call <4 x double> @llvm.vp.uitofp.v4f64.v4i64(<4 x i64> undef, <4 x i1> undef, i32 undef)
; RV32-NEXT:  Cost Model: Found an estimated cost of 1 for instruction: %14 = call <8 x double> @llvm.vp.uitofp.v8f64.v8i64(<8 x i64> undef, <8 x i1> undef, i32 undef)
; RV32-NEXT:  Cost Model: Found an estimated cost of 1 for instruction: %15 = call <16 x double> @llvm.vp.uitofp.v16f64.v16i64(<16 x i64> undef, <16 x i1> undef, i32 undef)
; RV32-NEXT:  Cost Model: Found an estimated cost of 1 for instruction: %16 = call <vscale x 1 x double> @llvm.vp.uitofp.nxv1f64.nxv1i64(<vscale x 1 x i64> undef, <vscale x 1 x i1> undef, i32 undef)
; RV32-NEXT:  Cost Model: Found an estimated cost of 1 for instruction: %17 = call <vscale x 2 x double> @llvm.vp.uitofp.nxv2f64.nxv2i64(<vscale x 2 x i64> undef, <vscale x 2 x i1> undef, i32 undef)
; RV32-NEXT:  Cost Model: Found an estimated cost of 1 for instruction: %18 = call <vscale x 4 x double> @llvm.vp.uitofp.nxv4f64.nxv4i64(<vscale x 4 x i64> undef, <vscale x 4 x i1> undef, i32 undef)
; RV32-NEXT:  Cost Model: Found an estimated cost of 1 for instruction: %19 = call <vscale x 8 x double> @llvm.vp.uitofp.nxv8f64.nxv8i64(<vscale x 8 x i64> undef, <vscale x 8 x i1> undef, i32 undef)
; RV32-NEXT:  Cost Model: Found an estimated cost of 0 for instruction: ret void
;
; RV32_TYPEBASED-LABEL: 'uitofp'
; RV32_TYPEBASED-NEXT:  Cost Model: Found an estimated cost of 1 for instruction: %1 = uitofp i64 undef to double
; RV32_TYPEBASED-NEXT:  Cost Model: Found an estimated cost of 1 for instruction: %2 = uitofp <1 x i64> undef to <1 x double>
; RV32_TYPEBASED-NEXT:  Cost Model: Found an estimated cost of 1 for instruction: %3 = uitofp <2 x i64> undef to <2 x double>
; RV32_TYPEBASED-NEXT:  Cost Model: Found an estimated cost of 1 for instruction: %4 = uitofp <4 x i64> undef to <4 x double>
; RV32_TYPEBASED-NEXT:  Cost Model: Found an estimated cost of 1 for instruction: %5 = uitofp <8 x i64> undef to <8 x double>
; RV32_TYPEBASED-NEXT:  Cost Model: Found an estimated cost of 1 for instruction: %6 = uitofp <16 x i64> undef to <16 x double>
; RV32_TYPEBASED-NEXT:  Cost Model: Found an estimated cost of 1 for instruction: %7 = uitofp <vscale x 1 x i64> undef to <vscale x 1 x double>
; RV32_TYPEBASED-NEXT:  Cost Model: Found an estimated cost of 1 for instruction: %8 = uitofp <vscale x 2 x i64> undef to <vscale x 2 x double>
; RV32_TYPEBASED-NEXT:  Cost Model: Found an estimated cost of 1 for instruction: %9 = uitofp <vscale x 4 x i64> undef to <vscale x 4 x double>
; RV32_TYPEBASED-NEXT:  Cost Model: Found an estimated cost of 1 for instruction: %10 = uitofp <vscale x 8 x i64> undef to <vscale x 8 x double>
; RV32_TYPEBASED-NEXT:  Cost Model: Found an estimated cost of 1 for instruction: %11 = call <1 x double> @llvm.vp.uitofp.v1f64.v1i64(<1 x i64> undef, <1 x i1> undef, i32 undef)
; RV32_TYPEBASED-NEXT:  Cost Model: Found an estimated cost of 1 for instruction: %12 = call <2 x double> @llvm.vp.uitofp.v2f64.v2i64(<2 x i64> undef, <2 x i1> undef, i32 undef)
; RV32_TYPEBASED-NEXT:  Cost Model: Found an estimated cost of 1 for instruction: %13 = call <4 x double> @llvm.vp.uitofp.v4f64.v4i64(<4 x i64> undef, <4 x i1> undef, i32 undef)
; RV32_TYPEBASED-NEXT:  Cost Model: Found an estimated cost of 1 for instruction: %14 = call <8 x double> @llvm.vp.uitofp.v8f64.v8i64(<8 x i64> undef, <8 x i1> undef, i32 undef)
; RV32_TYPEBASED-NEXT:  Cost Model: Found an estimated cost of 1 for instruction: %15 = call <16 x double> @llvm.vp.uitofp.v16f64.v16i64(<16 x i64> undef, <16 x i1> undef, i32 undef)
; RV32_TYPEBASED-NEXT:  Cost Model: Found an estimated cost of 1 for instruction: %16 = call <vscale x 1 x double> @llvm.vp.uitofp.nxv1f64.nxv1i64(<vscale x 1 x i64> undef, <vscale x 1 x i1> undef, i32 undef)
; RV32_TYPEBASED-NEXT:  Cost Model: Found an estimated cost of 1 for instruction: %17 = call <vscale x 2 x double> @llvm.vp.uitofp.nxv2f64.nxv2i64(<vscale x 2 x i64> undef, <vscale x 2 x i1> undef, i32 undef)
; RV32_TYPEBASED-NEXT:  Cost Model: Found an estimated cost of 1 for instruction: %18 = call <vscale x 4 x double> @llvm.vp.uitofp.nxv4f64.nxv4i64(<vscale x 4 x i64> undef, <vscale x 4 x i1> undef, i32 undef)
; RV32_TYPEBASED-NEXT:  Cost Model: Found an estimated cost of 1 for instruction: %19 = call <vscale x 8 x double> @llvm.vp.uitofp.nxv8f64.nxv8i64(<vscale x 8 x i64> undef, <vscale x 8 x i1> undef, i32 undef)
; RV32_TYPEBASED-NEXT:  Cost Model: Found an estimated cost of 0 for instruction: ret void
;
; RV64-LABEL: 'uitofp'
; RV64-NEXT:  Cost Model: Found an estimated cost of 1 for instruction: %1 = uitofp i64 undef to double
; RV64-NEXT:  Cost Model: Found an estimated cost of 1 for instruction: %2 = uitofp <1 x i64> undef to <1 x double>
; RV64-NEXT:  Cost Model: Found an estimated cost of 1 for instruction: %3 = uitofp <2 x i64> undef to <2 x double>
; RV64-NEXT:  Cost Model: Found an estimated cost of 1 for instruction: %4 = uitofp <4 x i64> undef to <4 x double>
; RV64-NEXT:  Cost Model: Found an estimated cost of 1 for instruction: %5 = uitofp <8 x i64> undef to <8 x double>
; RV64-NEXT:  Cost Model: Found an estimated cost of 1 for instruction: %6 = uitofp <16 x i64> undef to <16 x double>
; RV64-NEXT:  Cost Model: Found an estimated cost of 1 for instruction: %7 = uitofp <vscale x 1 x i64> undef to <vscale x 1 x double>
; RV64-NEXT:  Cost Model: Found an estimated cost of 1 for instruction: %8 = uitofp <vscale x 2 x i64> undef to <vscale x 2 x double>
; RV64-NEXT:  Cost Model: Found an estimated cost of 1 for instruction: %9 = uitofp <vscale x 4 x i64> undef to <vscale x 4 x double>
; RV64-NEXT:  Cost Model: Found an estimated cost of 1 for instruction: %10 = uitofp <vscale x 8 x i64> undef to <vscale x 8 x double>
; RV64-NEXT:  Cost Model: Found an estimated cost of 1 for instruction: %11 = call <1 x double> @llvm.vp.uitofp.v1f64.v1i64(<1 x i64> undef, <1 x i1> undef, i32 undef)
; RV64-NEXT:  Cost Model: Found an estimated cost of 1 for instruction: %12 = call <2 x double> @llvm.vp.uitofp.v2f64.v2i64(<2 x i64> undef, <2 x i1> undef, i32 undef)
; RV64-NEXT:  Cost Model: Found an estimated cost of 1 for instruction: %13 = call <4 x double> @llvm.vp.uitofp.v4f64.v4i64(<4 x i64> undef, <4 x i1> undef, i32 undef)
; RV64-NEXT:  Cost Model: Found an estimated cost of 1 for instruction: %14 = call <8 x double> @llvm.vp.uitofp.v8f64.v8i64(<8 x i64> undef, <8 x i1> undef, i32 undef)
; RV64-NEXT:  Cost Model: Found an estimated cost of 1 for instruction: %15 = call <16 x double> @llvm.vp.uitofp.v16f64.v16i64(<16 x i64> undef, <16 x i1> undef, i32 undef)
; RV64-NEXT:  Cost Model: Found an estimated cost of 1 for instruction: %16 = call <vscale x 1 x double> @llvm.vp.uitofp.nxv1f64.nxv1i64(<vscale x 1 x i64> undef, <vscale x 1 x i1> undef, i32 undef)
; RV64-NEXT:  Cost Model: Found an estimated cost of 1 for instruction: %17 = call <vscale x 2 x double> @llvm.vp.uitofp.nxv2f64.nxv2i64(<vscale x 2 x i64> undef, <vscale x 2 x i1> undef, i32 undef)
; RV64-NEXT:  Cost Model: Found an estimated cost of 1 for instruction: %18 = call <vscale x 4 x double> @llvm.vp.uitofp.nxv4f64.nxv4i64(<vscale x 4 x i64> undef, <vscale x 4 x i1> undef, i32 undef)
; RV64-NEXT:  Cost Model: Found an estimated cost of 1 for instruction: %19 = call <vscale x 8 x double> @llvm.vp.uitofp.nxv8f64.nxv8i64(<vscale x 8 x i64> undef, <vscale x 8 x i1> undef, i32 undef)
; RV64-NEXT:  Cost Model: Found an estimated cost of 0 for instruction: ret void
;
; RV64_TYPEBASED-LABEL: 'uitofp'
; RV64_TYPEBASED-NEXT:  Cost Model: Found an estimated cost of 1 for instruction: %1 = uitofp i64 undef to double
; RV64_TYPEBASED-NEXT:  Cost Model: Found an estimated cost of 1 for instruction: %2 = uitofp <1 x i64> undef to <1 x double>
; RV64_TYPEBASED-NEXT:  Cost Model: Found an estimated cost of 1 for instruction: %3 = uitofp <2 x i64> undef to <2 x double>
; RV64_TYPEBASED-NEXT:  Cost Model: Found an estimated cost of 1 for instruction: %4 = uitofp <4 x i64> undef to <4 x double>
; RV64_TYPEBASED-NEXT:  Cost Model: Found an estimated cost of 1 for instruction: %5 = uitofp <8 x i64> undef to <8 x double>
; RV64_TYPEBASED-NEXT:  Cost Model: Found an estimated cost of 1 for instruction: %6 = uitofp <16 x i64> undef to <16 x double>
; RV64_TYPEBASED-NEXT:  Cost Model: Found an estimated cost of 1 for instruction: %7 = uitofp <vscale x 1 x i64> undef to <vscale x 1 x double>
; RV64_TYPEBASED-NEXT:  Cost Model: Found an estimated cost of 1 for instruction: %8 = uitofp <vscale x 2 x i64> undef to <vscale x 2 x double>
; RV64_TYPEBASED-NEXT:  Cost Model: Found an estimated cost of 1 for instruction: %9 = uitofp <vscale x 4 x i64> undef to <vscale x 4 x double>
; RV64_TYPEBASED-NEXT:  Cost Model: Found an estimated cost of 1 for instruction: %10 = uitofp <vscale x 8 x i64> undef to <vscale x 8 x double>
; RV64_TYPEBASED-NEXT:  Cost Model: Found an estimated cost of 1 for instruction: %11 = call <1 x double> @llvm.vp.uitofp.v1f64.v1i64(<1 x i64> undef, <1 x i1> undef, i32 undef)
; RV64_TYPEBASED-NEXT:  Cost Model: Found an estimated cost of 1 for instruction: %12 = call <2 x double> @llvm.vp.uitofp.v2f64.v2i64(<2 x i64> undef, <2 x i1> undef, i32 undef)
; RV64_TYPEBASED-NEXT:  Cost Model: Found an estimated cost of 1 for instruction: %13 = call <4 x double> @llvm.vp.uitofp.v4f64.v4i64(<4 x i64> undef, <4 x i1> undef, i32 undef)
; RV64_TYPEBASED-NEXT:  Cost Model: Found an estimated cost of 1 for instruction: %14 = call <8 x double> @llvm.vp.uitofp.v8f64.v8i64(<8 x i64> undef, <8 x i1> undef, i32 undef)
; RV64_TYPEBASED-NEXT:  Cost Model: Found an estimated cost of 1 for instruction: %15 = call <16 x double> @llvm.vp.uitofp.v16f64.v16i64(<16 x i64> undef, <16 x i1> undef, i32 undef)
; RV64_TYPEBASED-NEXT:  Cost Model: Found an estimated cost of 1 for instruction: %16 = call <vscale x 1 x double> @llvm.vp.uitofp.nxv1f64.nxv1i64(<vscale x 1 x i64> undef, <vscale x 1 x i1> undef, i32 undef)
; RV64_TYPEBASED-NEXT:  Cost Model: Found an estimated cost of 1 for instruction: %17 = call <vscale x 2 x double> @llvm.vp.uitofp.nxv2f64.nxv2i64(<vscale x 2 x i64> undef, <vscale x 2 x i1> undef, i32 undef)
; RV64_TYPEBASED-NEXT:  Cost Model: Found an estimated cost of 1 for instruction: %18 = call <vscale x 4 x double> @llvm.vp.uitofp.nxv4f64.nxv4i64(<vscale x 4 x i64> undef, <vscale x 4 x i1> undef, i32 undef)
; RV64_TYPEBASED-NEXT:  Cost Model: Found an estimated cost of 1 for instruction: %19 = call <vscale x 8 x double> @llvm.vp.uitofp.nxv8f64.nxv8i64(<vscale x 8 x i64> undef, <vscale x 8 x i1> undef, i32 undef)
; RV64_TYPEBASED-NEXT:  Cost Model: Found an estimated cost of 0 for instruction: ret void
;
  uitofp i64 undef to double
  uitofp <1 x i64> undef to <1 x double>
  uitofp <2 x i64> undef to <2 x double>
  uitofp <4 x i64> undef to <4 x double>
  uitofp <8 x i64> undef to <8 x double>
  uitofp <16 x i64> undef to <16 x double>
  uitofp <vscale x 1 x i64> undef to <vscale x 1 x double>
  uitofp <vscale x 2 x i64> undef to <vscale x 2 x double>
  uitofp <vscale x 4 x i64> undef to <vscale x 4 x double>
  uitofp <vscale x 8 x i64> undef to <vscale x 8 x double>
  call <1 x double> @llvm.vp.uitofp.v1i64.v1double(<1 x i64> undef, <1 x i1> undef, i32 undef)
  call <2 x double> @llvm.vp.uitofp.v2i64.v2double(<2 x i64> undef, <2 x i1> undef, i32 undef)
  call <4 x double> @llvm.vp.uitofp.v4i64.v4double(<4 x i64> undef, <4 x i1> undef, i32 undef)
  call <8 x double> @llvm.vp.uitofp.v8i64.v8double(<8 x i64> undef, <8 x i1> undef, i32 undef)
  call <16 x double> @llvm.vp.uitofp.v16.v16(<16 x i64> undef, <16 x i1> undef, i32 undef)
  call <vscale x 1 x double> @llvm.vp.uitofp.nxv1i64.nxv1double(<vscale x 1 x i64> undef, <vscale x 1 x i1> undef, i32 undef)
  call <vscale x 2 x double> @llvm.vp.uitofp.nxv2i64.nxv2double(<vscale x 2 x i64> undef, <vscale x 2 x i1> undef, i32 undef)
  call <vscale x 4 x double> @llvm.vp.uitofp.nxv4i64.nxv4double(<vscale x 4 x i64> undef, <vscale x 4 x i1> undef, i32 undef)
  call <vscale x 8 x double> @llvm.vp.uitofp.nxv8i64.nxv8double(<vscale x 8 x i64> undef, <vscale x 8 x i1> undef, i32 undef)
  ret void
}

define void @sitofp() {
; RV32-LABEL: 'sitofp'
; RV32-NEXT:  Cost Model: Found an estimated cost of 1 for instruction: %1 = sitofp i64 undef to double
; RV32-NEXT:  Cost Model: Found an estimated cost of 1 for instruction: %2 = sitofp <1 x i64> undef to <1 x double>
; RV32-NEXT:  Cost Model: Found an estimated cost of 1 for instruction: %3 = sitofp <2 x i64> undef to <2 x double>
; RV32-NEXT:  Cost Model: Found an estimated cost of 1 for instruction: %4 = sitofp <4 x i64> undef to <4 x double>
; RV32-NEXT:  Cost Model: Found an estimated cost of 1 for instruction: %5 = sitofp <8 x i64> undef to <8 x double>
; RV32-NEXT:  Cost Model: Found an estimated cost of 1 for instruction: %6 = sitofp <16 x i64> undef to <16 x double>
; RV32-NEXT:  Cost Model: Found an estimated cost of 1 for instruction: %7 = sitofp <vscale x 1 x i64> undef to <vscale x 1 x double>
; RV32-NEXT:  Cost Model: Found an estimated cost of 1 for instruction: %8 = sitofp <vscale x 2 x i64> undef to <vscale x 2 x double>
; RV32-NEXT:  Cost Model: Found an estimated cost of 1 for instruction: %9 = sitofp <vscale x 4 x i64> undef to <vscale x 4 x double>
; RV32-NEXT:  Cost Model: Found an estimated cost of 1 for instruction: %10 = sitofp <vscale x 8 x i64> undef to <vscale x 8 x double>
; RV32-NEXT:  Cost Model: Found an estimated cost of 1 for instruction: %11 = call <1 x double> @llvm.vp.sitofp.v1f64.v1i64(<1 x i64> undef, <1 x i1> undef, i32 undef)
; RV32-NEXT:  Cost Model: Found an estimated cost of 1 for instruction: %12 = call <2 x double> @llvm.vp.sitofp.v2f64.v2i64(<2 x i64> undef, <2 x i1> undef, i32 undef)
; RV32-NEXT:  Cost Model: Found an estimated cost of 1 for instruction: %13 = call <4 x double> @llvm.vp.sitofp.v4f64.v4i64(<4 x i64> undef, <4 x i1> undef, i32 undef)
; RV32-NEXT:  Cost Model: Found an estimated cost of 1 for instruction: %14 = call <8 x double> @llvm.vp.sitofp.v8f64.v8i64(<8 x i64> undef, <8 x i1> undef, i32 undef)
; RV32-NEXT:  Cost Model: Found an estimated cost of 1 for instruction: %15 = call <16 x double> @llvm.vp.sitofp.v16f64.v16i64(<16 x i64> undef, <16 x i1> undef, i32 undef)
; RV32-NEXT:  Cost Model: Found an estimated cost of 1 for instruction: %16 = call <vscale x 1 x double> @llvm.vp.sitofp.nxv1f64.nxv1i64(<vscale x 1 x i64> undef, <vscale x 1 x i1> undef, i32 undef)
; RV32-NEXT:  Cost Model: Found an estimated cost of 1 for instruction: %17 = call <vscale x 2 x double> @llvm.vp.sitofp.nxv2f64.nxv2i64(<vscale x 2 x i64> undef, <vscale x 2 x i1> undef, i32 undef)
; RV32-NEXT:  Cost Model: Found an estimated cost of 1 for instruction: %18 = call <vscale x 4 x double> @llvm.vp.sitofp.nxv4f64.nxv4i64(<vscale x 4 x i64> undef, <vscale x 4 x i1> undef, i32 undef)
; RV32-NEXT:  Cost Model: Found an estimated cost of 1 for instruction: %19 = call <vscale x 8 x double> @llvm.vp.sitofp.nxv8f64.nxv8i64(<vscale x 8 x i64> undef, <vscale x 8 x i1> undef, i32 undef)
; RV32-NEXT:  Cost Model: Found an estimated cost of 0 for instruction: ret void
;
; RV32_TYPEBASED-LABEL: 'sitofp'
; RV32_TYPEBASED-NEXT:  Cost Model: Found an estimated cost of 1 for instruction: %1 = sitofp i64 undef to double
; RV32_TYPEBASED-NEXT:  Cost Model: Found an estimated cost of 1 for instruction: %2 = sitofp <1 x i64> undef to <1 x double>
; RV32_TYPEBASED-NEXT:  Cost Model: Found an estimated cost of 1 for instruction: %3 = sitofp <2 x i64> undef to <2 x double>
; RV32_TYPEBASED-NEXT:  Cost Model: Found an estimated cost of 1 for instruction: %4 = sitofp <4 x i64> undef to <4 x double>
; RV32_TYPEBASED-NEXT:  Cost Model: Found an estimated cost of 1 for instruction: %5 = sitofp <8 x i64> undef to <8 x double>
; RV32_TYPEBASED-NEXT:  Cost Model: Found an estimated cost of 1 for instruction: %6 = sitofp <16 x i64> undef to <16 x double>
; RV32_TYPEBASED-NEXT:  Cost Model: Found an estimated cost of 1 for instruction: %7 = sitofp <vscale x 1 x i64> undef to <vscale x 1 x double>
; RV32_TYPEBASED-NEXT:  Cost Model: Found an estimated cost of 1 for instruction: %8 = sitofp <vscale x 2 x i64> undef to <vscale x 2 x double>
; RV32_TYPEBASED-NEXT:  Cost Model: Found an estimated cost of 1 for instruction: %9 = sitofp <vscale x 4 x i64> undef to <vscale x 4 x double>
; RV32_TYPEBASED-NEXT:  Cost Model: Found an estimated cost of 1 for instruction: %10 = sitofp <vscale x 8 x i64> undef to <vscale x 8 x double>
; RV32_TYPEBASED-NEXT:  Cost Model: Found an estimated cost of 1 for instruction: %11 = call <1 x double> @llvm.vp.sitofp.v1f64.v1i64(<1 x i64> undef, <1 x i1> undef, i32 undef)
; RV32_TYPEBASED-NEXT:  Cost Model: Found an estimated cost of 1 for instruction: %12 = call <2 x double> @llvm.vp.sitofp.v2f64.v2i64(<2 x i64> undef, <2 x i1> undef, i32 undef)
; RV32_TYPEBASED-NEXT:  Cost Model: Found an estimated cost of 1 for instruction: %13 = call <4 x double> @llvm.vp.sitofp.v4f64.v4i64(<4 x i64> undef, <4 x i1> undef, i32 undef)
; RV32_TYPEBASED-NEXT:  Cost Model: Found an estimated cost of 1 for instruction: %14 = call <8 x double> @llvm.vp.sitofp.v8f64.v8i64(<8 x i64> undef, <8 x i1> undef, i32 undef)
; RV32_TYPEBASED-NEXT:  Cost Model: Found an estimated cost of 1 for instruction: %15 = call <16 x double> @llvm.vp.sitofp.v16f64.v16i64(<16 x i64> undef, <16 x i1> undef, i32 undef)
; RV32_TYPEBASED-NEXT:  Cost Model: Found an estimated cost of 1 for instruction: %16 = call <vscale x 1 x double> @llvm.vp.sitofp.nxv1f64.nxv1i64(<vscale x 1 x i64> undef, <vscale x 1 x i1> undef, i32 undef)
; RV32_TYPEBASED-NEXT:  Cost Model: Found an estimated cost of 1 for instruction: %17 = call <vscale x 2 x double> @llvm.vp.sitofp.nxv2f64.nxv2i64(<vscale x 2 x i64> undef, <vscale x 2 x i1> undef, i32 undef)
; RV32_TYPEBASED-NEXT:  Cost Model: Found an estimated cost of 1 for instruction: %18 = call <vscale x 4 x double> @llvm.vp.sitofp.nxv4f64.nxv4i64(<vscale x 4 x i64> undef, <vscale x 4 x i1> undef, i32 undef)
; RV32_TYPEBASED-NEXT:  Cost Model: Found an estimated cost of 1 for instruction: %19 = call <vscale x 8 x double> @llvm.vp.sitofp.nxv8f64.nxv8i64(<vscale x 8 x i64> undef, <vscale x 8 x i1> undef, i32 undef)
; RV32_TYPEBASED-NEXT:  Cost Model: Found an estimated cost of 0 for instruction: ret void
;
; RV64-LABEL: 'sitofp'
; RV64-NEXT:  Cost Model: Found an estimated cost of 1 for instruction: %1 = sitofp i64 undef to double
; RV64-NEXT:  Cost Model: Found an estimated cost of 1 for instruction: %2 = sitofp <1 x i64> undef to <1 x double>
; RV64-NEXT:  Cost Model: Found an estimated cost of 1 for instruction: %3 = sitofp <2 x i64> undef to <2 x double>
; RV64-NEXT:  Cost Model: Found an estimated cost of 1 for instruction: %4 = sitofp <4 x i64> undef to <4 x double>
; RV64-NEXT:  Cost Model: Found an estimated cost of 1 for instruction: %5 = sitofp <8 x i64> undef to <8 x double>
; RV64-NEXT:  Cost Model: Found an estimated cost of 1 for instruction: %6 = sitofp <16 x i64> undef to <16 x double>
; RV64-NEXT:  Cost Model: Found an estimated cost of 1 for instruction: %7 = sitofp <vscale x 1 x i64> undef to <vscale x 1 x double>
; RV64-NEXT:  Cost Model: Found an estimated cost of 1 for instruction: %8 = sitofp <vscale x 2 x i64> undef to <vscale x 2 x double>
; RV64-NEXT:  Cost Model: Found an estimated cost of 1 for instruction: %9 = sitofp <vscale x 4 x i64> undef to <vscale x 4 x double>
; RV64-NEXT:  Cost Model: Found an estimated cost of 1 for instruction: %10 = sitofp <vscale x 8 x i64> undef to <vscale x 8 x double>
; RV64-NEXT:  Cost Model: Found an estimated cost of 1 for instruction: %11 = call <1 x double> @llvm.vp.sitofp.v1f64.v1i64(<1 x i64> undef, <1 x i1> undef, i32 undef)
; RV64-NEXT:  Cost Model: Found an estimated cost of 1 for instruction: %12 = call <2 x double> @llvm.vp.sitofp.v2f64.v2i64(<2 x i64> undef, <2 x i1> undef, i32 undef)
; RV64-NEXT:  Cost Model: Found an estimated cost of 1 for instruction: %13 = call <4 x double> @llvm.vp.sitofp.v4f64.v4i64(<4 x i64> undef, <4 x i1> undef, i32 undef)
; RV64-NEXT:  Cost Model: Found an estimated cost of 1 for instruction: %14 = call <8 x double> @llvm.vp.sitofp.v8f64.v8i64(<8 x i64> undef, <8 x i1> undef, i32 undef)
; RV64-NEXT:  Cost Model: Found an estimated cost of 1 for instruction: %15 = call <16 x double> @llvm.vp.sitofp.v16f64.v16i64(<16 x i64> undef, <16 x i1> undef, i32 undef)
; RV64-NEXT:  Cost Model: Found an estimated cost of 1 for instruction: %16 = call <vscale x 1 x double> @llvm.vp.sitofp.nxv1f64.nxv1i64(<vscale x 1 x i64> undef, <vscale x 1 x i1> undef, i32 undef)
; RV64-NEXT:  Cost Model: Found an estimated cost of 1 for instruction: %17 = call <vscale x 2 x double> @llvm.vp.sitofp.nxv2f64.nxv2i64(<vscale x 2 x i64> undef, <vscale x 2 x i1> undef, i32 undef)
; RV64-NEXT:  Cost Model: Found an estimated cost of 1 for instruction: %18 = call <vscale x 4 x double> @llvm.vp.sitofp.nxv4f64.nxv4i64(<vscale x 4 x i64> undef, <vscale x 4 x i1> undef, i32 undef)
; RV64-NEXT:  Cost Model: Found an estimated cost of 1 for instruction: %19 = call <vscale x 8 x double> @llvm.vp.sitofp.nxv8f64.nxv8i64(<vscale x 8 x i64> undef, <vscale x 8 x i1> undef, i32 undef)
; RV64-NEXT:  Cost Model: Found an estimated cost of 0 for instruction: ret void
;
; RV64_TYPEBASED-LABEL: 'sitofp'
; RV64_TYPEBASED-NEXT:  Cost Model: Found an estimated cost of 1 for instruction: %1 = sitofp i64 undef to double
; RV64_TYPEBASED-NEXT:  Cost Model: Found an estimated cost of 1 for instruction: %2 = sitofp <1 x i64> undef to <1 x double>
; RV64_TYPEBASED-NEXT:  Cost Model: Found an estimated cost of 1 for instruction: %3 = sitofp <2 x i64> undef to <2 x double>
; RV64_TYPEBASED-NEXT:  Cost Model: Found an estimated cost of 1 for instruction: %4 = sitofp <4 x i64> undef to <4 x double>
; RV64_TYPEBASED-NEXT:  Cost Model: Found an estimated cost of 1 for instruction: %5 = sitofp <8 x i64> undef to <8 x double>
; RV64_TYPEBASED-NEXT:  Cost Model: Found an estimated cost of 1 for instruction: %6 = sitofp <16 x i64> undef to <16 x double>
; RV64_TYPEBASED-NEXT:  Cost Model: Found an estimated cost of 1 for instruction: %7 = sitofp <vscale x 1 x i64> undef to <vscale x 1 x double>
; RV64_TYPEBASED-NEXT:  Cost Model: Found an estimated cost of 1 for instruction: %8 = sitofp <vscale x 2 x i64> undef to <vscale x 2 x double>
; RV64_TYPEBASED-NEXT:  Cost Model: Found an estimated cost of 1 for instruction: %9 = sitofp <vscale x 4 x i64> undef to <vscale x 4 x double>
; RV64_TYPEBASED-NEXT:  Cost Model: Found an estimated cost of 1 for instruction: %10 = sitofp <vscale x 8 x i64> undef to <vscale x 8 x double>
; RV64_TYPEBASED-NEXT:  Cost Model: Found an estimated cost of 1 for instruction: %11 = call <1 x double> @llvm.vp.sitofp.v1f64.v1i64(<1 x i64> undef, <1 x i1> undef, i32 undef)
; RV64_TYPEBASED-NEXT:  Cost Model: Found an estimated cost of 1 for instruction: %12 = call <2 x double> @llvm.vp.sitofp.v2f64.v2i64(<2 x i64> undef, <2 x i1> undef, i32 undef)
; RV64_TYPEBASED-NEXT:  Cost Model: Found an estimated cost of 1 for instruction: %13 = call <4 x double> @llvm.vp.sitofp.v4f64.v4i64(<4 x i64> undef, <4 x i1> undef, i32 undef)
; RV64_TYPEBASED-NEXT:  Cost Model: Found an estimated cost of 1 for instruction: %14 = call <8 x double> @llvm.vp.sitofp.v8f64.v8i64(<8 x i64> undef, <8 x i1> undef, i32 undef)
; RV64_TYPEBASED-NEXT:  Cost Model: Found an estimated cost of 1 for instruction: %15 = call <16 x double> @llvm.vp.sitofp.v16f64.v16i64(<16 x i64> undef, <16 x i1> undef, i32 undef)
; RV64_TYPEBASED-NEXT:  Cost Model: Found an estimated cost of 1 for instruction: %16 = call <vscale x 1 x double> @llvm.vp.sitofp.nxv1f64.nxv1i64(<vscale x 1 x i64> undef, <vscale x 1 x i1> undef, i32 undef)
; RV64_TYPEBASED-NEXT:  Cost Model: Found an estimated cost of 1 for instruction: %17 = call <vscale x 2 x double> @llvm.vp.sitofp.nxv2f64.nxv2i64(<vscale x 2 x i64> undef, <vscale x 2 x i1> undef, i32 undef)
; RV64_TYPEBASED-NEXT:  Cost Model: Found an estimated cost of 1 for instruction: %18 = call <vscale x 4 x double> @llvm.vp.sitofp.nxv4f64.nxv4i64(<vscale x 4 x i64> undef, <vscale x 4 x i1> undef, i32 undef)
; RV64_TYPEBASED-NEXT:  Cost Model: Found an estimated cost of 1 for instruction: %19 = call <vscale x 8 x double> @llvm.vp.sitofp.nxv8f64.nxv8i64(<vscale x 8 x i64> undef, <vscale x 8 x i1> undef, i32 undef)
; RV64_TYPEBASED-NEXT:  Cost Model: Found an estimated cost of 0 for instruction: ret void
;
  sitofp i64 undef to double
  sitofp <1 x i64> undef to <1 x double>
  sitofp <2 x i64> undef to <2 x double>
  sitofp <4 x i64> undef to <4 x double>
  sitofp <8 x i64> undef to <8 x double>
  sitofp <16 x i64> undef to <16 x double>
  sitofp <vscale x 1 x i64> undef to <vscale x 1 x double>
  sitofp <vscale x 2 x i64> undef to <vscale x 2 x double>
  sitofp <vscale x 4 x i64> undef to <vscale x 4 x double>
  sitofp <vscale x 8 x i64> undef to <vscale x 8 x double>
  call <1 x double> @llvm.vp.sitofp.v1i64.v1double(<1 x i64> undef, <1 x i1> undef, i32 undef)
  call <2 x double> @llvm.vp.sitofp.v2i64.v2double(<2 x i64> undef, <2 x i1> undef, i32 undef)
  call <4 x double> @llvm.vp.sitofp.v4i64.v4double(<4 x i64> undef, <4 x i1> undef, i32 undef)
  call <8 x double> @llvm.vp.sitofp.v8i64.v8double(<8 x i64> undef, <8 x i1> undef, i32 undef)
  call <16 x double> @llvm.vp.sitofp.v16.v16(<16 x i64> undef, <16 x i1> undef, i32 undef)
  call <vscale x 1 x double> @llvm.vp.sitofp.nxv1i64.nxv1double(<vscale x 1 x i64> undef, <vscale x 1 x i1> undef, i32 undef)
  call <vscale x 2 x double> @llvm.vp.sitofp.nxv2i64.nxv2double(<vscale x 2 x i64> undef, <vscale x 2 x i1> undef, i32 undef)
  call <vscale x 4 x double> @llvm.vp.sitofp.nxv4i64.nxv4double(<vscale x 4 x i64> undef, <vscale x 4 x i1> undef, i32 undef)
  call <vscale x 8 x double> @llvm.vp.sitofp.nxv8i64.nxv8double(<vscale x 8 x i64> undef, <vscale x 8 x i1> undef, i32 undef)
  ret void
}
