; NOTE: Assertions have been autogenerated by utils/update_analyze_test_checks.py UTC_ARGS: --version 4
; RUN: opt < %s -mtriple=riscv32 -mattr=+v -passes="print<cost-model>" -cost-kind=throughput 2>&1 -disable-output --type-based-intrinsic-cost=true | FileCheck %s
; RUN: opt < %s -mtriple=riscv64 -mattr=+v -passes="print<cost-model>" -cost-kind=throughput 2>&1 -disable-output --type-based-intrinsic-cost=true | FileCheck %s
; RUN: opt < %s -mtriple=riscv32 -mattr=+v -passes="print<cost-model>" -cost-kind=code-size 2>&1 -disable-output --type-based-intrinsic-cost=true \
; RUN: | FileCheck %s --check-prefix=SIZE
; RUN: opt < %s -mtriple=riscv64 -mattr=+v -passes="print<cost-model>" -cost-kind=code-size 2>&1 -disable-output --type-based-intrinsic-cost=true \
; RUN: | FileCheck %s --check-prefix=SIZE

define float @reduce_fmaximum_f32(float %arg) {
; CHECK-LABEL: 'reduce_fmaximum_f32'
; CHECK-NEXT:  Cost Model: Found an estimated cost of 6 for instruction: %V2 = call float @llvm.vector.reduce.fminimum.v2f32(<2 x float> undef)
; CHECK-NEXT:  Cost Model: Found an estimated cost of 7 for instruction: %V4 = call float @llvm.vector.reduce.fminimum.v4f32(<4 x float> undef)
; CHECK-NEXT:  Cost Model: Found an estimated cost of 9 for instruction: %V8 = call float @llvm.vector.reduce.fminimum.v8f32(<8 x float> undef)
; CHECK-NEXT:  Cost Model: Found an estimated cost of 12 for instruction: %V16 = call float @llvm.vector.reduce.fminimum.v16f32(<16 x float> undef)
; CHECK-NEXT:  Cost Model: Found an estimated cost of 17 for instruction: %V32 = call float @llvm.vector.reduce.fminimum.v32f32(<32 x float> undef)
; CHECK-NEXT:  Cost Model: Found an estimated cost of 17 for instruction: %V64 = call float @llvm.vector.reduce.fminimum.v64f32(<64 x float> undef)
; CHECK-NEXT:  Cost Model: Found an estimated cost of 17 for instruction: %V128 = call float @llvm.vector.reduce.fminimum.v128f32(<128 x float> undef)
; CHECK-NEXT:  Cost Model: Found an estimated cost of 6 for instruction: %V2_vp = call float @llvm.vp.reduce.fminimum.v2f32(float 0.000000e+00, <2 x float> undef, <2 x i1> undef, i32 undef)
; CHECK-NEXT:  Cost Model: Found an estimated cost of 7 for instruction: %V4_vp = call float @llvm.vp.reduce.fminimum.v4f32(float 0.000000e+00, <4 x float> undef, <4 x i1> undef, i32 undef)
; CHECK-NEXT:  Cost Model: Found an estimated cost of 9 for instruction: %V8_vp = call float @llvm.vp.reduce.fminimum.v8f32(float 0.000000e+00, <8 x float> undef, <8 x i1> undef, i32 undef)
; CHECK-NEXT:  Cost Model: Found an estimated cost of 12 for instruction: %V16_vp = call float @llvm.vp.reduce.fminimum.v16f32(float 0.000000e+00, <16 x float> undef, <16 x i1> undef, i32 undef)
; CHECK-NEXT:  Cost Model: Found an estimated cost of 17 for instruction: %V32_vp = call float @llvm.vp.reduce.fminimum.v32f32(float 0.000000e+00, <32 x float> undef, <32 x i1> undef, i32 undef)
; CHECK-NEXT:  Cost Model: Found an estimated cost of 17 for instruction: %V64_vp = call float @llvm.vp.reduce.fminimum.v64f32(float 0.000000e+00, <64 x float> undef, <64 x i1> undef, i32 undef)
; CHECK-NEXT:  Cost Model: Found an estimated cost of 17 for instruction: %V128_vp = call float @llvm.vp.reduce.fminimum.v128f32(float 0.000000e+00, <128 x float> undef, <128 x i1> undef, i32 undef)
; CHECK-NEXT:  Cost Model: Found an estimated cost of 3 for instruction: %1 = call float @llvm.vp.reduce.fmin.v2f32(float 0.000000e+00, <2 x float> undef, <2 x i1> undef, i32 undef)
; CHECK-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: %2 = call float @llvm.vp.reduce.fmin.v4f32(float 0.000000e+00, <4 x float> undef, <4 x i1> undef, i32 undef)
; CHECK-NEXT:  Cost Model: Found an estimated cost of 5 for instruction: %3 = call float @llvm.vp.reduce.fmin.v8f32(float 0.000000e+00, <8 x float> undef, <8 x i1> undef, i32 undef)
; CHECK-NEXT:  Cost Model: Found an estimated cost of 6 for instruction: %4 = call float @llvm.vp.reduce.fmin.v16f32(float 0.000000e+00, <16 x float> undef, <16 x i1> undef, i32 undef)
; CHECK-NEXT:  Cost Model: Found an estimated cost of 7 for instruction: %5 = call float @llvm.vp.reduce.fmin.v32f32(float 0.000000e+00, <32 x float> undef, <32 x i1> undef, i32 undef)
; CHECK-NEXT:  Cost Model: Found an estimated cost of 15 for instruction: %6 = call float @llvm.vp.reduce.fmin.v64f32(float 0.000000e+00, <64 x float> undef, <64 x i1> undef, i32 undef)
; CHECK-NEXT:  Cost Model: Found an estimated cost of 31 for instruction: %7 = call float @llvm.vp.reduce.fmin.v128f32(float 0.000000e+00, <128 x float> undef, <128 x i1> undef, i32 undef)
; CHECK-NEXT:  Cost Model: Found an estimated cost of 0 for instruction: ret float undef
;
; SIZE-LABEL: 'reduce_fmaximum_f32'
; SIZE-NEXT:  Cost Model: Found an estimated cost of 7 for instruction: %V2 = call float @llvm.vector.reduce.fminimum.v2f32(<2 x float> undef)
; SIZE-NEXT:  Cost Model: Found an estimated cost of 7 for instruction: %V4 = call float @llvm.vector.reduce.fminimum.v4f32(<4 x float> undef)
; SIZE-NEXT:  Cost Model: Found an estimated cost of 7 for instruction: %V8 = call float @llvm.vector.reduce.fminimum.v8f32(<8 x float> undef)
; SIZE-NEXT:  Cost Model: Found an estimated cost of 7 for instruction: %V16 = call float @llvm.vector.reduce.fminimum.v16f32(<16 x float> undef)
; SIZE-NEXT:  Cost Model: Found an estimated cost of 7 for instruction: %V32 = call float @llvm.vector.reduce.fminimum.v32f32(<32 x float> undef)
; SIZE-NEXT:  Cost Model: Found an estimated cost of 7 for instruction: %V64 = call float @llvm.vector.reduce.fminimum.v64f32(<64 x float> undef)
; SIZE-NEXT:  Cost Model: Found an estimated cost of 7 for instruction: %V128 = call float @llvm.vector.reduce.fminimum.v128f32(<128 x float> undef)
; SIZE-NEXT:  Cost Model: Found an estimated cost of 7 for instruction: %V2_vp = call float @llvm.vp.reduce.fminimum.v2f32(float 0.000000e+00, <2 x float> undef, <2 x i1> undef, i32 undef)
; SIZE-NEXT:  Cost Model: Found an estimated cost of 7 for instruction: %V4_vp = call float @llvm.vp.reduce.fminimum.v4f32(float 0.000000e+00, <4 x float> undef, <4 x i1> undef, i32 undef)
; SIZE-NEXT:  Cost Model: Found an estimated cost of 7 for instruction: %V8_vp = call float @llvm.vp.reduce.fminimum.v8f32(float 0.000000e+00, <8 x float> undef, <8 x i1> undef, i32 undef)
; SIZE-NEXT:  Cost Model: Found an estimated cost of 7 for instruction: %V16_vp = call float @llvm.vp.reduce.fminimum.v16f32(float 0.000000e+00, <16 x float> undef, <16 x i1> undef, i32 undef)
; SIZE-NEXT:  Cost Model: Found an estimated cost of 7 for instruction: %V32_vp = call float @llvm.vp.reduce.fminimum.v32f32(float 0.000000e+00, <32 x float> undef, <32 x i1> undef, i32 undef)
; SIZE-NEXT:  Cost Model: Found an estimated cost of 7 for instruction: %V64_vp = call float @llvm.vp.reduce.fminimum.v64f32(float 0.000000e+00, <64 x float> undef, <64 x i1> undef, i32 undef)
; SIZE-NEXT:  Cost Model: Found an estimated cost of 7 for instruction: %V128_vp = call float @llvm.vp.reduce.fminimum.v128f32(float 0.000000e+00, <128 x float> undef, <128 x i1> undef, i32 undef)
; SIZE-NEXT:  Cost Model: Found an estimated cost of 3 for instruction: %1 = call float @llvm.vp.reduce.fmin.v2f32(float 0.000000e+00, <2 x float> undef, <2 x i1> undef, i32 undef)
; SIZE-NEXT:  Cost Model: Found an estimated cost of 3 for instruction: %2 = call float @llvm.vp.reduce.fmin.v4f32(float 0.000000e+00, <4 x float> undef, <4 x i1> undef, i32 undef)
; SIZE-NEXT:  Cost Model: Found an estimated cost of 3 for instruction: %3 = call float @llvm.vp.reduce.fmin.v8f32(float 0.000000e+00, <8 x float> undef, <8 x i1> undef, i32 undef)
; SIZE-NEXT:  Cost Model: Found an estimated cost of 3 for instruction: %4 = call float @llvm.vp.reduce.fmin.v16f32(float 0.000000e+00, <16 x float> undef, <16 x i1> undef, i32 undef)
; SIZE-NEXT:  Cost Model: Found an estimated cost of 3 for instruction: %5 = call float @llvm.vp.reduce.fmin.v32f32(float 0.000000e+00, <32 x float> undef, <32 x i1> undef, i32 undef)
; SIZE-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: %6 = call float @llvm.vp.reduce.fmin.v64f32(float 0.000000e+00, <64 x float> undef, <64 x i1> undef, i32 undef)
; SIZE-NEXT:  Cost Model: Found an estimated cost of 6 for instruction: %7 = call float @llvm.vp.reduce.fmin.v128f32(float 0.000000e+00, <128 x float> undef, <128 x i1> undef, i32 undef)
; SIZE-NEXT:  Cost Model: Found an estimated cost of 1 for instruction: ret float undef
;
%V2   = call float @llvm.vector.reduce.fminimum.v2f32(<2 x float> undef)
%V4   = call float @llvm.vector.reduce.fminimum.v4f32(<4 x float> undef)
%V8   = call float @llvm.vector.reduce.fminimum.v8f32(<8 x float> undef)
%V16   = call float @llvm.vector.reduce.fminimum.v16f32(<16 x float> undef)
%V32   = call float @llvm.vector.reduce.fminimum.v32f32(<32 x float> undef)
%V64   = call float @llvm.vector.reduce.fminimum.v64f32(<64 x float> undef)
%V128   = call float @llvm.vector.reduce.fminimum.v128f32(<128 x float> undef)

%V2_vp   = call float @llvm.vp.reduce.fminimum.v2f32(float 0.0, <2 x float> undef, <2 x i1> undef, i32 undef)
%V4_vp   = call float @llvm.vp.reduce.fminimum.v4f32(float 0.0, <4 x float> undef, <4 x i1> undef, i32 undef)
%V8_vp   = call float @llvm.vp.reduce.fminimum.v8f32(float 0.0, <8 x float> undef, <8 x i1> undef, i32 undef)
%V16_vp   = call float @llvm.vp.reduce.fminimum.v16f32(float 0.0, <16 x float> undef, <16 x i1> undef, i32 undef)
%V32_vp   = call float @llvm.vp.reduce.fminimum.v32f32(float 0.0, <32 x float> undef, <32 x i1> undef, i32 undef)
%V64_vp   = call float @llvm.vp.reduce.fminimum.v64f32(float 0.0, <64 x float> undef, <64 x i1> undef, i32 undef)
%V128_vp   = call float @llvm.vp.reduce.fminimum.v128f32(float 0.0, <128 x float> undef, <128 x i1> undef, i32 undef)

call float @llvm.vp.reduce.fmin.v2f32(float 0.0, <2 x float> undef, <2 x i1> undef, i32 undef)
call float @llvm.vp.reduce.fmin.v4f32(float 0.0, <4 x float> undef, <4 x i1> undef, i32 undef)
call float @llvm.vp.reduce.fmin.v8f32(float 0.0, <8 x float> undef, <8 x i1> undef, i32 undef)
call float @llvm.vp.reduce.fmin.v16f32(float 0.0, <16 x float> undef, <16 x i1> undef, i32 undef)
call float @llvm.vp.reduce.fmin.v32f32(float 0.0, <32 x float> undef, <32 x i1> undef, i32 undef)
call float @llvm.vp.reduce.fmin.v64f32(float 0.0, <64 x float> undef, <64 x i1> undef, i32 undef)
call float @llvm.vp.reduce.fmin.v128f32(float 0.0, <128 x float> undef, <128 x i1> undef, i32 undef)
ret float undef
}
declare float @llvm.vector.reduce.fminimum.v2f32(<2 x float>)
declare float @llvm.vector.reduce.fminimum.v4f32(<4 x float>)
declare float @llvm.vector.reduce.fminimum.v8f32(<8 x float>)
declare float @llvm.vector.reduce.fminimum.v16f32(<16 x float>)
declare float @llvm.vector.reduce.fminimum.v32f32(<32 x float>)
declare float @llvm.vector.reduce.fminimum.v64f32(<64 x float>)
declare float @llvm.vector.reduce.fminimum.v128f32(<128 x float>)

define double @reduce_fmaximum_f64(double %arg) {
; CHECK-LABEL: 'reduce_fmaximum_f64'
; CHECK-NEXT:  Cost Model: Found an estimated cost of 6 for instruction: %V2 = call double @llvm.vector.reduce.fminimum.v2f64(<2 x double> undef)
; CHECK-NEXT:  Cost Model: Found an estimated cost of 8 for instruction: %V4 = call double @llvm.vector.reduce.fminimum.v4f64(<4 x double> undef)
; CHECK-NEXT:  Cost Model: Found an estimated cost of 11 for instruction: %V8 = call double @llvm.vector.reduce.fminimum.v8f64(<8 x double> undef)
; CHECK-NEXT:  Cost Model: Found an estimated cost of 16 for instruction: %V16 = call double @llvm.vector.reduce.fminimum.v16f64(<16 x double> undef)
; CHECK-NEXT:  Cost Model: Found an estimated cost of 16 for instruction: %V32 = call double @llvm.vector.reduce.fminimum.v32f64(<32 x double> undef)
; CHECK-NEXT:  Cost Model: Found an estimated cost of 16 for instruction: %V64 = call double @llvm.vector.reduce.fminimum.v64f64(<64 x double> undef)
; CHECK-NEXT:  Cost Model: Found an estimated cost of 6 for instruction: %V2_vp = call double @llvm.vp.reduce.fminimum.v2f64(double 0.000000e+00, <2 x double> undef, <2 x i1> undef, i32 undef)
; CHECK-NEXT:  Cost Model: Found an estimated cost of 8 for instruction: %V4_vp = call double @llvm.vp.reduce.fminimum.v4f64(double 0.000000e+00, <4 x double> undef, <4 x i1> undef, i32 undef)
; CHECK-NEXT:  Cost Model: Found an estimated cost of 11 for instruction: %V8_vp = call double @llvm.vp.reduce.fminimum.v8f64(double 0.000000e+00, <8 x double> undef, <8 x i1> undef, i32 undef)
; CHECK-NEXT:  Cost Model: Found an estimated cost of 16 for instruction: %V16_vp = call double @llvm.vp.reduce.fminimum.v16f64(double 0.000000e+00, <16 x double> undef, <16 x i1> undef, i32 undef)
; CHECK-NEXT:  Cost Model: Found an estimated cost of 16 for instruction: %V32_vp = call double @llvm.vp.reduce.fminimum.v32f64(double 0.000000e+00, <32 x double> undef, <32 x i1> undef, i32 undef)
; CHECK-NEXT:  Cost Model: Found an estimated cost of 16 for instruction: %V64_vp = call double @llvm.vp.reduce.fminimum.v64f64(double 0.000000e+00, <64 x double> undef, <64 x i1> undef, i32 undef)
; CHECK-NEXT:  Cost Model: Found an estimated cost of 16 for instruction: %V128_vp = call double @llvm.vp.reduce.fminimum.v128f64(double 0.000000e+00, <128 x double> undef, <128 x i1> undef, i32 undef)
; CHECK-NEXT:  Cost Model: Found an estimated cost of 3 for instruction: %1 = call double @llvm.vp.reduce.fmin.v2f64(double 0.000000e+00, <2 x double> undef, <2 x i1> undef, i32 undef)
; CHECK-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: %2 = call double @llvm.vp.reduce.fmin.v4f64(double 0.000000e+00, <4 x double> undef, <4 x i1> undef, i32 undef)
; CHECK-NEXT:  Cost Model: Found an estimated cost of 5 for instruction: %3 = call double @llvm.vp.reduce.fmin.v8f64(double 0.000000e+00, <8 x double> undef, <8 x i1> undef, i32 undef)
; CHECK-NEXT:  Cost Model: Found an estimated cost of 6 for instruction: %4 = call double @llvm.vp.reduce.fmin.v16f64(double 0.000000e+00, <16 x double> undef, <16 x i1> undef, i32 undef)
; CHECK-NEXT:  Cost Model: Found an estimated cost of 14 for instruction: %5 = call double @llvm.vp.reduce.fmin.v32f64(double 0.000000e+00, <32 x double> undef, <32 x i1> undef, i32 undef)
; CHECK-NEXT:  Cost Model: Found an estimated cost of 30 for instruction: %6 = call double @llvm.vp.reduce.fmin.v64f64(double 0.000000e+00, <64 x double> undef, <64 x i1> undef, i32 undef)
; CHECK-NEXT:  Cost Model: Found an estimated cost of 62 for instruction: %7 = call double @llvm.vp.reduce.fmin.v128f64(double 0.000000e+00, <128 x double> undef, <128 x i1> undef, i32 undef)
; CHECK-NEXT:  Cost Model: Found an estimated cost of 0 for instruction: ret double undef
;
; SIZE-LABEL: 'reduce_fmaximum_f64'
; SIZE-NEXT:  Cost Model: Found an estimated cost of 7 for instruction: %V2 = call double @llvm.vector.reduce.fminimum.v2f64(<2 x double> undef)
; SIZE-NEXT:  Cost Model: Found an estimated cost of 7 for instruction: %V4 = call double @llvm.vector.reduce.fminimum.v4f64(<4 x double> undef)
; SIZE-NEXT:  Cost Model: Found an estimated cost of 7 for instruction: %V8 = call double @llvm.vector.reduce.fminimum.v8f64(<8 x double> undef)
; SIZE-NEXT:  Cost Model: Found an estimated cost of 7 for instruction: %V16 = call double @llvm.vector.reduce.fminimum.v16f64(<16 x double> undef)
; SIZE-NEXT:  Cost Model: Found an estimated cost of 7 for instruction: %V32 = call double @llvm.vector.reduce.fminimum.v32f64(<32 x double> undef)
; SIZE-NEXT:  Cost Model: Found an estimated cost of 7 for instruction: %V64 = call double @llvm.vector.reduce.fminimum.v64f64(<64 x double> undef)
; SIZE-NEXT:  Cost Model: Found an estimated cost of 7 for instruction: %V2_vp = call double @llvm.vp.reduce.fminimum.v2f64(double 0.000000e+00, <2 x double> undef, <2 x i1> undef, i32 undef)
; SIZE-NEXT:  Cost Model: Found an estimated cost of 7 for instruction: %V4_vp = call double @llvm.vp.reduce.fminimum.v4f64(double 0.000000e+00, <4 x double> undef, <4 x i1> undef, i32 undef)
; SIZE-NEXT:  Cost Model: Found an estimated cost of 7 for instruction: %V8_vp = call double @llvm.vp.reduce.fminimum.v8f64(double 0.000000e+00, <8 x double> undef, <8 x i1> undef, i32 undef)
; SIZE-NEXT:  Cost Model: Found an estimated cost of 7 for instruction: %V16_vp = call double @llvm.vp.reduce.fminimum.v16f64(double 0.000000e+00, <16 x double> undef, <16 x i1> undef, i32 undef)
; SIZE-NEXT:  Cost Model: Found an estimated cost of 7 for instruction: %V32_vp = call double @llvm.vp.reduce.fminimum.v32f64(double 0.000000e+00, <32 x double> undef, <32 x i1> undef, i32 undef)
; SIZE-NEXT:  Cost Model: Found an estimated cost of 7 for instruction: %V64_vp = call double @llvm.vp.reduce.fminimum.v64f64(double 0.000000e+00, <64 x double> undef, <64 x i1> undef, i32 undef)
; SIZE-NEXT:  Cost Model: Found an estimated cost of 7 for instruction: %V128_vp = call double @llvm.vp.reduce.fminimum.v128f64(double 0.000000e+00, <128 x double> undef, <128 x i1> undef, i32 undef)
; SIZE-NEXT:  Cost Model: Found an estimated cost of 3 for instruction: %1 = call double @llvm.vp.reduce.fmin.v2f64(double 0.000000e+00, <2 x double> undef, <2 x i1> undef, i32 undef)
; SIZE-NEXT:  Cost Model: Found an estimated cost of 3 for instruction: %2 = call double @llvm.vp.reduce.fmin.v4f64(double 0.000000e+00, <4 x double> undef, <4 x i1> undef, i32 undef)
; SIZE-NEXT:  Cost Model: Found an estimated cost of 3 for instruction: %3 = call double @llvm.vp.reduce.fmin.v8f64(double 0.000000e+00, <8 x double> undef, <8 x i1> undef, i32 undef)
; SIZE-NEXT:  Cost Model: Found an estimated cost of 3 for instruction: %4 = call double @llvm.vp.reduce.fmin.v16f64(double 0.000000e+00, <16 x double> undef, <16 x i1> undef, i32 undef)
; SIZE-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: %5 = call double @llvm.vp.reduce.fmin.v32f64(double 0.000000e+00, <32 x double> undef, <32 x i1> undef, i32 undef)
; SIZE-NEXT:  Cost Model: Found an estimated cost of 6 for instruction: %6 = call double @llvm.vp.reduce.fmin.v64f64(double 0.000000e+00, <64 x double> undef, <64 x i1> undef, i32 undef)
; SIZE-NEXT:  Cost Model: Found an estimated cost of 10 for instruction: %7 = call double @llvm.vp.reduce.fmin.v128f64(double 0.000000e+00, <128 x double> undef, <128 x i1> undef, i32 undef)
; SIZE-NEXT:  Cost Model: Found an estimated cost of 1 for instruction: ret double undef
;
%V2   = call double @llvm.vector.reduce.fminimum.v2f64(<2 x double> undef)
%V4   = call double @llvm.vector.reduce.fminimum.v4f64(<4 x double> undef)
%V8   = call double @llvm.vector.reduce.fminimum.v8f64(<8 x double> undef)
%V16   = call double @llvm.vector.reduce.fminimum.v16f64(<16 x double> undef)
%V32   = call double @llvm.vector.reduce.fminimum.v32f64(<32 x double> undef)
%V64   = call double @llvm.vector.reduce.fminimum.v64f64(<64 x double> undef)

%V2_vp   = call double @llvm.vp.reduce.fminimum.v2f64(double 0.0, <2 x double> undef, <2 x i1> undef, i32 undef)
%V4_vp   = call double @llvm.vp.reduce.fminimum.v4f64(double 0.0, <4 x double> undef, <4 x i1> undef, i32 undef)
%V8_vp   = call double @llvm.vp.reduce.fminimum.v8f64(double 0.0, <8 x double> undef, <8 x i1> undef, i32 undef)
%V16_vp   = call double @llvm.vp.reduce.fminimum.v16f64(double 0.0, <16 x double> undef, <16 x i1> undef, i32 undef)
%V32_vp   = call double @llvm.vp.reduce.fminimum.v32f64(double 0.0, <32 x double> undef, <32 x i1> undef, i32 undef)
%V64_vp   = call double @llvm.vp.reduce.fminimum.v64f64(double 0.0, <64 x double> undef, <64 x i1> undef, i32 undef)
%V128_vp   = call double @llvm.vp.reduce.fminimum.v128f64(double 0.0, <128 x double> undef, <128 x i1> undef, i32 undef)

call double @llvm.vp.reduce.fmin.v2f64(double 0.0, <2 x double> undef, <2 x i1> undef, i32 undef)
call double @llvm.vp.reduce.fmin.v4f64(double 0.0, <4 x double> undef, <4 x i1> undef, i32 undef)
call double @llvm.vp.reduce.fmin.v8f64(double 0.0, <8 x double> undef, <8 x i1> undef, i32 undef)
call double @llvm.vp.reduce.fmin.v16f64(double 0.0, <16 x double> undef, <16 x i1> undef, i32 undef)
call double @llvm.vp.reduce.fmin.v32f64(double 0.0, <32 x double> undef, <32 x i1> undef, i32 undef)
call double @llvm.vp.reduce.fmin.v64f64(double 0.0, <64 x double> undef, <64 x i1> undef, i32 undef)
call double @llvm.vp.reduce.fmin.v128f64(double 0.0, <128 x double> undef, <128 x i1> undef, i32 undef)
ret double undef
}
declare double @llvm.vector.reduce.fminimum.v2f64(<2 x double>)
declare double @llvm.vector.reduce.fminimum.v4f64(<4 x double>)
declare double @llvm.vector.reduce.fminimum.v8f64(<8 x double>)
declare double @llvm.vector.reduce.fminimum.v16f64(<16 x double>)
declare double @llvm.vector.reduce.fminimum.v32f64(<32 x double>)
declare double @llvm.vector.reduce.fminimum.v64f64(<64 x double>)
