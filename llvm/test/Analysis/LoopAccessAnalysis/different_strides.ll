; NOTE: Assertions have been autogenerated by utils/update_analyze_test_checks.py UTC_ARGS: --version 5
; RUN: opt --disable-output -mtriple=x86_64 --passes="print<access-info>" %s 2>&1 | FileCheck %s

@a = dso_local local_unnamed_addr global [65536 x float] zeroinitializer, align 16

; Equivalent C code for the test case:
; #define LEN 256 * 256
; float a[LEN];

; void different_strides() {
;   for (int i = 0; i < LEN - 1024 - 255; i++) {
;   #pragma clang loop interleave(disable)
;   #pragma clang loop unroll(disable)
;     for (int j = 0; j < 256; j++)
;       a[i + j + 1024] += a[j * 4 + i];
;   }
; }
define dso_local void @different_strides() local_unnamed_addr {
; CHECK-LABEL: 'different_strides'
; CHECK-NEXT:    for.body4:
; CHECK-NEXT:      Memory dependences are safe with a maximum safe vector width of 2048 bits
; CHECK-NEXT:      Dependences:
; CHECK-NEXT:        BackwardVectorizable:
; CHECK-NEXT:            %3 = load float, ptr %arrayidx, align 4 ->
; CHECK-NEXT:            store float %add9, ptr %arrayidx8, align 4
; CHECK-EMPTY:
; CHECK-NEXT:        Forward:
; CHECK-NEXT:            %5 = load float, ptr %arrayidx8, align 4 ->
; CHECK-NEXT:            store float %add9, ptr %arrayidx8, align 4
; CHECK-EMPTY:
; CHECK-NEXT:      Run-time memory checks:
; CHECK-NEXT:      Grouped accesses:
; CHECK-EMPTY:
; CHECK-NEXT:      Non vectorizable stores to invariant address were not found in loop.
; CHECK-NEXT:      SCEV assumptions:
; CHECK-EMPTY:
; CHECK-NEXT:      Expressions re-written:
; CHECK-NEXT:    for.cond1.preheader:
; CHECK-NEXT:      Report: loop is not the innermost loop
; CHECK-NEXT:      Dependences:
; CHECK-NEXT:      Run-time memory checks:
; CHECK-NEXT:      Grouped accesses:
; CHECK-EMPTY:
; CHECK-NEXT:      Non vectorizable stores to invariant address were not found in loop.
; CHECK-NEXT:      SCEV assumptions:
; CHECK-EMPTY:
; CHECK-NEXT:      Expressions re-written:
;
entry:
  br label %for.cond1.preheader

for.cond1.preheader:
  %indvars.iv25 = phi i64 [ 0, %entry ], [ %indvars.iv.next26, %for.cond.cleanup3 ]
  %0 = add nuw nsw i64 %indvars.iv25, 1024
  br label %for.body4

for.cond.cleanup:
  ret void

for.cond.cleanup3:
  %indvars.iv.next26 = add nuw nsw i64 %indvars.iv25, 1
  %exitcond29.not = icmp eq i64 %indvars.iv.next26, 64257
  br i1 %exitcond29.not, label %for.cond.cleanup, label %for.cond1.preheader

for.body4:
  %indvars.iv = phi i64 [ 0, %for.cond1.preheader ], [ %indvars.iv.next, %for.body4 ]
  %1 = shl nuw nsw i64 %indvars.iv, 2
  %2 = add nuw nsw i64 %1, %indvars.iv25
  %arrayidx = getelementptr inbounds [65536 x float], ptr @a, i64 0, i64 %2
  %3 = load float, ptr %arrayidx, align 4
  %4 = add nuw nsw i64 %0, %indvars.iv
  %arrayidx8 = getelementptr inbounds [65536 x float], ptr @a, i64 0, i64 %4
  %5 = load float, ptr %arrayidx8, align 4
  %add9 = fadd fast float %5, %3
  store float %add9, ptr %arrayidx8, align 4
  %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1
  %exitcond.not = icmp eq i64 %indvars.iv.next, 256
  br i1 %exitcond.not, label %for.cond.cleanup3, label %for.body4
}

