; NOTE: Assertions have been autogenerated by utils/update_llc_test_checks.py UTC_ARGS: --version 5
; RUN: llc -mtriple=thumbv7em-eabi -mcpu=cortex-m7 -verify-machineinstrs %s -o - | FileCheck %s

@d = external global [64 x i32]
@s = external global [64 x i32]
@d_32 = external global[32 x i32]
@s_32 = external global[32 x i32]


; Function Attrs: nounwind
define void @t1() #0 {
; CHECK-LABEL: t1:
; CHECK:       @ %bb.0: @ %entry
; CHECK-NEXT:    movw r0, :lower16:d
; CHECK-NEXT:    movw r2, :lower16:s
; CHECK-NEXT:    movt r0, :upper16:d
; CHECK-NEXT:    movt r2, :upper16:s
; CHECK-NEXT:    ldr r1, [r0]
; CHECK-NEXT:    str r1, [r2]
; CHECK-NEXT:    ldr r3, [r0, #4]
; CHECK-NEXT:    str r3, [r2, #4]
; CHECK-NEXT:    ldr r1, [r0, #8]
; CHECK-NEXT:    ldr r3, [r0, #12]
; CHECK-NEXT:    ldrb r0, [r0, #16]
; CHECK-NEXT:    strd r1, r3, [r2, #8]
; CHECK-NEXT:    strb r0, [r2, #16]
; CHECK-NEXT:    bx lr
entry:
; We use '[rl0-9]+' to allow 'r0'..'r12', 'lr'
    tail call void @llvm.memcpy.p0i8.p0i8.i32(i8* bitcast ([64 x i32]* @s to i8*), i8* bitcast ([64 x i32]* @d to i8*), i32 17, i32 4, i1 false)
    ret void
}

; Function Attrs: nounwind
define void @t2() #0 {
; CHECK-LABEL: t2:
; CHECK:       @ %bb.0: @ %entry
; CHECK-NEXT:    movw r0, :lower16:d
; CHECK-NEXT:    movw r1, :lower16:s
; CHECK-NEXT:    movt r0, :upper16:d
; CHECK-NEXT:    movt r1, :upper16:s
; CHECK-NEXT:    ldr.w r2, [r0, #11]
; CHECK-NEXT:    str.w r2, [r1, #11]
; CHECK-NEXT:    ldr r2, [r0]
; CHECK-NEXT:    str r2, [r1]
; CHECK-NEXT:    ldr r2, [r0, #4]
; CHECK-NEXT:    str r2, [r1, #4]
; CHECK-NEXT:    ldr r0, [r0, #8]
; CHECK-NEXT:    str r0, [r1, #8]
; CHECK-NEXT:    bx lr
entry:
    tail call void @llvm.memcpy.p0i8.p0i8.i32(i8* bitcast ([64 x i32]* @s to i8*), i8* bitcast ([64 x i32]* @d to i8*), i32 15, i32 4, i1 false)
    ret void
}

; Function Attrs: nounwind
declare void @llvm.memcpy.p0i8.p0i8.i32(i8* nocapture, i8* nocapture readonly, i32, i32, i1) #1


define void @t3() #0 {
; CHECK-LABEL: t3:
; CHECK:       @ %bb.0:
; CHECK-NEXT:    movw r0, :lower16:d_32
; CHECK-NEXT:    movw r2, :lower16:s_32
; CHECK-NEXT:    movt r0, :upper16:d_32
; CHECK-NEXT:    movt r2, :upper16:s_32
; CHECK-NEXT:    ldr r1, [r0]
; CHECK-NEXT:    str r1, [r2]
; CHECK-NEXT:    ldr r3, [r0, #4]
; CHECK-NEXT:    str r3, [r2, #4]
; CHECK-NEXT:    ldr r1, [r0, #8]
; CHECK-NEXT:    ldr r3, [r0, #12]
; CHECK-NEXT:    ldrb r0, [r0, #16]
; CHECK-NEXT:    strd r1, r3, [r2, #8]
; CHECK-NEXT:    strb r0, [r2, #16]
; CHECK-NEXT:    bx lr
    tail call void @llvm.memcpy.p0i8.p0i8.i32(i8* bitcast ([32 x i32]* @s_32 to i8*), i8* bitcast ([32 x i32]* @d_32 to i8*), i32 17, i32 4, i1 false)
    ret void
}

define void @t4() #0 {
; CHECK-LABEL: t4:
; CHECK:       @ %bb.0:
; CHECK-NEXT:    movw r0, :lower16:d_32
; CHECK-NEXT:    movw r1, :lower16:s_32
; CHECK-NEXT:    movt r0, :upper16:d_32
; CHECK-NEXT:    movt r1, :upper16:s_32
; CHECK-NEXT:    ldr.w r2, [r0, #11]
; CHECK-NEXT:    str.w r2, [r1, #11]
; CHECK-NEXT:    ldr r2, [r0]
; CHECK-NEXT:    str r2, [r1]
; CHECK-NEXT:    ldr r2, [r0, #4]
; CHECK-NEXT:    str r2, [r1, #4]
; CHECK-NEXT:    ldr r0, [r0, #8]
; CHECK-NEXT:    str r0, [r1, #8]
; CHECK-NEXT:    bx lr
    tail call void @llvm.memcpy.p0i8.p0i8.i32(i8* bitcast ([32 x i32]* @s_32 to i8*), i8* bitcast ([32 x i32]* @d_32 to i8*), i32 15, i32 4, i1 false)
    ret void
}

define void @t5() #0 {
; CHECK-LABEL: t5:
; CHECK:       @ %bb.0: @ %entry
; CHECK-NEXT:    .save {r4, r5, r7, lr}
; CHECK-NEXT:    push {r4, r5, r7, lr}
; CHECK-NEXT:    movw r0, :lower16:d
; CHECK-NEXT:    movw r1, :lower16:s
; CHECK-NEXT:    movt r0, :upper16:d
; CHECK-NEXT:    movt r1, :upper16:s
; CHECK-NEXT:    ldr r0, [r0]
; CHECK-NEXT:    ldr r1, [r1]
; CHECK-NEXT:    add.w r12, r0, #12
; CHECK-NEXT:    ldr r3, [r0, #24]
; CHECK-NEXT:    ldrd r2, lr, [r0, #4]
; CHECK-NEXT:    ldm.w r12, {r4, r5, r12}
; CHECK-NEXT:    str r3, [r1, #24]
; CHECK-NEXT:    add.w r3, r1, #12
; CHECK-NEXT:    strd r2, lr, [r1, #4]
; CHECK-NEXT:    stm.w r3, {r4, r5, r12}
; CHECK-NEXT:    ldr r0, [r0, #28]
; CHECK-NEXT:    str r0, [r1, #28]
; CHECK-NEXT:    pop {r4, r5, r7, pc}
entry:
  %0 = load i32*, i32** @s, align 4
  %arrayidx = getelementptr inbounds i32, i32* %0, i32 1
  %1 = bitcast i32* %arrayidx to i8*
  %2 = load i32*, i32** @d, align 4
  %arrayidx1 = getelementptr inbounds i32, i32* %2, i32 1
  %3 = bitcast i32* %arrayidx1 to i8*
  tail call void @llvm.memcpy.p0i8.p0i8.i32(i8* %1, i8* %3, i32 28, i32 4, i1 false)
  ret void
}

define void @t6() #0 {
; CHECK-LABEL: t6:
; CHECK:       @ %bb.0: @ %entry
; CHECK-NEXT:    .save {r4, r5, r7, lr}
; CHECK-NEXT:    push {r4, r5, r7, lr}
; CHECK-NEXT:    movw r0, :lower16:d
; CHECK-NEXT:    movw r1, :lower16:s
; CHECK-NEXT:    movt r0, :upper16:d
; CHECK-NEXT:    movt r1, :upper16:s
; CHECK-NEXT:    ldr r0, [r0]
; CHECK-NEXT:    ldr r1, [r1]
; CHECK-NEXT:    add.w r12, r0, #12
; CHECK-NEXT:    ldr r3, [r0, #24]
; CHECK-NEXT:    ldrd r2, lr, [r0, #4]
; CHECK-NEXT:    ldm.w r12, {r4, r5, r12}
; CHECK-NEXT:    str r3, [r1, #24]
; CHECK-NEXT:    add.w r3, r1, #12
; CHECK-NEXT:    strd r2, lr, [r1, #4]
; CHECK-NEXT:    stm.w r3, {r4, r5, r12}
; CHECK-NEXT:    ldr r0, [r0, #28]
; CHECK-NEXT:    str r0, [r1, #28]
; CHECK-NEXT:    pop {r4, r5, r7, pc}
entry:
  %0 = load i32*, i32** @s, align 8
  %arrayidx = getelementptr inbounds i32, i32* %0, i32 1
  %1 = bitcast i32* %arrayidx to i8*
  %2 = load i32*, i32** @d, align 8
  %arrayidx1 = getelementptr inbounds i32, i32* %2, i32 1
  %3 = bitcast i32* %arrayidx1 to i8*
  tail call void @llvm.memcpy.p0i8.p0i8.i32(i8* %1, i8* %3, i32 28, i32 4, i1 false)
  ret void
}
