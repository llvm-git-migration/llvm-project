; NOTE: Assertions have been autogenerated by utils/update_mir_test_checks.py UTC_ARGS: --version 3
; RUN: llc -global-isel -stop-after=irtranslator -mtriple=amdgcn-- -mcpu=gfx900 -verify-machineinstrs -o - %s | FileCheck %s

define i32 @basic(i32 %src) #1 {
  ; CHECK-LABEL: name: basic
  ; CHECK: bb.1 (%ir-block.0):
  ; CHECK-NEXT:   liveins: $vgpr0
  ; CHECK-NEXT: {{  $}}
  ; CHECK-NEXT:   [[COPY:%[0-9]+]]:_(s32) = COPY $vgpr0
  ; CHECK-NEXT:   [[CONVERGENCECTRL_ANCHOR:%[0-9]+]]:_(s0) = CONVERGENCECTRL_ANCHOR
  ; CHECK-NEXT:   [[INTRINSIC_CONVERGENT:%[0-9]+]]:_(s32) = G_INTRINSIC_CONVERGENT intrinsic(@llvm.amdgcn.readfirstlane), [[COPY]](s32), implicit [[CONVERGENCECTRL_ANCHOR]](s0)
  ; CHECK-NEXT:   $vgpr0 = COPY [[INTRINSIC_CONVERGENT]](s32)
  ; CHECK-NEXT:   SI_RETURN implicit $vgpr0
  %t = call token @llvm.experimental.convergence.anchor()
  %r = call i32 @llvm.amdgcn.readfirstlane(i32 %src) [ "convergencectrl"(token %t) ]
  ret i32 %r
}

define i32 @nested(i32 %src) #0 {
  ; CHECK-LABEL: name: nested
  ; CHECK: bb.1 (%ir-block.0):
  ; CHECK-NEXT:   liveins: $vgpr0
  ; CHECK-NEXT: {{  $}}
  ; CHECK-NEXT:   [[COPY:%[0-9]+]]:_(s32) = COPY $vgpr0
  ; CHECK-NEXT:   [[CONVERGENCECTRL_ENTRY:%[0-9]+]]:_(s0) = CONVERGENCECTRL_ENTRY
  ; CHECK-NEXT:   [[CONVERGENCECTRL_ANCHOR:%[0-9]+]]:_(s0) = CONVERGENCECTRL_ANCHOR
  ; CHECK-NEXT:   [[INTRINSIC_CONVERGENT:%[0-9]+]]:_(s32) = G_INTRINSIC_CONVERGENT intrinsic(@llvm.amdgcn.readfirstlane), [[COPY]](s32), implicit [[CONVERGENCECTRL_ANCHOR]](s0)
  ; CHECK-NEXT:   [[INTRINSIC_CONVERGENT1:%[0-9]+]]:_(s32) = G_INTRINSIC_CONVERGENT intrinsic(@llvm.amdgcn.readfirstlane), [[COPY]](s32), implicit [[CONVERGENCECTRL_ENTRY]](s0)
  ; CHECK-NEXT:   [[ADD:%[0-9]+]]:_(s32) = G_ADD [[INTRINSIC_CONVERGENT1]], [[INTRINSIC_CONVERGENT]]
  ; CHECK-NEXT:   $vgpr0 = COPY [[ADD]](s32)
  ; CHECK-NEXT:   SI_RETURN implicit $vgpr0
  %t1 = call token @llvm.experimental.convergence.entry()
  %t2 = call token @llvm.experimental.convergence.anchor()
  %r2 = call i32 @llvm.amdgcn.readfirstlane(i32 %src) [ "convergencectrl"(token %t2) ]
  %r1 = call i32 @llvm.amdgcn.readfirstlane(i32 %src) [ "convergencectrl"(token %t1) ]
  %sum = add i32 %r1, %r2
  ret i32 %sum
}

define i32 @trivial_heart(i32 %src) #1 {
bb1:
  %t1 = call token @llvm.experimental.convergence.anchor()
  br label %bb2

bb2:
  %t2 = call token @llvm.experimental.convergence.loop() [ "convergencectrl"(token %t1) ]
  %r = call i32 @llvm.amdgcn.readfirstlane(i32 %src) [ "convergencectrl"(token %t2) ]
  ret i32 %r
}

;; FIXME: Cannot test lowering of convergence control in the presence of
;; branches because the backend emits control flow pseudos such as SI_IF that
;; are marked convergent. These must also assigned convergence control tokens,
;; to satisfy the requirement that controlled and uncontrolled operations cannot
;; be mixed.
;; define i32 @branch(i32 %src, i1 %cond) #1 {
;; bb1:
;;   %t = call token @llvm.experimental.convergence.anchor()
;;   br i1 %cond, label %bb2, label %bb3
;;
;; bb2:
;;   %r2 = call i32 @llvm.amdgcn.readfirstlane(i32 %src) [ "convergencectrl"(token %t) ]
;;   br label %bb4
;;
;; bb3:
;;   %r3 = call i32 @llvm.amdgcn.readfirstlane(i32 %src) [ "convergencectrl"(token %t) ]
;;   br label %bb4
;;
;; bb4:
;;   %p = phi i32 [%r2, %bb2], [%r3, %bb3]
;;   ret i32 %p
;; }

;; TODO: Write tests using natural loops.

declare i32 @llvm.amdgcn.readfirstlane(i32) #0

declare token @llvm.experimental.convergence.entry()
declare token @llvm.experimental.convergence.anchor()
declare token @llvm.experimental.convergence.loop()

attributes #0 = { nounwind readnone convergent }
attributes #1 = { nounwind }
