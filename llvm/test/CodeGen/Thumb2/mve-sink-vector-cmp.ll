; NOTE: Assertions have been autogenerated by utils/update_llc_test_checks.py UTC_ARGS: --version 5
; RUN: llc -mtriple=thumbv8.1m.main -mattr=+mve.fp,+fp-armv8d16sp,+fp16,+fullfp16 < %s | FileCheck %s

define arm_aapcs_vfpcc void @vector_loop_with_icmp(ptr nocapture noundef writeonly %dest) {
; CHECK-LABEL: vector_loop_with_icmp:
; CHECK:       @ %bb.0: @ %entry
; CHECK-NEXT:    push.w {r4, r5, r6, r7, r8, r9, lr}
; CHECK-NEXT:    adr r1, .LCPI0_0
; CHECK-NEXT:    adr r2, .LCPI0_1
; CHECK-NEXT:    vldrw.u32 q0, [r1]
; CHECK-NEXT:    vldrw.u32 q1, [r2]
; CHECK-NEXT:    movs r1, #0
; CHECK-NEXT:    mov.w r12, #1
; CHECK-NEXT:    mov.w lr, #0
; CHECK-NEXT:  .LBB0_1: @ %vector.body
; CHECK-NEXT:    @ =>This Inner Loop Header: Depth=1
; CHECK-NEXT:    vmov r2, r3, d0
; CHECK-NEXT:    vmov r4, r5, d3
; CHECK-NEXT:    vmov r6, r7, d1
; CHECK-NEXT:    subs r2, #15
; CHECK-NEXT:    sbcs r2, r3, #0
; CHECK-NEXT:    cset r2, lo
; CHECK-NEXT:    cmp r2, #0
; CHECK-NEXT:    vmov r2, r3, d1
; CHECK-NEXT:    it ne
; CHECK-NEXT:    strne.w r12, [r0, r1, lsl #2]
; CHECK-NEXT:    subs r2, #15
; CHECK-NEXT:    sbcs r2, r3, #0
; CHECK-NEXT:    cset r2, lo
; CHECK-NEXT:    cmp r2, #0
; CHECK-NEXT:    itt ne
; CHECK-NEXT:    orrne r2, r1, #1
; CHECK-NEXT:    strne.w r12, [r0, r2, lsl #2]
; CHECK-NEXT:    vmov r2, r3, d2
; CHECK-NEXT:    subs r2, #15
; CHECK-NEXT:    sbcs r2, r3, #0
; CHECK-NEXT:    cset r2, lo
; CHECK-NEXT:    cmp r2, #0
; CHECK-NEXT:    itt ne
; CHECK-NEXT:    orrne r2, r1, #2
; CHECK-NEXT:    strne.w r12, [r0, r2, lsl #2]
; CHECK-NEXT:    vmov r2, r3, d3
; CHECK-NEXT:    subs r2, #15
; CHECK-NEXT:    sbcs r2, r3, #0
; CHECK-NEXT:    cset r2, lo
; CHECK-NEXT:    cmp r2, #0
; CHECK-NEXT:    itt ne
; CHECK-NEXT:    orrne r2, r1, #3
; CHECK-NEXT:    strne.w r12, [r0, r2, lsl #2]
; CHECK-NEXT:    vmov r2, r3, d2
; CHECK-NEXT:    adds r1, #4
; CHECK-NEXT:    adc lr, lr, #0
; CHECK-NEXT:    adds.w r9, r2, #4
; CHECK-NEXT:    adc r8, r3, #0
; CHECK-NEXT:    vmov r3, r2, d0
; CHECK-NEXT:    adds r4, #4
; CHECK-NEXT:    adc r5, r5, #0
; CHECK-NEXT:    adds r6, #4
; CHECK-NEXT:    adc r7, r7, #0
; CHECK-NEXT:    vmov q1[2], q1[0], r9, r4
; CHECK-NEXT:    vmov q1[3], q1[1], r8, r5
; CHECK-NEXT:    adds r3, #4
; CHECK-NEXT:    vmov q0[2], q0[0], r3, r6
; CHECK-NEXT:    adc r2, r2, #0
; CHECK-NEXT:    vmov q0[3], q0[1], r2, r7
; CHECK-NEXT:    eor r2, r1, #16
; CHECK-NEXT:    orrs.w r2, r2, lr
; CHECK-NEXT:    bne .LBB0_1
; CHECK-NEXT:  @ %bb.2: @ %for.cond.cleanup
; CHECK-NEXT:    pop.w {r4, r5, r6, r7, r8, r9, pc}
; CHECK-NEXT:    .p2align 4
; CHECK-NEXT:  @ %bb.3:
; CHECK-NEXT:  .LCPI0_0:
; CHECK-NEXT:    .long 0 @ 0x0
; CHECK-NEXT:    .long 0 @ 0x0
; CHECK-NEXT:    .long 1 @ 0x1
; CHECK-NEXT:    .long 0 @ 0x0
; CHECK-NEXT:  .LCPI0_1:
; CHECK-NEXT:    .long 2 @ 0x2
; CHECK-NEXT:    .long 0 @ 0x0
; CHECK-NEXT:    .long 3 @ 0x3
; CHECK-NEXT:    .long 0 @ 0x0
entry:
  br label %vector.body

vector.body:
  %index = phi i64 [ 0, %entry ], [ %index.next, %pred.store.continue18 ]
  %vec.ind = phi <4 x i64> [ <i64 0, i64 1, i64 2, i64 3>, %entry ], [ %vec.ind.next, %pred.store.continue18 ]
  %0 = icmp ult <4 x i64> %vec.ind, <i64 15, i64 15, i64 15, i64 15>
  %1 = extractelement <4 x i1> %0, i64 0
  br i1 %1, label %pred.store.if, label %pred.store.continue

pred.store.if:
  %2 = getelementptr inbounds i32, ptr %dest, i64 %index
  store i32 1, ptr %2, align 4
  br label %pred.store.continue

pred.store.continue:
  %3 = extractelement <4 x i1> %0, i64 1
  br i1 %3, label %pred.store.if5, label %pred.store.continue6

pred.store.if5:
  %4 = or disjoint i64 %index, 1
  %5 = getelementptr inbounds i32, ptr %dest, i64 %4
  store i32 1, ptr %5, align 4
  br label %pred.store.continue6

pred.store.continue6:
  %6 = extractelement <4 x i1> %0, i64 2
  br i1 %6, label %pred.store.if7, label %pred.store.continue8

pred.store.if7:
  %7 = or disjoint i64 %index, 2
  %8 = getelementptr inbounds i32, ptr %dest, i64 %7
  store i32 1, ptr %8, align 4
  br label %pred.store.continue8

pred.store.continue8:
  %9 = extractelement <4 x i1> %0, i64 3
  br i1 %9, label %pred.store.if9, label %pred.store.continue18

pred.store.if9:
  %10 = or disjoint i64 %index, 3
  %11 = getelementptr inbounds i32, ptr %dest, i64 %10
  store i32 1, ptr %11, align 4
  br label %pred.store.continue18

pred.store.continue18:
  %index.next = add i64 %index, 4
  %vec.ind.next = add <4 x i64> %vec.ind, <i64 4, i64 4, i64 4, i64 4>
  %24 = icmp eq i64 %index.next, 16
  br i1 %24, label %for.cond.cleanup, label %vector.body

for.cond.cleanup:
  ret void
}
