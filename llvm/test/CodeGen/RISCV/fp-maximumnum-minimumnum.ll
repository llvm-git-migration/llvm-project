; NOTE: Assertions have been autogenerated by utils/update_llc_test_checks.py
; RUN: llc --mtriple=riscv32 --mattr=+f,-d < %s | FileCheck %s --check-prefix=RV32F
; RUN: llc --mtriple=riscv32 --mattr=+d < %s | FileCheck %s --check-prefix=RV32D
; RUN: llc --mtriple=riscv64 --mattr=+f,-d < %s | FileCheck %s --check-prefix=RV64F
; RUN: llc --mtriple=riscv64 --mattr=+d < %s | FileCheck %s --check-prefix=RV64D

declare float @llvm.maximumnum.f32(float, float)
declare double @llvm.maximumnum.f64(double, double)
declare float @llvm.minimumnum.f32(float, float)
declare double @llvm.minimumnum.f64(double, double)

define float @maximumnum_float(float %x, float %y) {
;
; RV32F-LABEL: maximumnum_float:
; RV32F:       # %bb.0:
; RV32F-NEXT:    fmax.s fa0, fa0, fa1
; RV32F-NEXT:    ret
;
; RV32D-LABEL: maximumnum_float:
; RV32D:       # %bb.0:
; RV32D-NEXT:    fmax.s fa0, fa0, fa1
; RV32D-NEXT:    ret
;
; RV64F-LABEL: maximumnum_float:
; RV64F:       # %bb.0:
; RV64F-NEXT:    fmax.s fa0, fa0, fa1
; RV64F-NEXT:    ret
;
; RV64D-LABEL: maximumnum_float:
; RV64D:       # %bb.0:
; RV64D-NEXT:    fmax.s fa0, fa0, fa1
; RV64D-NEXT:    ret
  %z = call float @llvm.maximumnum.f32(float %x, float %y)
  ret float %z
}

define float @maximumnum_float_nsz(float %x, float %y) {
;
; RV32F-LABEL: maximumnum_float_nsz:
; RV32F:       # %bb.0:
; RV32F-NEXT:    fmax.s fa0, fa0, fa1
; RV32F-NEXT:    ret
;
; RV32D-LABEL: maximumnum_float_nsz:
; RV32D:       # %bb.0:
; RV32D-NEXT:    fmax.s fa0, fa0, fa1
; RV32D-NEXT:    ret
;
; RV64F-LABEL: maximumnum_float_nsz:
; RV64F:       # %bb.0:
; RV64F-NEXT:    fmax.s fa0, fa0, fa1
; RV64F-NEXT:    ret
;
; RV64D-LABEL: maximumnum_float_nsz:
; RV64D:       # %bb.0:
; RV64D-NEXT:    fmax.s fa0, fa0, fa1
; RV64D-NEXT:    ret
  %z = call nsz float @llvm.maximumnum.f32(float %x, float %y)
  ret float %z
}

define float @maximumnum_float_nnan(float %x, float %y) {
;
; RV32F-LABEL: maximumnum_float_nnan:
; RV32F:       # %bb.0:
; RV32F-NEXT:    fmax.s fa0, fa0, fa1
; RV32F-NEXT:    ret
;
; RV32D-LABEL: maximumnum_float_nnan:
; RV32D:       # %bb.0:
; RV32D-NEXT:    fmax.s fa0, fa0, fa1
; RV32D-NEXT:    ret
;
; RV64F-LABEL: maximumnum_float_nnan:
; RV64F:       # %bb.0:
; RV64F-NEXT:    fmax.s fa0, fa0, fa1
; RV64F-NEXT:    ret
;
; RV64D-LABEL: maximumnum_float_nnan:
; RV64D:       # %bb.0:
; RV64D-NEXT:    fmax.s fa0, fa0, fa1
; RV64D-NEXT:    ret
  %z = call nnan float @llvm.maximumnum.f32(float %x, float %y)
  ret float %z
}


define double @maximumnum_double(double %x, double %y) {
;
; RV32F-LABEL: maximumnum_double:
; RV32F:       # %bb.0:
; RV32F-NEXT:    addi sp, sp, -16
; RV32F-NEXT:    .cfi_def_cfa_offset 16
; RV32F-NEXT:    sw ra, 12(sp) # 4-byte Folded Spill
; RV32F-NEXT:    .cfi_offset ra, -4
; RV32F-NEXT:    call fmaximum_num
; RV32F-NEXT:    lw ra, 12(sp) # 4-byte Folded Reload
; RV32F-NEXT:    addi sp, sp, 16
; RV32F-NEXT:    ret
;
; RV32D-LABEL: maximumnum_double:
; RV32D:       # %bb.0:
; RV32D-NEXT:    fmax.d fa0, fa0, fa1
; RV32D-NEXT:    ret
;
; RV64F-LABEL: maximumnum_double:
; RV64F:       # %bb.0:
; RV64F-NEXT:    addi sp, sp, -16
; RV64F-NEXT:    .cfi_def_cfa_offset 16
; RV64F-NEXT:    sd ra, 8(sp) # 8-byte Folded Spill
; RV64F-NEXT:    .cfi_offset ra, -8
; RV64F-NEXT:    call fmaximum_num
; RV64F-NEXT:    ld ra, 8(sp) # 8-byte Folded Reload
; RV64F-NEXT:    addi sp, sp, 16
; RV64F-NEXT:    ret
;
; RV64D-LABEL: maximumnum_double:
; RV64D:       # %bb.0:
; RV64D-NEXT:    fmax.d fa0, fa0, fa1
; RV64D-NEXT:    ret
  %z = call double @llvm.maximumnum.f64(double %x, double %y)
  ret double %z
}

define double @maximumnum_double_nsz(double %x, double %y) {
;
; RV32F-LABEL: maximumnum_double_nsz:
; RV32F:       # %bb.0:
; RV32F-NEXT:    addi sp, sp, -16
; RV32F-NEXT:    .cfi_def_cfa_offset 16
; RV32F-NEXT:    sw ra, 12(sp) # 4-byte Folded Spill
; RV32F-NEXT:    .cfi_offset ra, -4
; RV32F-NEXT:    call fmaximum_num
; RV32F-NEXT:    lw ra, 12(sp) # 4-byte Folded Reload
; RV32F-NEXT:    addi sp, sp, 16
; RV32F-NEXT:    ret
;
; RV32D-LABEL: maximumnum_double_nsz:
; RV32D:       # %bb.0:
; RV32D-NEXT:    fmax.d fa0, fa0, fa1
; RV32D-NEXT:    ret
;
; RV64F-LABEL: maximumnum_double_nsz:
; RV64F:       # %bb.0:
; RV64F-NEXT:    addi sp, sp, -16
; RV64F-NEXT:    .cfi_def_cfa_offset 16
; RV64F-NEXT:    sd ra, 8(sp) # 8-byte Folded Spill
; RV64F-NEXT:    .cfi_offset ra, -8
; RV64F-NEXT:    call fmaximum_num
; RV64F-NEXT:    ld ra, 8(sp) # 8-byte Folded Reload
; RV64F-NEXT:    addi sp, sp, 16
; RV64F-NEXT:    ret
;
; RV64D-LABEL: maximumnum_double_nsz:
; RV64D:       # %bb.0:
; RV64D-NEXT:    fmax.d fa0, fa0, fa1
; RV64D-NEXT:    ret
  %z = call nsz double @llvm.maximumnum.f64(double %x, double %y)
  ret double %z
}

define double @maximumnum_double_nnan(double %x, double %y) {
;
; RV32F-LABEL: maximumnum_double_nnan:
; RV32F:       # %bb.0:
; RV32F-NEXT:    addi sp, sp, -16
; RV32F-NEXT:    .cfi_def_cfa_offset 16
; RV32F-NEXT:    sw ra, 12(sp) # 4-byte Folded Spill
; RV32F-NEXT:    .cfi_offset ra, -4
; RV32F-NEXT:    call fmaximum_num
; RV32F-NEXT:    lw ra, 12(sp) # 4-byte Folded Reload
; RV32F-NEXT:    addi sp, sp, 16
; RV32F-NEXT:    ret
;
; RV32D-LABEL: maximumnum_double_nnan:
; RV32D:       # %bb.0:
; RV32D-NEXT:    fmax.d fa0, fa0, fa1
; RV32D-NEXT:    ret
;
; RV64F-LABEL: maximumnum_double_nnan:
; RV64F:       # %bb.0:
; RV64F-NEXT:    addi sp, sp, -16
; RV64F-NEXT:    .cfi_def_cfa_offset 16
; RV64F-NEXT:    sd ra, 8(sp) # 8-byte Folded Spill
; RV64F-NEXT:    .cfi_offset ra, -8
; RV64F-NEXT:    call fmaximum_num
; RV64F-NEXT:    ld ra, 8(sp) # 8-byte Folded Reload
; RV64F-NEXT:    addi sp, sp, 16
; RV64F-NEXT:    ret
;
; RV64D-LABEL: maximumnum_double_nnan:
; RV64D:       # %bb.0:
; RV64D-NEXT:    fmax.d fa0, fa0, fa1
; RV64D-NEXT:    ret
  %z = call nnan double @llvm.maximumnum.f64(double %x, double %y)
  ret double %z
}

define float @minimumnum_float(float %x, float %y) {
;
; RV32F-LABEL: minimumnum_float:
; RV32F:       # %bb.0:
; RV32F-NEXT:    fmin.s fa0, fa0, fa1
; RV32F-NEXT:    ret
;
; RV32D-LABEL: minimumnum_float:
; RV32D:       # %bb.0:
; RV32D-NEXT:    fmin.s fa0, fa0, fa1
; RV32D-NEXT:    ret
;
; RV64F-LABEL: minimumnum_float:
; RV64F:       # %bb.0:
; RV64F-NEXT:    fmin.s fa0, fa0, fa1
; RV64F-NEXT:    ret
;
; RV64D-LABEL: minimumnum_float:
; RV64D:       # %bb.0:
; RV64D-NEXT:    fmin.s fa0, fa0, fa1
; RV64D-NEXT:    ret
  %z = call float @llvm.minimumnum.f32(float %x, float %y)
  ret float %z
}

define float @minimumnum_float_nsz(float %x, float %y) {
;
; RV32F-LABEL: minimumnum_float_nsz:
; RV32F:       # %bb.0:
; RV32F-NEXT:    fmin.s fa0, fa0, fa1
; RV32F-NEXT:    ret
;
; RV32D-LABEL: minimumnum_float_nsz:
; RV32D:       # %bb.0:
; RV32D-NEXT:    fmin.s fa0, fa0, fa1
; RV32D-NEXT:    ret
;
; RV64F-LABEL: minimumnum_float_nsz:
; RV64F:       # %bb.0:
; RV64F-NEXT:    fmin.s fa0, fa0, fa1
; RV64F-NEXT:    ret
;
; RV64D-LABEL: minimumnum_float_nsz:
; RV64D:       # %bb.0:
; RV64D-NEXT:    fmin.s fa0, fa0, fa1
; RV64D-NEXT:    ret
  %z = call nsz float @llvm.minimumnum.f32(float %x, float %y)
  ret float %z
}

define float @minimumnum_float_nnan(float %x, float %y) {
;
; RV32F-LABEL: minimumnum_float_nnan:
; RV32F:       # %bb.0:
; RV32F-NEXT:    fmin.s fa0, fa0, fa1
; RV32F-NEXT:    ret
;
; RV32D-LABEL: minimumnum_float_nnan:
; RV32D:       # %bb.0:
; RV32D-NEXT:    fmin.s fa0, fa0, fa1
; RV32D-NEXT:    ret
;
; RV64F-LABEL: minimumnum_float_nnan:
; RV64F:       # %bb.0:
; RV64F-NEXT:    fmin.s fa0, fa0, fa1
; RV64F-NEXT:    ret
;
; RV64D-LABEL: minimumnum_float_nnan:
; RV64D:       # %bb.0:
; RV64D-NEXT:    fmin.s fa0, fa0, fa1
; RV64D-NEXT:    ret
  %z = call nnan float @llvm.minimumnum.f32(float %x, float %y)
  ret float %z
}

define double @minimumnum_double(double %x, double %y) {
;
; RV32F-LABEL: minimumnum_double:
; RV32F:       # %bb.0:
; RV32F-NEXT:    addi sp, sp, -16
; RV32F-NEXT:    .cfi_def_cfa_offset 16
; RV32F-NEXT:    sw ra, 12(sp) # 4-byte Folded Spill
; RV32F-NEXT:    .cfi_offset ra, -4
; RV32F-NEXT:    call fminimum_num
; RV32F-NEXT:    lw ra, 12(sp) # 4-byte Folded Reload
; RV32F-NEXT:    addi sp, sp, 16
; RV32F-NEXT:    ret
;
; RV32D-LABEL: minimumnum_double:
; RV32D:       # %bb.0:
; RV32D-NEXT:    fmin.d fa0, fa0, fa1
; RV32D-NEXT:    ret
;
; RV64F-LABEL: minimumnum_double:
; RV64F:       # %bb.0:
; RV64F-NEXT:    addi sp, sp, -16
; RV64F-NEXT:    .cfi_def_cfa_offset 16
; RV64F-NEXT:    sd ra, 8(sp) # 8-byte Folded Spill
; RV64F-NEXT:    .cfi_offset ra, -8
; RV64F-NEXT:    call fminimum_num
; RV64F-NEXT:    ld ra, 8(sp) # 8-byte Folded Reload
; RV64F-NEXT:    addi sp, sp, 16
; RV64F-NEXT:    ret
;
; RV64D-LABEL: minimumnum_double:
; RV64D:       # %bb.0:
; RV64D-NEXT:    fmin.d fa0, fa0, fa1
; RV64D-NEXT:    ret
  %z = call double @llvm.minimumnum.f64(double %x, double %y)
  ret double %z
}

define double @minimumnum_double_nsz(double %x, double %y) {
;
; RV32F-LABEL: minimumnum_double_nsz:
; RV32F:       # %bb.0:
; RV32F-NEXT:    addi sp, sp, -16
; RV32F-NEXT:    .cfi_def_cfa_offset 16
; RV32F-NEXT:    sw ra, 12(sp) # 4-byte Folded Spill
; RV32F-NEXT:    .cfi_offset ra, -4
; RV32F-NEXT:    call fminimum_num
; RV32F-NEXT:    lw ra, 12(sp) # 4-byte Folded Reload
; RV32F-NEXT:    addi sp, sp, 16
; RV32F-NEXT:    ret
;
; RV32D-LABEL: minimumnum_double_nsz:
; RV32D:       # %bb.0:
; RV32D-NEXT:    fmin.d fa0, fa0, fa1
; RV32D-NEXT:    ret
;
; RV64F-LABEL: minimumnum_double_nsz:
; RV64F:       # %bb.0:
; RV64F-NEXT:    addi sp, sp, -16
; RV64F-NEXT:    .cfi_def_cfa_offset 16
; RV64F-NEXT:    sd ra, 8(sp) # 8-byte Folded Spill
; RV64F-NEXT:    .cfi_offset ra, -8
; RV64F-NEXT:    call fminimum_num
; RV64F-NEXT:    ld ra, 8(sp) # 8-byte Folded Reload
; RV64F-NEXT:    addi sp, sp, 16
; RV64F-NEXT:    ret
;
; RV64D-LABEL: minimumnum_double_nsz:
; RV64D:       # %bb.0:
; RV64D-NEXT:    fmin.d fa0, fa0, fa1
; RV64D-NEXT:    ret
  %z = call nsz double @llvm.minimumnum.f64(double %x, double %y)
  ret double %z
}

define double @minimumnum_double_nnan(double %x, double %y) {
;
; RV32F-LABEL: minimumnum_double_nnan:
; RV32F:       # %bb.0:
; RV32F-NEXT:    addi sp, sp, -16
; RV32F-NEXT:    .cfi_def_cfa_offset 16
; RV32F-NEXT:    sw ra, 12(sp) # 4-byte Folded Spill
; RV32F-NEXT:    .cfi_offset ra, -4
; RV32F-NEXT:    call fminimum_num
; RV32F-NEXT:    lw ra, 12(sp) # 4-byte Folded Reload
; RV32F-NEXT:    addi sp, sp, 16
; RV32F-NEXT:    ret
;
; RV32D-LABEL: minimumnum_double_nnan:
; RV32D:       # %bb.0:
; RV32D-NEXT:    fmin.d fa0, fa0, fa1
; RV32D-NEXT:    ret
;
; RV64F-LABEL: minimumnum_double_nnan:
; RV64F:       # %bb.0:
; RV64F-NEXT:    addi sp, sp, -16
; RV64F-NEXT:    .cfi_def_cfa_offset 16
; RV64F-NEXT:    sd ra, 8(sp) # 8-byte Folded Spill
; RV64F-NEXT:    .cfi_offset ra, -8
; RV64F-NEXT:    call fminimum_num
; RV64F-NEXT:    ld ra, 8(sp) # 8-byte Folded Reload
; RV64F-NEXT:    addi sp, sp, 16
; RV64F-NEXT:    ret
;
; RV64D-LABEL: minimumnum_double_nnan:
; RV64D:       # %bb.0:
; RV64D-NEXT:    fmin.d fa0, fa0, fa1
; RV64D-NEXT:    ret
  %z = call nnan double @llvm.minimumnum.f64(double %x, double %y)
  ret double %z
}
