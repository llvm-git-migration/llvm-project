; NOTE: Assertions have been autogenerated by utils/update_test_checks.py UTC_ARGS: --version 4
; RUN: opt --bpf-check-and-opt-ir -S -mtriple=bpf-pc-linux < %s | FileCheck %s

; Generated from the following C code:

; #define __uptr __attribute__((address_space(272)))
;
; void simple_store(void __uptr *foo) {
;   *((volatile int __uptr *)(foo + 16)) = 0xdead;
;   *((volatile int __uptr *)(foo + 12)) = 0xbeef;
; }
;
; void separate_addr_store(void __uptr *foo, void __uptr *bar) {
;   *((volatile int __uptr *)(foo + 16)) = 0xdead;
;   *((volatile int __uptr *)(bar + 12)) = 0xbeef;
; }
;
; void ptr_store(void __uptr *foo, void __uptr *bar) {
;   *((volatile void __uptr * __uptr*)(foo + 16)) = bar + 16;
;   *((volatile void __uptr * __uptr*)(foo + 8)) = bar + 8;
; }
;
; void separate_ptr_store(void __uptr *foo, void __uptr *bar, void __uptr *buz) {
;   *((volatile void __uptr * __uptr*)(foo + 16)) = bar;
;   *((volatile void __uptr * __uptr*)(foo + 8)) = buz;
; }
;
; int simple_load(int __uptr *foo) {
;   return *foo;
; }
;
; Using the following command:
;
;   clang --target=bpf -O2 -S -emit-llvm -o t.ll t.c

; Function Attrs: nofree norecurse nounwind memory(argmem: readwrite, inaccessiblemem: readwrite)
define dso_local void @simple_store(ptr addrspace(272) noundef %foo) local_unnamed_addr #0 {
; CHECK-LABEL: define dso_local void @simple_store(
; CHECK-SAME: ptr addrspace(272) noundef [[FOO:%.*]]) local_unnamed_addr #[[ATTR0:[0-9]+]] {
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[TMP0:%.*]] = call ptr addrspace(272) @llvm.bpf.addr.space.p272.p272(ptr addrspace(272) [[FOO]], i32 1)
; CHECK-NEXT:    [[ADD_PTR:%.*]] = getelementptr inbounds i8, ptr addrspace(272) [[TMP0]], i64 16
; CHECK-NEXT:    store volatile i32 57005, ptr addrspace(272) [[ADD_PTR]], align 4, !tbaa [[TBAA3:![0-9]+]]
; CHECK-NEXT:    [[ADD_PTR1:%.*]] = getelementptr inbounds i8, ptr addrspace(272) [[TMP0]], i64 12
; CHECK-NEXT:    store volatile i32 48879, ptr addrspace(272) [[ADD_PTR1]], align 4, !tbaa [[TBAA3]]
; CHECK-NEXT:    ret void
;
entry:
  %add.ptr = getelementptr inbounds i8, ptr addrspace(272) %foo, i64 16
  store volatile i32 57005, ptr addrspace(272) %add.ptr, align 4, !tbaa !3
  %add.ptr1 = getelementptr inbounds i8, ptr addrspace(272) %foo, i64 12
  store volatile i32 48879, ptr addrspace(272) %add.ptr1, align 4, !tbaa !3
  ret void
}

; Function Attrs: nofree norecurse nounwind memory(argmem: readwrite, inaccessiblemem: readwrite)
define dso_local void @separate_addr_store(ptr addrspace(272) noundef %foo, ptr addrspace(272) noundef %bar) local_unnamed_addr #0 {
; CHECK-LABEL: define dso_local void @separate_addr_store(
; CHECK-SAME: ptr addrspace(272) noundef [[FOO:%.*]], ptr addrspace(272) noundef [[BAR:%.*]]) local_unnamed_addr #[[ATTR0]] {
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[TMP0:%.*]] = call ptr addrspace(272) @llvm.bpf.addr.space.p272.p272(ptr addrspace(272) [[BAR]], i32 1)
; CHECK-NEXT:    [[TMP1:%.*]] = call ptr addrspace(272) @llvm.bpf.addr.space.p272.p272(ptr addrspace(272) [[FOO]], i32 1)
; CHECK-NEXT:    [[ADD_PTR:%.*]] = getelementptr inbounds i8, ptr addrspace(272) [[TMP1]], i64 16
; CHECK-NEXT:    store volatile i32 57005, ptr addrspace(272) [[ADD_PTR]], align 4, !tbaa [[TBAA3]]
; CHECK-NEXT:    [[ADD_PTR1:%.*]] = getelementptr inbounds i8, ptr addrspace(272) [[TMP0]], i64 12
; CHECK-NEXT:    store volatile i32 48879, ptr addrspace(272) [[ADD_PTR1]], align 4, !tbaa [[TBAA3]]
; CHECK-NEXT:    ret void
;
entry:
  %add.ptr = getelementptr inbounds i8, ptr addrspace(272) %foo, i64 16
  store volatile i32 57005, ptr addrspace(272) %add.ptr, align 4, !tbaa !3
  %add.ptr1 = getelementptr inbounds i8, ptr addrspace(272) %bar, i64 12
  store volatile i32 48879, ptr addrspace(272) %add.ptr1, align 4, !tbaa !3
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define dso_local void @ptr_store(ptr addrspace(272) nocapture noundef writeonly %foo, ptr addrspace(272) noundef %bar) local_unnamed_addr #1 {
; CHECK-LABEL: define dso_local void @ptr_store(
; CHECK-SAME: ptr addrspace(272) nocapture noundef writeonly [[FOO:%.*]], ptr addrspace(272) noundef [[BAR:%.*]]) local_unnamed_addr #[[ATTR1:[0-9]+]] {
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[TMP0:%.*]] = call ptr addrspace(272) @llvm.bpf.addr.space.p272.p272(ptr addrspace(272) [[BAR]], i32 2)
; CHECK-NEXT:    [[TMP1:%.*]] = call ptr addrspace(272) @llvm.bpf.addr.space.p272.p272(ptr addrspace(272) [[FOO]], i32 1)
; CHECK-NEXT:    [[ADD_PTR:%.*]] = getelementptr inbounds i8, ptr addrspace(272) [[TMP0]], i64 16
; CHECK-NEXT:    [[ADD_PTR1:%.*]] = getelementptr inbounds i8, ptr addrspace(272) [[TMP1]], i64 16
; CHECK-NEXT:    store ptr addrspace(272) [[ADD_PTR]], ptr addrspace(272) [[ADD_PTR1]], align 8, !tbaa [[TBAA7:![0-9]+]]
; CHECK-NEXT:    [[ADD_PTR2:%.*]] = getelementptr inbounds i8, ptr addrspace(272) [[TMP0]], i64 8
; CHECK-NEXT:    [[ADD_PTR3:%.*]] = getelementptr inbounds i8, ptr addrspace(272) [[TMP1]], i64 8
; CHECK-NEXT:    store ptr addrspace(272) [[ADD_PTR2]], ptr addrspace(272) [[ADD_PTR3]], align 8, !tbaa [[TBAA7]]
; CHECK-NEXT:    ret void
;
entry:
  %add.ptr = getelementptr inbounds i8, ptr addrspace(272) %bar, i64 16
  %add.ptr1 = getelementptr inbounds i8, ptr addrspace(272) %foo, i64 16
  store ptr addrspace(272) %add.ptr, ptr addrspace(272) %add.ptr1, align 8, !tbaa !7
  %add.ptr2 = getelementptr inbounds i8, ptr addrspace(272) %bar, i64 8
  %add.ptr3 = getelementptr inbounds i8, ptr addrspace(272) %foo, i64 8
  store ptr addrspace(272) %add.ptr2, ptr addrspace(272) %add.ptr3, align 8, !tbaa !7
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define dso_local void @separate_ptr_store(ptr addrspace(272) nocapture noundef writeonly %foo, ptr addrspace(272) noundef %bar, ptr addrspace(272) noundef %buz) local_unnamed_addr #1 {
; CHECK-LABEL: define dso_local void @separate_ptr_store(
; CHECK-SAME: ptr addrspace(272) nocapture noundef writeonly [[FOO:%.*]], ptr addrspace(272) noundef [[BAR:%.*]], ptr addrspace(272) noundef [[BUZ:%.*]]) local_unnamed_addr #[[ATTR1]] {
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[TMP0:%.*]] = call ptr addrspace(272) @llvm.bpf.addr.space.p272.p272(ptr addrspace(272) [[BUZ]], i32 2)
; CHECK-NEXT:    [[TMP1:%.*]] = call ptr addrspace(272) @llvm.bpf.addr.space.p272.p272(ptr addrspace(272) [[BAR]], i32 2)
; CHECK-NEXT:    [[TMP2:%.*]] = call ptr addrspace(272) @llvm.bpf.addr.space.p272.p272(ptr addrspace(272) [[FOO]], i32 1)
; CHECK-NEXT:    [[ADD_PTR:%.*]] = getelementptr inbounds i8, ptr addrspace(272) [[TMP2]], i64 16
; CHECK-NEXT:    store ptr addrspace(272) [[TMP1]], ptr addrspace(272) [[ADD_PTR]], align 8, !tbaa [[TBAA7]]
; CHECK-NEXT:    [[ADD_PTR1:%.*]] = getelementptr inbounds i8, ptr addrspace(272) [[TMP2]], i64 8
; CHECK-NEXT:    store ptr addrspace(272) [[TMP0]], ptr addrspace(272) [[ADD_PTR1]], align 8, !tbaa [[TBAA7]]
; CHECK-NEXT:    ret void
;
entry:
  %add.ptr = getelementptr inbounds i8, ptr addrspace(272) %foo, i64 16
  store ptr addrspace(272) %bar, ptr addrspace(272) %add.ptr, align 8, !tbaa !7
  %add.ptr1 = getelementptr inbounds i8, ptr addrspace(272) %foo, i64 8
  store ptr addrspace(272) %buz, ptr addrspace(272) %add.ptr1, align 8, !tbaa !7
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define dso_local i32 @simple_load(ptr addrspace(272) nocapture noundef readonly %foo) local_unnamed_addr #2 {
; CHECK-LABEL: define dso_local i32 @simple_load(
; CHECK-SAME: ptr addrspace(272) nocapture noundef readonly [[FOO:%.*]]) local_unnamed_addr #[[ATTR2:[0-9]+]] {
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[TMP0:%.*]] = call ptr addrspace(272) @llvm.bpf.addr.space.p272.p272(ptr addrspace(272) [[FOO]], i32 1)
; CHECK-NEXT:    [[TMP1:%.*]] = load i32, ptr addrspace(272) [[TMP0]], align 4, !tbaa [[TBAA3]]
; CHECK-NEXT:    ret i32 [[TMP1]]
;
entry:
  %0 = load i32, ptr addrspace(272) %foo, align 4, !tbaa !3
  ret i32 %0
}

attributes #0 = { nofree norecurse nounwind memory(argmem: readwrite, inaccessiblemem: readwrite) "frame-pointer"="all" "no-trapping-math"="true" "stack-protector-buffer-size"="8" }
attributes #1 = { mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write) "frame-pointer"="all" "no-trapping-math"="true" "stack-protector-buffer-size"="8" }
attributes #2 = { mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read) "frame-pointer"="all" "no-trapping-math"="true" "stack-protector-buffer-size"="8" }

!llvm.module.flags = !{!0, !1}
!llvm.ident = !{!2}

!0 = !{i32 1, !"wchar_size", i32 4}
!1 = !{i32 7, !"frame-pointer", i32 2}
!2 = !{!"some clang version"}
!3 = !{!4, !4, i64 0}
!4 = !{!"int", !5, i64 0}
!5 = !{!"omnipotent char", !6, i64 0}
!6 = !{!"Simple C/C++ TBAA"}
!7 = !{!8, !8, i64 0}
!8 = !{!"any pointer", !5, i64 0}
