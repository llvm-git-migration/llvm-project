; NOTE: Assertions have been autogenerated by utils/update_llc_test_checks.py UTC_ARGS: --version 5
; RUN: llc -mattr=+neon,+fprcvt -verify-machineinstrs %s -o - | FileCheck %s
; RUN: llc -mattr=+neon -verify-machineinstrs %s -o - | FileCheck %s --check-prefix=CHECK-NO-FPRCVT

target triple = "aarch64-unknown-linux-gnu"


; To demonstrate what we have implemented, we'll want a scalar integer value in a SIMD/FP register.
; A common case for this setup is when using the result of an integer reduction intrinsic.

; SCVTF

define half @scvtf_f16i32(<4 x i32> %x) {
; CHECK-LABEL: scvtf_f16i32:
; CHECK:       // %bb.0:
; CHECK-NEXT:    addv s0, v0.4s
; CHECK-NEXT:    scvtf h0, s0
; CHECK-NEXT:    ret
;
; CHECK-NO-FPRCVT-LABEL: scvtf_f16i32:
; CHECK-NO-FPRCVT:       // %bb.0:
; CHECK-NO-FPRCVT-NEXT:    addv s0, v0.4s
; CHECK-NO-FPRCVT-NEXT:    scvtf s0, s0
; CHECK-NO-FPRCVT-NEXT:    fcvt h0, s0
; CHECK-NO-FPRCVT-NEXT:    ret
 %addv = tail call i32 @llvm.aarch64.neon.saddv.i32.v4i32(<4 x i32> %x)
 %conv = sitofp i32 %addv to half
 ret half %conv
}

define double @scvtf_f64i32(<4 x i32> %x) {
; CHECK-LABEL: scvtf_f64i32:
; CHECK:       // %bb.0:
; CHECK-NEXT:    addv s0, v0.4s
; CHECK-NEXT:    scvtf d0, s0
; CHECK-NEXT:    ret
;
; CHECK-NO-FPRCVT-LABEL: scvtf_f64i32:
; CHECK-NO-FPRCVT:       // %bb.0:
; CHECK-NO-FPRCVT-NEXT:    addv s0, v0.4s
; CHECK-NO-FPRCVT-NEXT:    fmov w8, s0
; CHECK-NO-FPRCVT-NEXT:    scvtf d0, w8
; CHECK-NO-FPRCVT-NEXT:    ret
 %addv = tail call i32 @llvm.aarch64.neon.saddv.i32.v4i32(<4 x i32> %x)
 %conv = sitofp i32 %addv to double
 ret double %conv
}

define half @scvtf_f16i64(<2 x i64> %x) {
; CHECK-LABEL: scvtf_f16i64:
; CHECK:       // %bb.0:
; CHECK-NEXT:    addp d0, v0.2d
; CHECK-NEXT:    scvtf h0, d0
; CHECK-NEXT:    ret
;
; CHECK-NO-FPRCVT-LABEL: scvtf_f16i64:
; CHECK-NO-FPRCVT:       // %bb.0:
; CHECK-NO-FPRCVT-NEXT:    addp d0, v0.2d
; CHECK-NO-FPRCVT-NEXT:    fmov x8, d0
; CHECK-NO-FPRCVT-NEXT:    scvtf s0, x8
; CHECK-NO-FPRCVT-NEXT:    fcvt h0, s0
; CHECK-NO-FPRCVT-NEXT:    ret
 %addp = tail call i64 @llvm.aarch64.neon.saddv.i64.v2i64(<2 x i64> %x)
 %conv = sitofp i64 %addp to half
 ret half %conv
}

define float @scvtf_f32i64(<2 x i64> %x) {
; CHECK-LABEL: scvtf_f32i64:
; CHECK:       // %bb.0:
; CHECK-NEXT:    addp d0, v0.2d
; CHECK-NEXT:    scvtf s0, d0
; CHECK-NEXT:    ret
;
; CHECK-NO-FPRCVT-LABEL: scvtf_f32i64:
; CHECK-NO-FPRCVT:       // %bb.0:
; CHECK-NO-FPRCVT-NEXT:    addp d0, v0.2d
; CHECK-NO-FPRCVT-NEXT:    fmov x8, d0
; CHECK-NO-FPRCVT-NEXT:    scvtf s0, x8
; CHECK-NO-FPRCVT-NEXT:    ret
 %addp = tail call i64 @llvm.aarch64.neon.saddv.i64.v2i64(<2 x i64> %x)
 %conv = sitofp i64 %addp to float
 ret float %conv
}

; UCVTF

define half @ucvtf_f16i32(<4 x i32> %x) {
; CHECK-LABEL: ucvtf_f16i32:
; CHECK:       // %bb.0:
; CHECK-NEXT:    addv s0, v0.4s
; CHECK-NEXT:    ucvtf h0, s0
; CHECK-NEXT:    ret
;
; CHECK-NO-FPRCVT-LABEL: ucvtf_f16i32:
; CHECK-NO-FPRCVT:       // %bb.0:
; CHECK-NO-FPRCVT-NEXT:    addv s0, v0.4s
; CHECK-NO-FPRCVT-NEXT:    ucvtf s0, s0
; CHECK-NO-FPRCVT-NEXT:    fcvt h0, s0
; CHECK-NO-FPRCVT-NEXT:    ret
 %addv = tail call i32 @llvm.aarch64.neon.uaddv.i32.v4i32(<4 x i32> %x)
 %conv = uitofp i32 %addv to half
 ret half %conv
}

define double @ucvtf_f64i32(<4 x i32> %x) {
; CHECK-LABEL: ucvtf_f64i32:
; CHECK:       // %bb.0:
; CHECK-NEXT:    addv s0, v0.4s
; CHECK-NEXT:    ucvtf d0, s0
; CHECK-NEXT:    ret
;
; CHECK-NO-FPRCVT-LABEL: ucvtf_f64i32:
; CHECK-NO-FPRCVT:       // %bb.0:
; CHECK-NO-FPRCVT-NEXT:    addv s0, v0.4s
; CHECK-NO-FPRCVT-NEXT:    fmov w8, s0
; CHECK-NO-FPRCVT-NEXT:    ucvtf d0, w8
; CHECK-NO-FPRCVT-NEXT:    ret
 %addv = tail call i32 @llvm.aarch64.neon.uaddv.i32.v4i32(<4 x i32> %x)
 %conv = uitofp i32 %addv to double
 ret double %conv
}

define half @ucvtf_f16i64(<2 x i64> %x) {
; CHECK-LABEL: ucvtf_f16i64:
; CHECK:       // %bb.0:
; CHECK-NEXT:    addp d0, v0.2d
; CHECK-NEXT:    ucvtf h0, d0
; CHECK-NEXT:    ret
;
; CHECK-NO-FPRCVT-LABEL: ucvtf_f16i64:
; CHECK-NO-FPRCVT:       // %bb.0:
; CHECK-NO-FPRCVT-NEXT:    addp d0, v0.2d
; CHECK-NO-FPRCVT-NEXT:    fmov x8, d0
; CHECK-NO-FPRCVT-NEXT:    ucvtf s0, x8
; CHECK-NO-FPRCVT-NEXT:    fcvt h0, s0
; CHECK-NO-FPRCVT-NEXT:    ret
 %addp = tail call i64 @llvm.aarch64.neon.uaddv.i64.v2i64(<2 x i64> %x)
 %conv = uitofp i64 %addp to half
 ret half %conv
}

define float @ucvtf_f32i64(<2 x i64> %x) {
; CHECK-LABEL: ucvtf_f32i64:
; CHECK:       // %bb.0:
; CHECK-NEXT:    addp d0, v0.2d
; CHECK-NEXT:    ucvtf s0, d0
; CHECK-NEXT:    ret
;
; CHECK-NO-FPRCVT-LABEL: ucvtf_f32i64:
; CHECK-NO-FPRCVT:       // %bb.0:
; CHECK-NO-FPRCVT-NEXT:    addp d0, v0.2d
; CHECK-NO-FPRCVT-NEXT:    fmov x8, d0
; CHECK-NO-FPRCVT-NEXT:    ucvtf s0, x8
; CHECK-NO-FPRCVT-NEXT:    ret
 %addp = tail call i64 @llvm.aarch64.neon.uaddv.i64.v2i64(<2 x i64> %x)
 %conv = uitofp i64 %addp to float
 ret float %conv
}
