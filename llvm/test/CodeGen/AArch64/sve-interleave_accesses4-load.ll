; NOTE: Assertions have been autogenerated by utils/update_llc_test_checks.py
; RUN: llc -mtriple=aarch64--linux-gnu -mattr=+sve < %s | FileCheck %s

%struct.xyzt = type { i32, i32, i32, i32 }

define void @interleave(ptr noalias nocapture noundef writeonly %dst, ptr nocapture noundef readonly %a, <vscale x 4 x i32> %x) {
; CHECK-LABEL: interleave:
; CHECK:       // %bb.0:
; CHECK-NEXT:    ptrue p0.s
; CHECK-NEXT:    ld2w { z1.s, z2.s }, p0/z, [x1]
; CHECK-NEXT:    ld2w { z3.s, z4.s }, p0/z, [x1, #2, mul vl]
; CHECK-NEXT:    uzp2 z5.s, z1.s, z3.s
; CHECK-NEXT:    uzp1 z6.s, z1.s, z3.s
; CHECK-NEXT:    uzp2 z7.s, z2.s, z4.s
; CHECK-NEXT:    uzp1 z1.s, z2.s, z4.s
; CHECK-NEXT:    add z2.s, z0.s, z6.s
; CHECK-NEXT:    movprfx z3, z5
; CHECK-NEXT:    lsl z3.s, p0/m, z3.s, z0.s
; CHECK-NEXT:    sub z1.s, z1.s, z0.s
; CHECK-NEXT:    asrr z0.s, p0/m, z0.s, z7.s
; CHECK-NEXT:    zip1 z4.s, z2.s, z3.s
; CHECK-NEXT:    zip2 z2.s, z2.s, z3.s
; CHECK-NEXT:    zip1 z5.s, z1.s, z0.s
; CHECK-NEXT:    zip2 z3.s, z1.s, z0.s
; CHECK-NEXT:    st2w { z4.s, z5.s }, p0, [x0]
; CHECK-NEXT:    st2w { z2.s, z3.s }, p0, [x0, #2, mul vl]
; CHECK-NEXT:    ret
  %wide.vec = load <vscale x 16 x i32>, ptr %a, align 4
  %root.strided.vec = tail call { <vscale x 8 x i32>, <vscale x 8 x i32> } @llvm.vector.deinterleave2.nxv16i32(<vscale x 16 x i32> %wide.vec)
  %3 = extractvalue { <vscale x 8 x i32>, <vscale x 8 x i32> } %root.strided.vec, 0
  %4 = extractvalue { <vscale x 8 x i32>, <vscale x 8 x i32> } %root.strided.vec, 1
  %root.strided.vec55 = tail call { <vscale x 4 x i32>, <vscale x 4 x i32> } @llvm.vector.deinterleave2.nxv8i32(<vscale x 8 x i32> %3)
  %5 = extractvalue { <vscale x 4 x i32>, <vscale x 4 x i32> } %root.strided.vec55, 0
  %6 = extractvalue { <vscale x 4 x i32>, <vscale x 4 x i32> } %root.strided.vec55, 1
  %root.strided.vec56 = tail call { <vscale x 4 x i32>, <vscale x 4 x i32> } @llvm.vector.deinterleave2.nxv8i32(<vscale x 8 x i32> %4)
  %7 = extractvalue { <vscale x 4 x i32>, <vscale x 4 x i32> } %root.strided.vec56, 0
  %8 = extractvalue { <vscale x 4 x i32>, <vscale x 4 x i32> } %root.strided.vec56, 1
  %9 = add nsw <vscale x 4 x i32> %x, %5
  %10 = sub nsw <vscale x 4 x i32> %7, %x
  %11 = shl <vscale x 4 x i32> %6, %x
  %12 = ashr <vscale x 4 x i32> %8, %x
  %interleaved.vec = tail call <vscale x 8 x i32> @llvm.vector.interleave2.nxv8i32(<vscale x 4 x i32> %9, <vscale x 4 x i32> %11)
  %interleaved.vec61 = tail call <vscale x 8 x i32> @llvm.vector.interleave2.nxv8i32(<vscale x 4 x i32> %10, <vscale x 4 x i32> %12)
  %interleaved.vec62 = tail call <vscale x 16 x i32> @llvm.vector.interleave2.nxv16i32(<vscale x 8 x i32> %interleaved.vec, <vscale x 8 x i32> %interleaved.vec61)
  store <vscale x 16 x i32> %interleaved.vec62, ptr %dst, align 4
  ret void
}

define void @wide_interleave(ptr noalias nocapture noundef writeonly %dst, ptr nocapture noundef readonly %a, <vscale x 8 x i32> %x) {
; CHECK-LABEL: wide_interleave:
; CHECK:       // %bb.0:
; CHECK-NEXT:    ptrue p0.s
; CHECK-NEXT:    ld2w { z2.s, z3.s }, p0/z, [x1]
; CHECK-NEXT:    ld2w { z4.s, z5.s }, p0/z, [x1, #2, mul vl]
; CHECK-NEXT:    ld2w { z6.s, z7.s }, p0/z, [x1, #4, mul vl]
; CHECK-NEXT:    ld2w { z24.s, z25.s }, p0/z, [x1, #6, mul vl]
; CHECK-NEXT:    uzp2 z26.s, z2.s, z4.s
; CHECK-NEXT:    uzp1 z27.s, z2.s, z4.s
; CHECK-NEXT:    uzp2 z28.s, z3.s, z5.s
; CHECK-NEXT:    uzp1 z2.s, z3.s, z5.s
; CHECK-NEXT:    add z3.s, z0.s, z27.s
; CHECK-NEXT:    movprfx z4, z26
; CHECK-NEXT:    lsl z4.s, p0/m, z4.s, z0.s
; CHECK-NEXT:    sub z2.s, z2.s, z0.s
; CHECK-NEXT:    asrr z0.s, p0/m, z0.s, z28.s
; CHECK-NEXT:    zip1 z26.s, z3.s, z4.s
; CHECK-NEXT:    zip2 z3.s, z3.s, z4.s
; CHECK-NEXT:    zip1 z27.s, z2.s, z0.s
; CHECK-NEXT:    zip2 z4.s, z2.s, z0.s
; CHECK-NEXT:    uzp2 z0.s, z6.s, z24.s
; CHECK-NEXT:    uzp1 z2.s, z6.s, z24.s
; CHECK-NEXT:    st2w { z26.s, z27.s }, p0, [x0]
; CHECK-NEXT:    lsl z0.s, p0/m, z0.s, z1.s
; CHECK-NEXT:    add z2.s, z1.s, z2.s
; CHECK-NEXT:    st2w { z3.s, z4.s }, p0, [x0, #2, mul vl]
; CHECK-NEXT:    uzp2 z3.s, z7.s, z25.s
; CHECK-NEXT:    uzp1 z4.s, z7.s, z25.s
; CHECK-NEXT:    zip1 z5.s, z2.s, z0.s
; CHECK-NEXT:    sub z4.s, z4.s, z1.s
; CHECK-NEXT:    asrr z1.s, p0/m, z1.s, z3.s
; CHECK-NEXT:    zip2 z2.s, z2.s, z0.s
; CHECK-NEXT:    zip1 z6.s, z4.s, z1.s
; CHECK-NEXT:    zip2 z3.s, z4.s, z1.s
; CHECK-NEXT:    st2w { z5.s, z6.s }, p0, [x0, #4, mul vl]
; CHECK-NEXT:    st2w { z2.s, z3.s }, p0, [x0, #6, mul vl]
; CHECK-NEXT:    ret
  %wide.vec = load <vscale x 32 x i32>, ptr %a, align 4
  %root.strided.vec = tail call { <vscale x 16 x i32>, <vscale x 16 x i32> } @llvm.vector.deinterleave2.nxv32i32(<vscale x 32 x i32> %wide.vec)
  %3 = extractvalue { <vscale x 16 x i32>, <vscale x 16 x i32> } %root.strided.vec, 0
  %4 = extractvalue { <vscale x 16 x i32>, <vscale x 16 x i32> } %root.strided.vec, 1
  %root.strided.vec55 = tail call { <vscale x 8 x i32>, <vscale x 8 x i32> } @llvm.vector.deinterleave2.nxv16i32(<vscale x 16 x i32> %3)
  %5 = extractvalue { <vscale x 8 x i32>, <vscale x 8 x i32> } %root.strided.vec55, 0
  %6 = extractvalue { <vscale x 8 x i32>, <vscale x 8 x i32> } %root.strided.vec55, 1
  %root.strided.vec56 = tail call { <vscale x 8 x i32>, <vscale x 8 x i32> } @llvm.vector.deinterleave2.nxv16i32(<vscale x 16 x i32> %4)
  %7 = extractvalue { <vscale x 8 x i32>, <vscale x 8 x i32> } %root.strided.vec56, 0
  %8 = extractvalue { <vscale x 8 x i32>, <vscale x 8 x i32> } %root.strided.vec56, 1
  %9 = add nsw <vscale x 8 x i32> %x, %5
  %10 = sub nsw <vscale x 8 x i32> %7, %x
  %11 = shl <vscale x 8 x i32> %6, %x
  %12 = ashr <vscale x 8 x i32> %8, %x
  %interleaved.vec = tail call <vscale x 16 x i32> @llvm.vector.interleave2.nxv16i32(<vscale x 8 x i32> %9, <vscale x 8 x i32> %11)
  %interleaved.vec61 = tail call <vscale x 16 x i32> @llvm.vector.interleave2.nxv16i32(<vscale x 8 x i32> %10, <vscale x 8 x i32> %12)
  %interleaved.vec62 = tail call <vscale x 32 x i32> @llvm.vector.interleave2.nxv32i32(<vscale x 16 x i32> %interleaved.vec, <vscale x 16 x i32> %interleaved.vec61)
  store <vscale x 32 x i32> %interleaved.vec62, ptr %dst, align 4
  ret void
}
