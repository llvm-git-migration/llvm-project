; NOTE: Assertions have been autogenerated by utils/update_llc_test_checks.py
; RUN: llc -mtriple=aarch64--linux-gnu -mattr=+sve < %s | FileCheck %s

%struct.xyzt = type { i32, i32, i32, i32 }

define void @interleave(ptr noalias nocapture noundef writeonly %dst, ptr nocapture noundef readonly %a, <vscale x 4 x i32> %x) {
; CHECK-LABEL: interleave:
; CHECK:       // %bb.0:
; CHECK-NEXT:    ptrue p0.s
; CHECK-NEXT:    ld4w { z1.s - z4.s }, p0/z, [x1]
; CHECK-NEXT:    add z24.s, z0.s, z1.s
; CHECK-NEXT:    sub z26.s, z3.s, z0.s
; CHECK-NEXT:    movprfx z25, z2
; CHECK-NEXT:    lsl z25.s, p0/m, z25.s, z0.s
; CHECK-NEXT:    movprfx z27, z4
; CHECK-NEXT:    asr z27.s, p0/m, z27.s, z0.s
; CHECK-NEXT:    st4w { z24.s - z27.s }, p0, [x0]
; CHECK-NEXT:    ret
  %wide.vec = load <vscale x 16 x i32>, ptr %a, align 4
  %root.strided.vec = tail call { <vscale x 8 x i32>, <vscale x 8 x i32> } @llvm.vector.deinterleave2.nxv16i32(<vscale x 16 x i32> %wide.vec)
  %3 = extractvalue { <vscale x 8 x i32>, <vscale x 8 x i32> } %root.strided.vec, 0
  %4 = extractvalue { <vscale x 8 x i32>, <vscale x 8 x i32> } %root.strided.vec, 1
  %root.strided.vec55 = tail call { <vscale x 4 x i32>, <vscale x 4 x i32> } @llvm.vector.deinterleave2.nxv8i32(<vscale x 8 x i32> %3)
  %5 = extractvalue { <vscale x 4 x i32>, <vscale x 4 x i32> } %root.strided.vec55, 0
  %6 = extractvalue { <vscale x 4 x i32>, <vscale x 4 x i32> } %root.strided.vec55, 1
  %root.strided.vec56 = tail call { <vscale x 4 x i32>, <vscale x 4 x i32> } @llvm.vector.deinterleave2.nxv8i32(<vscale x 8 x i32> %4)
  %7 = extractvalue { <vscale x 4 x i32>, <vscale x 4 x i32> } %root.strided.vec56, 0
  %8 = extractvalue { <vscale x 4 x i32>, <vscale x 4 x i32> } %root.strided.vec56, 1
  %9 = add nsw <vscale x 4 x i32> %x, %5
  %10 = sub nsw <vscale x 4 x i32> %7, %x
  %11 = shl <vscale x 4 x i32> %6, %x
  %12 = ashr <vscale x 4 x i32> %8, %x
  %interleaved.vec = tail call <vscale x 8 x i32> @llvm.vector.interleave2.nxv8i32(<vscale x 4 x i32> %9, <vscale x 4 x i32> %11)
  %interleaved.vec61 = tail call <vscale x 8 x i32> @llvm.vector.interleave2.nxv8i32(<vscale x 4 x i32> %10, <vscale x 4 x i32> %12)
  %interleaved.vec62 = tail call <vscale x 16 x i32> @llvm.vector.interleave2.nxv16i32(<vscale x 8 x i32> %interleaved.vec, <vscale x 8 x i32> %interleaved.vec61)
  store <vscale x 16 x i32> %interleaved.vec62, ptr %dst, align 4
  ret void
}

define void @wide_interleave(ptr noalias nocapture noundef writeonly %dst, ptr nocapture noundef readonly %a, <vscale x 8 x i32> %x) {
; CHECK-LABEL: wide_interleave:
; CHECK:       // %bb.0:
; CHECK-NEXT:    ptrue p0.s
; CHECK-NEXT:    ld4w { z2.s - z5.s }, p0/z, [x1]
; CHECK-NEXT:    ld4w { z24.s - z27.s }, p0/z, [x1, #4, mul vl]
; CHECK-NEXT:    add z28.s, z0.s, z2.s
; CHECK-NEXT:    sub z30.s, z4.s, z0.s
; CHECK-NEXT:    movprfx z29, z3
; CHECK-NEXT:    lsl z29.s, p0/m, z29.s, z0.s
; CHECK-NEXT:    movprfx z31, z5
; CHECK-NEXT:    asr z31.s, p0/m, z31.s, z0.s
; CHECK-NEXT:    add z2.s, z1.s, z24.s
; CHECK-NEXT:    sub z4.s, z26.s, z1.s
; CHECK-NEXT:    movprfx z3, z25
; CHECK-NEXT:    lsl z3.s, p0/m, z3.s, z1.s
; CHECK-NEXT:    movprfx z5, z27
; CHECK-NEXT:    asr z5.s, p0/m, z5.s, z1.s
; CHECK-NEXT:    st4w { z28.s - z31.s }, p0, [x0]
; CHECK-NEXT:    st4w { z2.s - z5.s }, p0, [x0, #4, mul vl]
; CHECK-NEXT:    ret
  %wide.vec = load <vscale x 32 x i32>, ptr %a, align 4
  %root.strided.vec = tail call { <vscale x 16 x i32>, <vscale x 16 x i32> } @llvm.vector.deinterleave2.nxv32i32(<vscale x 32 x i32> %wide.vec)
  %3 = extractvalue { <vscale x 16 x i32>, <vscale x 16 x i32> } %root.strided.vec, 0
  %4 = extractvalue { <vscale x 16 x i32>, <vscale x 16 x i32> } %root.strided.vec, 1
  %root.strided.vec55 = tail call { <vscale x 8 x i32>, <vscale x 8 x i32> } @llvm.vector.deinterleave2.nxv16i32(<vscale x 16 x i32> %3)
  %5 = extractvalue { <vscale x 8 x i32>, <vscale x 8 x i32> } %root.strided.vec55, 0
  %6 = extractvalue { <vscale x 8 x i32>, <vscale x 8 x i32> } %root.strided.vec55, 1
  %root.strided.vec56 = tail call { <vscale x 8 x i32>, <vscale x 8 x i32> } @llvm.vector.deinterleave2.nxv16i32(<vscale x 16 x i32> %4)
  %7 = extractvalue { <vscale x 8 x i32>, <vscale x 8 x i32> } %root.strided.vec56, 0
  %8 = extractvalue { <vscale x 8 x i32>, <vscale x 8 x i32> } %root.strided.vec56, 1
  %9 = add nsw <vscale x 8 x i32> %x, %5
  %10 = sub nsw <vscale x 8 x i32> %7, %x
  %11 = shl <vscale x 8 x i32> %6, %x
  %12 = ashr <vscale x 8 x i32> %8, %x
  %interleaved.vec = tail call <vscale x 16 x i32> @llvm.vector.interleave2.nxv16i32(<vscale x 8 x i32> %9, <vscale x 8 x i32> %11)
  %interleaved.vec61 = tail call <vscale x 16 x i32> @llvm.vector.interleave2.nxv16i32(<vscale x 8 x i32> %10, <vscale x 8 x i32> %12)
  %interleaved.vec62 = tail call <vscale x 32 x i32> @llvm.vector.interleave2.nxv32i32(<vscale x 16 x i32> %interleaved.vec, <vscale x 16 x i32> %interleaved.vec61)
  store <vscale x 32 x i32> %interleaved.vec62, ptr %dst, align 4
  ret void
}
