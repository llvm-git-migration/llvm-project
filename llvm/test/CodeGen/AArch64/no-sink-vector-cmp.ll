; NOTE: Assertions have been autogenerated by utils/update_llc_test_checks.py UTC_ARGS: --version 5
; RUN: llc < %s | FileCheck %s

target triple = "aarch64-unknown-linux-gnu"

define void @vector_loop_with_icmp(ptr nocapture noundef writeonly %dest) {
; CHECK-LABEL: vector_loop_with_icmp:
; CHECK:       // %bb.0: // %entry
; CHECK-NEXT:    mov w9, #15 // =0xf
; CHECK-NEXT:    mov w10, #4 // =0x4
; CHECK-NEXT:    adrp x8, .LCPI0_0
; CHECK-NEXT:    adrp x11, .LCPI0_1
; CHECK-NEXT:    dup v0.2d, x9
; CHECK-NEXT:    dup v1.2d, x10
; CHECK-NEXT:    ldr q2, [x8, :lo12:.LCPI0_0]
; CHECK-NEXT:    ldr q3, [x11, :lo12:.LCPI0_1]
; CHECK-NEXT:    add x8, x0, #8
; CHECK-NEXT:    mov w9, #16 // =0x10
; CHECK-NEXT:    mov w10, #1 // =0x1
; CHECK-NEXT:    b .LBB0_2
; CHECK-NEXT:  .LBB0_1: // %pred.store.continue18
; CHECK-NEXT:    // in Loop: Header=BB0_2 Depth=1
; CHECK-NEXT:    add v2.2d, v2.2d, v1.2d
; CHECK-NEXT:    add v3.2d, v3.2d, v1.2d
; CHECK-NEXT:    subs x9, x9, #4
; CHECK-NEXT:    add x8, x8, #16
; CHECK-NEXT:    b.eq .LBB0_10
; CHECK-NEXT:  .LBB0_2: // %vector.body
; CHECK-NEXT:    // =>This Inner Loop Header: Depth=1
; CHECK-NEXT:    cmhi v4.2d, v0.2d, v2.2d
; CHECK-NEXT:    cmhi v5.2d, v0.2d, v3.2d
; CHECK-NEXT:    uzp1 v4.4s, v5.4s, v4.4s
; CHECK-NEXT:    xtn v4.4h, v4.4s
; CHECK-NEXT:    umov w11, v4.h[0]
; CHECK-NEXT:    tbnz w11, #0, .LBB0_6
; CHECK-NEXT:  // %bb.3: // %pred.store.continue
; CHECK-NEXT:    // in Loop: Header=BB0_2 Depth=1
; CHECK-NEXT:    umov w11, v4.h[1]
; CHECK-NEXT:    tbnz w11, #0, .LBB0_7
; CHECK-NEXT:  .LBB0_4: // %pred.store.continue6
; CHECK-NEXT:    // in Loop: Header=BB0_2 Depth=1
; CHECK-NEXT:    umov w11, v4.h[2]
; CHECK-NEXT:    tbnz w11, #0, .LBB0_8
; CHECK-NEXT:  .LBB0_5: // %pred.store.continue8
; CHECK-NEXT:    // in Loop: Header=BB0_2 Depth=1
; CHECK-NEXT:    umov w11, v4.h[3]
; CHECK-NEXT:    tbz w11, #0, .LBB0_1
; CHECK-NEXT:    b .LBB0_9
; CHECK-NEXT:  .LBB0_6: // %pred.store.if
; CHECK-NEXT:    // in Loop: Header=BB0_2 Depth=1
; CHECK-NEXT:    stur w10, [x8, #-8]
; CHECK-NEXT:    umov w11, v4.h[1]
; CHECK-NEXT:    tbz w11, #0, .LBB0_4
; CHECK-NEXT:  .LBB0_7: // %pred.store.if5
; CHECK-NEXT:    // in Loop: Header=BB0_2 Depth=1
; CHECK-NEXT:    stur w10, [x8, #-4]
; CHECK-NEXT:    umov w11, v4.h[2]
; CHECK-NEXT:    tbz w11, #0, .LBB0_5
; CHECK-NEXT:  .LBB0_8: // %pred.store.if7
; CHECK-NEXT:    // in Loop: Header=BB0_2 Depth=1
; CHECK-NEXT:    str w10, [x8]
; CHECK-NEXT:    umov w11, v4.h[3]
; CHECK-NEXT:    tbz w11, #0, .LBB0_1
; CHECK-NEXT:  .LBB0_9: // %pred.store.if9
; CHECK-NEXT:    // in Loop: Header=BB0_2 Depth=1
; CHECK-NEXT:    str w10, [x8, #4]
; CHECK-NEXT:    b .LBB0_1
; CHECK-NEXT:  .LBB0_10: // %for.cond.cleanup
; CHECK-NEXT:    ret
entry:
  br label %vector.body

vector.body:
  %index = phi i64 [ 0, %entry ], [ %index.next, %pred.store.continue18 ]
  %vec.ind = phi <4 x i64> [ <i64 0, i64 1, i64 2, i64 3>, %entry ], [ %vec.ind.next, %pred.store.continue18 ]
  %0 = icmp ult <4 x i64> %vec.ind, <i64 15, i64 15, i64 15, i64 15>
  %1 = extractelement <4 x i1> %0, i64 0
  br i1 %1, label %pred.store.if, label %pred.store.continue

pred.store.if:
  %2 = getelementptr inbounds i32, ptr %dest, i64 %index
  store i32 1, ptr %2, align 4
  br label %pred.store.continue

pred.store.continue:
  %3 = extractelement <4 x i1> %0, i64 1
  br i1 %3, label %pred.store.if5, label %pred.store.continue6

pred.store.if5:
  %4 = or disjoint i64 %index, 1
  %5 = getelementptr inbounds i32, ptr %dest, i64 %4
  store i32 1, ptr %5, align 4
  br label %pred.store.continue6

pred.store.continue6:
  %6 = extractelement <4 x i1> %0, i64 2
  br i1 %6, label %pred.store.if7, label %pred.store.continue8

pred.store.if7:
  %7 = or disjoint i64 %index, 2
  %8 = getelementptr inbounds i32, ptr %dest, i64 %7
  store i32 1, ptr %8, align 4
  br label %pred.store.continue8

pred.store.continue8:
  %9 = extractelement <4 x i1> %0, i64 3
  br i1 %9, label %pred.store.if9, label %pred.store.continue18

pred.store.if9:
  %10 = or disjoint i64 %index, 3
  %11 = getelementptr inbounds i32, ptr %dest, i64 %10
  store i32 1, ptr %11, align 4
  br label %pred.store.continue18

pred.store.continue18:
  %index.next = add i64 %index, 4
  %vec.ind.next = add <4 x i64> %vec.ind, <i64 4, i64 4, i64 4, i64 4>
  %24 = icmp eq i64 %index.next, 16
  br i1 %24, label %for.cond.cleanup, label %vector.body

for.cond.cleanup:
  ret void
}
