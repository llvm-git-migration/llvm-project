; NOTE: Assertions have been autogenerated by utils/update_llc_test_checks.py
; RUN: llc -mtriple=aarch64-none-linux-gnu -mattr=+sve -O3 < %s -o - | FileCheck %s --check-prefixes=CHECK

; Tests consecutive stores of @llvm.aarch64.sve.faddv. Within SDAG faddv is
; lowered as a FADDV + EXTRACT_VECTOR_ELT (of lane 0). Stores of extracts can
; be matched by DAGCombiner::mergeConsecutiveStores(), which we want to avoid in
; some cases as it can lead to worse codegen.

define void @consecutive_stores_pair(ptr noalias %dest0, ptr noalias %src0) {
; CHECK-LABEL: consecutive_stores_pair:
; CHECK:       // %bb.0:
; CHECK-NEXT:    ptrue p0.s
; CHECK-NEXT:    ld1w { z0.s }, p0/z, [x1]
; CHECK-NEXT:    ld1w { z1.s }, p0/z, [x1, #1, mul vl]
; CHECK-NEXT:    faddv s0, p0, z0.s
; CHECK-NEXT:    faddv s1, p0, z1.s
; CHECK-NEXT:    mov v0.s[1], v1.s[0]
; CHECK-NEXT:    str d0, [x0]
; CHECK-NEXT:    ret
  %ptrue = call <vscale x 4 x i1> @llvm.aarch64.sve.ptrue.nxv4i1(i32 31)
  %vscale = call i64 @llvm.vscale.i64()
  %c4_vscale = shl i64 %vscale, 2
  %src1 = getelementptr inbounds float, ptr %src0, i64 %c4_vscale
  %dest1 = getelementptr inbounds i8, ptr %dest0, i64 4
  %vec0 = load <vscale x 4 x float>, ptr %src0, align 4
  %vec1 = load <vscale x 4 x float>, ptr %src1, align 4
  %reduce0 = call float @llvm.aarch64.sve.faddv.nxv4f32(<vscale x 4 x i1> %ptrue, <vscale x 4 x float> %vec0)
  %reduce1 = call float @llvm.aarch64.sve.faddv.nxv4f32(<vscale x 4 x i1> %ptrue, <vscale x 4 x float> %vec1)
  store float %reduce0, ptr %dest0, align 4
  store float %reduce1, ptr %dest1, align 4
  ret void
}

define void @consecutive_stores_quadruple(ptr noalias %dest0, ptr noalias %src0) {
; CHECK-LABEL: consecutive_stores_quadruple:
; CHECK:       // %bb.0:
; CHECK-NEXT:    ptrue p0.s
; CHECK-NEXT:    ld1w { z0.s }, p0/z, [x1]
; CHECK-NEXT:    ld1w { z1.s }, p0/z, [x1, #1, mul vl]
; CHECK-NEXT:    ld1w { z2.s }, p0/z, [x1, #2, mul vl]
; CHECK-NEXT:    ld1w { z3.s }, p0/z, [x1, #3, mul vl]
; CHECK-NEXT:    faddv s0, p0, z0.s
; CHECK-NEXT:    faddv s1, p0, z1.s
; CHECK-NEXT:    faddv s2, p0, z2.s
; CHECK-NEXT:    mov v0.s[1], v1.s[0]
; CHECK-NEXT:    faddv s3, p0, z3.s
; CHECK-NEXT:    mov v2.s[1], v3.s[0]
; CHECK-NEXT:    stp d0, d2, [x0]
; CHECK-NEXT:    ret
  %ptrue = call <vscale x 4 x i1> @llvm.aarch64.sve.ptrue.nxv4i1(i32 31)
  %vscale = call i64 @llvm.vscale.i64()
  %c4_vscale = shl i64 %vscale, 2
  %dest1 = getelementptr inbounds i8, ptr %dest0, i64 4
  %dest2 = getelementptr inbounds i8, ptr %dest1, i64 4
  %dest3 = getelementptr inbounds i8, ptr %dest2, i64 4
  %src1 = getelementptr inbounds float, ptr %src0, i64 %c4_vscale
  %src2 = getelementptr inbounds float, ptr %src1, i64 %c4_vscale
  %src3 = getelementptr inbounds float, ptr %src2, i64 %c4_vscale
  %vec0 = load <vscale x 4 x float>, ptr %src0, align 4
  %vec1 = load <vscale x 4 x float>, ptr %src1, align 4
  %vec2 = load <vscale x 4 x float>, ptr %src2, align 4
  %vec3 = load <vscale x 4 x float>, ptr %src3, align 4
  %reduce0 = call float @llvm.aarch64.sve.faddv.nxv4f32(<vscale x 4 x i1> %ptrue, <vscale x 4 x float> %vec0)
  %reduce1 = call float @llvm.aarch64.sve.faddv.nxv4f32(<vscale x 4 x i1> %ptrue, <vscale x 4 x float> %vec1)
  %reduce2 = call float @llvm.aarch64.sve.faddv.nxv4f32(<vscale x 4 x i1> %ptrue, <vscale x 4 x float> %vec2)
  %reduce3 = call float @llvm.aarch64.sve.faddv.nxv4f32(<vscale x 4 x i1> %ptrue, <vscale x 4 x float> %vec3)
  store float %reduce0, ptr %dest0, align 4
  store float %reduce1, ptr %dest1, align 4
  store float %reduce2, ptr %dest2, align 4
  store float %reduce3, ptr %dest3, align 4
  ret void
}

define void @consecutive_stores_pair_streaming_function(ptr noalias %dest0, ptr noalias %src0) #0 "aarch64_pstate_sm_enabled"  {
; CHECK-LABEL: consecutive_stores_pair_streaming_function:
; CHECK:       // %bb.0:
; CHECK-NEXT:    sub sp, sp, #16
; CHECK-NEXT:    .cfi_def_cfa_offset 16
; CHECK-NEXT:    ptrue p0.s
; CHECK-NEXT:    ld1w { z0.s }, p0/z, [x1, #1, mul vl]
; CHECK-NEXT:    ld1w { z1.s }, p0/z, [x1]
; CHECK-NEXT:    faddv s0, p0, z0.s
; CHECK-NEXT:    faddv s1, p0, z1.s
; CHECK-NEXT:    stp s1, s0, [sp, #8]
; CHECK-NEXT:    ldr d0, [sp, #8]
; CHECK-NEXT:    str d0, [x0]
; CHECK-NEXT:    add sp, sp, #16
; CHECK-NEXT:    ret
  %ptrue = call <vscale x 4 x i1> @llvm.aarch64.sve.ptrue.nxv4i1(i32 31)
  %vscale = call i64 @llvm.vscale.i64()
  %c4_vscale = shl i64 %vscale, 2
  %src1 = getelementptr inbounds float, ptr %src0, i64 %c4_vscale
  %dest1 = getelementptr inbounds i8, ptr %dest0, i64 4
  %vec0 = load <vscale x 4 x float>, ptr %src0, align 4
  %vec1 = load <vscale x 4 x float>, ptr %src1, align 4
  %reduce0 = call float @llvm.aarch64.sve.faddv.nxv4f32(<vscale x 4 x i1> %ptrue, <vscale x 4 x float> %vec0)
  %reduce1 = call float @llvm.aarch64.sve.faddv.nxv4f32(<vscale x 4 x i1> %ptrue, <vscale x 4 x float> %vec1)
  store float %reduce0, ptr %dest0, align 4
  store float %reduce1, ptr %dest1, align 4
  ret void
}

define void @consecutive_stores_quadruple_streaming_function(ptr noalias %dest0, ptr noalias %src0) #0 "aarch64_pstate_sm_enabled" {
; CHECK-LABEL: consecutive_stores_quadruple_streaming_function:
; CHECK:       // %bb.0:
; CHECK-NEXT:    ptrue p0.s
; CHECK-NEXT:    ld1w { z0.s }, p0/z, [x1]
; CHECK-NEXT:    ld1w { z1.s }, p0/z, [x1, #1, mul vl]
; CHECK-NEXT:    ld1w { z2.s }, p0/z, [x1, #3, mul vl]
; CHECK-NEXT:    ld1w { z3.s }, p0/z, [x1, #2, mul vl]
; CHECK-NEXT:    faddv s0, p0, z0.s
; CHECK-NEXT:    faddv s1, p0, z1.s
; CHECK-NEXT:    faddv s2, p0, z2.s
; CHECK-NEXT:    faddv s3, p0, z3.s
; CHECK-NEXT:    stp s0, s1, [sp, #-16]!
; CHECK-NEXT:    .cfi_def_cfa_offset 16
; CHECK-NEXT:    ldr d0, [sp]
; CHECK-NEXT:    str d0, [x0]
; CHECK-NEXT:    stp s3, s2, [sp, #8]
; CHECK-NEXT:    ldr d0, [sp, #8]
; CHECK-NEXT:    str d0, [x0, #8]
; CHECK-NEXT:    add sp, sp, #16
; CHECK-NEXT:    ret
  %ptrue = call <vscale x 4 x i1> @llvm.aarch64.sve.ptrue.nxv4i1(i32 31)
  %vscale = call i64 @llvm.vscale.i64()
  %c4_vscale = shl i64 %vscale, 2
  %dest1 = getelementptr inbounds i8, ptr %dest0, i64 4
  %dest2 = getelementptr inbounds i8, ptr %dest1, i64 4
  %dest3 = getelementptr inbounds i8, ptr %dest2, i64 4
  %src1 = getelementptr inbounds float, ptr %src0, i64 %c4_vscale
  %src2 = getelementptr inbounds float, ptr %src1, i64 %c4_vscale
  %src3 = getelementptr inbounds float, ptr %src2, i64 %c4_vscale
  %vec0 = load <vscale x 4 x float>, ptr %src0, align 4
  %vec1 = load <vscale x 4 x float>, ptr %src1, align 4
  %vec2 = load <vscale x 4 x float>, ptr %src2, align 4
  %vec3 = load <vscale x 4 x float>, ptr %src3, align 4
  %reduce0 = call float @llvm.aarch64.sve.faddv.nxv4f32(<vscale x 4 x i1> %ptrue, <vscale x 4 x float> %vec0)
  %reduce1 = call float @llvm.aarch64.sve.faddv.nxv4f32(<vscale x 4 x i1> %ptrue, <vscale x 4 x float> %vec1)
  %reduce2 = call float @llvm.aarch64.sve.faddv.nxv4f32(<vscale x 4 x i1> %ptrue, <vscale x 4 x float> %vec2)
  %reduce3 = call float @llvm.aarch64.sve.faddv.nxv4f32(<vscale x 4 x i1> %ptrue, <vscale x 4 x float> %vec3)
  store float %reduce0, ptr %dest0, align 4
  store float %reduce1, ptr %dest1, align 4
  store float %reduce2, ptr %dest2, align 4
  store float %reduce3, ptr %dest3, align 4
  ret void
}

attributes #0 = { vscale_range(1, 16) "target-features"="+sve,+sme" }
