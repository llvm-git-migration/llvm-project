; NOTE: Assertions have been autogenerated by utils/update_llc_test_checks.py UTC_ARGS: --version 4
; RUN: llc < %s -mtriple=wasm32 -verify-machineinstrs -disable-wasm-fallthrough-return-opt -wasm-disable-explicit-locals -wasm-keep-registers -mattr=+simd128 | FileCheck %s --check-prefix=SIMD128

define i64 @pairwise_add_v2i64(<2 x i64> %arg) {
; SIMD128-LABEL: pairwise_add_v2i64:
; SIMD128:         .functype pairwise_add_v2i64 (v128) -> (i64)
; SIMD128-NEXT:  # %bb.0:
; SIMD128-NEXT:    i8x16.shuffle $push0=, $0, $0, 8, 9, 10, 11, 12, 13, 14, 15, 0, 1, 2, 3, 4, 5, 6, 7
; SIMD128-NEXT:    i64x2.add $push1=, $0, $pop0
; SIMD128-NEXT:    i64x2.extract_lane $push2=, $pop1, 0
; SIMD128-NEXT:    return $pop2
  %res = tail call i64 @llvm.vector.reduce.add.i64.v4i64(<2 x i64> %arg)
  ret i64 %res
}

define i32 @pairwise_add_v4i32(<4 x i32> %arg) {
; SIMD128-LABEL: pairwise_add_v4i32:
; SIMD128:         .functype pairwise_add_v4i32 (v128) -> (i32)
; SIMD128-NEXT:  # %bb.0:
; SIMD128-NEXT:    i8x16.shuffle $push0=, $0, $0, 4, 5, 6, 7, 0, 1, 2, 3, 12, 13, 14, 15, 0, 1, 2, 3
; SIMD128-NEXT:    i32x4.add $push5=, $0, $pop0
; SIMD128-NEXT:    local.tee $push4=, $0=, $pop5
; SIMD128-NEXT:    i8x16.shuffle $push1=, $0, $0, 8, 9, 10, 11, 0, 1, 2, 3, 0, 1, 2, 3, 0, 1, 2, 3
; SIMD128-NEXT:    i32x4.add $push2=, $pop4, $pop1
; SIMD128-NEXT:    i32x4.extract_lane $push3=, $pop2, 0
; SIMD128-NEXT:    return $pop3
  %res = tail call i32 @llvm.vector.reduce.add.i32.v4f32(<4 x i32> %arg)
  ret i32 %res
}

define i16 @pairwise_add_v8i16(<8 x i16> %arg) {
; SIMD128-LABEL: pairwise_add_v8i16:
; SIMD128:         .functype pairwise_add_v8i16 (v128) -> (i32)
; SIMD128-NEXT:  # %bb.0:
; SIMD128-NEXT:    i8x16.shuffle $push0=, $0, $0, 2, 3, 0, 1, 6, 7, 0, 1, 10, 11, 0, 1, 14, 15, 0, 1
; SIMD128-NEXT:    i16x8.add $push8=, $0, $pop0
; SIMD128-NEXT:    local.tee $push7=, $0=, $pop8
; SIMD128-NEXT:    i8x16.shuffle $push1=, $0, $0, 4, 5, 0, 1, 0, 1, 0, 1, 12, 13, 0, 1, 0, 1, 0, 1
; SIMD128-NEXT:    i16x8.add $push6=, $pop7, $pop1
; SIMD128-NEXT:    local.tee $push5=, $0=, $pop6
; SIMD128-NEXT:    i8x16.shuffle $push2=, $0, $0, 8, 9, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1
; SIMD128-NEXT:    i16x8.add $push3=, $pop5, $pop2
; SIMD128-NEXT:    i16x8.extract_lane_u $push4=, $pop3, 0
; SIMD128-NEXT:    return $pop4
  %res = tail call i16 @llvm.vector.reduce.add.i16.v8i16(<8 x i16> %arg)
  ret i16 %res
}

define i8 @pairwise_add_v16i8(<16 x i8> %arg) {
; SIMD128-LABEL: pairwise_add_v16i8:
; SIMD128:         .functype pairwise_add_v16i8 (v128) -> (i32)
; SIMD128-NEXT:  # %bb.0:
; SIMD128-NEXT:    i8x16.shuffle $push0=, $0, $0, 1, 0, 3, 0, 5, 0, 7, 0, 9, 0, 11, 0, 13, 0, 15, 0
; SIMD128-NEXT:    i8x16.add $push11=, $0, $pop0
; SIMD128-NEXT:    local.tee $push10=, $0=, $pop11
; SIMD128-NEXT:    i8x16.shuffle $push1=, $0, $0, 2, 0, 0, 0, 6, 0, 0, 0, 10, 0, 0, 0, 14, 0, 0, 0
; SIMD128-NEXT:    i8x16.add $push9=, $pop10, $pop1
; SIMD128-NEXT:    local.tee $push8=, $0=, $pop9
; SIMD128-NEXT:    i8x16.shuffle $push2=, $0, $0, 4, 0, 0, 0, 0, 0, 0, 0, 12, 0, 0, 0, 0, 0, 0, 0
; SIMD128-NEXT:    i8x16.add $push7=, $pop8, $pop2
; SIMD128-NEXT:    local.tee $push6=, $0=, $pop7
; SIMD128-NEXT:    i8x16.shuffle $push3=, $0, $0, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
; SIMD128-NEXT:    i8x16.add $push4=, $pop6, $pop3
; SIMD128-NEXT:    i8x16.extract_lane_u $push5=, $pop4, 0
; SIMD128-NEXT:    return $pop5
  %res = tail call i8 @llvm.vector.reduce.add.i8.v16i8(<16 x i8> %arg)
  ret i8 %res
}

define double @pairwise_add_v2f64(<2 x double> %arg) {
; SIMD128-LABEL: pairwise_add_v2f64:
; SIMD128:         .functype pairwise_add_v2f64 (v128) -> (f64)
; SIMD128-NEXT:  # %bb.0:
; SIMD128-NEXT:    f64x2.extract_lane $push1=, $0, 0
; SIMD128-NEXT:    f64x2.extract_lane $push0=, $0, 1
; SIMD128-NEXT:    f64.add $push2=, $pop1, $pop0
; SIMD128-NEXT:    return $pop2
  %res = tail call double @llvm.vector.reduce.fadd.f64.v2f64(double -0.0, <2 x double> %arg)
  ret double%res
}

define double @pairwise_add_v2f64_fast(<2 x double> %arg) {
; SIMD128-LABEL: pairwise_add_v2f64_fast:
; SIMD128:         .functype pairwise_add_v2f64_fast (v128) -> (f64)
; SIMD128-NEXT:  # %bb.0:
; SIMD128-NEXT:    i8x16.shuffle $push0=, $0, $0, 8, 9, 10, 11, 12, 13, 14, 15, 0, 1, 2, 3, 4, 5, 6, 7
; SIMD128-NEXT:    f64x2.add $push1=, $0, $pop0
; SIMD128-NEXT:    f64x2.extract_lane $push2=, $pop1, 0
; SIMD128-NEXT:    return $pop2
  %res = tail call fast double @llvm.vector.reduce.fadd.f64.v2f64(double -0.0, <2 x double> %arg)
  ret double%res
}

define float @pairwise_add_v4f32(<4 x float> %arg) {
; SIMD128-LABEL: pairwise_add_v4f32:
; SIMD128:         .functype pairwise_add_v4f32 (v128) -> (f32)
; SIMD128-NEXT:  # %bb.0:
; SIMD128-NEXT:    f32x4.extract_lane $push1=, $0, 0
; SIMD128-NEXT:    f32x4.extract_lane $push0=, $0, 1
; SIMD128-NEXT:    f32.add $push2=, $pop1, $pop0
; SIMD128-NEXT:    f32x4.extract_lane $push3=, $0, 2
; SIMD128-NEXT:    f32.add $push4=, $pop2, $pop3
; SIMD128-NEXT:    f32x4.extract_lane $push5=, $0, 3
; SIMD128-NEXT:    f32.add $push6=, $pop4, $pop5
; SIMD128-NEXT:    return $pop6
  %res = tail call float @llvm.vector.reduce.fadd.f32.v4f32(float -0.0, <4 x float> %arg)
  ret float %res
}

define float @pairwise_add_v4f32_fast(<4 x float> %arg) {
; SIMD128-LABEL: pairwise_add_v4f32_fast:
; SIMD128:         .functype pairwise_add_v4f32_fast (v128) -> (f32)
; SIMD128-NEXT:  # %bb.0:
; SIMD128-NEXT:    i8x16.shuffle $push0=, $0, $0, 4, 5, 6, 7, 0, 1, 2, 3, 12, 13, 14, 15, 0, 1, 2, 3
; SIMD128-NEXT:    f32x4.add $push5=, $0, $pop0
; SIMD128-NEXT:    local.tee $push4=, $0=, $pop5
; SIMD128-NEXT:    i8x16.shuffle $push1=, $0, $0, 8, 9, 10, 11, 0, 1, 2, 3, 0, 1, 2, 3, 0, 1, 2, 3
; SIMD128-NEXT:    f32x4.add $push2=, $pop4, $pop1
; SIMD128-NEXT:    f32x4.extract_lane $push3=, $pop2, 0
; SIMD128-NEXT:    return $pop3
  %res = tail call fast float @llvm.vector.reduce.fadd.f32.v4f32(float -0.0, <4 x float> %arg)
  ret float %res
}

declare i64 @llvm.vector.reduce.add.i64.v4i64(<2 x i64>)
declare i32 @llvm.vector.reduce.add.i32.v4i32(<4 x i32>)
declare i16 @llvm.vector.reduce.add.i16.v8i16(<8 x i16>)
declare i8 @llvm.vector.reduce.add.i8.v16i8(<16 x i8>)
declare double @llvm.vector.reduce.fadd.f64.v2f64(double, <2 x double>)
declare float @llvm.vector.reduce.fadd.f32.v4f32(float, <4 x float>)
