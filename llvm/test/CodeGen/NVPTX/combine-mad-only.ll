; NOTE: Assertions have been autogenerated by utils/update_llc_test_checks.py UTC_ARGS: --version 5
; RUN: llc < %s -mtriple=nvptx -mcpu=sm_20 -O1 --selectiondag-simplify-nodes=false --combiner-generic-combines=false --debug-counter=early-cse=100, | FileCheck %s
; RUN: llc < %s -mtriple=nvptx64 -mcpu=sm_20 -O1 --selectiondag-simplify-nodes=false --combiner-generic-combines=false --debug-counter=early-cse=100, | FileCheck %s
; RUN: %if ptxas && !ptxas-12.0 %{ llc < %s -mtriple=nvptx -mcpu=sm_20 -O1 --selectiondag-simplify-nodes=false --combiner-generic-combines=false --debug-counter=early-cse=100, | %ptxas-verify %}
; RUN: %if ptxas %{ llc < %s -mtriple=nvptx64 -mcpu=sm_20 -O1 --selectiondag-simplify-nodes=false --combiner-generic-combines=false --debug-counter=early-cse=100, | %ptxas-verify %}

;; mad x 1 y => add y x
define i32 @test_mad_mul_1(i32 %x, i32 %y) {
; CHECK-LABEL: test_mad_mul_1(
; CHECK:       {
; CHECK-NEXT:    .reg .b32 %r<4>;
; CHECK-EMPTY:
; CHECK-NEXT:  // %bb.0:
; CHECK-NEXT:    ld.param.u32 %r1, [test_mad_mul_1_param_0];
; CHECK-NEXT:    ld.param.u32 %r2, [test_mad_mul_1_param_1];
; CHECK-NEXT:    add.s32 %r3, %r1, %r2;
; CHECK-NEXT:    st.param.b32 [func_retval0], %r3;
; CHECK-NEXT:    ret;
  %mul = mul i32 %x, 1
  %add = add i32 %mul, %y
  ret i32 %add
}

;; mad x -1 y => sub y x
define i32 @test_mad_mul_neg_1(i32 %x, i32 %y) {
; CHECK-LABEL: test_mad_mul_neg_1(
; CHECK:       {
; CHECK-NEXT:    .reg .b32 %r<4>;
; CHECK-EMPTY:
; CHECK-NEXT:  // %bb.0:
; CHECK-NEXT:    ld.param.u32 %r1, [test_mad_mul_neg_1_param_0];
; CHECK-NEXT:    ld.param.u32 %r2, [test_mad_mul_neg_1_param_1];
; CHECK-NEXT:    sub.s32 %r3, %r2, %r1;
; CHECK-NEXT:    st.param.b32 [func_retval0], %r3;
; CHECK-NEXT:    ret;
  %mul = mul i32 %x, -1
  %add = add i32 %mul, %y
  ret i32 %add
}

;; mad x 0 y => y
define i32 @test_mad_mul_0(i32 %x, i32 %y) {
; CHECK-LABEL: test_mad_mul_0(
; CHECK:       {
; CHECK-NEXT:    .reg .b32 %r<2>;
; CHECK-EMPTY:
; CHECK-NEXT:  // %bb.0:
; CHECK-NEXT:    ld.param.u32 %r1, [test_mad_mul_0_param_1];
; CHECK-NEXT:    st.param.b32 [func_retval0], %r1;
; CHECK-NEXT:    ret;
  %mul = mul i32 %x, 0
  %add = add i32 %mul, %y
  ret i32 %add
}

;; mad x y 0 => mul x y
define i32 @test_mad_add_0(i32 %x, i32 %y) {
; CHECK-LABEL: test_mad_add_0(
; CHECK:       {
; CHECK-NEXT:    .reg .b32 %r<4>;
; CHECK-EMPTY:
; CHECK-NEXT:  // %bb.0:
; CHECK-NEXT:    ld.param.u32 %r1, [test_mad_add_0_param_0];
; CHECK-NEXT:    ld.param.u32 %r2, [test_mad_add_0_param_1];
; CHECK-NEXT:    mul.lo.s32 %r3, %r1, %r2;
; CHECK-NEXT:    st.param.b32 [func_retval0], %r3;
; CHECK-NEXT:    ret;
  %mul = mul i32 %x, %y
  %add = add i32 %mul, 0
  ret i32 %add
}

;; mad c0 c1 x => add x (c0*c1)
define i32 @test_mad_fold_mul(i32 %x) {
; CHECK-LABEL: test_mad_fold_mul(
; CHECK:       {
; CHECK-NEXT:    .reg .b32 %r<3>;
; CHECK-EMPTY:
; CHECK-NEXT:  // %bb.0:
; CHECK-NEXT:    ld.param.u32 %r1, [test_mad_fold_mul_param_0];
; CHECK-NEXT:    add.s32 %r2, %r1, 12;
; CHECK-NEXT:    st.param.b32 [func_retval0], %r2;
; CHECK-NEXT:    ret;
  %mul = mul i32 4, 3
  %add = add i32 %mul, %x
  ret i32 %add
}
