; NOTE: Assertions have been autogenerated by utils/update_test_checks.py UTC_ARGS: --version 5
; RUN: opt < %s -mtriple nvptx -mcpu=sm_70 -nvptx-lower-args -S | FileCheck %s --check-prefixes=CHECK,CHECK32
source_filename = "<stdin>"
target datalayout = "e-i64:64-i128:128-v16:16-v32:32-n16:32:64"
target triple = "nvptx64-nvidia-cuda"

%struct.S = type { i32, i32 }

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: readwrite)
declare dso_local void @_Z6escapePv(ptr noundef) local_unnamed_addr #0

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: readwrite)
declare dso_local void @_Z6escapei(i32 noundef) local_unnamed_addr #0

; Function Attrs: nocallback nofree nounwind willreturn memory(argmem: readwrite)
declare void @llvm.memcpy.p0.p0.i64(ptr noalias nocapture writeonly, ptr noalias nocapture readonly, i64, i1 immarg) #1

; Function Attrs: nocallback nofree nounwind willreturn memory(argmem: readwrite)
declare void @llvm.memmove.p0.p0.i64(ptr nocapture writeonly, ptr nocapture readonly, i64, i1 immarg) #1

; Function Attrs: nocallback nofree nounwind willreturn memory(argmem: write)
declare void @llvm.memset.p0.i64(ptr nocapture writeonly, i8, i64, i1 immarg) #2

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: readwrite)
define dso_local void @read_only(ptr nocapture noundef writeonly %out, ptr nocapture noundef readonly byval(%struct.S) align 4 %s) local_unnamed_addr #0 {
; CHECK-LABEL: define dso_local void @read_only(
; CHECK-SAME: ptr nocapture noundef writeonly [[OUT:%.*]], ptr nocapture noundef readonly byval([[STRUCT_S:%.*]]) align 4 [[S:%.*]]) local_unnamed_addr #[[ATTR0:[0-9]+]] {
; CHECK-NEXT:  [[ENTRY:.*:]]
; CHECK-NEXT:    [[S3:%.*]] = addrspacecast ptr [[S]] to ptr addrspace(101)
; CHECK-NEXT:    [[OUT1:%.*]] = addrspacecast ptr [[OUT]] to ptr addrspace(1)
; CHECK-NEXT:    [[OUT2:%.*]] = addrspacecast ptr addrspace(1) [[OUT1]] to ptr
; CHECK-NEXT:    [[I:%.*]] = load i32, ptr addrspace(101) [[S3]], align 4
; CHECK-NEXT:    store i32 [[I]], ptr [[OUT2]], align 4
; CHECK-NEXT:    ret void
;
entry:
  %i = load i32, ptr %s, align 4
  store i32 %i, ptr %out, align 4
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: readwrite)
define dso_local void @read_only_gep(ptr nocapture noundef writeonly %out, ptr nocapture noundef readonly byval(%struct.S) align 4 %s) local_unnamed_addr #0 {
; CHECK-LABEL: define dso_local void @read_only_gep(
; CHECK-SAME: ptr nocapture noundef writeonly [[OUT:%.*]], ptr nocapture noundef readonly byval([[STRUCT_S:%.*]]) align 4 [[S:%.*]]) local_unnamed_addr #[[ATTR0]] {
; CHECK-NEXT:  [[ENTRY:.*:]]
; CHECK-NEXT:    [[S3:%.*]] = addrspacecast ptr [[S]] to ptr addrspace(101)
; CHECK-NEXT:    [[OUT1:%.*]] = addrspacecast ptr [[OUT]] to ptr addrspace(1)
; CHECK-NEXT:    [[OUT2:%.*]] = addrspacecast ptr addrspace(1) [[OUT1]] to ptr
; CHECK-NEXT:    [[B4:%.*]] = getelementptr inbounds i8, ptr addrspace(101) [[S3]], i64 4
; CHECK-NEXT:    [[I:%.*]] = load i32, ptr addrspace(101) [[B4]], align 4
; CHECK-NEXT:    store i32 [[I]], ptr [[OUT2]], align 4
; CHECK-NEXT:    ret void
;
entry:
  %b = getelementptr inbounds nuw i8, ptr %s, i64 4
  %i = load i32, ptr %b, align 4
  store i32 %i, ptr %out, align 4
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: readwrite)
define dso_local void @read_only_gep_asc(ptr nocapture noundef writeonly %out, ptr nocapture noundef readonly byval(%struct.S) align 4 %s) local_unnamed_addr #0 {
; CHECK-LABEL: define dso_local void @read_only_gep_asc(
; CHECK-SAME: ptr nocapture noundef writeonly [[OUT:%.*]], ptr nocapture noundef readonly byval([[STRUCT_S:%.*]]) align 4 [[S:%.*]]) local_unnamed_addr #[[ATTR0]] {
; CHECK-NEXT:  [[ENTRY:.*:]]
; CHECK-NEXT:    [[S3:%.*]] = addrspacecast ptr [[S]] to ptr addrspace(101)
; CHECK-NEXT:    [[OUT1:%.*]] = addrspacecast ptr [[OUT]] to ptr addrspace(1)
; CHECK-NEXT:    [[OUT2:%.*]] = addrspacecast ptr addrspace(1) [[OUT1]] to ptr
; CHECK-NEXT:    [[B4:%.*]] = getelementptr inbounds i8, ptr addrspace(101) [[S3]], i64 4
; CHECK-NEXT:    [[I:%.*]] = load i32, ptr addrspace(101) [[B4]], align 4
; CHECK-NEXT:    store i32 [[I]], ptr [[OUT2]], align 4
; CHECK-NEXT:    ret void
;
entry:
  %b = getelementptr inbounds nuw i8, ptr %s, i64 4
  %asc = addrspacecast ptr %b to ptr addrspace(101)
  %i = load i32, ptr addrspace(101) %asc, align 4
  store i32 %i, ptr %out, align 4
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: readwrite)
define dso_local void @read_only_gep_asc0(ptr nocapture noundef writeonly %out, ptr nocapture noundef readonly byval(%struct.S) align 4 %s) local_unnamed_addr #0 {
; CHECK-LABEL: define dso_local void @read_only_gep_asc0(
; CHECK-SAME: ptr nocapture noundef writeonly [[OUT:%.*]], ptr nocapture noundef readonly byval([[STRUCT_S:%.*]]) align 4 [[S:%.*]]) local_unnamed_addr #[[ATTR0]] {
; CHECK-NEXT:  [[ENTRY:.*:]]
; CHECK-NEXT:    [[S3:%.*]] = alloca [[STRUCT_S]], align 4
; CHECK-NEXT:    [[S4:%.*]] = addrspacecast ptr [[S]] to ptr addrspace(101)
; CHECK-NEXT:    [[S5:%.*]] = load [[STRUCT_S]], ptr addrspace(101) [[S4]], align 4
; CHECK-NEXT:    store [[STRUCT_S]] [[S5]], ptr [[S3]], align 4
; CHECK-NEXT:    [[OUT1:%.*]] = addrspacecast ptr [[OUT]] to ptr addrspace(1)
; CHECK-NEXT:    [[OUT2:%.*]] = addrspacecast ptr addrspace(1) [[OUT1]] to ptr
; CHECK-NEXT:    [[B:%.*]] = getelementptr inbounds nuw i8, ptr [[S3]], i64 4
; CHECK-NEXT:    [[ASC:%.*]] = addrspacecast ptr [[B]] to ptr addrspace(101)
; CHECK-NEXT:    [[ASC0:%.*]] = addrspacecast ptr addrspace(101) [[ASC]] to ptr
; CHECK-NEXT:    [[I:%.*]] = load i32, ptr [[ASC0]], align 4
; CHECK-NEXT:    store i32 [[I]], ptr [[OUT2]], align 4
; CHECK-NEXT:    ret void
;
entry:
  %b = getelementptr inbounds nuw i8, ptr %s, i64 4
  %asc = addrspacecast ptr %b to ptr addrspace(101)
  %asc0 = addrspacecast ptr addrspace(101) %asc to ptr
  %i = load i32, ptr %asc0, align 4
  store i32 %i, ptr %out, align 4
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: readwrite)
define dso_local void @escape_ptr(ptr nocapture noundef readnone %out, ptr noundef byval(%struct.S) align 4 %s) local_unnamed_addr #0 {
; CHECK-LABEL: define dso_local void @escape_ptr(
; CHECK-SAME: ptr nocapture noundef readnone [[OUT:%.*]], ptr noundef byval([[STRUCT_S:%.*]]) align 4 [[S:%.*]]) local_unnamed_addr #[[ATTR0]] {
; CHECK-NEXT:  [[ENTRY:.*:]]
; CHECK-NEXT:    [[S3:%.*]] = alloca [[STRUCT_S]], align 4
; CHECK-NEXT:    [[S4:%.*]] = addrspacecast ptr [[S]] to ptr addrspace(101)
; CHECK-NEXT:    [[S5:%.*]] = load [[STRUCT_S]], ptr addrspace(101) [[S4]], align 4
; CHECK-NEXT:    store [[STRUCT_S]] [[S5]], ptr [[S3]], align 4
; CHECK-NEXT:    [[OUT1:%.*]] = addrspacecast ptr [[OUT]] to ptr addrspace(1)
; CHECK-NEXT:    [[OUT2:%.*]] = addrspacecast ptr addrspace(1) [[OUT1]] to ptr
; CHECK-NEXT:    call void @_Z6escapePv(ptr noundef nonnull [[S3]]) #[[ATTR0]]
; CHECK-NEXT:    ret void
;
entry:
  call void @_Z6escapePv(ptr noundef nonnull %s) #0
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: readwrite)
define dso_local void @escape_ptr_gep(ptr nocapture noundef readnone %out, ptr noundef byval(%struct.S) align 4 %s) local_unnamed_addr #0 {
; CHECK-LABEL: define dso_local void @escape_ptr_gep(
; CHECK-SAME: ptr nocapture noundef readnone [[OUT:%.*]], ptr noundef byval([[STRUCT_S:%.*]]) align 4 [[S:%.*]]) local_unnamed_addr #[[ATTR0]] {
; CHECK-NEXT:  [[ENTRY:.*:]]
; CHECK-NEXT:    [[S3:%.*]] = alloca [[STRUCT_S]], align 4
; CHECK-NEXT:    [[S4:%.*]] = addrspacecast ptr [[S]] to ptr addrspace(101)
; CHECK-NEXT:    [[S5:%.*]] = load [[STRUCT_S]], ptr addrspace(101) [[S4]], align 4
; CHECK-NEXT:    store [[STRUCT_S]] [[S5]], ptr [[S3]], align 4
; CHECK-NEXT:    [[OUT1:%.*]] = addrspacecast ptr [[OUT]] to ptr addrspace(1)
; CHECK-NEXT:    [[OUT2:%.*]] = addrspacecast ptr addrspace(1) [[OUT1]] to ptr
; CHECK-NEXT:    [[B:%.*]] = getelementptr inbounds nuw i8, ptr [[S3]], i64 4
; CHECK-NEXT:    call void @_Z6escapePv(ptr noundef nonnull [[B]]) #[[ATTR0]]
; CHECK-NEXT:    ret void
;
entry:
  %b = getelementptr inbounds nuw i8, ptr %s, i64 4
  call void @_Z6escapePv(ptr noundef nonnull %b) #0
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: readwrite)
define dso_local void @escape_ptr_store(ptr nocapture noundef writeonly %out, ptr noundef byval(%struct.S) align 4 %s) local_unnamed_addr #0 {
; CHECK-LABEL: define dso_local void @escape_ptr_store(
; CHECK-SAME: ptr nocapture noundef writeonly [[OUT:%.*]], ptr noundef byval([[STRUCT_S:%.*]]) align 4 [[S:%.*]]) local_unnamed_addr #[[ATTR0]] {
; CHECK-NEXT:  [[ENTRY:.*:]]
; CHECK-NEXT:    [[S3:%.*]] = alloca [[STRUCT_S]], align 4
; CHECK-NEXT:    [[S4:%.*]] = addrspacecast ptr [[S]] to ptr addrspace(101)
; CHECK-NEXT:    [[S5:%.*]] = load [[STRUCT_S]], ptr addrspace(101) [[S4]], align 4
; CHECK-NEXT:    store [[STRUCT_S]] [[S5]], ptr [[S3]], align 4
; CHECK-NEXT:    [[OUT1:%.*]] = addrspacecast ptr [[OUT]] to ptr addrspace(1)
; CHECK-NEXT:    [[OUT2:%.*]] = addrspacecast ptr addrspace(1) [[OUT1]] to ptr
; CHECK-NEXT:    [[I:%.*]] = ptrtoint ptr [[S3]] to i64
; CHECK-NEXT:    store i64 [[I]], ptr [[OUT2]], align 8
; CHECK-NEXT:    ret void
;
entry:
  %i = ptrtoint ptr %s to i64
  store i64 %i, ptr %out, align 8
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: readwrite)
define dso_local void @escape_ptr_gep_store(ptr nocapture noundef writeonly %out, ptr noundef byval(%struct.S) align 4 %s) local_unnamed_addr #0 {
; CHECK-LABEL: define dso_local void @escape_ptr_gep_store(
; CHECK-SAME: ptr nocapture noundef writeonly [[OUT:%.*]], ptr noundef byval([[STRUCT_S:%.*]]) align 4 [[S:%.*]]) local_unnamed_addr #[[ATTR0]] {
; CHECK-NEXT:  [[ENTRY:.*:]]
; CHECK-NEXT:    [[S3:%.*]] = alloca [[STRUCT_S]], align 4
; CHECK-NEXT:    [[S4:%.*]] = addrspacecast ptr [[S]] to ptr addrspace(101)
; CHECK-NEXT:    [[S5:%.*]] = load [[STRUCT_S]], ptr addrspace(101) [[S4]], align 4
; CHECK-NEXT:    store [[STRUCT_S]] [[S5]], ptr [[S3]], align 4
; CHECK-NEXT:    [[OUT1:%.*]] = addrspacecast ptr [[OUT]] to ptr addrspace(1)
; CHECK-NEXT:    [[OUT2:%.*]] = addrspacecast ptr addrspace(1) [[OUT1]] to ptr
; CHECK-NEXT:    [[B:%.*]] = getelementptr inbounds nuw i8, ptr [[S3]], i64 4
; CHECK-NEXT:    [[I:%.*]] = ptrtoint ptr [[B]] to i64
; CHECK-NEXT:    store i64 [[I]], ptr [[OUT2]], align 8
; CHECK-NEXT:    ret void
;
entry:
  %b = getelementptr inbounds nuw i8, ptr %s, i64 4
  %i = ptrtoint ptr %b to i64
  store i64 %i, ptr %out, align 8
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: readwrite)
define dso_local void @escape_math_store(ptr nocapture noundef writeonly %out, ptr noundef byval(%struct.S) align 4 %s) local_unnamed_addr #0 {
; CHECK-LABEL: define dso_local void @escape_math_store(
; CHECK-SAME: ptr nocapture noundef writeonly [[OUT:%.*]], ptr noundef byval([[STRUCT_S:%.*]]) align 4 [[S:%.*]]) local_unnamed_addr #[[ATTR0]] {
; CHECK-NEXT:  [[ENTRY:.*:]]
; CHECK-NEXT:    [[S3:%.*]] = alloca [[STRUCT_S]], align 4
; CHECK-NEXT:    [[S4:%.*]] = addrspacecast ptr [[S]] to ptr addrspace(101)
; CHECK-NEXT:    [[S5:%.*]] = load [[STRUCT_S]], ptr addrspace(101) [[S4]], align 4
; CHECK-NEXT:    store [[STRUCT_S]] [[S5]], ptr [[S3]], align 4
; CHECK-NEXT:    [[OUT1:%.*]] = addrspacecast ptr [[OUT]] to ptr addrspace(1)
; CHECK-NEXT:    [[OUT2:%.*]] = addrspacecast ptr addrspace(1) [[OUT1]] to ptr
; CHECK-NEXT:    [[I:%.*]] = ptrtoint ptr [[S3]] to i64
; CHECK-NEXT:    [[ADD:%.*]] = or disjoint i64 [[I]], 1
; CHECK-NEXT:    store i64 [[ADD]], ptr [[OUT2]], align 8
; CHECK-NEXT:    ret void
;
entry:
  %i = ptrtoint ptr %s to i64
  %add = or disjoint i64 %i, 1
  store i64 %add, ptr %out, align 8
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: readwrite)
define dso_local void @memcpy_from_param(ptr nocapture noundef writeonly %out, ptr nocapture noundef readonly byval(%struct.S) align 4 %s) local_unnamed_addr #0 {
; CHECK-LABEL: define dso_local void @memcpy_from_param(
; CHECK-SAME: ptr nocapture noundef writeonly [[OUT:%.*]], ptr nocapture noundef readonly byval([[STRUCT_S:%.*]]) align 4 [[S:%.*]]) local_unnamed_addr #[[ATTR0]] {
; CHECK-NEXT:  [[ENTRY:.*:]]
; CHECK-NEXT:    [[S4:%.*]] = addrspacecast ptr [[S]] to ptr addrspace(101)
; CHECK-NEXT:    [[OUT1:%.*]] = addrspacecast ptr [[OUT]] to ptr addrspace(1)
; CHECK-NEXT:    [[OUT2:%.*]] = addrspacecast ptr addrspace(1) [[OUT1]] to ptr
; CHECK-NEXT:    call void @llvm.memcpy.p0.p101.i64(ptr [[OUT2]], ptr addrspace(101) [[S4]], i64 16, i1 true)
; CHECK-NEXT:    ret void
;
entry:
  tail call void @llvm.memcpy.p0.p0.i64(ptr %out, ptr %s, i64 16, i1 true)
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: readwrite)
define dso_local void @memcpy_to_param(ptr nocapture noundef readonly %in, ptr nocapture noundef readnone byval(%struct.S) align 4 %s) local_unnamed_addr #0 {
; CHECK-LABEL: define dso_local void @memcpy_to_param(
; CHECK-SAME: ptr nocapture noundef readonly [[IN:%.*]], ptr nocapture noundef readnone byval([[STRUCT_S:%.*]]) align 4 [[S:%.*]]) local_unnamed_addr #[[ATTR0]] {
; CHECK-NEXT:  [[ENTRY:.*:]]
; CHECK-NEXT:    [[S3:%.*]] = alloca [[STRUCT_S]], align 4
; CHECK-NEXT:    [[S4:%.*]] = addrspacecast ptr [[S]] to ptr addrspace(101)
; CHECK-NEXT:    [[S5:%.*]] = load [[STRUCT_S]], ptr addrspace(101) [[S4]], align 4
; CHECK-NEXT:    store [[STRUCT_S]] [[S5]], ptr [[S3]], align 4
; CHECK-NEXT:    [[IN1:%.*]] = addrspacecast ptr [[IN]] to ptr addrspace(1)
; CHECK-NEXT:    [[IN2:%.*]] = addrspacecast ptr addrspace(1) [[IN1]] to ptr
; CHECK-NEXT:    tail call void @llvm.memcpy.p0.p0.i64(ptr [[S3]], ptr [[IN2]], i64 16, i1 true)
; CHECK-NEXT:    ret void
;
entry:
  tail call void @llvm.memcpy.p0.p0.i64(ptr %s, ptr %in, i64 16, i1 true)
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: readwrite)
define dso_local void @copy_on_store(ptr nocapture noundef readonly %in, ptr nocapture noundef byval(%struct.S) align 4 %s, i1 noundef zeroext %b) local_unnamed_addr #0 {
; CHECK-LABEL: define dso_local void @copy_on_store(
; CHECK-SAME: ptr nocapture noundef readonly [[IN:%.*]], ptr nocapture noundef byval([[STRUCT_S:%.*]]) align 4 [[S:%.*]], i1 noundef zeroext [[B:%.*]]) local_unnamed_addr #[[ATTR0]] {
; CHECK-NEXT:  [[BB:.*:]]
; CHECK-NEXT:    [[S3:%.*]] = alloca [[STRUCT_S]], align 4
; CHECK-NEXT:    [[S4:%.*]] = addrspacecast ptr [[S]] to ptr addrspace(101)
; CHECK-NEXT:    [[S5:%.*]] = load [[STRUCT_S]], ptr addrspace(101) [[S4]], align 4
; CHECK-NEXT:    store [[STRUCT_S]] [[S5]], ptr [[S3]], align 4
; CHECK-NEXT:    [[IN1:%.*]] = addrspacecast ptr [[IN]] to ptr addrspace(1)
; CHECK-NEXT:    [[IN2:%.*]] = addrspacecast ptr addrspace(1) [[IN1]] to ptr
; CHECK-NEXT:    [[I:%.*]] = load i32, ptr [[IN2]], align 4
; CHECK-NEXT:    store i32 [[I]], ptr [[S3]], align 4
; CHECK-NEXT:    ret void
;
bb:
  %i = load i32, ptr %in, align 4
  store i32 %i, ptr %s, align 4
  ret void
}

attributes #0 = { mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: readwrite) "no-trapping-math"="true" "target-cpu"="sm_60" "target-features"="+ptx78,+sm_60" "uniform-work-group-size"="true" }
attributes #1 = { nocallback nofree nounwind willreturn memory(argmem: readwrite) }
attributes #2 = { nocallback nofree nounwind willreturn memory(argmem: write) }

!llvm.module.flags = !{!0, !1, !2, !3}
!nvvm.annotations = !{!4, !5, !6, !7, !8, !9, !10, !11, !12, !13, !14, !15}
!llvm.ident = !{!16, !17}

!0 = !{i32 2, !"SDK Version", [2 x i32] [i32 11, i32 8]}
!1 = !{i32 1, !"wchar_size", i32 4}
!2 = !{i32 4, !"nvvm-reflect-ftz", i32 0}
!3 = !{i32 7, !"frame-pointer", i32 2}
!4 = !{ptr @read_only, !"kernel", i32 1}
!5 = !{ptr @escape_ptr, !"kernel", i32 1}
!6 = !{ptr @escape_ptr_gep, !"kernel", i32 1}
!7 = !{ptr @escape_ptr_store, !"kernel", i32 1}
!8 = !{ptr @escape_ptr_gep_store, !"kernel", i32 1}
!9 = !{ptr @escape_math_store, !"kernel", i32 1}
!10 = !{ptr @memcpy_from_param, !"kernel", i32 1}
!11 = !{ptr @memcpy_to_param, !"kernel", i32 1}
!12 = !{ptr @copy_on_store, !"kernel", i32 1}
!13 = !{ptr @read_only_gep, !"kernel", i32 1}
!14 = !{ptr @read_only_gep_asc, !"kernel", i32 1}
!15 = !{ptr @read_only_gep_asc0, !"kernel", i32 1}
!16 = !{!"clang version 20.0.0git"}
!17 = !{!"clang version 3.8.0 (tags/RELEASE_380/final)"}
;; NOTE: These prefixes are unused and the list is autogenerated. Do not add tests below this line:
; CHECK32: {{.*}}
