; NOTE: Assertions have been autogenerated by utils/update_llc_test_checks.py UTC_ARGS: --version 2
; RUN: llc -O1 -mtriple=powerpc64-unknown-linux-gnu -mcpu=pwr8 < %s | FileCheck %s

; Test that a negative parameter smaller than 64 bits (e.g., int)
; is correctly implemented with sign-extension when passed to
; a floating point libcall.

define double @ldexp_test(ptr %a, ptr %b) nounwind {
; CHECK-LABEL: ldexp_test:
; CHECK:       # %bb.0:
; CHECK-NEXT:    mflr 0
; CHECK-NEXT:    stdu 1, -112(1)
; CHECK-NEXT:    std 0, 128(1)
; CHECK-NEXT:    lfd 1, 0(3)
; CHECK-NEXT:    lwa 4, 0(4)
; CHECK-NEXT:    bl ldexp
; CHECK-NEXT:    nop
; CHECK-NEXT:    addi 1, 1, 112
; CHECK-NEXT:    ld 0, 16(1)
; CHECK-NEXT:    mtlr 0
; CHECK-NEXT:    blr
  %base = load double, ptr %a
  %exp = load i32, ptr %b
  %call = call double @llvm.ldexp.f64.i32(double %base, i32 signext %exp)
  ret double %call
}

define i64 @frexp_test(ptr %a) nounwind {
; CHECK-LABEL: frexp_test:
; CHECK:       # %bb.0:
; CHECK-NEXT:    mflr 0
; CHECK-NEXT:    stdu 1, -128(1)
; CHECK-NEXT:    std 0, 144(1)
; CHECK-NEXT:    addi 4, 1, 124
; CHECK-NEXT:    lfd 1, 0(3)
; CHECK-NEXT:    bl frexp
; CHECK-NEXT:    nop
; CHECK-NEXT:    lwa 3, 124(1)
; CHECK-NEXT:    addi 1, 1, 128
; CHECK-NEXT:    ld 0, 16(1)
; CHECK-NEXT:    mtlr 0
; CHECK-NEXT:    blr

  %input = load double, ptr %a
  %call = call { double, i32 } @llvm.frexp.f64.i32(double %input)
  %exp_result = extractvalue { double, i32 } %call, 1
  %exp_extended = sext i32 %exp_result to i64
  ret i64 %exp_extended
}
