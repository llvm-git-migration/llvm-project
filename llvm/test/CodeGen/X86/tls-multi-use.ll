; NOTE: Assertions have been autogenerated by utils/update_llc_test_checks.py UTC_ARGS: --version 4
; RUN: llc -o - %s | FileCheck %s
; RUN: llc -o - -relocation-model=pic %s | FileCheck --check-prefix=CHECK_PIC %s
target triple = "x86_64--linux-gnu"

@foo = dso_local thread_local global i32 0, align 4

declare i32 @rand()
declare nonnull ptr @llvm.threadlocal.address.p0(ptr nonnull)

define i32 @tls_multi_use(i32 %arg) {
; CHECK-LABEL: tls_multi_use:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    pushq %rbx
; CHECK-NEXT:    .cfi_def_cfa_offset 16
; CHECK-NEXT:    .cfi_offset %rbx, -16
; CHECK-NEXT:    movl %fs:foo@TPOFF, %ebx
; CHECK-NEXT:    testl %edi, %edi
; CHECK-NEXT:    movl %ebx, %eax
; CHECK-NEXT:    jne .LBB0_2
; CHECK-NEXT:  # %bb.1: # %if.then
; CHECK-NEXT:    callq rand@PLT
; CHECK-NEXT:    movl %fs:foo@TPOFF, %eax
; CHECK-NEXT:  .LBB0_2: # %if.end
; CHECK-NEXT:    addl %eax, %ebx
; CHECK-NEXT:    movl %ebx, %eax
; CHECK-NEXT:    popq %rbx
; CHECK-NEXT:    .cfi_def_cfa_offset 8
; CHECK-NEXT:    retq
;
; CHECK_PIC-LABEL: tls_multi_use:
; CHECK_PIC:       # %bb.0: # %entry
; CHECK_PIC-NEXT:    pushq %rbp
; CHECK_PIC-NEXT:    .cfi_def_cfa_offset 16
; CHECK_PIC-NEXT:    pushq %r14
; CHECK_PIC-NEXT:    .cfi_def_cfa_offset 24
; CHECK_PIC-NEXT:    pushq %rbx
; CHECK_PIC-NEXT:    .cfi_def_cfa_offset 32
; CHECK_PIC-NEXT:    .cfi_offset %rbx, -32
; CHECK_PIC-NEXT:    .cfi_offset %r14, -24
; CHECK_PIC-NEXT:    .cfi_offset %rbp, -16
; CHECK_PIC-NEXT:    movl %edi, %ebp
; CHECK_PIC-NEXT:    leaq .Lfoo$local@TLSLD(%rip), %rdi
; CHECK_PIC-NEXT:    callq __tls_get_addr@PLT
; CHECK_PIC-NEXT:    movl .Lfoo$local@DTPOFF(%rax), %ebx
; CHECK_PIC-NEXT:    testl %ebp, %ebp
; CHECK_PIC-NEXT:    movl %ebx, %ecx
; CHECK_PIC-NEXT:    jne .LBB0_2
; CHECK_PIC-NEXT:  # %bb.1: # %if.then
; CHECK_PIC-NEXT:    leaq .Lfoo$local@DTPOFF(%rax), %r14
; CHECK_PIC-NEXT:    callq rand@PLT
; CHECK_PIC-NEXT:    movl (%r14), %ecx
; CHECK_PIC-NEXT:  .LBB0_2: # %if.end
; CHECK_PIC-NEXT:    addl %ecx, %ebx
; CHECK_PIC-NEXT:    movl %ebx, %eax
; CHECK_PIC-NEXT:    popq %rbx
; CHECK_PIC-NEXT:    .cfi_def_cfa_offset 24
; CHECK_PIC-NEXT:    popq %r14
; CHECK_PIC-NEXT:    .cfi_def_cfa_offset 16
; CHECK_PIC-NEXT:    popq %rbp
; CHECK_PIC-NEXT:    .cfi_def_cfa_offset 8
; CHECK_PIC-NEXT:    retq
entry:
  %addr = tail call align 4 ptr @llvm.threadlocal.address.p0(ptr align 4 @foo)
  %load0 = load i32, ptr %addr, align 4
  %cond = icmp eq i32 %arg, 0
  br i1 %cond, label %if.then, label %if.end

if.then:
  tail call i32 @rand()
  %load1 = load i32, ptr %addr, align 4
  br label %if.end

if.end:
  %phi = phi i32 [ %load1, %if.then ], [ %load0, %entry ]
  %add = add nsw i32 %load0, %phi
  ret i32 %add
}

@foo_nonlocal = thread_local global i32 0, align 4

define i32 @tls_multi_use_nonlocal(i32 %arg) {
; CHECK-LABEL: tls_multi_use_nonlocal:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    pushq %r14
; CHECK-NEXT:    .cfi_def_cfa_offset 16
; CHECK-NEXT:    pushq %rbx
; CHECK-NEXT:    .cfi_def_cfa_offset 24
; CHECK-NEXT:    pushq %rax
; CHECK-NEXT:    .cfi_def_cfa_offset 32
; CHECK-NEXT:    .cfi_offset %rbx, -24
; CHECK-NEXT:    .cfi_offset %r14, -16
; CHECK-NEXT:    movq foo_nonlocal@GOTTPOFF(%rip), %r14
; CHECK-NEXT:    movl %fs:(%r14), %ebx
; CHECK-NEXT:    testl %edi, %edi
; CHECK-NEXT:    movl %ebx, %eax
; CHECK-NEXT:    jne .LBB1_2
; CHECK-NEXT:  # %bb.1: # %if.then
; CHECK-NEXT:    addq %fs:0, %r14
; CHECK-NEXT:    callq rand@PLT
; CHECK-NEXT:    movl (%r14), %eax
; CHECK-NEXT:  .LBB1_2: # %if.end
; CHECK-NEXT:    addl %eax, %ebx
; CHECK-NEXT:    movl %ebx, %eax
; CHECK-NEXT:    addq $8, %rsp
; CHECK-NEXT:    .cfi_def_cfa_offset 24
; CHECK-NEXT:    popq %rbx
; CHECK-NEXT:    .cfi_def_cfa_offset 16
; CHECK-NEXT:    popq %r14
; CHECK-NEXT:    .cfi_def_cfa_offset 8
; CHECK-NEXT:    retq
;
; CHECK_PIC-LABEL: tls_multi_use_nonlocal:
; CHECK_PIC:       # %bb.0: # %entry
; CHECK_PIC-NEXT:    pushq %rbp
; CHECK_PIC-NEXT:    .cfi_def_cfa_offset 16
; CHECK_PIC-NEXT:    pushq %r14
; CHECK_PIC-NEXT:    .cfi_def_cfa_offset 24
; CHECK_PIC-NEXT:    pushq %rbx
; CHECK_PIC-NEXT:    .cfi_def_cfa_offset 32
; CHECK_PIC-NEXT:    .cfi_offset %rbx, -32
; CHECK_PIC-NEXT:    .cfi_offset %r14, -24
; CHECK_PIC-NEXT:    .cfi_offset %rbp, -16
; CHECK_PIC-NEXT:    movl %edi, %ebp
; CHECK_PIC-NEXT:    data16
; CHECK_PIC-NEXT:    leaq foo_nonlocal@TLSGD(%rip), %rdi
; CHECK_PIC-NEXT:    data16
; CHECK_PIC-NEXT:    data16
; CHECK_PIC-NEXT:    rex64
; CHECK_PIC-NEXT:    callq __tls_get_addr@PLT
; CHECK_PIC-NEXT:    movq %rax, %r14
; CHECK_PIC-NEXT:    movl (%rax), %ebx
; CHECK_PIC-NEXT:    testl %ebp, %ebp
; CHECK_PIC-NEXT:    movl %ebx, %eax
; CHECK_PIC-NEXT:    jne .LBB1_2
; CHECK_PIC-NEXT:  # %bb.1: # %if.then
; CHECK_PIC-NEXT:    callq rand@PLT
; CHECK_PIC-NEXT:    movl (%r14), %eax
; CHECK_PIC-NEXT:  .LBB1_2: # %if.end
; CHECK_PIC-NEXT:    addl %eax, %ebx
; CHECK_PIC-NEXT:    movl %ebx, %eax
; CHECK_PIC-NEXT:    popq %rbx
; CHECK_PIC-NEXT:    .cfi_def_cfa_offset 24
; CHECK_PIC-NEXT:    popq %r14
; CHECK_PIC-NEXT:    .cfi_def_cfa_offset 16
; CHECK_PIC-NEXT:    popq %rbp
; CHECK_PIC-NEXT:    .cfi_def_cfa_offset 8
; CHECK_PIC-NEXT:    retq
entry:
  %addr = tail call align 4 ptr @llvm.threadlocal.address.p0(ptr align 4 @foo_nonlocal)
  %load0 = load i32, ptr %addr, align 4
  %cond = icmp eq i32 %arg, 0
  br i1 %cond, label %if.then, label %if.end

if.then:
  tail call i32 @rand()
  %load1 = load i32, ptr %addr, align 4
  br label %if.end

if.end:
  %phi = phi i32 [ %load1, %if.then ], [ %load0, %entry ]
  %add = add nsw i32 %load0, %phi
  ret i32 %add
}
