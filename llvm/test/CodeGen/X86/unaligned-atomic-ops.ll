; NOTE: Assertions have been autogenerated by utils/update_llc_test_checks.py UTC_ARGS: --version 4
; RUN: llc < %s -mtriple=i386-apple-darwin10.0 -mcpu=core2  -relocation-model=dynamic-no-pic    | FileCheck -check-prefix=I386 %s
; RUN: llc < %s -mtriple=x86_64-apple-darwin10.0 -mcpu=core2  -relocation-model=dynamic-no-pic  | FileCheck -check-prefix=CORE2 %s
; RUN: llc < %s -mtriple=x86_64-apple-darwin10.0 -mcpu=corei7 -relocation-model=dynamic-no-pic  | FileCheck -check-prefix=COREI7 %s

; This verifies that the middle end can handle an unaligned atomic load.
;
; In the past, an assertion inside the SelectionDAGBuilder would always
; hit an assertion for unaligned loads and stores.

%AtomicI16 = type { %CellI16, [0 x i8] }
%CellI16 = type { i16, [0 x i8] }

; CHECK-LABEL: foo
; CHECK: ret
define void @foo(%AtomicI16* %self) {
; I386-LABEL: foo:
; I386:       ## %bb.0: ## %start
; I386-NEXT:    pushl %esi
; I386-NEXT:    .cfi_def_cfa_offset 8
; I386-NEXT:    subl $24, %esp
; I386-NEXT:    .cfi_def_cfa_offset 32
; I386-NEXT:    .cfi_offset %esi, -8
; I386-NEXT:    movl {{[0-9]+}}(%esp), %esi
; I386-NEXT:    leal {{[0-9]+}}(%esp), %eax
; I386-NEXT:    movl %eax, {{[0-9]+}}(%esp)
; I386-NEXT:    movl %esi, {{[0-9]+}}(%esp)
; I386-NEXT:    movl $5, {{[0-9]+}}(%esp)
; I386-NEXT:    movl $2, (%esp)
; I386-NEXT:    calll ___atomic_load
; I386-NEXT:    movw $5, {{[0-9]+}}(%esp)
; I386-NEXT:    leal {{[0-9]+}}(%esp), %eax
; I386-NEXT:    movl %eax, {{[0-9]+}}(%esp)
; I386-NEXT:    movl %esi, {{[0-9]+}}(%esp)
; I386-NEXT:    movl $5, {{[0-9]+}}(%esp)
; I386-NEXT:    movl $2, (%esp)
; I386-NEXT:    calll ___atomic_store
; I386-NEXT:    addl $24, %esp
; I386-NEXT:    popl %esi
; I386-NEXT:    retl
;
; CORE2-LABEL: foo:
; CORE2:       ## %bb.0: ## %start
; CORE2-NEXT:    pushq %rbx
; CORE2-NEXT:    .cfi_def_cfa_offset 16
; CORE2-NEXT:    subq $16, %rsp
; CORE2-NEXT:    .cfi_def_cfa_offset 32
; CORE2-NEXT:    .cfi_offset %rbx, -16
; CORE2-NEXT:    movq %rdi, %rbx
; CORE2-NEXT:    leaq {{[0-9]+}}(%rsp), %rdx
; CORE2-NEXT:    movl $2, %edi
; CORE2-NEXT:    movq %rbx, %rsi
; CORE2-NEXT:    movl $5, %ecx
; CORE2-NEXT:    callq ___atomic_load
; CORE2-NEXT:    movw $5, {{[0-9]+}}(%rsp)
; CORE2-NEXT:    leaq {{[0-9]+}}(%rsp), %rdx
; CORE2-NEXT:    movl $2, %edi
; CORE2-NEXT:    movq %rbx, %rsi
; CORE2-NEXT:    movl $5, %ecx
; CORE2-NEXT:    callq ___atomic_store
; CORE2-NEXT:    addq $16, %rsp
; CORE2-NEXT:    popq %rbx
; CORE2-NEXT:    retq
;
; COREI7-LABEL: foo:
; COREI7:       ## %bb.0: ## %start
; COREI7-NEXT:    pushq %rbx
; COREI7-NEXT:    .cfi_def_cfa_offset 16
; COREI7-NEXT:    subq $16, %rsp
; COREI7-NEXT:    .cfi_def_cfa_offset 32
; COREI7-NEXT:    .cfi_offset %rbx, -16
; COREI7-NEXT:    movq %rdi, %rbx
; COREI7-NEXT:    leaq {{[0-9]+}}(%rsp), %rdx
; COREI7-NEXT:    movl $2, %edi
; COREI7-NEXT:    movq %rbx, %rsi
; COREI7-NEXT:    movl $5, %ecx
; COREI7-NEXT:    callq ___atomic_load
; COREI7-NEXT:    movw $5, {{[0-9]+}}(%rsp)
; COREI7-NEXT:    leaq {{[0-9]+}}(%rsp), %rdx
; COREI7-NEXT:    movl $2, %edi
; COREI7-NEXT:    movq %rbx, %rsi
; COREI7-NEXT:    movl $5, %ecx
; COREI7-NEXT:    callq ___atomic_store
; COREI7-NEXT:    addq $16, %rsp
; COREI7-NEXT:    popq %rbx
; COREI7-NEXT:    retq
start:
  %a = getelementptr inbounds %AtomicI16, %AtomicI16* %self, i16 0, i32 0, i32 0
  load atomic i16, i16* %a seq_cst, align 1
  store atomic i16 5, i16* %a seq_cst, align 1
  ret void
}
