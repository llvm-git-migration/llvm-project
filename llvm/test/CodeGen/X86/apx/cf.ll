; NOTE: Assertions have been autogenerated by utils/update_llc_test_checks.py
; RUN: llc < %s -mtriple=x86_64 -mattr=+cf -verify-machineinstrs | FileCheck %s

define void @test (i32 %a, ptr %b, ptr %p, ptr %q) {
; CHECK-LABEL: test:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    testl %edi, %edi
; CHECK-NEXT:    sete %al
; CHECK-NEXT:    negb %al
; CHECK-NEXT:    testl %edi, %edi
; CHECK-NEXT:    # implicit-def: $r8d
; CHECK-NEXT:    je .LBB0_1
; CHECK-NEXT:  # %bb.2: # %else
; CHECK-NEXT:    testb $1, %al
; CHECK-NEXT:    jne .LBB0_3
; CHECK-NEXT:  .LBB0_4: # %else1
; CHECK-NEXT:    testl %edi, %edi
; CHECK-NEXT:    jne .LBB0_5
; CHECK-NEXT:  .LBB0_6: # %else3
; CHECK-NEXT:    retq
; CHECK-NEXT:  .LBB0_1: # %cond.load
; CHECK-NEXT:    movl (%rsi), %r8d
; CHECK-NEXT:    testb $1, %al
; CHECK-NEXT:    je .LBB0_4
; CHECK-NEXT:  .LBB0_3: # %cond.store
; CHECK-NEXT:    movl %r8d, (%rdx)
; CHECK-NEXT:    testl %edi, %edi
; CHECK-NEXT:    je .LBB0_6
; CHECK-NEXT:  .LBB0_5: # %cond.store2
; CHECK-NEXT:    movl $1, (%rcx)
; CHECK-NEXT:    retq
entry:
  %cond = icmp eq i32 %a, 0
  %vcond = insertelement <1 x i1> undef, i1 %cond, i32 0
  %v0 = call <1 x i32> @llvm.masked.load.v1i32.p0 (ptr %b, i32 4, <1 x i1> %vcond, <1 x i32> poison)
  %0 = bitcast <1 x i32> %v0 to i32
  call void @llvm.masked.store.v1i32.p0(<1 x i32> %v0, ptr %p, i32 4, <1 x i1> %vcond)
  %cond.not = xor i1 %cond, true
  %vcond.not = insertelement <1 x i1> undef, i1 %cond.not, i32 0
  call void @llvm.masked.store.v1i32.p0(<1 x i32> <i32 1>, ptr %q, i32 4, <1 x i1> %vcond.not)
  br i1 %cond, label %if.true, label %if.false

if.false:                                          ; preds = %entry
  br label %if.end

if.true:                                          ; preds = %entry
  br label %if.end

if.end:                                           ; preds = %if.true, %if.false
  ret void
}
