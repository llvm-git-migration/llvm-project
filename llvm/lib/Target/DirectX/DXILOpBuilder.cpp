//===- DXILOpBuilder.cpp - Helper class for build DIXLOp functions --------===//
//
// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
// See https://llvm.org/LICENSE.txt for license information.
// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
//
//===----------------------------------------------------------------------===//
///
/// \file This file contains class to help build DXIL op functions.
//===----------------------------------------------------------------------===//

#include "DXILOpBuilder.h"
#include "DXILConstants.h"
#include "llvm/IR/IRBuilder.h"
#include "llvm/IR/Module.h"
#include "llvm/Support/DXILABI.h"
#include "llvm/Support/ErrorHandling.h"
#include "llvm/TargetParser/Triple.h"

using namespace llvm;
using namespace llvm::dxil;

constexpr StringLiteral DXILOpNamePrefix = "dx.op.";

// Include DXIL Operation data and corresponding access functions
// generated by the TableGen backend DXILEmitter.
#define DXIL_OP_OPERATION_TABLE
#include "DXILOperation.inc"
#undef DXIL_OP_OPERATION_TABLE

static OverloadKind getOverloadKind(Type *Ty) {
  Type::TypeID T = Ty->getTypeID();
  switch (T) {
  case Type::VoidTyID:
    return OverloadKind::VOID;
  case Type::HalfTyID:
    return OverloadKind::HALF;
  case Type::FloatTyID:
    return OverloadKind::FLOAT;
  case Type::DoubleTyID:
    return OverloadKind::DOUBLE;
  case Type::IntegerTyID: {
    IntegerType *ITy = cast<IntegerType>(Ty);
    unsigned Bits = ITy->getBitWidth();
    switch (Bits) {
    case 1:
      return OverloadKind::I1;
    case 8:
      return OverloadKind::I8;
    case 16:
      return OverloadKind::I16;
    case 32:
      return OverloadKind::I32;
    case 64:
      return OverloadKind::I64;
    default:
      llvm_unreachable("invalid overload type");
      return OverloadKind::VOID;
    }
  }
  case Type::PointerTyID:
    return OverloadKind::UserDefineType;
  case Type::StructTyID:
    return OverloadKind::ObjectType;
  default:
    llvm_unreachable("invalid overload type");
    return OverloadKind::VOID;
  }
}

static std::string getTypeName(OverloadKind Kind, Type *Ty) {
  if (Kind < OverloadKind::UserDefineType) {
    return getOverloadTypeName(Kind);
  } else if (Kind == OverloadKind::UserDefineType) {
    StructType *ST = cast<StructType>(Ty);
    return ST->getStructName().str();
  } else if (Kind == OverloadKind::ObjectType) {
    StructType *ST = cast<StructType>(Ty);
    return ST->getStructName().str();
  } else {
    std::string Str;
    raw_string_ostream OS(Str);
    Ty->print(OS);
    return OS.str();
  }
}

static std::string constructOverloadName(OverloadKind Kind, Type *Ty,
                                         const OpCodeProperty &Prop) {
  if (Kind == OverloadKind::VOID) {
    return (Twine(DXILOpNamePrefix) + getOpCodeClassName(Prop)).str();
  }
  return (Twine(DXILOpNamePrefix) + getOpCodeClassName(Prop) + "." +
          getTypeName(Kind, Ty))
      .str();
}

static std::string constructOverloadTypeName(OverloadKind Kind,
                                             StringRef TypeName) {
  if (Kind == OverloadKind::VOID)
    return TypeName.str();

  assert(Kind < OverloadKind::UserDefineType && "invalid overload kind");
  return (Twine(TypeName) + getOverloadTypeName(Kind)).str();
}

static StructType *getOrCreateStructType(StringRef Name,
                                         ArrayRef<Type *> EltTys,
                                         LLVMContext &Ctx) {
  StructType *ST = StructType::getTypeByName(Ctx, Name);
  if (ST)
    return ST;

  return StructType::create(Ctx, EltTys, Name);
}

static StructType *getResRetType(Type *OverloadTy, LLVMContext &Ctx) {
  OverloadKind Kind = getOverloadKind(OverloadTy);
  std::string TypeName = constructOverloadTypeName(Kind, "dx.types.ResRet.");
  Type *FieldTypes[5] = {OverloadTy, OverloadTy, OverloadTy, OverloadTy,
                         Type::getInt32Ty(Ctx)};
  return getOrCreateStructType(TypeName, FieldTypes, Ctx);
}

static StructType *getHandleType(LLVMContext &Ctx) {
  return getOrCreateStructType("dx.types.Handle", PointerType::getUnqual(Ctx),
                               Ctx);
}

static Type *getTypeFromParameterKind(ParameterKind Kind, Type *OverloadTy) {
  auto &Ctx = OverloadTy->getContext();
  switch (Kind) {
  case ParameterKind::Void:
    return Type::getVoidTy(Ctx);
  case ParameterKind::Half:
    return Type::getHalfTy(Ctx);
  case ParameterKind::Float:
    return Type::getFloatTy(Ctx);
  case ParameterKind::Double:
    return Type::getDoubleTy(Ctx);
  case ParameterKind::I1:
    return Type::getInt1Ty(Ctx);
  case ParameterKind::I8:
    return Type::getInt8Ty(Ctx);
  case ParameterKind::I16:
    return Type::getInt16Ty(Ctx);
  case ParameterKind::I32:
    return Type::getInt32Ty(Ctx);
  case ParameterKind::I64:
    return Type::getInt64Ty(Ctx);
  case ParameterKind::Overload:
    return OverloadTy;
  case ParameterKind::ResourceRet:
    return getResRetType(OverloadTy, Ctx);
  case ParameterKind::DXILHandle:
    return getHandleType(Ctx);
  default:
    break;
  }
  llvm_unreachable("Invalid parameter kind");
  return nullptr;
}

static ShaderKind getShaderKindEnum(Triple::EnvironmentType EnvType) {
  switch (EnvType) {
  case Triple::Pixel:
    return ShaderKind::pixel;
  case Triple::Vertex:
    return ShaderKind::vertex;
  case Triple::Geometry:
    return ShaderKind::geometry;
  case Triple::Hull:
    return ShaderKind::hull;
  case Triple::Domain:
    return ShaderKind::domain;
  case Triple::Compute:
    return ShaderKind::compute;
  case Triple::Library:
    return ShaderKind::library;
  case Triple::RayGeneration:
    return ShaderKind::raygeneration;
  case Triple::Intersection:
    return ShaderKind::intersection;
  case Triple::AnyHit:
    return ShaderKind::anyhit;
  case Triple::ClosestHit:
    return ShaderKind::closesthit;
  case Triple::Miss:
    return ShaderKind::miss;
  case Triple::Callable:
    return ShaderKind::callable;
  case Triple::Mesh:
    return ShaderKind::mesh;
  case Triple::Amplification:
    return ShaderKind::amplification;
  default:
    break;
  }
  llvm_unreachable(
      "Shader Kind Not Found - Invalid DXIL Environment Specified");
}

/// Construct DXIL function type. This is the type of a function with
/// the following prototype
///     OverloadType dx.op.<opclass>.<return-type>(int opcode, <param types>)
/// <param-types> are constructed from types in Prop.
/// \param Prop  Structure containing DXIL Operation properties based on
///               its specification in DXIL.td.
/// \param OverloadTy Return type to be used to construct DXIL function type.
static FunctionType *getDXILOpFunctionType(const OpCodeProperty *Prop,
                                           Type *ReturnTy, Type *OverloadTy) {
  SmallVector<Type *> ArgTys;

  auto ParamKinds = getOpCodeParameterKind(*Prop);

  // Add ReturnTy as return type of the function
  ArgTys.emplace_back(ReturnTy);

  // Add DXIL Opcode value type viz., Int32 as first argument
  ArgTys.emplace_back(Type::getInt32Ty(OverloadTy->getContext()));

  // Add DXIL Operation parameter types as specified in DXIL properties
  for (unsigned I = 0; I < Prop->NumOfParameters; ++I) {
    ParameterKind Kind = ParamKinds[I];
    ArgTys.emplace_back(getTypeFromParameterKind(Kind, OverloadTy));
  }
  return FunctionType::get(
      ArgTys[0], ArrayRef<Type *>(&ArgTys[1], ArgTys.size() - 1), false);
}

static int getValidConstraintIndex(const OpCodeProperty *Prop,
                                   const VersionTuple SMVer) {
  // std::vector Prop->Constraints is in ascending order of SM Version
  // Overloads of highest SM version that is not greater than SMVer
  // are the ones that are valid for SMVer.
  auto Size = Prop->Constraints.size();
  for (int I = Size - 1; I >= 0; I--) {
    auto OL = Prop->Constraints[I];
    if (VersionTuple(OL.ShaderModelVer.Major, OL.ShaderModelVer.Minor) <=
        SMVer) {
      return I;
    }
  }
  report_fatal_error(
      StringRef(SMVer.getAsString().append(": Unknown Shader Model Version")),
      /*gen_crash_diag*/ false);

  return -1;
}

namespace llvm {
namespace dxil {

CallInst *DXILOpBuilder::createDXILOpCall(dxil::OpCode OpCode, Type *ReturnTy,
                                          Type *OverloadTy,
                                          SmallVector<Value *> Args) {

  std::string TTStr = M.getTargetTriple();
  // No extra checks need be performed to verify that the Triple is
  // well-formed or the target is supported since these checks would have
  // been done at the time the module M is constructed in the earlier stages of
  // compilation.
  auto Major = Triple(TTStr).getOSVersion().getMajor();
  auto MinorOrErr = Triple(TTStr).getOSVersion().getMinor();
  uint32_t Minor = MinorOrErr.has_value() ? *MinorOrErr : 0;
  VersionTuple SMVer(Major, Minor);
  // Get Shader Stage Kind
  Triple::EnvironmentType ShaderEnv = Triple(TTStr).getEnvironment();
  auto ShaderEnvStr = Triple(TTStr).getEnvironmentName();

  const OpCodeProperty *Prop = getOpCodeProperty(OpCode);
  int Index = getValidConstraintIndex(Prop, SMVer);
  uint16_t ValidTyMask = Prop->Constraints[Index].ValidTys;

  OverloadKind Kind = getOverloadKind(OverloadTy);

  // Check if the operation supports overload types and OverloadTy is valid
  // per the specified types for the operation
  if ((ValidTyMask != OverloadKind::UNDEFINED) &&
      (ValidTyMask & (uint16_t)Kind) == 0) {
    report_fatal_error(
        StringRef(std::string("Invalid Overload Type for DXIL operation - ")
                      .append(getOpCodeName((OpCode)))),
        /* gen_crash_diag=*/false);
  }

  // Ensure Environment type is known
  if (ShaderEnv == Triple::UnknownEnvironment) {
    report_fatal_error(
        StringRef(SMVer.getAsString().append(
            ": Unknown Compilation Target Shader Stage specified ")),
        /*gen_crash_diag*/ false);
  }

  // Perform necessary checks to ensure Opcode is valid in the targeted shader
  // kind
  uint16_t ValidShaderKindMask = Prop->Constraints[Index].ValidShaderKinds;
  enum ShaderKind ModuleStagekind = getShaderKindEnum(ShaderEnv);

  // Ensure valid shader stage constraints are specified
  if (ValidShaderKindMask == ShaderKind::Unknown) {
    report_fatal_error(
        StringRef(
            SMVer.getAsString()
                .append(": Unknown Target Shader Stage for DXIL operation - ")
                .append(getOpCodeName((OpCode)))),
        /*gen_crash_diag*/ false);
  }

  // Validate the shader stage specified in target triple to be known
  if (ModuleStagekind == ShaderKind::Unknown) {
    report_fatal_error(StringRef(SMVer.getAsString().append(
                           ": DXIL Module created with Unspecifed or Unknown "
                           "Target Shader Stage")),
                       /*gen_crash_diag*/ false);
  }

  // Verify the target shader stage is valid for the DXIL operation
  if (!(ValidShaderKindMask & ModuleStagekind)) {
    report_fatal_error(
        StringRef(std::string(ShaderEnvStr)
                      .append(" : Invalid Shader Stage for DXIL operation - ")
                      .append(getOpCodeName(OpCode))
                      .append(" for Shader Model ")
                      .append(SMVer.getAsString())),
        /*gen_crash_diag*/ false);
  }

  std::string DXILFnName = constructOverloadName(Kind, OverloadTy, *Prop);
  FunctionCallee DXILFn;
  // Get the function with name DXILFnName, if one exists
  if (auto *Func = M.getFunction(DXILFnName)) {
    DXILFn = FunctionCallee(Func);
  } else {
    // Construct and add a function with name DXILFnName
    FunctionType *DXILOpFT = getDXILOpFunctionType(Prop, ReturnTy, OverloadTy);
    DXILFn = M.getOrInsertFunction(DXILFnName, DXILOpFT);
  }

  return B.CreateCall(DXILFn, Args);
}

Type *DXILOpBuilder::getOverloadTy(dxil::OpCode OpCode, FunctionType *FT) {

  const OpCodeProperty *Prop = getOpCodeProperty(OpCode);
  // If DXIL Op has no overload parameter, just return the
  // precise return type specified.
  if (Prop->OverloadParamIndex < 0) {
    return FT->getReturnType();
  }

  // Consider FT->getReturnType() as default overload type, unless
  // Prop->OverloadParamIndex != 0.
  Type *OverloadType = FT->getReturnType();
  if (Prop->OverloadParamIndex != 0) {
    // Skip Return Type.
    OverloadType = FT->getParamType(Prop->OverloadParamIndex - 1);
  }

  const auto *ParamKinds = getOpCodeParameterKind(*Prop);
  auto Kind = ParamKinds[Prop->OverloadParamIndex];
  // For ResRet and CBufferRet, OverloadTy is in field of StructType.
  if (Kind == ParameterKind::CBufferRet ||
      Kind == ParameterKind::ResourceRet) {
    auto *ST = cast<StructType>(OverloadType);
    OverloadType = ST->getElementType(0);
  }
  return OverloadType;
}

const char *DXILOpBuilder::getOpCodeName(dxil::OpCode DXILOp) {
  return ::getOpCodeName(DXILOp);
}
} // namespace dxil
} // namespace llvm
